[
  
  {
    "title": "使用Rclone迁移对象存储数据",
    "url": "/posts/rclone/",
    "categories": "Knowledge, OSS",
    "tags": "OSS",
    "date": "2024-10-28 13:47:00 +0800",
    





    
    "snippet": "一、安装Rclone下载地址：https://rclone.org/downloads/。二、启动解压下载的压缩包，进到Rclone根目录，使用以下命令启动。# 不带账号密码启动rclone rcd --rc-web-gui# 带账号密码启动rclone rcd --rc-web-gui --rc-user me --rc-pass mypassword启动后会自动下载页面文件到C:\\Use...",
    "content": "一、安装Rclone下载地址：https://rclone.org/downloads/。二、启动解压下载的压缩包，进到Rclone根目录，使用以下命令启动。# 不带账号密码启动rclone rcd --rc-web-gui# 带账号密码启动rclone rcd --rc-web-gui --rc-user me --rc-pass mypassword启动后会自动下载页面文件到C:\\Users\\admin\\AppData\\Local\\rclone目录下，启动成功后自动跳转到浏览器，可以在浏览器页面进行查看、下载OSS文件等操作。三、配置OSS连接打开C:\\Users\\admin\\AppData\\Roaming\\rclone目录下的rclone.conf文件，没有的话新建一个，写入以下OSS配置，以下为多个OSS的配置。[remote]type = s3access_key_id = ak-wretwertwertwrtsecret_access_key = sk-JO235243HJLIJendpoint = http://127.0.0.1provider = Other[remote-1]type = s3access_key_id = ak-wretwertwertwrtsecret_access_key = sk-JO235243HJLIJendpoint = http://127.0.0.1provider = Other四、迁移文件使用命令行迁移数据。# 把remote的directory目录下的所有文件复制到remote-1下的directory-1目录rclone -P copy remote:/directory remote1:/directory-1五、常用命令rclone config - 以控制会话的形式添加rclone的配置，配置保存在.rclone.conf文件中。rclone copy - 将文件从源复制到目的地址，跳过已复制完成的。rclone sync - 将源数据同步到目的地址，只更新目的地址的数据。 rclone move - 将源数据移动到目的地址。rclone delete - 删除指定路径下的文件内容。rclone purge - 清空指定路径下所有文件数据。rclone mkdir - 创建一个新目录。rclone rmdir - 删除空目录。rclone check - 检查源和目的地址数据是否匹配。rclone ls - 列出指定路径下所有的文件以及文件大小和路径。rclone lsd - 列出指定路径下所有的目录/容器/桶。rclone lsl - 列出指定路径下所有文件以及修改时间、文件大小和路径。rclone md5sum - 为指定路径下的所有文件产生一个md5sum文件。rclone sha1sum - 为指定路径下的所有文件产生一个sha1sum文件。rclone size - 获取指定路径下，文件内容的总大小。.rclone version - 查看当前版本。rclone cleanup - 清空remote。rclone dedupe - 交互式查找重复文件，进行删除/重命名操作。"
  },
  
  {
    "title": "山西 - 云冈石窟",
    "url": "/posts/yungangshiku/",
    "categories": "Collection, Travel",
    "tags": "Travel",
    "date": "2024-10-08 10:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Redis缓存的雪崩、击穿、穿透",
    "url": "/posts/redishuancun-xuebeng/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2024-09-12 13:47:00 +0800",
    





    
    "snippet": "缓存雪崩缓存雪崩是指在某个时间点，大量的缓存数据同时失效或过期，导致大量的请求直接打到数据库或后端系统，从而造成数据库负载激增，甚至导致数据库宕机或系统崩溃的现象。  合理设置缓存的过期时间：将缓存的过期时间分散设置，避免大量缓存在同一时间过期。可以使用随机时间，或者将过期时间分布在一个时间段内。  实现缓存数据的自动刷新：确保热点数据在即将过期时能够自动刷新，避免数据大规模失效。  多级缓...",
    "content": "缓存雪崩缓存雪崩是指在某个时间点，大量的缓存数据同时失效或过期，导致大量的请求直接打到数据库或后端系统，从而造成数据库负载激增，甚至导致数据库宕机或系统崩溃的现象。  合理设置缓存的过期时间：将缓存的过期时间分散设置，避免大量缓存在同一时间过期。可以使用随机时间，或者将过期时间分布在一个时间段内。  实现缓存数据的自动刷新：确保热点数据在即将过期时能够自动刷新，避免数据大规模失效。  多级缓存：使用多级缓存，将热点数据缓存在多个层次，例如内存缓存、分布式缓存，以减轻缓存层的负担。  限流和熔断：实施请求限流和服务熔断，避免大量请求同时打到后端系统。  监控和报警：建立监控系统，实时监测缓存和后端系统的状态，及时发现问题并采取措施。缓存穿透缓存和数据库中都没有的数据，可用户还是源源不断的发起请求，导致每次请求都会到数据库，从而压垮数据库。比如客户查询一个根本不存在的东西，首先从Redis中查不到，然后会去数据库中查询，数据库中也查询不到，那么就不会将数据放入到缓存中，后面如果还有类似源源不断的请求，最后都会压到数据库来处理，从而给数据库造成巨大的压力。  业务层校验：用户发过来的请求，根据请求参数进行校验，对于明显错误的参数，直接拦截返回。  不存在数据设置短过期时间：对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s，可以根据实际业务设定。注意一定不要影响正常业务。  布隆过滤器：可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了，从而避免下一步对数据库的压力。缓存击穿Redis中一个热点key在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。  设置热点数据永不过期：对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。当然这种方式比较粗暴，对于某些业务场景是不适合的。  定时更新：比如这个热点数据的过期时间是1h，那么每到59minutes时，通过定时任务去更新这个热点key，并重新设置其过期时间。  互斥锁：这是解决缓存穿透比较常用的方法。互斥锁简单来说就是在Redis中根据key获得的value值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该key时，发现获取锁失败，则睡眠一段时间（比如100ms）后重试。"
  },
  
  {
    "title": "线程池",
    "url": "/posts/xianchengchi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2024-09-12 11:47:00 +0800",
    





    
    "snippet": "线程池的五种状态  RUNNING：线程池处于运行状态，能够接收新任务并处理队列中的任务。  SHUTDOWN：线程池处于关闭状态，不再接收新任务，但会处理队列中的剩余任务。  STOP：线程池处于停止状态，不再接收新任务，并中断正在执行的任务。  TIDYING：线程池中的所有任务执行完毕，活动线程数为0时的状态。  TERMINATED：线程池执行完terminated()方法后的状态。...",
    "content": "线程池的五种状态  RUNNING：线程池处于运行状态，能够接收新任务并处理队列中的任务。  SHUTDOWN：线程池处于关闭状态，不再接收新任务，但会处理队列中的剩余任务。  STOP：线程池处于停止状态，不再接收新任务，并中断正在执行的任务。  TIDYING：线程池中的所有任务执行完毕，活动线程数为0时的状态。  TERMINATED：线程池执行完terminated()方法后的状态。每种状态的定义和转换条件  RUNNING：线程池创建后默认进入此状态，能够接收新任务并处理队列中的任务。  SHUTDOWN：调用shutdown()方法后，线程池进入此状态，不再接收新任务，但会处理队列中的剩余任务。  STOP：调用shutdownNow()方法后，线程池进入此状态，不再接收新任务，并中断正在执行的任务。  TIDYING：所有任务执行完毕后，活动线程数为0时的状态。  TERMINATED：执行完terminated()方法后的状态。"
  },
  
  {
    "title": "保险名词",
    "url": "/posts/baoxianmingci/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2024-09-11 08:47:00 +0800",
    





    
    "snippet": "  保险金额： 保险金额，简称”保额”，是保险利益的货币价值表现，是投保时给保险标的确定的金额，又是保险人计收保险费的依据和承担给付责任的最高限额。  保险人： 保险人是保险合同当事人的一方，是经营保险业务收取保险费，在保险事故发生时给付保险金的人。据我国《保险法》规定，保险人是指与投保人订立保险合同，并承担赔偿或者给付保险金责任的保险公司。  被保险人： 被保险人是受保险合同保障的人。他们...",
    "content": "  保险金额： 保险金额，简称”保额”，是保险利益的货币价值表现，是投保时给保险标的确定的金额，又是保险人计收保险费的依据和承担给付责任的最高限额。  保险人： 保险人是保险合同当事人的一方，是经营保险业务收取保险费，在保险事故发生时给付保险金的人。据我国《保险法》规定，保险人是指与投保人订立保险合同，并承担赔偿或者给付保险金责任的保险公司。  被保险人： 被保险人是受保险合同保障的人。他们以其财产、生命或身体为保险标的，在保险事故发生后，享有保险金请求权。被保险人可以与投保人为同一人。  投保人： 投保人是保险合同当事人的另一方，是向保险人申请订立保险合同，并负有交付保险费义务的人。  保单现金价值： 是指带有储蓄性的人身保险单所具有的价值。在长期人身保险中，保险费率中含有储蓄因素，特别是长期性带有生存给付保险的纯保险费，往往含有很大比重的储蓄保险费。于是保险单交费达到一定时间后，逐年积存相当数额的储蓄保险费，并随着时间的延伸而不断增加，这就形成了保单现金价值。  保单贷款：  对于长期性人身保险合同，投保人可以将具有现金价值的保险单作为质押，在现金价值数额内，向保险公司申请贷款，习惯上称为保单贷款。  保单自动垫付：  保单的一种规定，当保费支付中断时，投保人可用保单下的现金价值垫缴保险费。以保额10万元保障期限20年的保险为例。自动垫付，即利用保单已有的现金价值支付未来若干年的保费，直到现金价值用完，所保障的年限由现金价值所能支付的保费决定，但期间保障额度仍为10万元。比较来看，自动垫付更适合短期经济困境的家庭，如果出险，赔付时10万元的保障仍然比较划算；而减额缴清虽然相对适合经济困难稍长的家庭，但保障额度打了折扣，可能对并不富裕的家庭来说更加不利。显然，在经济状况不佳的时候，保额的高低有明显的优劣。  减额缴清： 当投保人不愿意继续交纳保险费时，投保人可以将保险单当时的现金价值作为趸缴保险费，向保险人申请同类保险的”减额缴清保险”。改保后的保险合同，保险人只对将来给付的保险金作相应调整，减少给付数额，而保险期间与其他保险内容不变，投保人也不用再续交保险费。减额缴清则是消费者可以按保单现金价值一次性缴清所有保险费，保障期限仍旧为20年，但保障额度将低于10万元。  免赔额： 对于健康保险，特别是其中的医疗费用保险，为了避免保险人在处理赔款时费用过大，通常健康保险单通过规定一些条款，来达到被保险人与保险人费用共担的目的。免赔额条款是其中的一种，即规定保险人只负责超过免赔额的部分。  保单周年日： 指一份保单签发后满周年的日期。  趸缴： 对于人寿保险或年金保险，在保单签发时就缴付全数足额保费。  展期定期： 当投保人不愿意继续交纳保险费时，投保人可以按保险单当时的现金价值作为趸缴保险费，向保险人申请变更为”展期定期保险”，主要指的是定期死亡保险。变更后，保险合同的保险责任、保险期限等主要内容会有所改变，而变更后的保险金额与原保险合同的保险金额一致。投保人无须再交纳续期保险费。  附加险：  附加险是相对于主险而言的，顾名思义是指附加在主险合同下的附加合同。它不可以单独投保，要购买附加险必须先购买主险。一般来说，附加险所交的保险费比较少，但它的存在是以主险存在为前提的，不能脱离主险，形成一个比较全面的险种。  保险的除外责任： 除外责任指保单列明的不负赔偿责任的范围。除外责任可以以列举式的方式在保单中列举除外事项，也可以以不列举方式明确除外责任，即凡未列入承保范围的灾害事故均为除外责任。 任何保险商品都不是万能的，总有一些不能赔付的责任内容。这是因为，保险公司都是经营性的，以盈利为目的，要考虑承担的风险的问题。保险公司要对风险认真考察，避免承保风险过大，造成保险公司的亏损。对应的，保险公司对风险进行筛选，把一些发生的可能性较大，损失较多的风险列为除外责任。  保险责任： 一般来说，人寿保险合同中，保险公司开始承担责任是从保险公司同意承保，而且投保人交纳了首期保险费开始的。也就是说，保险公司开始承担责任需要两个前提，一是保险公司同意承保，它的标志为保险公司签发保单。一般投保程序分为两个步骤，要约和承诺。投保人向保险公司表示愿意投保，并填写投保书，视为要约；保险公司核保以后决定承保并签发保单，视为承诺。因此，签发保单是保险公司同意承保的标志。二是投保人交纳首期保险费。二者缺一不可。  终身保险： 即终身死亡寿险，是死亡保险的一种，以人的死亡作为保险事故，在事故发生时，由保险人给付一定保险金额的保险。死亡保险所保障的是避免由于被保险人死亡而使其家属或依其收入生活的人陷入困境。终身保险作为一种不定期限的死亡保险。在保单签发后，除非应交的保费不交，或因解约而早期停交，被保险人在任何时候死亡，保险人都得给付保险金。相对于定期死亡寿险，终身保险具有以下特点**： （1）每一张有效保单必然发生给付；（2）保险费率高于定期寿险的费率；（3）具有储蓄性。终身保险属长期性保险，保单都具有现金价值，带有一定储蓄成分，因而适宜于需要终身保障和储蓄的人投保。  定期寿险： 即定期死亡保险，指对特定期间的死亡提供保障的人寿保险形式。只要被保险人在保险有效期内死亡，保险人就给付保险金于受益人；如果被保险人生存至保险期满，保险合同即告终止，保险人既不退还已交保费，也不给付任何金额。如想继续获得此种保障，必须重新投保。  两全保险： 是被保险人无论在保险期内死亡还是生存至期满，保险人都给付保险金的一种人寿保险。两全保险具有如下特点**： 1，是寿险业务中承保责任最全面的一个险种。既承保生存给付，又承担可能的死亡给付，而且保险人必然支付保险金。 2，费率最高。相对于死亡保险和生存保险，两全保险保费是定期死亡保险保费和生存保险保费之和，所以保费相对较高。  年金保险： 是指被保险人生存期间，保险人按合同约定的金额、方式、期限，有规则并且定期向被保险人给付保险金的生存保险。年金保险因其在保险金的给付方式上采用年金的形式而得名。年金保险的保险金是否给付，取决于被保险人是否生存。除年金这一特性外，还有两个独特之处**： 一是免体检。二是费率厘定主要以生命表中的生存率为基础。从根本上来讲，年金保险是为了避免寿命较长者的经济收入无法充分得到保障而进行的一种经济储蓄。  健康保险：  健康保险也称疾病保险，是指被保险人在患疾病时发生医疗费用支出，或因疾病所致残疾或死亡时或因疾病、伤残不能工作而减少收入时，由保险人负责给付保险金的一种保险。健康保险所承保的疾病危险应符合以下的构成要件： （1）由于非明显的外来原因造成的；（2） 由于非先天的原因造成的；（3）由于非长存的原因造成的。健康保险的特征： （1）保险金额和期限： 健康保险既有对患病给付一定保险金的险种，也有对医疗费用和收入损失的补偿的险种，其给付金额往往是按照实际发生的费用或收入损失而定。另外，人寿保险一般属于长期合同，而健康保险通常是短期保险，以一年期居多。（2）承保标准： 健康保险的承保条件一般比寿险要严格，对疾病产生的因素，需要相当严格的审查，一般是根据被保险人的病历来判断。  医疗保险： 医疗保险是指提供医疗费用保障的保险，它是健康保险的主要险种之一。常见的医疗保险有以下几种：（1）普通医疗保险：为被保险人提供治疗疾病时所相关的一般性医疗费用，其主要包括门诊费用、医药费用、检查费用等。（2）住院保险：主要是每天医疗房间的费用、住院期间的诊断费、手术费、药费和医院设备使用费。（3）手术保险：提供因病人需做必要的手术而发生的费用，一般负担全部手术费用，而不由被保险人按比例分担。（4）综合医疗保险：为被保险人提供的一种全面的医疗费用保险，其保障范口包括医疗和住院手术等一切费用。（5）特种疾病保险：某些特殊疾病往往给病人带来灾难性的费用支付，如癌症、血液病、肾衰竭及心脏疾病等，这些疾病一经确诊，必然会产生大范口的医疗费用支出。通常要求这种保单的保险金额较大，以足够支付其产生的各种费用。  射幸合同：以不确定性事项为合同标的，为人们所常说的撞大运。与人们平常生活中订立合同以确定性事件为标的的原则不同。因而常容易激发人们的投机心理，带来道德风险，所以人们一般视射幸合同为不正当的。但在法律史上，早在罗马法时期法律就有对射幸合同调整的记录，而且在现代各国民法中，也多有对射幸合同进行明文规定的。且在现实生活中，随经济社会发展，许多新种类的射幸合同如有奖销售合同、金融期权合同等如雨后春笋般冒出，射幸合同应在法律上取得一席之地应为理所当然之事。由于射幸合同的许多副作用，也由于例外从严的法律原则，我国也应在法律上明文规定射幸合同的适用范围，以对其进行严格规制。　　保险利益原则产生的原因是基于保险合同的射幸性，即保险合同是一种机会性合同，投保人购买保险后能否获得保险金的赔付取决于在保险合同有效期内保险事故是否发生，这在财产保险合同中表现得尤为明显。正因为保险合同具有这一特性，在保险业务的发展过程中，为了避免不法之徒利用他人的财产或人身进行赌博而获利，防范道德风险的发生，各国保险立法一般都将保险利益原则作为保险合同产生法律效力的条件。同时，随着保险业的发展和保险活动的日趋复杂，各国在保险立法中不断对该原则进行修正和完善。      减额缴清：简单来说就是根据保单具有的现金价值作为一次性缴纳的保费，购买同类保险，保额降低。减额缴清后，当初订立合同的条件如预定利率、保险责任等都不变，只是保险金额减少，以后不必再交保费。    保险： 投保人根据合同约定，向保险人支付保险费，保险人对于合同约定的可能发生的事故因其发生所造成的财产损失承担赔偿保险金责任，或者当被保险人死亡、伤残、疾病或者达到合同约定的年龄、期限时承担给付保险金责任的商业行为。  财产保险： 保险人按保险合同的约定对所承保的财产及其有关利益因自然灾害或意外事故造成的损失承担赔偿责任的保险。  企业财产保险： 以企业存放在固定地点的财产和物资作为保险标的的财产保险。  家庭财产保险： 以个人生活资料、农具、私住房屋等财产为保险标的的财产保险。  利润损失保险： 对财产遭受责任范围内的毁损后，被保险人在一段时间内因停产、停业或经营受影响而损失的预期利润及必要的费用支出提供补偿的保险。  机器损坏保险： 承保各类已安装完毕并投入运行的机器因人为的、意外的或物理性原因造成物质损失的保险。  运输工具保险： 承保因遭受自然灾害和意外事故造成的运输工具的损失及第三者损害赔偿的责任的保险。  机动车辆保险： 以机动车辆本身及其相关经济利益为保险标的的运输工具保险。  船舶保险： 以各种船舶、水上装置及其碰撞责任为保险标的的运输工具保险。  飞机保险/航空保险： 以飞机及其相关责任为保险对象的保险。  货物运输保险： 以运输途中的货物作为保险标的，保险人对由自然灾害和意外事故造成的货物损失负责赔偿的保险。  海上货物运输保险： 以海上运输工具运输的货物作为保险标的，保险人承担整个运输过程，包括内河、内陆运输保险标的遭受自然灾害和意外事故的损失的保险。  陆上货物运输保险： 以陆上运输工具，包括火车、汽车等运载的货物为保险标的的保险。  航空货物运输保险： 以航空运输的货物为保险标的的保险。  工程保险： 以工程项目中的财产损失和相关法律赔偿责任为保险标的的保险。  责任保险： 以被保险人对第三者依法应负的赔偿责任为保险标的的保险。  公众责任保险： 承保被保险人在公共场所进行生产、经营或其他活动时，因发生意外事故而造成的公众人身伤亡或财产损失，依法应由被保险人承担的经济赔偿责任的保险。  雇主责任保险： 被保险人所雇用的员工，在受雇过程中从事保险单所载明的与被保险人的业务有关的工作时，因遭受意外事故而伤亡、残废或因患有与业务有关的职业性疾病，所致伤残或死亡，被保险人根据法律或雇用合同，须负担医药费用及经济赔偿责任，包括应支出的诉讼费用，由保险人在规定的赔偿限额内负责赔偿的一种保险。  产品责任保险： 被保险人所生产、出售的产品或商品在承保区域内发生事故，造成使用、消费或操作该产品或商品的人或其他任何人的人身伤害、疾病、死亡或财产损失，依法应由被保险人负责时，保险人在约定的赔偿限额内负责赔偿、提供保障的一种保险。  职业责任保险： 以各种专业技术人员在从事职业技术工作时因疏忽或过失造成合同对方或他人的人身伤害或财产损失所导致的经济赔偿责任为承保风险的责任保险。  个人责任保险： 承保自然人或家庭成员因作为或不作为而造成他人人身伤害或财产的直接损失，依法应由被保险人承担的经济赔偿责任的一种保险。  信用保险： 权利人向保险人投保债务人的信用风险的一种保险，当债务人不能履行其义务时，由保险人承担赔偿责任。  保证保险： 被保证人（债务人）根据权利人（债权人）的要求，请求保险人担保自己信用的保险，如果由于被保证人不履行合同义务或者有犯罪行为，致使权利人受到经济损失，由保险人负赔偿责任。  农业保险： 农业生产者以支付保险费为代价把农业生产经营过程中由于灾害事故所造成的财产损失转嫁给保险人的一种制度安排。  人寿保险： 是以被保险人的生命为保险标的，以被保险人（在保险期限内）生存或死亡为给付保险金条件的人身保险。  定期寿险： 以死亡为给付保险金条件，且保险期限为固定年限的人寿保险。  终身寿险： 以死亡为给付保险金条件，且保险期限为终身的人寿保险。  两全保险： 以在保险期间内死亡或生存至保险期满为给付保险金条件的人寿保险。  年金保险： 以生存为给付保险金条件，按约定分期给付生存保险金，且分期给付生存保险金的间隔通常不超过一年(含一年)的人寿保险。  定额年金： 根据保险合同的约定，每期领取的年金数额相同的年金。  变额年金： 年金的给付值随着分立账户投资业绩的变化而变化，保险公司不保证年金领取人的定期给付金额的一种年金形式。  延期年金： 根据保险合同的约定，开始领取年金的日期与保单生效日期相隔超过一年的年金保险。又称递延年金。  终身年金： 被保险人生存至一定时期后，依照保险合同的约定，按期领取生存保险金，直至被保险人身故为止的年金保险。  意外伤害保险： 以意外伤害而致身故或残疾为给付保险金条件的人身保险。  意外死亡保险： 以意外伤害而致死亡为给付保险金条件的人身保险。  伤残保险： 出现由于事故导致的身体不同部分伤残的情况时进行保险给付。保单中的保险利益表列示了身体每一部分缺失的保险给付。  意外伤害收入保障保险： 被保险人在保险期间内因遭受意外伤害事故导致身故、残疾的，按合同规定给付身故、残疾保险金。  健康保险： 以被保险人的身体为保险标的，依据合同约定当被保险人在疾病或意外事故所致伤害时发生的医疗费用或财产损失获得补偿或给付的一种保险。  短期健康保险： 保险期限在一年以下的(包含一年)健康保险。  长期健康保险： 保险期限在一年以上的(不含一年)健康保险。  强制健康保险： 法律规定的强制健康保险，缴费通常与收入相关。可能是雇主代表雇员缴费的义务。强制险通常由公共或准公共实体进行管理，但也可由私人保险业者管理。  个人健康保险： 用于个人的健康保险合同。可以提供医疗费用支出的保障。被保险人通常是那些没有资格的人。保费通常依承保范围及被保险人个人状况而定，例如年龄、性别、居住省份或城市，以及被保险人的年免赔额。  团体健康保险： 承保像特定行业的雇员、协会会员或雇主群体等自然群体的保险。向每位雇员提供住院、膳食、外科和内科的检查费用，以及其它的医疗费用。通常有需要雇员自付部分费用的或条款。  疾病保险： 以约定疾病的发生为给付保险金条件的保险。  医疗保险： 以约定的医疗费用为给付保险金条件的保险。  收入保障保险： 以因意外伤害、疾病导致收入中断或减少为给付保险金条件的保险。  利率敏感型保险： 利率对险种收益影响较大的险种，比如投资连接保险和万能保险。  分红保险： 保险公司将其实际经营成果优于定价假设的盈余，按一定比例向投保人进行分配的一种人寿保险。  万能保险： 一种缴费灵活、保额可调整、非约束性的人寿保险，相当于一个定额（或递减）的定期保险与一个递增的累积基金相结合而构成的保险。  投资连结保险： 包含保险保障功能并至少在一个投资账户拥有一定资产价值的人身保险。  保险责任： 保险合同中载明的应由保险人赔偿损失或给付保险金的责任。  主险/基本险： 投保人在投保特定的保险产品时必须选择的保险责任。  附加险： 投保人在投保特定的保险产品时可选的保险责任，该保险责任必须附加于主险或基本险，用来补充主险的保险范围。  除外责任： 保险合同中规定的在某些特定的灾害、事故及损失范围下，保险人不负的赔偿损失或给付保险金的责任。  风险事故： 造成生命财产损失的偶发事件，是造成损失的直接的或外在的原因，是损失的媒介物。  损失： 非故意的、非预期的、非计划的经济价值的灭失和人身的伤害。通常分为直接损失和间接损失。  投保： 对财产、人身、责任及权益等具有保险利益的自然人或法人，通过购买保险与保险人建立保险合同关系的行为。  投保人： 与保险人订立保险合同，并按照保险合同负有支付保险费义务的人。  保险人： 与投保人订立保险合同，并承担赔偿或者给付保险金责任的保险公司。  被保险人： 其财产或者人身受保险合同保障，享有保险金请求权的人。  附加的被保险人： 保单以背书形式确定的可为其提供一定程度的保险保障的被保险人。  受益人： 人身保险合同中由被保险人或者投保人指定的享有保险金请求权的人。  保险标的： 作为保险对象的财产及其有关利益或者人的寿命和身体。  投保单/要保单/投保申请书： 投保人向保险人申请订立保险合同的书面文件。  告知： 投保人在订立保险合同时，应将与保险标的有关的重要事实以口头或书面形式向保险人作真实陈述。  保险利益： 投保人对保险标的具有的法律上承认的利益。  最大诚信： 保险合同双方以完全的诚实，向对方履行告知所有相关重要事实。  保险利益原则： 投保人对保险标的应当具有保险利益，否则导致保险合同无效。  最大诚信原则： 保险双方在签订和履行保险合同时，必须以最大的诚意，履行自己应尽的义务，互不欺骗和隐瞒，恪守合同的约定与承诺，否则导致保险合同无效。  保证： 保险人要求投保人或被保险人对某一事项的作为或不作为，某种事态的存在或不存在作出的许诺。  默示保证： 习惯上或社会公认的被保险人应在保险实践中遵守的规则，而不书面载明于保险合同中的保证。  明示保证： 将保证的内容以文字或书面形式载明于保险合同中，成为保险合同条款的保证。  保额： 保险人承担赔偿或者给付保险金责任的最高限额。  累计赔付限额： 保险人在保单期限或责任期限内会支付的最高金额。  每案赔付限额： 保险人对被保险人的每次索赔的保险金给付上限。  每事故赔付限额： 保险人对被保险人的每一次事故的保险金给付上限。  每损失赔付限额： 保险人对被保险人的每一次损失的保险金给付上限。  免赔额： 在保险合同中规定的损失在一定限度内保险人不负赔偿责任的额度。  相对免赔额： 保单项下的损失超过规定的免赔额时，保险人承担保额之内的全部损失。  绝对免赔额： 保险人只承担超过规定的免赔额部分的损失。  每案免赔额： 在每一次索赔中被保险人需自己支付的最低金额。  每事故免赔额： 在每一事故中被保险人需自己支付的最低金额。  每损失免赔额： 在每一次损失中被保险人需自己支付的最低金额。  保险价值： 经投保人或被保险人与保险人约定并记载于保险单中的保险标的的价值或保险事故发生时按保单裁明的估价方法确定的保险标的的实际价值。  定值保险： 在保险合同中载明经保险合同双方同意的保险标的的价值金额的保险。  不定值保险： 在保险合同中未载明保险标的的价值金额，而列明保险金额的保险。注：通常，不定值保险合同中含有约定保险价值确定方法的内容。  足额保险： 保险金额等于保险价值的保险。  不足额保险： 保险金额低于保险价值的保险。  超额保险： 保险金额超过保险价值的保险。  赔偿限额： 保险单中约定的，当保险人负有赔偿责任的损失发生时，保险人所承担的最高金额。  累计赔偿限额： 保险合同中载明的保险人对保险责任范围内所有损失的最高赔偿金额。  重置成本保险： 以重新购置保险标的的成本及费用作为保险金额的保险。　  基本保险金额： 指保险合同载明的经保险公司核准的保险金额。  最高给付限额： 对医疗费用设定的一个总的支付限额，限额以内的部分由保险公司支付，限额以外的部分由被保险人自付。  分项给付限额： 医疗费用按服务项目规定不同程度的给付限额，超出限额部分由被保险人自付。  保险金最长给付期： 被保险人单次住院补贴医疗保险金给付的最高天数，或每一保单年度的最高给付天数。  免赔期： 免赔期即免除期，在保险合同中约定的一个时期内，若被保险人住院天数在该时间段以内，则相关的费用支出或收入损失由被保险人自己承担；若住院天数超过该时间段，则保险公司承担超出该时间段部分的费用支出或收入损失。  免赔天数： 在收入保障保险中，由被保险人自行承担损失的天数。  等待期/观察期： 在个人健康保险或伤残保险中，从保单生效日开始，到保险人具有保险金给付责任之日的一段时间。  生存期： 在重大疾病保险中，从被保险人被确诊患重大疾病当天开始，到其具有保险金给付请求权之日一段时间。  保险单/保单： 投保人与保险人约定保险权利义务关系的协议。  不定额保险： 财产保险中，合同当事人事先没有协议一定数目的保险金额，风险事故发生时，保险人根据被保险人所遭受的实际损失程度而给予补偿的保险。被保险人所遭受的实际损失程度而给予补偿的保险。  开口保单/预约保险单： 保险人与被保险人事先约定保险货物的范围、险别、保险费率或每批货物的最高金额，并在预约保单上载明，但不规定保险的总金额。凡属于预约保险范围的货物，一经启运，保险人即自动按保单所列的条件承保。  孤儿保单： 与保险公司终止代理关系的代理人在离开公司之前所代理销售的有效保单。  小保单： 不载明保险条款、并声明以保险单所载明的条款为准的简化的保险单。  保险标志： 保险人向投保人核发的、证明投保人已经投保某个保险产品的标志。　  批单： 保险人出具的变更保险合同的证明文件。  暂保单/临时保险单： 保险人在签发正式保单之前发出的一种临时保险凭证。注：暂保单与保险单一样具有证明保险合同的法律效力。待正式保单签发后，暂保单自动失效。  标准保单： 通常由权威机构制定，经过一定审查程序或备案认定的，由保险人事先印就的、具有统一格式的保险单。  非标准保单： 保险公司根据业务需要和客户需求自行制订的保单。  不可抗辩期间： 保险合同生效且经过一定期限后的期间，在这期间以外保险公司不得仅以违反告知义务为理由解除合同。  犹豫期/冷静期： 投保人签收保单后的若干天，在此期间投保人可以提出解除合同的申请，保险公司将扣除工本费后退还全部保险费。  保险期间/保险期限： 保险合同载明的保险责任开始到终止的时间。  追溯期： 赔款发生制的责任保险单中约定的从保险期限起始日期向前追溯的一段时间。注：对追溯期以前发生的保险事故，不论是否在保险单载明的有效期限提出索赔，保险人均不负责赔偿。  报告期： 事故发生制的责任保险单中约定的从保险期限终止日期往后延续的一段时间。注：若保险事故是发生在追溯期或保险期限内，而受害人在报告期内首次提出索赔，保险人也负责赔偿。  保险合同中止： 指在保险合同有效期限内，因某种事由出现而使合同的效力处于暂时停止的状态。　  保险合同复效： 在保险合同失效后一定时间内，由投保人申请，经保险公司同意，投保人补缴保险费及利息后，保险合同恢复效力。  保险合同终止： 因某种法定或约定事由的出现，致使保险合同当事人双方的权利义务归于消灭的行为。  保单期满： 保单规定的合同期限届满，保险合同不再为被保险人期满后发生的事故或事故提供保险保障。  退保： 在保险合同履行过程中，保险合同双方当事人中的任何一方中途通知对方要求终止保险合同的行为。  续保： 保险合同即将期满时，被保险人向保险人提出申请，要求延长该保险合同的期限或重新办理保险手续的行为。  附加险续保： 在主险合同继续有效、且其附加险责任期满终止的前提下，按双方约定，使原附加险责任继续有效或在一定条件下继续有效的业务操作。  批改： 在保险合同的有效期限内，保险合同当事人根据主客观情况的变化，依照法律规定的条件和程序，在协商一致的基础上，对保险合同的某些条款进行的修改或补充。  风险变更通知： 投保人或被保险人由于工作场所、设备、业务种类或其他变更，导致风险有显著增加或减少时，投保人以书面形式向保险公司发出的通知。  现金价值： 对于长期人身保险产品，根据保险合同的约定在客户退保时可领取的保单累积的价值。  保单现金价值净额： 保单现金价值扣除欠缴保险费及其他欠款本息的净额。  加保： 保险合同生效后每届满一定年期，投保人根据条款规定，申请增加保险金额而无需核保。投保人申请保额增加权益时，保险合同必须有效。注：此功能主要适用于条款中有保额增加权益的传统险种。  减保/部分退保： 在保险合同有效期内，经投保人申请，保险公司在一定金额范围内降低保险合同原有的保险金额或保险费，降低部分的保险金额或保险费视同部分解除合同。  退保金： 投保人在退保时可取回的金额。包括退还的保险费或现金价值扣除保单贷款余额及利息。  退保费用： 投保人由于各种原因可能在保险合同已经签订而尚未满期时，提前要求解除合同，保险人按照已承保的时间长短及相关的费率表向投保人收取的费用。  减额缴清： 保单持有人要求将人寿保险保单的现金价值一次性购买保险金额比原保单少，但保险期限不变的保险。新保单的保险金额取决于与被保险人的年龄相对应的保险成本和保单的终止费用。  缴清增额： 保单持有人将每年的红利购买缴清保险，增加原保单的保险金额的情况。  保单贷款： 人身保险合同在保费缴纳一定时间后，投保人可凭借保单向保险公司申请贷款，其贷款的额度连同利息一般不得超过该保单的现金价值的一定比例。如果贷款本息达到保单上现金价值净额，则合同终止。  保险合同转换： 投保人可于合同生效满一定时间后，经保险公司审核同意，将原保险合同转换成该保险公司的其他保险合同，但通常对被保险人在转换时的年龄都有限制。  红利： 保险公司保险公司根据实际经营成果优于定价假设的可分配盈余的一定比例向保单持有人分配的数额。  保单红利： 在分红保险有效期间内，保险公司根据分红保险业务的实际经营状况，按照保险监管机关的有关规定返还给保单持有人的金额。  保险事故： 保险人按照保险合同的约定需承担保险责任的各种事故或者事件。  风险事故/风险事件： 可能引起经济损失或人员伤亡的不可预见的事件。  损失事件： （有可能）引起受益人提出损失索赔的一次事故包括死亡、偷窃、车祸和住院等。  意外事件： 外来的、突然的、非本意、非疾病的使被保险人身体受到伤害或或财产遭受损失的客观事件。  出险： 在保险责任有效期间内，因发生保险事故导致保险标的出现经济损失的过程。  近因： 发生事故造成损失的最直接、最有效并起主导作用或支配作用的原因，而不是时间或空间上与损失最接近的原因。  近因原则： 保险事故发生后，保险人以最具支配影响或最有效原因作为损失起因的原则。  意外伤害： 在被保险人没有预见到或违背被保险人意愿的情况下，突然发生的外来致害物对被保险人的身体的剧烈地、明显地侵害的事实  意外身故： 被保险人因遭受意外伤害而身亡的情况。  意外残疾： 被保险人因遭受意外伤害而导致人体器官的缺如或机能丧失的情况。  自我伤害/自伤： 被保险人故意伤害自己身体的情况。  疾病身故： 因疾病原因造成被保险人身故的情况。  疾病全残： 因疾病原因造成被保险人全残的情况。  非残疾性伤害： 被保险人所受的伤害程度没有达到合同中规定领取全部或部分残疾给付的情况。  暂时性伤残： 被保险人由于疾病或意外事故导致身体或精神受损而暂时失去工作能力的情况。  暂时性部分伤残： 被保险人因身体遭受伤害或患疾病，导致工作能力减弱，但预计可完全恢复的状态。  永久完全残疾/完全永久伤残/完全永久性伤残： 被保险人由于疾病或意外事故导致维持人的生命活动的器官功能的严重衰竭或缺失的，经相关权威医疗机构或医疗鉴定机构认定，被保险人完全和永久性的不能从事获得收入的活动或工作的情况。  全残： 双目永久完全失明的，或两上肢腕关节以上或两下肢踝关节以上缺失的，或一上肢腕关节以上及一下肢踝关节以上缺失的，或一目永久完全失明及一上肢腕关节以上缺失的，或一目永久完全失明及一下肢踝关节以上缺失的，或四肢关节机能永久完全丧失的，或咀嚼、吞咽机能永久完全丧失的，或中枢神经系统机能或胸、腹部脏器机能极度障碍，终身不能从事任何工作，为维持生命必要的日常生活活动，全需他人扶助的状态。  部分伤残： 被保险人由于疾病或意外事故导致维持生命活动的器官功能部分衰竭或缺失，将永久丧失部分生理功能的状态。  后遗伤残： 被保险人在一定时期的暂时性伤残状态之后虽可以回到工作，但工作能力受到影响的残疾。  职业病： 是由于在受雇期间长期暴露于不良的或有危险的工作环境下而引发的疾病。  终末疾病： 经医院诊断确定为严重疾病末期，并经保险公司认定所患疾病无法治愈且根据医学及临床经验其平均存活期间在保险公司合同约定的期限以内的疾病。  间隔期： 在医疗、健康类保险中，如果两次事件发生的时间长度小于间隔期，那么在理赔时，将这两次事件视为一次事件处理。  物质损失： 保险标的在遭受保险事故后，造成了其本身功能的降低或丧失的情况。  部分损失/分损： 保险标的遭受损害，但其受损程度未达到全损的情况。  全部损失/全损： 保险标的实际上完全灭失或受损程度已使其丧失原有的价值和形态的损失状态。可以分为实际全损和推定全损。  实际全损： 保险标的完全灭失或保险标的的所有权的丧失已无法挽回或保险标的在受损后已完全丧失使用价值或保险标的失踪达到一定的时间可视作完全灭失的情况。  推定全损： 保险标的受损后，虽未达到完全灭失的程度，但其实际全损将是无法避免的，或是其修理费用、整理费用、续运费用、施救费用、赎回费用等都超过获救后保险标的的价值。  协议全损： 保险标的所遭受的损失既不是实际全损也没有达到推定全损的要求，但基于维持保险人和被保险人之间良好关系的考虑，对保险标的按全部损失进行赔偿的情况。  财产物质损坏： 易碎财产的物质损坏或灭失的状态，包括由此引起的价值减少，但不包括任何由于正常使用引起的损失。  交通事故： 车辆在道路上因过错或者意外造成人身伤亡或者财产损失的事件。  车辆损失/车损： 车辆因碰撞原因（两车相撞或与其它物体相撞）和非碰撞原因（自然灾害、意外事故等）引起的损失。  船舶损失/船损： 船舶因碰撞原因（两车相撞或与其它物体相撞）和非碰撞原因（自然灾害、意外事故等）引起的损失。  共同海损： 载货船舶在运输途中遭受海上风险或外来风险时危及船与货的共同安全，船长为挽救船舶及货物，采取合理措施而导致船、货等一部分财产的特殊牺牲和支付的特殊费用。这部分损失由船舶、货物、运费有关受益各方根据船舶及货物到达目的港时的价值按比例分摊。  单独海损： 船舶或货物在运输过程中，因受海上风险和外来风险所造成的除共同海损之外的部分损失。  报案： 将可能导致保险人承担某张保单赔付责任的事件通知保险人的行为。  出险通知： 保险事故发生后，被保险人或受益人及事故的知情人将事故发生的时间、地点、原因及其他有关情况，以最快的方式通知保险人的行为。  索赔： 被保险人或受益人在保险标的遭受损失后，按照保单有关条款的规定，向保险人请求赔偿损失的行为。  简易索赔： 保险合同约定的事故轻微且预计赔付金额在一定范围内，申请材料齐全且保险责任认定明确的小赔案，一般只审核索赔材料，毋需进行理赔调查。  给付请求： 发生保险合同约定的保险事故后，被保险人为获得给付而提出的口头或书面的要求。  索赔时效： 根据保险法或保险合同规定，保险事故发生后被保险人向保险人请求赔偿或给付保险金的有效期间。  报案延误/报案延迟： 保险事故的发生与保险公司接到报案的时间差。实务中的概念应该是实际报案时间对正常报案时间的延后。或保险事故发生后向保险公司报案过程时间的滞后性。  案件撤销： 由于发生的保险事故不符合合同约定的事项而由被保险人或保险公司按照相关规定将其撤消的行为。  保险欺诈： 被保险人或受益人故意制造保险事故或故意夸大保险标的损失后向保险人提出索赔请求的行为。  索赔人/索赔申请人： 保险事故发生后向保险公司提出保险赔款要求的自然人或单位。  救助： 抢救或者挽救损失标的以获得对象保留价值的活动。  施救： 保险标的在遭受保险责任范围内的灾害事故时，被保险人及其代理人为了避免或减少损失，而进行的抢救、保护、清理等工作。  施救费用： 保险事故发生后，被保险人为防止或者减少保险标的的损失所支付的必要的、合理的费用。  救助担保人： 是指被救助方发生事故后，为其提供担保以保证救助方提供施救后会得到应有的报酬的当事方。  海事担保： 海事担保是指为一切海商事活动提供的担保的总称，既包括海商事活动中带有合约性质的担保，也包括海事诉讼及海事仲裁活动中带有纠纷色彩的担保。包括海事请求保全、海事强制令、海事证据保全等程序中所涉及的担保。担保的方式为提供现金或者保证、设置抵押或者质押。  核赔： 保险人收到被保险人或受益人的索赔请求后，对被保险人或受益人提供的证明、资料进行审核、调查，作出给予赔付或拒绝赔付的过程。  理算： 对保险损失进行调查，确定赔付金额大小和分摊比例的行为。  期内索赔： 以损害事故提出的时间为基础，计算责任事故的有效期。保险人不考虑责任事故发生的具体时间，只要首次正式提出索赔的时间在保险单有效期内，保险人就要承担赔偿责任。  期内发生： 保险事故必须发生在保险期间内，保险人才依照保险合同承担赔偿责任。  查抄底单/抄单： 保险标的发生事故后，保险人核对保单以确认出险标的的保单是否在责任有效期内，以及事故是否属于保险责任等的核实行为。  理赔调查/理赔查勘/理赔勘查： 对保险事故的时间、原因、可能的赔付额，保险责任的确定等方面进行的调查，包括对索赔材料的真实性审查、现场查勘等。  定损： 确定保险标的实际损失的过程或行为。  赔付： 保险人对被保险人或受益人因保险事故造成的损失给予经济赔偿或给付保险金的行为。  通融赔付： 保险人根据保险条款本不应承担或完全承担赔付责任的，但权衡经营业务得失，有意放宽赔付责任而作出全部或部分赔偿保险金的行为。  拒赔： 保险人对被保险人提出的索赔要求根据保险法或保险合同的约定经审核不属于保险赔偿范围并予以拒绝该索赔请求的行为。  理赔延误/理赔延迟： 保险公司接到报案与理赔终结之间的时间差。  保险金： 保险合同约定对于发生保险事故后保险公司根据标的的损失和损伤程度按照保险责任计算审核后给付的金额。  给付： 人身保险合同中，保险公司按照合同约定对发生保险事故的被保险人给予经济补偿的行为。  给付方式： 保险公司向被保险人或受益人提供的给付保险金的方式。  给付期间： 保险公司对被保险人或受益人进行受益金给付的约定期间，在该约定期间内，保险公司将按一定的时间间隔提供给付。  身故给付/死亡给付： 被保险人发生保险合同约定的保险事故身故后，保险公司按照保险合同的约定给付的保险金。  生存给付： 按照保险合同的约定被保险人生存到保单约定的时间或年龄，所领取的保险金。  意外给付： 因意外事故引发的保险给付，包括死亡给付、残疾给付、永久失能给付等，在一些寿险保单条款中，因意外事故引发的给付有别于保单的基本保险金额，例如为基本保险金额的两倍。  意外死亡给付： 因意外事故造成被保险人死亡的情况下，一次性支付的保险金。  失能给付/残疾给付/伤残给付： 因保险事故造成被保险人永久丧失某些生理机能的利益给付。  部分失能给付/半残给付： 在健康保险中，当被保险人因疾病或伤害导致不能从事部分或大部分工作，但非完全丧失工作能力时，保险公司所提供的部分残废给付。  提前给付： 允许在被保险人死亡前支取部分死亡给付金的一种寿险保单条款，。已支取的部分将从死亡给付金中扣除。  附加月度给付： 在丧失劳动能力收入保险中，被保险人发生保险事故提出索赔后的第一年内，在社会保障给付开始发放之前，由保险人根据保单条款规定按月给付。  满期给付： 保险合同约定保险人在保险责任期间届满时的给付，满期给付完成后，原保险合同终止。  保险金分配： 保单持有人向保险人的授权，以使保险人直接向家庭主力给付保险金。保险金可能只是对关系网内的家庭主力进行给付。  赔款： 按照保险合同的约定保险人对被保险人或受益人因保险事故造成的损失给予的经济补偿。  损失补偿原则： 在财产保险合同中，当被保险人具有保险利益的保险标的遭受了保险责任范围内的损失时，保险人要对被保险人的经济损失给予补偿，且补偿的数额以弥补被保险人因保险事故而造成的经济损失为限，被保险人不能获得额外利益的原则。  医疗费用补偿原则： 在医疗费用保险中，被保险人通过社保和商业保险（包括本保险）所获得的医疗费用补偿金额总和以被保险人实际支出的医疗费用金额为限。  比例赔偿方式： 在不足额投保的情况下，对于保险标的的实际损失，保险人按保险金额与保险价值的比例给予赔偿。  第一危险赔偿方式： 当实际损失金额不高于保险金额时，不论是否足额投保，保险人均按照实际损失金额赔偿；当实际损失金额高于保险金额时，超出部分由被保险人自担的保险方式。  分摊原则： 在重复保险的情况下赔偿原则，当保险事故发生时，各家保险公司按一定的方法对赔款进行分摊，以使被保险人从各家保险公司得到的赔款总额不超过其实际发生的损失额。  比例责任分摊： 在重复保险中，各保险公司按其保险金额在总保险金额中的比例来分摊损失的分摊方式。  限额责任分摊： 在重复保险中，以假设没有重复保险的情况下，各保险人按其承保的保险金额独自应负的赔偿限额与所有保险人应负的该赔偿限额的总和的比例承担损失赔偿责任的分摊方式。  顺序责任分摊： 在重复保险中，以保险合同的签订顺序为依据分摊损失，由先出单的保险人先赔偿，不足时再由后一保险人赔偿，依此类推，直至被保险人的损失得以足额补偿的分摊方式。  追偿： 保险人对被保险人因保险事故造成的损失进行补偿后，向第三者责任方提出索赔的行为。  代位/代位求偿/代位追偿： 保险人对被保险人因保险事故造成的损失进行补偿后，依法或按保险合同约定取得对财产损失负有责任的第三者进行追偿的权利或对受损标的的所有权的行为。  权利代位： 保险事故由第三者责任方所致，被保险人因保险标的受损而从保险人处获得赔偿以后，应将其向第三者责任方享有的赔偿请求权转让给保险人，由保险人在赔偿金额范围内代位行使被保险人向第三者请求赔偿的权利。  物上代位： 保险标的发生推定全损，保险人对被保险人赔偿经济损失后，取得对受损标的的所有权。  代位追偿原则： 在财产保险中，保险标的发生保险事故造成推定全损，或者保险标的由于第三者责任导致的损失，保险人按照合同约定履行赔偿责任后，依法取得对保险标的的所有权或对保险标的的损失负有责任的第三者的追偿权的原则。  代位追偿权： 在财产保险中，保险人根据保险合同对被保险人的损失给予补偿后享有的、由被保险人转移而来的、向对被保险人负有民事赔偿责任的第三方请求赔偿的权利。  代位授权书： 保险人从被保险人处取得的对某保险标的的代位求偿权的一种书面证明文件。  委付： 保险标的遭受损失但未达到全损的程度，被保险人要求按推定全损赔偿时，将保险标的的一切权利转移给保险人的行为。  残值/损余物资： 保险财产遭受损失后尚有经济价值和使用价值的残存物资。  缴费通知： 保险人或保险代理人在期缴保单的缴费日之前向投保人发出的缴费提醒的通知。  保费缴付/保费支付： 投保人按照保险合同的约定，向保险人支付保险费的行为。  分期缴纳保费： 投保人按照保险合同的约定，分多期向保险人支付保险费的行为。  保费豁免： 在保险合同约定的保险事故发生后，保险人不再向投保人收取以后的保险费、而保险合同继续有效的行为。  保费退还： 保险人将投保人实际缴纳的保费与按照保险合同约定应缴纳的保费之间的差额退还给投保人的行为。  缴费宽限期： 在投保人未按时缴纳续期保险费的情况下，保险合同状态保持有效的期限。  保费自动垫缴： 期缴保单的付款人在宽限期末仍未缴纳保费，保险公司根据客户申请用保单现金价值垫付保费，日后保费付款人偿还垫缴的保费和利息。  预收保费： 保险公司在保单责任生效前向投保人预收的保险费。  复效保费： 为复效已中止效力的保险合同而应缴纳的保险费。  保费支付人： 向保险人实际缴纳保险费的的个人或组织。  保险中介： 介于保险机构之间或保险机构与投保人之间，专门从事保险中介服务，并从中依法获取佣金和手续费的单位和个人。  直接保险经纪： 基于投保人的利益，为投保人与保险人订立保险合同提供中介服务，并依法收取佣金的单位。  保险代理人： 根据保险人的委托，向保险人收取代理手续费，并在保险人授权的范围内代为办理保险业务的单位或者个人。  保险公估机构： 受保险当事人的委托，专门从事保险标的的评估、勘验、鉴定、估损、理算等业务，并据此向保险当事人合理收取费用的单位。  保险专业代理机构： 根据保险人的委托，专门从事保险代理业务的单位。  保险兼业代理机构： 根据保险人的委托，在从事自身业务的同时，指定专人为保险人代办保险业务的单位。  独立代理人： 接受两家或两家以上保险人委托，从事保险代理业务的保险代理人。  专属代理人： 仅接受一家保险人委托，从事保险代理业务的保险代理人。  保险营销员： 取得中国保险监督管理委员会颁发的资格证书，为保险公司销售保险产品及提供相关服务，并收取手续费或者佣金的个人。  保险公司： 经保险监督管理机构批准设立，并依法登记注册的商业保险公司。  保险公司分支机构： 保险公司依法设立的营业性机构和营销服务机构，包括分公司、中心支公司、支公司、营业部和营销服务部。  保险机构： 保险公司总公司及其分支机构。  总公司： 管理全部公司组织的总机构，具有法人资格。  分公司： 受总公司管辖的分支机构的一种组织形式，不具有法人资格。  支公司： 受总公司管辖的分支机构的一种组织形式，不具有法人资格。  营业部： 由保险机构设立的持有《经营保险业务许可证》的营业部。  营销服务部： 经中国保险监督管理委员会派出机构批准，在工商行政管理机关登记注册，由保险公司或者保险公司分支机构设立的对保险营销人员进行管理，为客户提供保险服务的机构。  代表处： 保险公司在某些区域设立的、不能从事保险业务的联络机构。  再保险公司： 经保险监督管理机构批准设立，依法登记注册专门经营再保险业务的公司。依据业务范围，可以分为人寿再保险公司、非人寿再保险公司和综合再保险公司。  信用保险公司： 以信用保险为其主要经营业务的保险公司。  保险资产管理公司： 经中国保监会会同有关部门批准，依法登记注册、受托管理保险资金的金融机构。  股份有限保险公司： 依据我国公司法和保险法的规定设立的、全部资本分为等额股份，股东以其所持股份为限对公司承担责任，公司以其全部资产对公司债务承担责任的保险公司。  国有独资保险公司： 经国家保险监管机构批准，由国家授权投资的机构或者国家授权投资的部门单独投资设立的有限责任保险公司。  外国保险公司分公司： 依照《中华人民共和国保险法》及相关法律的规定，经国家保险监管机构批准，在中国境内设立的从事保险经营活动的分公司。  中外合资保险公司： 中国合营者与外国合营者依照中华人民共和国法律的规定，在中国境内共同投资、经保险监管机构批准设立的保险公司。  财产保险公司： 以财产保险为其主要经营业务的保险公司。  人寿保险公司： 以人身保险为其主要经营业务的保险公司。"
  },
  
  {
    "title": "Docker基础命令",
    "url": "/posts/docker-mingling/",
    "categories": "Knowledge, Docker",
    "tags": "Docker",
    "date": "2024-08-23 08:47:00 +0800",
    





    
    "snippet": "# 启动Dockersystemctl start docker# 关闭Dockersystemctl stop docker#重启Dockersystemctl restart docker# Docker设置随服务启动systemctl enable docker# 查看Docker运行状态systemctl status docker# 查看Docker版本号信息docker vers...",
    "content": "# 启动Dockersystemctl start docker# 关闭Dockersystemctl stop docker#重启Dockersystemctl restart docker# Docker设置随服务启动systemctl enable docker# 查看Docker运行状态systemctl status docker# 查看Docker版本号信息docker versiondocker info# 查看自己服务器中Docker镜像列表docker images# 搜索镜像docker search 镜像名# 搜索STARS&gt;9000的MySQL镜像docker search --filter=STARS=9000 mysql # 拉取最新版本镜像docker pull 镜像名# 拉取指定版本镜像docker pull 镜像名:Tag# 运行镜像docker run 镜像名docker run 镜像名:Tag# -it 与容器进行交互式启动# -d  可后台运行容器（守护式运行）# --name 给要运行的容器起的名字# /bin/bash 交互路径docker run -it -d --name 别名 镜像名:Tag /bin/bash# 保存镜像docker save 镜像名/镜像ID -o 镜像保存位置和名称# 删除一个镜像docker rmi -f 镜像名/镜像ID# 删除多个镜像docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID# 删除全部镜像 -a 显示全部 -q 只显示IDdocker rmi -f $(docker images -aq)# 强制删除镜像docker image rm 镜像名/镜像ID# 加载镜像docker load -i 镜像保存位置# 查看正在运行的容器docker ps# 查看所有容器docker ps -a# 镜像标签，对一个镜像进行分类或者版本迭代docker tag 源镜像名:版本 新镜像名:新版本# docker tag app-user:1.0.0 app-user:2.0.0# 进入容器docker attach# 退出容器先按Ctrl+P，再按Ctrl+Q"
  },
  
  {
    "title": "Windows11关闭BitLocker加密",
    "url": "/posts/win11-guanbi-bitlocker-jiami/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2024-06-25 13:47:00 +0800",
    





    
    "snippet": "使用manage-bde.exe -off E:命令对E区的数据进行解密。",
    "content": "使用manage-bde.exe -off E:命令对E区的数据进行解密。"
  },
  
  {
    "title": "Windows11安装跳过联网",
    "url": "/posts/win11-anzhuang-tiaoguo-wangluopeizhi/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2024-06-25 13:47:00 +0800",
    





    
    "snippet": "使用快捷键Shift + F10调出命令提示符窗口，然后输入OOBE\\BYPASSNRO，重启电脑，在重启后的Win11联网界面中，选择“我没有Internet连接”的选项，并继续执行受限设置，这样可以跳过联网激活环节。",
    "content": "使用快捷键Shift + F10调出命令提示符窗口，然后输入OOBE\\BYPASSNRO，重启电脑，在重启后的Win11联网界面中，选择“我没有Internet连接”的选项，并继续执行受限设置，这样可以跳过联网激活环节。"
  },
  
  {
    "title": "自定义启动banner",
    "url": "/posts/zidingyi-qidong-banner/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2024-06-03 13:47:00 +0800",
    





    
    "snippet": "Spring Boot启动的时候默认的banner是spring的字样，看多了觉得挺单调的，Spring Boot为我们提供了自定义banner的功能。自定义banner只需要在resource下新建一个banner.txt文件，将我们需要的banner字样放进去，启动的时候就会去读取使用这个文本文件中的banner。控制banner样式Spring提供了三个枚举类来设定字符的颜色，分别是：...",
    "content": "Spring Boot启动的时候默认的banner是spring的字样，看多了觉得挺单调的，Spring Boot为我们提供了自定义banner的功能。自定义banner只需要在resource下新建一个banner.txt文件，将我们需要的banner字样放进去，启动的时候就会去读取使用这个文本文件中的banner。控制banner样式Spring提供了三个枚举类来设定字符的颜色，分别是：  AnsiColor： 用来设定字符的前景色  AnsiBackground： 用来设定字符的背景色  AnsiStyle： 用来控制加粗、斜体、下划线等等使用${AnsiFoo.Bar}来指定样式，这个颜色的设置是可以变的，也就是说同一个屏幕可以指定多个${AnsiColor.FooColor}这种，指定了颜色之后直到下次指定之前的字符都是FooColor颜色的${AnsiColor.BRIGHT_YELLOW}${AnsiColor.BRIGHT_RED}_ooOoo_${AnsiColor.BRIGHT_YELLOW}${AnsiColor.BRIGHT_RED}o8888888o${AnsiColor.BRIGHT_YELLOW}${AnsiColor.BRIGHT_RED}88${AnsiColor.BRIGHT_YELLOW}\" . \"${AnsiColor.BRIGHT_RED}88${AnsiColor.BRIGHT_YELLOW}显示应用信息除了上面的指定样式之外，还可以显示一些与应用相关的版本信息：  ${application.version}：与MANIFEST.MF文件中相同的版本号，比如1.5.4.RELEASE  ${application.formatted-version}：格式化过的版本号就是加个v然后用括号包起来，比如(v1.5.4.RELEASE)  ${application.title}  ${spring-boot.version}：Spring Boot的版本  ${spring-boot.formatted-version}：格式化过的版本控制banner是否开启设置banner mode为OFF关闭banner：package org.cc11001100; import org.springframework.boot.Banner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplicationpublic class SpringBootStudy002Application {     public static void main(String[] args) {        SpringApplication springApplication = \t\t\t\tnew SpringApplication(SpringBootStudy002Application.class);        springApplication.setBannerMode(Banner.Mode.OFF);        springApplication.run(args);    } }几个常用的字符画生成网站  http://patorjk.com/software/taag/#p=display&amp;f=Henry%203D&amp;t=CC11001100%0A 这个是比较常用的，可以根据输入的字符生成字符画  https://spring-boot-banner-gen.cfapps.io/ 可以将上传图片转为文本形式的字符画  http://www.degraeve.com/img2txt.php 可以根据在线的图片网址生成字符画，比如可以直接将公司logo的地址粘贴进去生成字符画  参考：Spring Boot笔记之自定义启动banner"
  },
  
  {
    "title": "MyBatis Generator配置详解",
    "url": "/posts/mybatis-generator-peizhi-xiangjie/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2024-05-31 09:47:00 +0800",
    





    
    "snippet": "一、添加MyBatis和数据库驱动依赖&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/versi...",
    "content": "一、添加MyBatis和数据库驱动依赖&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.28&lt;/version&gt;&lt;/dependency&gt;二、引入MyBatis Generator插件&lt;plugin&gt;    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;${mybatis-generator-core-version}&lt;/version&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/plugin&gt;三、配置MyBatis Generator插件3.1 配置MyBatis Generator config文件路径&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;configuration&gt;                &lt;!--mybatis的代码生成器的配置文件--&gt;                &lt;configurationFile&gt;                    src/main/resources/mybatis-generator-config.xml                &lt;/configurationFile&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;plugins&gt;    &lt;/build&gt;注意，这个路径是配置文件相对于该pom文件的路径3.2 允许覆盖生成的文件&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;configuration&gt;                &lt;!--mybatis的代码生成器的配置文件--&gt;                &lt;configurationFile&gt;                    src/main/resources/mybatis-generator-config.xml                &lt;/configurationFile&gt;                &lt;!--允许覆盖生成的文件--&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;plugins&gt;    &lt;/build&gt;3.3 添加数据库驱动依赖&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;configuration&gt;                &lt;!--mybatis的代码生成器的配置文件--&gt;                &lt;configurationFile&gt;                    src/main/resources/mybatis-generator-config.xml                &lt;/configurationFile&gt;                &lt;!--允许覆盖生成的文件--&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;            &lt;dependencies&gt;                &lt;!-- mysql的JDBC驱动 --&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;8.0.17&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;plugins&gt;    &lt;/build&gt;大部分情况下，我们的项目中已经配置过了对应数据库的JDBC驱动，现在在插件中又配置一次，感觉有些冗余，Maven提供了includeCompileDependencies属性，让我们在插件中引用dependencies的依赖，这样就不需要重复配置了&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;configuration&gt;                &lt;!--mybatis的代码生成器的配置文件--&gt;                &lt;configurationFile&gt;                    src/main/resources/mybatis-generator-config.xml                &lt;/configurationFile&gt;                &lt;!--允许覆盖生成的文件--&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;!--将当前pom的依赖项添加到生成器的类路径中--&gt;                &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;plugins&gt;    &lt;/build&gt;3.4 配置MyBatis Generator Config&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!--mybatis的代码生成器相关配置--&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt; &lt;generatorConfiguration&gt;    &lt;!-- 引入配置文件 --&gt;    &lt;properties resource=\"application-dev.properties\"/&gt;     &lt;!-- 一个数据库一个context,context的子元素必须按照以下给出的个数、顺序配置        (MyBatis Generator对配置的循序还有要求)        property (0..N)        plugin (0..N)        commentGenerator (0 or 1)        jdbcConnection (需要connectionFactory 或 jdbcConnection)        javaTypeResolver (0 or 1)        javaModelGenerator (至少1个)        sqlMapGenerator (0 or 1)        javaClientGenerator (0 or 1)        table (1..N)    --&gt;    &lt;!-- id: 随便填,保证多个context id不重复就行         defaultModelType： 可以不填,默认值conditional,flat表示一张表对应一个po         targetRuntime：可以不填,默认值MyBatis3,常用的还有MyBatis3Simple                        这个配置会影响生成的dao和mapper.xml的内容                         targetRuntime = MyBatis3Simple,生成的接口会少很多,只包含最最常用的    --&gt;    &lt;context id=\"myContext\" targetRuntime=\"MyBatis3\" defaultModelType=\"flat\"&gt;         &lt;!-- 这个插件给生成的Java模型对象增加了equals和hashCode方法 --&gt;        &lt;!-- &lt;plugin type=\"org.mybatis.generator.plugins.EqualsHashCodePlugin\"/&gt; --&gt;         &lt;!-- 用来配置生成的注释。默认是生成注释的,并且会生成时间戳 --&gt;        &lt;commentGenerator&gt;            &lt;!-- 是否不生成注释 --&gt;            &lt;property name=\"suppressAllComments\" value=\"true\"/&gt;            &lt;!-- 不希望生成的注释中包含时间戳 --&gt;            &lt;!-- &lt;property name=\"suppressDate\" value=\"true\"/&gt; --&gt;            &lt;!-- 添加db表中字段的注释,只有suppressAllComments为false时才生效 --&gt;            &lt;!-- &lt;property name=\"addRemarkComments\" value=\"true\"/&gt; --&gt;        &lt;/commentGenerator&gt;         &lt;!-- JDBC连接 --&gt;        &lt;jdbcConnection driverClass=\"${spring.datasource.driverClassName}\"                        connectionURL=\"${spring.datasource.url}\"                        userId=\"${spring.datasource.username}\"                        password=\"${spring.datasource.password}\"&gt;            &lt;!-- 高版本的mysql-connector-java需要设置nullCatalogMeansCurrent=true --&gt;            &lt;property name=\"nullCatalogMeansCurrent\" value=\"true\"/&gt;        &lt;/jdbcConnection&gt;         &lt;!-- 类型转换 --&gt;        &lt;javaTypeResolver&gt;            &lt;!-- 是否使用bigDecimal,默认false。                 false,把JDBC DECIMAL和NUMERIC类型解析为Integer                 true,把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal            --&gt;            &lt;property name=\"forceBigDecimals\" value=\"true\"/&gt;            &lt;!-- 默认false                 false,将所有JDBC的时间类型解析为java.util.Date                 true,将JDBC的时间类型按如下规则解析                    DATE                    -&gt; java.time.LocalDate                    TIME                    -&gt; java.time.LocalTime                    TIMESTAMP               -&gt; java.time.LocalDateTime                    TIME_WITH_TIMEZONE      -&gt; java.time.OffsetTime                    TIMESTAMP_WITH_TIMEZONE -&gt; java.time.OffsetDateTime            --&gt;            &lt;!-- &lt;property name=\"useJSR310Types\" value=\"false\"/&gt; --&gt;        &lt;/javaTypeResolver&gt;         &lt;!-- 配置po生成的包路径和项目路径 --&gt;        &lt;javaModelGenerator targetPackage=\"com.wqlm.boot.user.po\"                 targetProject=\"src/main/java\"&gt;            &lt;!-- 是否让 schema 作为包的后缀,默认为false --&gt;            &lt;!-- &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; --&gt;            &lt;!-- 是否针对string类型的字段在set方法中进行修剪,默认false --&gt;            &lt;property name=\"trimStrings\" value=\"true\"/&gt;        &lt;/javaModelGenerator&gt;         &lt;!-- 生成Mapper.xml文件 --&gt;        &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"&gt;            &lt;!-- &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; --&gt;        &lt;/sqlMapGenerator&gt;         &lt;!-- 生成XxxMapper.java接口              type=\"XMLMAPPER\"会将接口的实现放在mapper.xml中,推荐这样配置             type=\"ANNOTATEDMAPPER\",接口的实现通过注解写在接口上面             如果采用这种方式,不会生成mapper.xml也不用配置&lt;sqlMapGenerator&gt;,             但是采用注解来实现接口应对简单查询还好,如果是复杂查询并不如xml方便             所以还是建议将type配置成XMLMAPPER        --&gt;        &lt;javaClientGenerator targetPackage=\"com.wqlm.boot.user.dao\"                 targetProject=\"src/main/java\" type=\"XMLMAPPER\"&gt;            &lt;!-- &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; --&gt;        &lt;/javaClientGenerator&gt;         &lt;!-- 一个table对应一张表,如果想同时生成多张表,需要配置多个table             schema为数据库名,Oracle需要配置,MySQL不需要配置。             tableName为对应的数据库表名             domainObjectName是要生成的实体类名(可以不指定,默认按帕斯卡命名法将表名转换成类名)             enableXXXByExample默认为true, 为true会生成一个对应Example帮助类,             帮助你进行条件查询,不想要可以设为false        --&gt;        &lt;table schema=\"\" tableName=\"user\" domainObjectName=\"User\"               enableCountByExample=\"false\" enableDeleteByExample=\"false\"                enableSelectByExample=\"false\"               enableUpdateByExample=\"false\" selectByExampleQueryId=\"false\"&gt;            &lt;!-- 是否使用实际列名,默认为false --&gt;            &lt;!-- &lt;property name=\"useActualColumnNames\" value=\"false\" /&gt; --&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;四、使用MyBatis Generator配置好后，双击Maven中的MyBatis Generator运行  参考：MyBatis Generator 超详细配置"
  },
  
  {
    "title": "GaussDB查进程锁和杀进程",
    "url": "/posts/gaussdb-shajincheng/",
    "categories": "Knowledge, GaussDB",
    "tags": "GaussDB",
    "date": "2024-05-10 13:47:00 +0800",
    





    
    "snippet": "通过以下SQL就能确认当前的连接用户、连接地址、连接应用、状态、是否等待锁、排队状态以及线程idSELECT  usename,  client_addr,  application_name,  state,  waiting,  enqueue,  pidFROM  PG_STAT_ACTIVITY;中止某个会话连接SELECT PG_TERMINATE_BACKEND(pid);查看当...",
    "content": "通过以下SQL就能确认当前的连接用户、连接地址、连接应用、状态、是否等待锁、排队状态以及线程idSELECT  usename,  client_addr,  application_name,  state,  waiting,  enqueue,  pidFROM  PG_STAT_ACTIVITY;中止某个会话连接SELECT PG_TERMINATE_BACKEND(pid);查看当前处于阻塞状态的查询语句SELECT  pid,  datname,  usename,  state,  queryFROM  PG_STAT_ACTIVITYWHERE  state &lt;&gt; 'idle'  and waiting = true;查看事务有没有持有锁select  datname,  usename,  application_name,  now() - xact_start elp,  waiting,  state,  queryfrom  pg_stat_activitywhere  state &lt;&gt; 'idle';  参考：GaussDB帮助文档"
  },
  
  {
    "title": "AES加密异常",
    "url": "/posts/aes-jiami-yichang/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2024-03-21 11:47:00 +0800",
    





    
    "snippet": "报错信息Java实现AES加密，抛出异常如下：java.security.InvalidKeyException: Illegal key size报错原因Illegal key size or default parameters是指密钥长度受限制，Java运行时环境读到的是受限的policy文件。policy文件位于${java_home}/jre/lib/security 目录下。这种...",
    "content": "报错信息Java实现AES加密，抛出异常如下：java.security.InvalidKeyException: Illegal key size报错原因Illegal key size or default parameters是指密钥长度受限制，Java运行时环境读到的是受限的policy文件。policy文件位于${java_home}/jre/lib/security 目录下。这种限制是因为美国对软件出口的控制。解决方法去除该限制只需下载Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files，覆盖上述目录下的对应jar文件local_policy.jar, US_export_policy.jar即可。下载地址：  JDK6：Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 6  JDK7：Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 7 Download  JDK8：JCE Unlimited Strength Jurisdiction Policy Files for JDK/JRE 8 Download"
  },
  
  {
    "title": "数据库常用查询和函数",
    "url": "/posts/shujuku-changyong-hanshu/",
    "categories": "Knowledge, Database",
    "tags": "Database",
    "date": "2024-02-22 08:47:00 +0800",
    





    
    "snippet": "MySQL-- 字符串转数字-- 1、+0select '00123' + 0;-- 2、cast('字符串' as 数值类型)-- 整数 SIGNED，无符号整数 UNSIGNED，浮点数 DECIMALselect cast('000123' as SIGNED);-- 3、convert('字符串', 数值类型)-- 整数 SIGNED，无符号整数 UNSIGNED，浮点数 DECIM...",
    "content": "MySQL-- 字符串转数字-- 1、+0select '00123' + 0;-- 2、cast('字符串' as 数值类型)-- 整数 SIGNED，无符号整数 UNSIGNED，浮点数 DECIMALselect cast('000123' as SIGNED);-- 3、convert('字符串', 数值类型)-- 整数 SIGNED，无符号整数 UNSIGNED，浮点数 DECIMALselect convert('000123' as SIGNED);"
  },
  
  {
    "title": "Mybatis分页计算公式",
    "url": "/posts/mybatis-fenye-jisuan-gongshi/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2024-02-21 09:47:00 +0800",
    





    
    "snippet": "MySQL-- n为页码，m为每页数据条数select * from table_name limit (n-1)*m, mOracle-- n为页码，m为每页数据条数select a.* from (  select b.*,rownum as rn from table_name b) awhere a.rn between (n-1)*m+1 and n*m  ",
    "content": "MySQL-- n为页码，m为每页数据条数select * from table_name limit (n-1)*m, mOracle-- n为页码，m为每页数据条数select a.* from (  select b.*,rownum as rn from table_name b) awhere a.rn between (n-1)*m+1 and n*m  "
  },
  
  {
    "title": "GaussDB正则查询",
    "url": "/posts/gaussdb-zhengze-chaxun/",
    "categories": "Knowledge, GaussDB",
    "tags": "GaussDB",
    "date": "2024-01-27 13:47:00 +0800",
    





    
    "snippet": "GaussDB使用正则表达式查询示例：-- 查询所有以abc开头的字符串select * from table where cloum ~ '^abc'",
    "content": "GaussDB使用正则表达式查询示例：-- 查询所有以abc开头的字符串select * from table where cloum ~ '^abc'"
  },
  
  {
    "title": "List转String，逗号分割",
    "url": "/posts/java-list-zhuan-string-douhao-fenge/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2024-01-27 11:47:00 +0800",
    





    
    "snippet": "// 将List转化为逗号分割的字符串String str = String.join(\",\", list);String str = StringUtils.json(list.toArray(), \",\");// 将逗号分隔的字符串转换为ListList&lt;String&gt; list = Arrays.asList(str.split(\",\"));List&lt;String&g...",
    "content": "// 将List转化为逗号分割的字符串String str = String.join(\",\", list);String str = StringUtils.json(list.toArray(), \",\");// 将逗号分隔的字符串转换为ListList&lt;String&gt; list = Arrays.asList(str.split(\",\"));List&lt;String&gt; list = Arrays.asList(StringUtils.split(str, \",\"));"
  },
  
  {
    "title": "Mybatis报错，栏位索引超过许可范围",
    "url": "/posts/mybatis-baocuo/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2024-01-27 09:47:00 +0800",
    





    
    "snippet": "报错信息Caused by: org.postgresql.util.PSQLException: 栏位索引超过许可范围：4，栏位数：3报错原因极有可能是Mybatis的xml文件中的注释格式书写不正确解决办法删除或修正xml中注释",
    "content": "报错信息Caused by: org.postgresql.util.PSQLException: 栏位索引超过许可范围：4，栏位数：3报错原因极有可能是Mybatis的xml文件中的注释格式书写不正确解决办法删除或修正xml中注释"
  },
  
  {
    "title": "分布式情况下synchronized锁失效",
    "url": "/posts/fenbushi-xia-synchronized-suo-shixiao/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2023-12-12 11:47:00 +0800",
    





    
    "snippet": "  参考：IDEA启动两个Tomcat服务的方式 &amp; 使用nginx进行反向代理 &amp; JMeter测试分布式情况下synchronized锁失效",
    "content": "  参考：IDEA启动两个Tomcat服务的方式 &amp; 使用nginx进行反向代理 &amp; JMeter测试分布式情况下synchronized锁失效"
  },
  
  {
    "title": "使用Magisk获取root权限相关",
    "url": "/posts/Magisk/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-10-31 13:47:00 +0800",
    





    
    "snippet": "官方网址Shizuku：https://shizuku.rikka.app/zh-hans/小黑屋：https://stopapp.https.gs/Magisk中文网：https://magiskcn.com/固件ColorOS官方固件：https://www.coloros.com/romMagisk插件AD快消：https://www.magisk.cool/2020/10/11/ad...",
    "content": "官方网址Shizuku：https://shizuku.rikka.app/zh-hans/小黑屋：https://stopapp.https.gs/Magisk中文网：https://magiskcn.com/固件ColorOS官方固件：https://www.coloros.com/romMagisk插件AD快消：https://www.magisk.cool/2020/10/11/adkuaixiao.html隐藏root( rootcloak)：https://www.magisk.cool/2020/09/23/yincangroot-rootcloak.html#google_vignette安装教程Magisk细安装教程：https://momeis.net/post-65473.html"
  },
  
  {
    "title": "UnsupportedOperationException异常",
    "url": "/posts/UnsupportedOperationException-yichang/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2023-10-31 11:47:00 +0800",
    





    
    "snippet": "报错信息java.lang.UnsupportedOperationException: null    at java.util.AbstractList.add(AbstractList.java:148) ~[?:1.8.0_131]    at java.util.AbstractList.add(AbstractList.java:108) ~[?:1.8.0_131]报错原因pu...",
    "content": "报错信息java.lang.UnsupportedOperationException: null    at java.util.AbstractList.add(AbstractList.java:148) ~[?:1.8.0_131]    at java.util.AbstractList.add(AbstractList.java:108) ~[?:1.8.0_131]报错原因public class test {  public static void main(String[] args) {    //定义一个字符长度为5的字符串    String[] strings = new String[5];    strings[0] = \"a\";    strings[1] = \"b\";    strings[2] = \"c\";    strings[3] = \"d\";    strings[4] = \"e\";     //调用Arrays中的asList方法将String[]转化为List&lt;String&gt;    List&lt;String&gt; list = Arrays.asList(strings);    System.out.println(\"list&lt;String&gt;:\" + list.toString());     //为list添加一个元素    list.add(\"f\");    System.out.println(\"list&lt;String&gt;:\" + list.toString());  }}Arrays.asList(strings);方法返回的List对象不是我们常见的ArrayList，而是Arrays的一个内部类，我们把返回的对象处理一下，转成我们熟悉的List实现类就可以了。List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(strings));或List&lt;String&gt; list = new ArrayList&lt;&gt;();list.addAll(Arrays.asList(strings));  参考：UnsupportedOperationException异常解析"
  },
  
  {
    "title": "Java多线程共享Map",
    "url": "/posts/java-duoxiancheng-gongxiang-map/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2023-10-25 11:47:00 +0800",
    





    
    "snippet": "在Java编程中，多线程是一种常见的并发编程模型，可以有效地提高程序的性能和响应能力。然而，在多线程环境下，共享数据的访问可能会导致问题，特别是在操作共享的数据结构时。本文将介绍如何在多线程环境下共享Map，并提供相应的代码示例和解释。我们将通过使用ConcurrentHashMap来实现多线程共享的Map，它是Java中线程安全的Hash表实现。它是通过使用锁分段技术来实现高效的并发访问。...",
    "content": "在Java编程中，多线程是一种常见的并发编程模型，可以有效地提高程序的性能和响应能力。然而，在多线程环境下，共享数据的访问可能会导致问题，特别是在操作共享的数据结构时。本文将介绍如何在多线程环境下共享Map，并提供相应的代码示例和解释。我们将通过使用ConcurrentHashMap来实现多线程共享的Map，它是Java中线程安全的Hash表实现。它是通过使用锁分段技术来实现高效的并发访问。下面是一个示例代码，演示了如何使用ConcurrentHashMap来实现线程安全的Map。import java.util.Map;import java.util.concurrent.ConcurrentHashMap;public class SharedMapExample {    private static Map&lt;String, Integer&gt; sharedMap = new ConcurrentHashMap&lt;&gt;();    public static void main(String[] args) {        // 创建多个线程来同时访问和修改共享的Map        Thread thread1 = new Thread(() -&gt; {            for (int i = 0; i &lt; 10000; i++) {                sharedMap.put(\"key\" + i, i);            }        });        Thread thread2 = new Thread(() -&gt; {            for (int i = 0; i &lt; 10000; i++) {                sharedMap.put(\"key\" + i, i);            }        });        // 启动线程        thread1.start();        thread2.start();        // 等待线程执行完成        try {            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        // 输出Map的大小        System.out.println(\"Map size: \" + sharedMap.size());    }}在上面的代码中，我们首先创建了一个ConcurrentHashMap实例作为共享的Map。然后，我们创建两个线程，并在每个线程中使用put()方法往Map中添加10000个键值对。最后，我们等待两个线程执行完成，并输出Map的大小。由于ConcurrentHashMap是线程安全的，所以即使多个线程同时访问和修改Map，也不会出现问题。  参考：java多线程共享map"
  },
  
  {
    "title": "GaussDB去重",
    "url": "/posts/gaussdb-quchong/",
    "categories": "Knowledge, GaussDB",
    "tags": "GaussDB",
    "date": "2023-10-24 13:47:00 +0800",
    





    
    "snippet": "1、示例场景描述以保险行业的客户信息去重为例，为防止坐席重复联系客户，需要将客户进行唯一身份识别。存在以下两种情况，需要将其识别成一个人，这时候就需要进行数据去重的动作。  情况一：同一个客户有不同的来源渠道：客户即购买了寿险、又购买了产险（两个不同的来源系统）；  情况二：同一个客户多次回流：客户在同一个渠道多次购买（续保或者购买同一险种的不同产品）。2、定义重复数据通过姓名+证件类型+证...",
    "content": "1、示例场景描述以保险行业的客户信息去重为例，为防止坐席重复联系客户，需要将客户进行唯一身份识别。存在以下两种情况，需要将其识别成一个人，这时候就需要进行数据去重的动作。  情况一：同一个客户有不同的来源渠道：客户即购买了寿险、又购买了产险（两个不同的来源系统）；  情况二：同一个客户多次回流：客户在同一个渠道多次购买（续保或者购买同一险种的不同产品）。2、定义重复数据通过姓名+证件类型+证件号将其识别为一个人，即只要这三个字段重复，就认为这些数据行为重复数据。3、制定去重规则  多选一随机：根据去重规则，随机保留一条数据。优先级：根据去重规则 + 业务逻辑，保留优先需要的一条数据。例如优先保留“是否有房、是否有车”。  多合一将重复数据合并成一条数据，合并规则根据业务逻辑确定。4、创建测试数据（GaussDB）客户信息字段主要包含姓名、性别、出生年月日、证件类型、证件号、来源、是否有车、是否有房、婚姻状态、手机号、……等信息。--创建客户信息表CREATE TABLE customer(  name VARCHAR(20),  sex INT,  birthday VARCHAR(10),  ID_type INT,  ID_number VARCHAR(20),  source VARCHAR(10),  IS_car INT,  IS_house INT,  marital_status INT,  tel_number VARCHAR(15)); --插入测试数据INSERT INTO customer VALUES('张三','1','1988-01-01','1','61010019880101****','寿险','1','1','1','');INSERT INTO customer VALUES('张三','1','1988-01-01','1','61010019880101****','车险','1','0','1','');INSERT INTO customer VALUES('张三','1','1988-01-01','1','61010019880101****','','','','','186****0701');INSERT INTO customer VALUES('李四','1','1989-01-02','1','61010019890102****','寿险','1','1','1','');INSERT INTO customer VALUES('李四','1','1989-01-02','1','61010019890102****','车险','1','0','1','');INSERT INTO customer VALUES('李四','1','1989-01-02','1','61010019890102****','','','','','186****0702'); --查看结果SELECT * FROM customer;5、编写去重方法1）随机保留：根据业务逻辑，随机保留一条记录。SELECT  *FROM  (    SELECT      *,      ROW_NUMBER() OVER (PARTITION BY name, id_type, id_number) as row_num    FROM      customer  )WHERE  row_num = 1;  说明：      ROW_NUMBER()：从第一行开始，依次为每一行分配一个唯一且连续的编号。    PARTITION BY col1[, col2…]：指定分区的列，例如去重的键“姓名、证件类型、证件号码”。    WHERE row_num = 1：取ROW_NUMBER()生成的编号1。  2）按优先级保留：根据业务逻辑，优先保留有手机号的一条记录，如果有多条记录含有手机号或有没有手机号，则在此基础上随机保留。--保留含有手机号的记录行SELECT  t.*FROM  (    SELECT      *,      ROW_NUMBER() OVER (PARTITION BY name, id_type, id_number        ORDER BY tel_number ASC      ) as row_num    FROM      customer  ) tWHERE  t.row_num = 1;  说明：      ROW_NUMBER()：从第一行开始，依次为每一行分配一个唯一且连续的号码。    PARTITION BY col1[, col2…]：指定分区的列，例如去重的键“姓名、证件类型、证件号码”。    ORDER BY col [asc或desc]：指定排序的列。升序（ ASC ）排列指只保留第一行，而降序排列（ DESC ）则指保留最后一行。    WHERE row_num = 1：取ROW_NUMBER()生成的编号1。  3）合并保留：根据业务逻辑，合并完整性高、准确性高的字段信息。例如优先将含有手机号的记录行进行补齐，需要补齐的字段有“是否有车、是否有房、婚姻状况”，其取值是来源为“车险”的对应记录。--合并保留SELECT  t1.name,  t1.sex,  t1.birthday,  t1.id_type,  t1.id_number,  t1.source,  t2.is_car,  t2.is_house,  t2.marital_status,  t1.tel_numberFROM  (    SELECT t.* FROM      (SELECT *, \t          ROW_NUMBER() OVER (PARTITION BY name, id_type, id_number            ORDER BY              tel_number ASC          ) as row_num        FROM          customer      ) t    WHERE      t.row_num = 1  ) t1  LEFT JOIN (    SELECT      *    FROM      customer    WHERE      source = '车险'      and is_car IS NOT NULL      AND is_house IS NOT NULL      AND marital_status IS NOT NULL  ) t2 ON t1.name = t2.name  and t1.id_type = t2.id_type  and t1.id_number = t2.id_number  说明：  t1表是优先保留含有手机的记录行（去重），并作为主表，t2表是需要补齐的字段来源表。两张表通过“姓名+证件类型+证件号码”进行关联，然后合并需要的信息。  参考：GaussDB数据库SQL系列-数据去重"
  },
  
  {
    "title": "NoClassDefFoundError：javax/servlet/ServletOutputStream报错解决",
    "url": "/posts/java-servlet-api-baocuo/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2023-10-08 01:47:00 +0800",
    





    
    "snippet": "报错信息java.lang.NoClassDefFoundError: javax/servlet/ServletOutputStreamat java.lang.Class.getDeclaredMethods0(Native Method)at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)at java.lang.C...",
    "content": "报错信息java.lang.NoClassDefFoundError: javax/servlet/ServletOutputStreamat java.lang.Class.getDeclaredMethods0(Native Method)at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)at java.lang.Class.privateGetMethodRecursive(Class.java:3048)at java.lang.Class.getMethod0(Class.java:3018)at java.lang.Class.getMethod(Class.java:1784)at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)Caused by: java.lang.ClassNotFoundException: javax.servlet.ServletOutputStreamat java.net.URLClassLoader.findClass(URLClassLoader.java:381)at java.lang.ClassLoader.loadClass(ClassLoader.java:424)at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)at java.lang.ClassLoader.loadClass(ClassLoader.java:357)... 7 moreError: A JNI error has occurred, please check your installation and try againException in thread \"main\"报错原因1、test范围：指的是测试范围有效，在编译和打包时都不会使用这个依赖。2、compile范围：指的是编译范围有效，在编译和打包时都会将依赖存储进去。3、provided范围：在编译和测试的过程有效，最后生成war包时不会加入，诸如：servlet-api，因为servlet-api，Tomcat等web服务器已经存在了，如果再打包会冲突。4、runtime范围：在运行的时候依赖，在编译的时候不依赖。解决办法pom.xml中引入的servlet-api中定义了provided，把这里的provided改成compile&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;  参考：java javax.servlet_java.lang.NoClassDefFoundError: javax/servlet/ServletOutputStream 报错解决Maven中servlet-api的dependency的scope作用域为什么是provided?"
  },
  
  {
    "title": "Mybatis-Plus进行update的三种方式",
    "url": "/posts/mybatis-plus-jinxing-update-de-3zhong-fangshi/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2023-10-07 09:47:00 +0800",
    





    
    "snippet": "第一种：主键updateByIdUser user = new User();// 这个id是主键user.setId(4L);user.setPhone(\"119\");// getBaseMapper是mybatis-plus方法getBaseMapper().updateById(user);第二种：通过实体类筛选进行update// 作为查询条件UpdateWrapper&lt;Use...",
    "content": "第一种：主键updateByIdUser user = new User();// 这个id是主键user.setId(4L);user.setPhone(\"119\");// getBaseMapper是mybatis-plus方法getBaseMapper().updateById(user);第二种：通过实体类筛选进行update// 作为查询条件UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();updateWrapper.eq(\"user_name\", \"rhb\");// new出来的对象作为修改值User user = new User();user.setPhone(\"110\");// 直接update修改getBaseMapper().update(user, updateWrapper);第三种：通过lambdaUpdateWrapper进行updateLambdaUpdateWrapper&lt;User&gt; lambdaUpdateWrapper = new LambdaUpdateWrapper&lt;&gt;();// eq是指你查询的条件，set是指你修改的值lambdaUpdateWrapper      .eq(User::getPhone, \"110\")      .set(User::getPhone, \"119\");getBaseMapper().update(null, lambdaUpdateWrapper);  参考：mybatis-plus进行update的三种方式"
  },
  
  {
    "title": "Linux和Windows平台Android SDK中build tools的区别",
    "url": "/posts/linux-he-win-build-tools-qubie/",
    "categories": "Knowledge, Android",
    "tags": "Android",
    "date": "2023-07-25 13:47:00 +0800",
    





    
    "snippet": "在linux和Windows平台上，gradle wrapper和gradle依赖的jar都是不区分平台的├── gradle│   └── wrapper│       ├── gradle-wrapper.jar│       └── gradle-wrapper.properties├── gradlew└── gradlew.bat一个Android项目gradle结构（看一个基本结...",
    "content": "在linux和Windows平台上，gradle wrapper和gradle依赖的jar都是不区分平台的├── gradle│   └── wrapper│       ├── gradle-wrapper.jar│       └── gradle-wrapper.properties├── gradlew└── gradlew.bat一个Android项目gradle结构（看一个基本结构的Android多Moudule（也就是gradle中的多Project Multi-Projects Build）的基本项目结构）├── app #Android App目录│   ├── app.iml│   ├── build #构建输出目录│   ├── build.gradle #构建脚本│   ├── libs #so相关库│   ├── proguard-rules.pro #proguard混淆配置│   └── src #源代码，资源等├── module #Android 另外一个module目录│   ├── module.iml│   ├── build #构建输出目录│   ├── build.gradle #构建脚本│   ├── libs #so相关库│   ├── proguard-rules.pro #proguard混淆配置│   └── src #源代码，资源等├── build│   └── intermediates├── build.gradle #工程构建文件├── gradle│   └── wrapper├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat├── LibSqlite.iml├── local.properties #配置Androod SDK位置文件└── settings.gradle #工程配置AndroidStudio中的项目结构├── app │   ├── build.gradle #构建脚本├── module │   ├── build.gradle #构建脚本├── build.gradle #工程构建文件├── gradle│   └── wrapper    #先不去管它├── gradle.properties #gradle的配置├── gradlew #gradle wrapper linux shell脚本├── gradlew.bat└── settings.gradle #工程配置但是对于Android SDK中部分工具是不区分Linux和Windows的。比如platform中android API是不区别系统平台的。但是对于SDK中的build-tools是区分平台的WindowsLinux对于platform-tool也是根据系统平台来的WindowsLinux"
  },
  
  {
    "title": "Gradle的安装配置及使用",
    "url": "/posts/gradle-anzhuang-he-shiyong/",
    "categories": "Knowledge, Gradle",
    "tags": "Gradle",
    "date": "2023-07-20 08:47:00 +0800",
    





    
    "snippet": "1、官网下载链接https://gradle.org/releases/，下载后解压2、新建GRADLE_HOME环境变量指向Gradle解压路径3、将%GRADLE_HOME%\\bin添加到Path环境变量中4、打开cmd命令行输入gradle -v验证Gradle是否安装成功5、配置Gradle默认的仓库地址，Gradle和Maven类似也需要配置仓库地址，首先新建一个文件夹，然后新建G...",
    "content": "1、官网下载链接https://gradle.org/releases/，下载后解压2、新建GRADLE_HOME环境变量指向Gradle解压路径3、将%GRADLE_HOME%\\bin添加到Path环境变量中4、打开cmd命令行输入gradle -v验证Gradle是否安装成功5、配置Gradle默认的仓库地址，Gradle和Maven类似也需要配置仓库地址，首先新建一个文件夹，然后新建GRADLE_USER_HOME环境变量指向新建的文件夹6、配置阿里云镜像，在Gradle安装目录的init.d文件夹中新建一个init.gradle文件并在文件中添加如下配置allprojects {    repositories {        mavenLocal()        maven { name \"Alibaba\" ; url \"https://maven.aliyun.com/repository/public\" }        maven { name \"Bstek\" ; url \"http://nexus.bsdn.org/content/groups/public/\" }        mavenCentral()    }    buildscript {         repositories {             maven { name \"Alibaba\" ; url 'https://maven.aliyun.com/repository/public' }            maven { name \"Bstek\" ; url 'http://nexus.bsdn.org/content/groups/public/' }            maven { name \"M2\" ; url 'https://plugins.gradle.org/m2/' }        }    }}"
  },
  
  {
    "title": "MySQL查询数据库的数据量大小",
    "url": "/posts/mysql-chaxun-shujuku-shujuliang-daxiao/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2023-07-02 09:47:00 +0800",
    





    
    "snippet": "查询数据库最大连接数show variables like '%max_connections%';查询数据库连接超时时间单位(s)Show variables like 'wait_timeout';查询各个数据库量的大小select  TABLE_SCHEMA,  CONCAT(ROUND(SUM(DATA_LENGTH / 1024 / 1024), 2), 'MB') dbsizef...",
    "content": "查询数据库最大连接数show variables like '%max_connections%';查询数据库连接超时时间单位(s)Show variables like 'wait_timeout';查询各个数据库量的大小select  TABLE_SCHEMA,  CONCAT(ROUND(SUM(DATA_LENGTH / 1024 / 1024), 2), 'MB') dbsizefrom  information_schema.tablesgroup by  TABLE_SCHEMA;查询指定数据库量的大小select  '数据库大小',  CONCAT(ROUND(SUM(DATA_LENGTH / 1024 / 1024), 2), 'MB') dbsizefrom  information_schema.tableswhere  table_schema = '库名';查询某个表的大小select  '表大小',  CONCAT(ROUND(SUM(DATA_LENGTH / 1024 / 1024), 2), 'MB') tbsizefrom  information_schema.tableswhere  table_schema = '库名'  and table_name = '表名';查询各个表的大小select  table_name,  '表大小',  CONCAT(ROUND(SUM(DATA_LENGTH / 1024 / 1024), 2), 'MB') tbsizefrom  information_schema.tableswhere  table_schema = '库名'group by  table_name;"
  },
  
  {
    "title": "正向代理和反向代理",
    "url": "/posts/zhengxiangdaili-he-fanxiangdaili/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-06-21 13:47:00 +0800",
    





    
    "snippet": "正向代理是一个位于客户端和原始服务器之间的服务器。反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器。两者区别在于正向代理代理的对象是客户端，反向代理代理的对象是服务端。一、正向代理举个例子：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内...",
    "content": "正向代理是一个位于客户端和原始服务器之间的服务器。反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器。两者区别在于正向代理代理的对象是客户端，反向代理代理的对象是服务端。一、正向代理举个例子：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。总结来说：正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。正向代理的用途：  访问原来无法访问的资源，如google  可以做缓存，加速访问资源  对客户端访问授权，上网进行认证  代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息二、反向代理初次接触反向代理的感觉是，客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。反向代理的作用：  保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。  负载均衡，通过反向代理服务器来优化网站的负载。三、Nginx的反向代理Nginx支持配置反向代理，通过反向代理实现网站的负载均衡。Nginx通过proxy_pass_http配置代理站点，upstream实现负载均衡。"
  },
  
  {
    "title": "Filebeat启动后自动停止的问题",
    "url": "/posts/filebeat-zidong-tingzhi-de-wenti/",
    "categories": "Knowledge, Filebeat",
    "tags": "Filebeat",
    "date": "2023-06-14 13:47:00 +0800",
    





    
    "snippet": "Linux环境部署的Filebeat在启动正常的情况下自动停止运行。启动Filebeat的指令是：nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;通过对nohup的指令了解后发现，当关闭xshell终端时，断开ssh连接，会导致nohup进程同时终止。解决办法：关闭xshell终端前，先exit退出，断开s...",
    "content": "Linux环境部署的Filebeat在启动正常的情况下自动停止运行。启动Filebeat的指令是：nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;通过对nohup的指令了解后发现，当关闭xshell终端时，断开ssh连接，会导致nohup进程同时终止。解决办法：关闭xshell终端前，先exit退出，断开ssh连接，然后就可以关闭终端；或者在原来的启动指令上加上disown参数，这个参数会将nohup进程从当前shell的作业列表中清除，从而避免在关闭xshell时nohup进程接收到SIGHUP信号而停止运行:nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp; disown"
  },
  
  {
    "title": "宝兰德部署Spring Boot项目",
    "url": "/posts/springboot-zhenghe-baolande/",
    "categories": "Knowledge, BES Web",
    "tags": "BES Web",
    "date": "2023-05-29 13:47:00 +0800",
    





    
    "snippet": "之前在网上找资料看到说Spring Boot部署宝兰德有jar包的改造，这里说明下，如果最终应用要部署在BES单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突。即com单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突，即com.bes.enterprise.logging.internal.Log: ...",
    "content": "之前在网上找资料看到说Spring Boot部署宝兰德有jar包的改造，这里说明下，如果最终应用要部署在BES单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突。即com单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突，即com.bes.enterprise.logging.internal.Log: Provider com.bes.enterprise.jul.formatter.log.BESASLog not a subtype。BES和Tomcat中间件针对springboot的部署方式是一致的，因此这种情况，不需要做单独的改造。只有单集成宝兰德时，才需要在项目中添加相应的jar包，如下所示（程序包由宝兰德提供）            包名      说明                  bes-lite-spring-boot-2.x-starter-9.5.2      核心包，必须              bes-actuator-spring-boot-2.x-starter-9.5.2.jar      监控包，可选              bes-websocket      支持websocket              bes-gmssl      国密安全包，可选              bes-jasper      支持JSP，可选              bes-jdbcra      支持JDBC ，可选      ​项目pom中去掉spring-boot-starter-web的Tomcat依赖，将上面用到的包放到自己的私服后，在pom中添加如下内容：&lt;dependency&gt;    &lt;groupId&gt;com.bes.appserver&lt;/groupId&gt;    &lt;artifactId&gt;bes-lite-spring-boot-2.x-starter&lt;/artifactId&gt;    &lt;version&gt;9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.bes.appserver&lt;/groupId&gt;    &lt;artifactId&gt;bes-websocket&lt;/artifactId&gt;    &lt;version&gt;9.5.2&lt;/version&gt;&lt;/dependency&gt;"
  },
  
  {
    "title": "宝兰德常用命令",
    "url": "/posts/baolande-changyong-mingling/",
    "categories": "Knowledge, BES Web",
    "tags": "BES Web",
    "date": "2023-05-29 13:47:00 +0800",
    





    
    "snippet": "登录命令行控制台./iastool --passport admin创建节点create --node --host 192.168.92.135 --port 1900 --user admin \\--password admin --domainname domain1 node136创建名为domain1的域./iastool create --domain --passport ad...",
    "content": "登录命令行控制台./iastool --passport admin创建节点create --node --host 192.168.92.135 --port 1900 --user admin \\--password admin --domainname domain1 node136创建名为domain1的域./iastool create --domain --passport admin --user admin \\--password admin --adminport 1900 domain1创建名为Node1的节点./iastool create --node --passport admin --domainname domain1 Node1创建名Server1的实例./iastool create --instance --passport admin --node Node1 Server1启动BES的顺序是先启动域，再启动节点，最后启动实例# 启动域domain1 (必须命令行启动)./iastool start --domain --passport admin domain1# 启动节点Node1 (必须命令行启动)./iastool start --node --passport admin --domainname domain1 Node1 # 启动实例Server1 (必须命令行启动)./iastool start --instance --passport admin Server1停止BES的顺序是先停止实例，再停止节点，最后停止域# 停止实例Server1./iastool stop --instance --passport admin Server1 # 停止节点Node1./iastool stop --node --passport admin --domainname domain1 Node1 # 停止域domain1./iastool stop --domain --passport admin domain1创建集群名为Cluster1的集群./iastool create --cluster --passport admin --user admin --password admin Cluster1在集群Cluster1下创建集群实例c1s1（将此实例创建在节点Node1下）./iastool create --instance --passport admin --ajpport 60001 \\--node Node1--cluster Cluster1 c1s1在集群Cluster1下创建集群实例c1s2（将此实例创建在节点Node2下）./iastool create --instance --passport admin --ajpport 60002 \\--node Node2--cluster Cluster1 c1s2部署应用./iastool deploy --passport admin --host localhost --port 1900 --user admin \\--password admin --domain domain1 --target server01 D:\\tmp\\J2EE5WebTest.war解部署应用./iastool undeploy --passport admin --host localhost --port 1900 --user admin \\--password admin --domain domain1 --target server01 J2EE5WebTest"
  },
  
  {
    "title": "MySQL查询主键相关",
    "url": "/posts/mysql-chaxun-zhujian/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2023-05-25 13:47:00 +0800",
    





    
    "snippet": "-- 查询数据库中所有表名和表的主键select table_name,column_name from information_schema.key_column_usage where constraint_name = 'primary' and table_name in (select table_namefrom information_schema.tableswhere ta...",
    "content": "-- 查询数据库中所有表名和表的主键select table_name,column_name from information_schema.key_column_usage where constraint_name = 'primary' and table_name in (select table_namefrom information_schema.tableswhere table_schema = 'testdb' order by table_name)and table_schema = 'testdb';-- 查询数据库中没有主键的表SELECT    a.TABLE_SCHEMA,    a.TABLE_NAME FROM    (    SELECT        TABLE_SCHEMA,        TABLE_NAME     FROM        information_schema.TABLES     WHERE    TABLE_SCHEMA NOT IN \t( 'mysql', 'information_schema', 'performance_schema', 'sys', 'sysdb' )) AS a    LEFT JOIN (    SELECT        TABLE_SCHEMA,        TABLE_NAME     FROM        information_schema.TABLE_CONSTRAINTS     WHERE        CONSTRAINT_TYPE = 'PRIMARY KEY'     AND TABLE_SCHEMA NOT IN \t( 'mysql', 'information_schema', 'performance_schema', 'sys', 'sysdb' )) AS b     ON a.TABLE_SCHEMA = b.TABLE_SCHEMA     AND a.TABLE_NAME = b.TABLE_NAME WHERE    b.TABLE_NAME IS NULL;"
  },
  
  {
    "title": "Redis使用redis-cli连接报错：WRONGPASS invalid username-password pair or user is disabled.",
    "url": "/posts/redis-lianjie-baocuo/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2023-05-24 13:47:00 +0800",
    





    
    "snippet": "报错信息使用redis-cli连接Redis时报错，具体为认证失败问题WRONGPASS invalid username-password pair or user is disabled.。之前输入auth pass即可，但此次在终端窗口有提示需要username。报错原因本机Redis为7.0版本。Redis6.0起，支持ACL权限控制，Redis6.0之前的版本只支持验证密码方式的权...",
    "content": "报错信息使用redis-cli连接Redis时报错，具体为认证失败问题WRONGPASS invalid username-password pair or user is disabled.。之前输入auth pass即可，但此次在终端窗口有提示需要username。报错原因本机Redis为7.0版本。Redis6.0起，支持ACL权限控制，Redis6.0之前的版本只支持验证密码方式的权限控制，格式如下：AUTH &lt;password&gt;。当使用Redis ACLs权限控制时，AUTH 验证格式如下：AUTH &lt;username&gt; &lt;password&gt;，在ACLs模式下，如果传递一个密码参数给AUTH，那么会隐式设置用户名default。解决方法使用auth default &lt;password&gt;验证。"
  },
  
  {
    "title": "Nginx添加ssl模块",
    "url": "/posts/nginx-tianjia-ssl-mokuai/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2023-05-23 13:47:00 +0800",
    





    
    "snippet": "一、在安装时添加ssl模块1、进入源码包所在的目录，进行编译，编译时添加参数–with-http_stub_status_module --with-http_ssl_modulecd /usr/local/nginx-1.20.2./configure --with-http_stub_status_module --with-http_ssl_module2、进行编译与编译安装make ...",
    "content": "一、在安装时添加ssl模块1、进入源码包所在的目录，进行编译，编译时添加参数–with-http_stub_status_module --with-http_ssl_modulecd /usr/local/nginx-1.20.2./configure --with-http_stub_status_module --with-http_ssl_module2、进行编译与编译安装make &amp;&amp; make install3、查看是否含有ssl模块/usr/local/nginx/sbin/nginx -V二、在安装好后添加ssl模块1、进入到源码包所在的目录，进行编译，编译时添加参数./configure --prefix=系统生成的Nginx目录 --with-http_stub_status_module --with-http_ssl_module./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module2、编译（这里不能编译安装）make3、配置Nginx二进制文件cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak4、停掉Nginxkillall nginx5、替换Nginx二进制文件（新的二进制文件在源码包的objs目录里面）cd objscp nginx /usr/local/nginx/sbin/6、查看ssl模块是否已添加/usr/local/nginx/sbin/nginx -V"
  },
  
  {
    "title": "Nginx配置详解",
    "url": "/posts/nginx-peizhi-xiangjie/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2023-05-23 13:47:00 +0800",
    





    
    "snippet": "一、main：全局配置#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;该部分配置主要影响Nginx全局，上述配置都是存放在main...",
    "content": "一、main：全局配置#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;该部分配置主要影响Nginx全局，上述配置都是存放在main全局配置模块中的配置项。  user：用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行；  worker_processes：指定Nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍；  error_log：定义错误日志文件的位置及输出级别【debug/info/notice/warn/error/crit】；  pid：用来指定进程id的存储文件的位置；  worker_rlimit_nofile：用于指定一个进程可以打开最多文件数量的描述。二、events：配置Nginx工作模式events {    worker_connections  1024;    multi_accept on;    use epoll;}该部分配置主要影响Nginx服务器与用户的网络连接，上述配置是针对Nginx服务器的工作模式的一些操作配置。  worker_connections：指定最大可以同时接收的连接数量，这里一定要注意，最大连接数量是和worker processes共同决定的；  multi_accept：指定Nginx在收到一个新连接通知后尽可能多的接受更多的连接；  use epoll：配置指定了线程轮询的方法，如果是linux2.6+，使用epoll，如果是BSD如Mac请使用Kqueue。三、http：配置http协议信息作为web服务器，http模块是Nginx最核心的一个模块，配置项也是比较多的，项目中会涉及到很多的实际业务场景，需要根据硬件信息进行适当的配置，常规情况下，使用默认配置即可。http {    # 基础配置    sendfile on;    tcp_nopush on;    tcp_nodelay on;    keepalive_timeout 65;    types_hash_max_size 2048;    # server_tokens off;    # server_names_hash_bucket_size 64;    # server_name_in_redirect off;    include /etc/nginx/mime.types;    default_type application/octet-stream;    # SSL证书配置    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE    ssl_prefer_server_ciphers on;    # 日志配置    access_log /var/log/nginx/access.log;    error_log /var/log/nginx/error.log;    # gzip压缩配置    gzip on;    gzip_disable \"msie6\";    # gzip_vary on;    # gzip_proxied any;    # gzip_comp_level 6;    # gzip_buffers 16 8k;    # gzip_http_version 1.1;    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;    # 虚拟主机配置    server {        ......    }}基础配置  sendfile on：配置on让sendfile发挥作用，将文件的回写过程交给数据缓冲去去完成，而不是放在应用中完成，这样的话在性能提升有有好处；  tc_nopush on：让Nginx在一个数据包中发送所有的头文件，而不是一个一个单独发；  tcp_nodelay on：让Nginx不要缓存数据，而是一段一段发送，如果数据的传输有实时，性的要求的话可以配置它，发送完一小段数据就立刻能得到返回值；  keepalive_timeout 10：给客户端分配连接超时时间，服务器会在这个时间过后关闭连接，一般设置时间较短，可以让Nginx工作持续性更好；  client_header_timeout 10：设置请求头的超时时间；  client_body_timeout 10：设置请求体的超时时间；  send_timeout 10：指定客户端响应超时时间，如果客户端两次操作间隔超过这个时间，服务器就会关闭这个链接；  limit_conn_zone $binary_remote_addr zone=addr:5m：设置用于保存各种key的共享内存的参数.  limit_conn addr 100: 给定的key设置最大连接数；  server_tokens：虽然不会让Nginx执行速度更快，但是可以在错误页面关闭Nginx版本，提示，对于网站安全性的提升有好处；  include /etc/nginx/mime.types：指定在当前文件中包含另一个文件的指令；  default_type application/octet-stream：指定默认处理的文件类型可以是二进制；  type_hash_max_size 2048：混淆数据，影响三列冲突率，值越大消耗内存越多，散列key冲突率会降低，检索速度更快；值越小key，占用内存较少，冲突率越高，检索速度变慢。日志配置  access_log logs/access.log：设置存储访问记录的日志；  error_log logs/error.log：设置存储记录错误发生的日志。SSL证书加密  ssl_protocols：指令用于启动特定的加密协议，Nginx在1.1.13和1.0.12版本后默认是ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2，TLSv1.1与TLSv1.2要确保OpenSSL &gt;= 1.0.1，SSLv3现在还有很多地方在用但有不少被攻击的漏洞；  ssl prefer server ciphers：设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。压缩配置  gzip on：告诉Nginx采用gzip压缩的形式发送数据，这将会减少我们发送的数据量；  gzip_disable：为指定的客户端禁用gzip功能；我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。  gzip_static：告诉Nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样Nginx就不用再压缩这些文件了；  gzip_proxied：允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求；  gzip_min_length：设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度；  gzip_comp_level：设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置；  gzip_type：设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。文件缓存配置  open_file_cache：打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉；  open_file_cache_valid：在open_file_cache中指定检测正确信息的间隔时间；  open_file_cache_min_uses：定义了open_file_cache中指令参数不活动时间期间里最小的文件数；  open_file_cache_errors：指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置；四、server：配置服务器访问信息srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息。server {    listen        80;    server_name   localhost 192.168.1.100;    root          /nginx/www;    index         index.php index.html index.html;    charset       utf-8;    access_log    logs/access.log;    error_log     logs/error.log;    ......}  server：一个虚拟主机的配置，一个http中可以配置多个server；  server_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔；  root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录；  index：用户访问web网站时的全局首页；  charset：用于设置www/路径中配置的网页的默认编码格式；  access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径；  error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径。五、location：配置访问路由location模块是Nginx配置中出现最多的一个配置，主要用于配置路由访问信息，在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location，模块也是一个非常重要的配置模块。location / {    root    /nginx/www;    index   index.php index.html index.htm;}  location /：表示匹配访问根目录；  root：用于指定访问根目录时，访问虚拟主机的web目录；  index：在不指定访问具体资源时，默认展示的资源文件列表。location /api {    proxy_pass http://www.baidu.com;    # 以下是一些反向代理的配置可删除    proxy_redirect     off;     # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP    proxy_set_header   Host $host;     proxy_set_header   X-Real-IP $remote_addr;     proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;     client_max_body_size       10m; #允许客户端请求的最大单文件字节数    client_body_buffer_size    128k; #缓冲区代理缓冲用户端请求的最大字节数    proxy_connect_timeout      300; #Nginx跟后端服务器连接超时时间(代理连接超时)    proxy_send_timeout         300; #后端服务器数据回传时间(代理发送超时)    proxy_read_timeout         300; #连接成功后，后端服务器响应时间(代理接收超时)    proxy_buffer_size          4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小    proxy_buffers              4 32k; #proxy_buffers缓冲区，网页平均在32k以下就设置    proxy_busy_buffers_size    64k; #高负荷下缓冲大小（proxy_buffers*2）    proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传}六、upstream：配置负载均衡upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器。upstream name {    ip_hash;    server 192.168.1.100:8000;    server 192.168.1.100:8001 down;    server 192.168.1.100:8002 max_fails=3;    server 192.168.1.100:8003 fail_timeout=20s;    server 192.168.1.100:8004 max_fails=3 fail_timeout=20s;}  ip_hash：指定请求调度算法，默认是weight权重轮询调度，可以指定；  server host:port：分发服务器的列表配置。          down：表示该主机暂停服务；      max_fails：表示失败最大次数，超过失败最大次数暂停服务；      fail_timeout：表示如果请求受理失败，暂停指定的时间之后重新发起请求。      七、一份配置清单  参考：Nginx基本使用"
  },
  
  {
    "title": "Nginx正常启动，端口没有被监听",
    "url": "/posts/nginx-zhengchang-qidong-duankou-meiyou-jianting/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2023-05-22 13:47:00 +0800",
    





    
    "snippet": "启动nginx服务：/usr/local/nginx/sbin/nginx -c conf/nginx.conf启动完成也没有报错，ps看进程也正常，netstat发现端口没有被监听，也没有错误日志，找了半天最后才发现，conf/nginx.conf使用的是安装目录下面的Nginx配置，没有使用我们制定的配置，也就是说我们要用绝对路径制定Nginx配置，如下：/usr/local/nginx...",
    "content": "启动nginx服务：/usr/local/nginx/sbin/nginx -c conf/nginx.conf启动完成也没有报错，ps看进程也正常，netstat发现端口没有被监听，也没有错误日志，找了半天最后才发现，conf/nginx.conf使用的是安装目录下面的Nginx配置，没有使用我们制定的配置，也就是说我们要用绝对路径制定Nginx配置，如下：/usr/local/nginx/sbin/nginx -c /data/app/nginx/conf/nginx.conf如果不确认用的是哪个配置，可以用-t参数先test一下，终端会显示使用的Nginx配置：/usr/local/nginx/sbin/nginx -c conf/nginx.conf -t"
  },
  
  {
    "title": "Redis Desktop Manager使用SSH连接Redis",
    "url": "/posts/shiyong-ssh-fangshi-lianjie-redis/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2023-05-10 13:47:00 +0800",
    





    
    "snippet": "第一步第二步第三步",
    "content": "第一步第二步第三步"
  },
  
  {
    "title": "如何卸载UniAccessAgent并且不影响网络连接",
    "url": "/posts/ruhe-xiezai-uniacess/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2023-05-10 08:47:00 +0800",
    





    
    "snippet": "下载360安全卫士文件粉碎机独立版，使用文件粉碎机打开C:\\Windows\\LVUAAgentInstBaseRoot目录（使用Windows资源管理器打开无法看到目录下的文件），强力删除目录下的UniAccessAgentBrowser.exe、UniAccessAgentDaemon.exe、UniAccessAgentTray.exe这3个文件，UniAccessAgentUI.exe...",
    "content": "下载360安全卫士文件粉碎机独立版，使用文件粉碎机打开C:\\Windows\\LVUAAgentInstBaseRoot目录（使用Windows资源管理器打开无法看到目录下的文件），强力删除目录下的UniAccessAgentBrowser.exe、UniAccessAgentDaemon.exe、UniAccessAgentTray.exe这3个文件，UniAccessAgentUI.exe和UniAccessAgent.exe这两个文件要留着，这个就是程序的界面，然后UniAccessAgentUI.exe创建一个快捷方式到桌面，如果不能登录内网，双击快捷方式就会弹出桌面管家网络认证的界面，点击其中的登录网络即可。然后重启Windows系统，UniAccessAgent相关的进程就不会自动重启了。# Ntrtscan服务注册sc create ntrtscan binpath= \"C:\\Program Files (x86)\\Asiainfo Security\\OfficeScan Client\\Ntrtscan.exe\" type= own start= auto displayname= \"OfficeScan NT RealTime Scan\"# UniAccessAgent服务注册sc create UniAccessAgent binpath= \"C:\\Windows\\LVUAAgentInstBaseRoot\\UniAccessAgent.exe\" type= own start= auto displayname= \"UniAccessAgent\"# 启动服务sc start ntrtscan# 停止服务sc stop ntrtscan# 删除服务sc delete ntrscan"
  },
  
  {
    "title": "JSON转XML工具类",
    "url": "/posts/json-zhuan-xml-gongjulei/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2023-05-10 01:47:00 +0800",
    





    
    "snippet": "import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Test {...",
    "content": "import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Test {    /**     * Json to xml string.     *     * @param json the json     * @return the string     */    public static String jsonToXml(String json){        try {            StringBuffer buffer = new StringBuffer();            buffer.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\");            JSONObject jObj = JSON.parseObject(json);            jsonToXmlstr(jObj,buffer);            return buffer.toString();        } catch (Exception e) {            e.printStackTrace();            return \"\";        }    }    /**     * Json to xmlstr string.     *     * @param jObj   the j obj     * @param buffer the buffer     * @return the string     */    public static String jsonToXmlstr(JSONObject jObj, StringBuffer buffer ){        Set&lt;Map.Entry&lt;String, Object&gt;&gt; se = jObj.entrySet();        for(Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = se.iterator(); it.hasNext(); )        {            Map.Entry&lt;String, Object&gt; en = it.next();            if(en.getValue().getClass().getName().equals(\"com.alibaba.fastjson.JSONObject\")){                buffer.append(\"&lt;\"+en.getKey()+\"&gt;\");                JSONObject jo = jObj.getJSONObject(en.getKey());                jsonToXmlstr(jo,buffer);                buffer.append(\"&lt;/\"+en.getKey()+\"&gt;\");            }else if(en.getValue().getClass().getName().equals(\"com.alibaba.fastjson.JSONArray\")){                JSONArray jarray = jObj.getJSONArray(en.getKey());                for (int i = 0; i &lt; jarray.size(); i++) {                    buffer.append(\"&lt;\"+en.getKey()+\"&gt;\");                    JSONObject jsonobject =  jarray.getJSONObject(i);                    jsonToXmlstr(jsonobject,buffer);                    buffer.append(\"&lt;/\"+en.getKey()+\"&gt;\");                }            }else if(en.getValue().getClass().getName().equals(\"java.lang.String\")){                buffer.append(\"&lt;\"+en.getKey()+\"&gt;\"+en.getValue());                buffer.append(\"&lt;/\"+en.getKey()+\"&gt;\");            }        }        return buffer.toString();    }    /**     * The entry point of application.     *     * @param args the input arguments     */    public static void main(String[] args) {        String xmlstr = jsonToXml(\"{\\\"class\\\": {\\\"student\\\": [{\\\"age\\\": \\\"18\\\",\\\"gender\\\": \\\"男\\\",\\\"name\\\": \\\"张三\\\",\\\"qk\\\": [{\\\"q1\\\": \\\"001\\\",\\\"q2\\\": \\\"002\\\",\\\"q3\\\": \\\"003\\\"},{\\\"q1\\\": \\\"001\\\",\\\"q2\\\": \\\"002\\\",\\\"q3\\\": \\\"003\\\"}]},{\\\"age\\\": \\\"17\\\",\\\"gender\\\": \\\"男\\\",\\\"name\\\": \\\"李四\\\",\\\"qk\\\": {\\\"q1\\\": \\\"005\\\",\\\"q2\\\": \\\"006\\\",\\\"q3\\\": \\\"007\\\"}},{\\\"age\\\": \\\"19\\\",\\\"gender\\\": \\\"女\\\",\\\"name\\\": \\\"王五\\\",\\\"qk\\\": {\\\"q1\\\": \\\"008\\\",\\\"q2\\\": \\\"009\\\",\\\"q3\\\": \\\"010\\\"}}]}}\");        System.out.println(xmlstr);    }}Maven依赖&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.45&lt;/version&gt;&lt;/dependency&gt;  参考：Java代码 json格式数据转化成xml jsonToXml"
  },
  
  {
    "title": "CentOS安装Nginx",
    "url": "/posts/centos-anzhuang-nginx/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-04-11 01:47:00 +0800",
    





    
    "snippet": "1. 下载Nginx安装包http://nginx.org/download/2. 解压Nginx压缩包tar zxvf nginx-1.23.4.tar.gz3. 进入Nginx目录下cd /nginx/nginx-1.23.44. 配置安装运行目录./configure --prefix=/usr/local/nginx5. 出现错误需要安装依赖包yum -y install pcre-...",
    "content": "1. 下载Nginx安装包http://nginx.org/download/2. 解压Nginx压缩包tar zxvf nginx-1.23.4.tar.gz3. 进入Nginx目录下cd /nginx/nginx-1.23.44. 配置安装运行目录./configure --prefix=/usr/local/nginx5. 出现错误需要安装依赖包yum -y install pcre-develyum -y install gccyum -y install openssl openssl-devel# 进行重新配置./configure --prefix=/usr/local/nginx6. 执行编译安装make &amp;&amp; make install7. 安装完毕，进入Nginx下的sbin目录并启动Nginxcd /usr/local/nginx/sbin# 启动nginx./nginx# 或./nginx -c /usr/local/nginx/conf/nginx.conf# 停止nginx./nginx -s stop# 停止nginx（等待进程处理完毕进行关闭）./nginx -s quit# 重启nginx./nginx -s reload# 查看Nginx配置是否正确nginx -t "
  },
  
  {
    "title": "Git清除用户名密码",
    "url": "/posts/git-qingchu-yonghu-xinxi/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2023-04-03 13:47:00 +0800",
    





    
    "snippet": "清空所有用户名和密码git config –system –unset credential.helper如果不好使，那就得去Windows管理凭据里更改了控制面板 — 用户账户 — Windows管理凭据 — 编辑",
    "content": "清空所有用户名和密码git config –system –unset credential.helper如果不好使，那就得去Windows管理凭据里更改了控制面板 — 用户账户 — Windows管理凭据 — 编辑"
  },
  
  {
    "title": "一个域名可以对应多个IP地址吗",
    "url": "/posts/yige-yuming-keyi-duiying-duoge-ip/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-04-03 13:47:00 +0800",
    





    
    "snippet": "一个域名可以对应多个IP的，在用户访问过程中，会指向某一个具体IP，并不会同时访问多个IP。一个域名对应多个IP地址的时候，智能DNS服务器会根据请求的线路、地理位置等信息综合考虑，返回对于该请求最快的IP。如一个域名可以分给电信、联通、南方、北方等多个线路多台分布式的服务器使用，这样对各种用户来说，访问的服务器都是距离自己较近的。",
    "content": "一个域名可以对应多个IP的，在用户访问过程中，会指向某一个具体IP，并不会同时访问多个IP。一个域名对应多个IP地址的时候，智能DNS服务器会根据请求的线路、地理位置等信息综合考虑，返回对于该请求最快的IP。如一个域名可以分给电信、联通、南方、北方等多个线路多台分布式的服务器使用，这样对各种用户来说，访问的服务器都是距离自己较近的。"
  },
  
  {
    "title": "SNAT和DNAT的区别",
    "url": "/posts/snat-he-dnat/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-04-03 13:47:00 +0800",
    





    
    "snippet": "SNAT是原地址转换，DNAT是目标地址转换。区分这两个功能可以简单的由服务的发起者是谁来区分，内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有IP，网关这个地址转换称为SNAT。当内部需要对外提供服务时，外部发起主动连接，路由器或者防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有IP的网关代替内部服务来接收外部的连接，然后在内部做地址转换，此转换...",
    "content": "SNAT是原地址转换，DNAT是目标地址转换。区分这两个功能可以简单的由服务的发起者是谁来区分，内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有IP，网关这个地址转换称为SNAT。当内部需要对外提供服务时，外部发起主动连接，路由器或者防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有IP的网关代替内部服务来接收外部的连接，然后在内部做地址转换，此转换称为DNAT，主要用于内部服务对外发布。"
  },
  
  {
    "title": "MySQL修改密码提示ERROR 1054",
    "url": "/posts/mysql-xiugai-mima-tishi-error/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2023-03-30 09:47:00 +0800",
    





    
    "snippet": "报错信息执行update mysql.user set password=password('password') where user='root';会出现以下错误ERROR 1054 (42S22): Unknown column 'password' in 'field list'。报错原因MySQL数据库下已经没有password这个字段了，password字段改成了authenti...",
    "content": "报错信息执行update mysql.user set password=password('password') where user='root';会出现以下错误ERROR 1054 (42S22): Unknown column 'password' in 'field list'。报错原因MySQL数据库下已经没有password这个字段了，password字段改成了authentication_string。解决办法mysql&gt; update mysql.user set authentication_string=PASSWORD('password') where user='root';Query OK, 1 row affected, 1 warning (0.15 sec)Rows matched: 1 Changed: 1 Warnings: 1"
  },
  
  {
    "title": "MySQL进行删除等操作时卡死",
    "url": "/posts/mysql-shujuku-kasi-zenmeban/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2023-03-30 09:47:00 +0800",
    





    
    "snippet": "报错信息删除MySQL数据库中一个库出现卡死情况。解决办法进入MySQL使用命令show full processlist;查看当前的操作process，然后执行kill processid;删除对应id的process（都删了，或者删除waiting的就行）。",
    "content": "报错信息删除MySQL数据库中一个库出现卡死情况。解决办法进入MySQL使用命令show full processlist;查看当前的操作process，然后执行kill processid;删除对应id的process（都删了，或者删除waiting的就行）。"
  },
  
  {
    "title": "CentOS安装Redis",
    "url": "/posts/centos-anzhuang-redis/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-03-03 01:47:00 +0800",
    





    
    "snippet": "1. 下载Redis安装包https://redis.io/download/2. 安装依赖yum install -y gcc gcc-c++3. 解压并安装redistar -zxvf redis-7.0.11.tar.gzcd redis-7.0.11makecd srcmake install PREFIX=/usr/local/redis4. 整理文件夹cd /usr/local/...",
    "content": "1. 下载Redis安装包https://redis.io/download/2. 安装依赖yum install -y gcc gcc-c++3. 解压并安装redistar -zxvf redis-7.0.11.tar.gzcd redis-7.0.11makecd srcmake install PREFIX=/usr/local/redis4. 整理文件夹cd /usr/local/redismkdir binmkdir datamkdir logmkdir etc5. 迁移常用命令将原编译目录src路径下的常用命令移动到bin目录下mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-cli \\redis-server redis-sentinel /usr/local/redis/bin/将原编译目录redis.conf、sentinel.conf文件移动到etc路径下mv redis.conf /usr/local/redis/etcmv sentinel.conf /usr/local/redis/etc6. 修改Redis配置文件主从复制可以是服务高可用，同时如果数据访问量过大，也可以缓解读取数据压力，能达到高可用，读写分离，服务宕机数据不丢失等目的。实现Redis的主从复制有多种方式，本文采用的是Redis自带的sentinel哨兵机制达到服务高可用及主从复制的目的。根据上面Linux安装单机Redis的步骤，安装三台Redis，如果条件有限也可在一台服务器启动三个不同端口的Redis服务。配置Redis主从很简单，只需要将主机的IP和端口配置到从机的redis.conf文件最后，重启各个从节点的服务，主从复制配置就完成了。# 表示允许远程连接# bind不是针对远程客户端的IP，而是服务器的网卡IP，远程客户端通过服务器的网卡地址来连接Redisbind 0.0.0.0主节点vi redis.confbind * -::*daemonize yes                        # 表明需要在后台运行logfile \"/usr/local/redis/log/redis.log\"masterauth \"123456\"                  # 其它Redis视我为master时的验证密码requirepass \"123456\"                 # 本机Redis的登录密码maxmemory 100mbdir /usr/local/redis/dataport 6379主哨兵vi sentinel.confbind 192.168.182.136daemonize yeslogfile \"/usr/local/redis/log/sentinel.log\"sentinel monitor mymaster 192.168.182.136 6379 2sentinel auth-pass mymaster 123456port 6479dir /usr/local/redis/data-sentinel从节点vi redis.confbind * -::*daemonize yeslogfile \"/usr/local/redis-slave/log/redis.log\"masterauth \"123456\"                  # 其它Redis视我为master时的验证密码requirepass \"123456\"                 # 本机Redis的登录密码maxmemory 100mbdir /usr/local/redis-slave/datareplicaof 192.168.182.136 6379         # master的IP和Redis端口port 26379从哨兵vi sentinel.confbind 192.168.182.136daemonize yeslogfile \"/usr/local/redis-slave/log/sentinel.log\"sentinel monitor mymaster 192.168.182.136 6379 2 # master的IP和Redis端口sentinel auth-pass mymaster 123456port 26479dir /usr/local/redis-slave/data-sentinel7. 启动# 启动主节点/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf# 启动从节点/usr/local/redis-slave/bin/redis-server /usr/local/redis-slave/etc/redis.conf# 启动主节点哨兵/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf# 启动从节点哨兵/usr/local/redis-slave/bin/redis-sentinel /usr/local/redis-slave/etc/sentinel.conf8. 登录# 登录主节点/usr/local/redis/bin/redis-cli -h 192.168.182.136 -p 6379 -a 123456# 登录从节点/usr/local/redis/bin/redis-cli -h 192.168.182.136 -p 26379 -a 123456需要认证的输入密码认证，没设置密码可略过192.168.182.136:6379&gt; auth 密码OK192.168.182.136:6379&gt;9. 常用命令info replication # 节点信息CONFIG GET dir   # 数据存放位置10. 验证# 验证主从复制# 在主节点添加key，然后登录从节点查看是否复制到了从节点。# 验证哨兵# 把master的redis服务停掉192.168.182.136:6379&gt; shutdown# 等待5秒后，查看从上的Redis服务是否升级为了master192.168.182.136:6379&gt; info replication# 如果结果中的role为master说明主从切换成功11. 其他安全配置# 重命名或者禁用危险的命令vi redis.confrename-command FLUSHALL \"\"rename-command FLUSHDB  \"\"rename-command PEXPIRE  \"\"rename-command SPOP     \"\"rename-command SREM     \"\"rename-command RENAME   \"\"#rename-command CONFIG   \"\"#rename-command DEL      \"\"FLUSHDB,FLUSHALL,PEXPIRE,DEL,SPOP,SREM,RENAME命令可能无法使用，则不能清空当前数据库，也不能清空所有数据库，也不能设置键的有效时间，也不能删除键，也不能从集合中随机删除元素，也不能删除集合中的元素，也不能重命名键。# 开启protected-mode模式vi redis.confprotected-mode yes我们想要其他机器连接我们的Redis服务，有三种方式：  想办法让Redis运行在protected-mode为no的模式。  如果protected-mode为yes，那么我们可以在Redis服务上设置bind，也就是我们的一台机器有几个IP，指定我们的服务绑定监听本机的哪个IP。  如果protected-mode为yes，除了设置bind外，亦可通过设置密码的形式，也即是设置参数requirepass，从而达到可以从其他机器访问的目标。"
  },
  
  {
    "title": "GitHub访问不了",
    "url": "/posts/github-fangwenman/",
    "categories": "Knowledge, GitHub",
    "tags": "GitHub",
    "date": "2023-03-01 13:47:00 +0800",
    





    
    "snippet": "修改hosts文件，该文件在Windows系统的路径C:\\Windows\\System32\\drivers\\etc\\hosts。把以下内容粘贴到hosts文件中。# GitHub520 Host Start140.82.114.25                 alive.github.com140.82.114.6                  api.github.com185....",
    "content": "修改hosts文件，该文件在Windows系统的路径C:\\Windows\\System32\\drivers\\etc\\hosts。把以下内容粘贴到hosts文件中。# GitHub520 Host Start140.82.114.25                 alive.github.com140.82.114.6                  api.github.com185.199.110.153               assets-cdn.github.com185.199.108.133               avatars.githubusercontent.com185.199.108.133               avatars0.githubusercontent.com185.199.108.133               avatars1.githubusercontent.com185.199.108.133               avatars2.githubusercontent.com185.199.108.133               avatars3.githubusercontent.com185.199.108.133               avatars4.githubusercontent.com185.199.108.133               avatars5.githubusercontent.com185.199.108.133               camo.githubusercontent.com140.82.114.21                 central.github.com185.199.108.133               cloud.githubusercontent.com140.82.112.10                 codeload.github.com140.82.112.21                 collector.github.com185.199.108.133               desktop.githubusercontent.com185.199.108.133               favicons.githubusercontent.com140.82.113.3                  gist.github.com52.217.37.228                 github-cloud.s3.amazonaws.com52.216.35.249                 github-com.s3.amazonaws.com52.216.210.105                github-production-release-asset-2e65be.s3.amazonaws.com52.216.37.201                 github-production-repository-file-5c1aeb.s3.amazonaws.com52.217.201.177                github-production-user-asset-6210df.s3.amazonaws.com192.0.66.2                    github.blog140.82.112.4                  github.com140.82.112.18                 github.community185.199.109.154               github.githubassets.com151.101.129.194               github.global.ssl.fastly.net185.199.110.153               github.io185.199.108.133               github.map.fastly.net185.199.110.153               githubstatus.com140.82.113.26                 live.github.com185.199.108.133               media.githubusercontent.com185.199.108.133               objects.githubusercontent.com13.107.43.16                  pipelines.actions.githubusercontent.com185.199.108.133               raw.githubusercontent.com185.199.108.133               user-images.githubusercontent.com13.107.226.51                 vscode.dev# Update time: 2023-03-01T14:06:17+08:00# Update url: https://raw.hellogithub.com/hosts# Star me: https://github.com/521xueweihan/GitHub520# GitHub520 Host End大部分情况下是直接生效，如未生效可尝试下面的办法刷新DNS，Windows系统在CMD窗口输入：ipconfig /flushdns。以上信息来源于GitHub520，Github地址：https://github.com/521xueweihan/GitHub520。"
  },
  
  {
    "title": "Oracle 连接总是中断",
    "url": "/posts/oracle-lianjie-zongshi-zhongduan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2023-03-01 01:47:00 +0800",
    





    
    "snippet": "报错信息Mon Nov 16 13:41:19 2020**********************************************************************Fatal NI connect error 12170. VERSION INFORMATION:TNS for Linux: Version 11.2.0.4.0 - ProductionOra...",
    "content": "报错信息Mon Nov 16 13:41:19 2020**********************************************************************Fatal NI connect error 12170. VERSION INFORMATION:TNS for Linux: Version 11.2.0.4.0 - ProductionOracle Bequeath NT Protocol Adapter for Linux: Version 11.2.0.4.0 - ProductionTCP/IP NT Protocol Adapter for Linux: Version 11.2.0.4.0 - ProductionTime: 16-NOV-2020 13:41:19Tracing not turned on.Tns error struct:ns main err code: 12535 TNS-12535: TNS:operation timed outns secondary err code: 12560nt main err code: 505 TNS-00505: Operation timed outnt secondary err code: 110nt OS err code: 0Client address: (ADDRESS=(PROTOCOL=tcp)(HOST=10.0.128.100)(PORT=20233))报错原因上述报错表示，一个会话与Oracle实例建立连接之后断开了。断开原因可能是会话空闲，一直没有数据通信，最终连接时间是超过了防火墙设置的最大空闲时长（idle time），最终断开连接。“nt secondary err code” 表示网络传输超时（TCP/IP）。“nt secondary err code” 也指出了操作系统类型。110是Linux x86或者Linux x86-64；238是HP-UX；78是AIX；145是Solaris。解决方法1、增大防火墙的空闲时间。网络一般不大可能修改。2、在sqlnet.ora中增加sqlnet.expire_time参数（单位：分钟）。当连接长时间空闲时，定时模仿客户端与数据库实例之间的通信，确保不会被防火墙断开。$ cat $ORACLE_HOME/network/admin/sqlnet.oraSQLNET.EXPIRE_TIME=1表示空闲连接1分钟客户端与服务端通信一次。加上该参数后，无需重启监听，参数对新连接生效。原有连接可能依然会出现上面的情况，直到所有原有连接遇到上面的问题断开后重新连接时，这个错误会彻底消失。  参考：TNS-12535: TNS:operation timed out TNS-00505: Operation timed out"
  },
  
  {
    "title": "CentOS安装MySQL",
    "url": "/posts/centos-anzhuang-mysql/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-03-01 01:47:00 +0800",
    





    
    "snippet": "1. 检测系统是否有自带MySQL#检查是否安装过MySQLrpm -qa | grep mysql #检查是否存在Mariadb数据库（内置的MySQL数据库），有则强制删除rpm -qa | grep mariadb #强制删除rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 rpm -e --nodeps mariadb-5.5.68-1...",
    "content": "1. 检测系统是否有自带MySQL#检查是否安装过MySQLrpm -qa | grep mysql #检查是否存在Mariadb数据库（内置的MySQL数据库），有则强制删除rpm -qa | grep mariadb #强制删除rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 rpm -e --nodeps mariadb-5.5.68-1.el7.x86_64 2. 文件上传到Linux服务器后进行解压# 本次安装目录为/data/databasemkdir -p /data/database# 解压MySQl安装包tar -zxvf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz# MySQL安装包名字太长，为了方便输入，我们更改一下文件夹的名字mv mysql-5.7.17-linux-glibc2.5-x86_64/ mysql-5.7.173. 创建mysql用户组和mysql用户# 创建mysql用户组groupadd mysql# 创建mysql用户并放入mysql用户组useradd -g mysql mysql# 设置mysql密码passwd mysql 4. 建立必要的目录# 数据存放目录mkdir /data/database/mysql-5.7.17/data# 日志目录和日志文件mkdir /data/database/mysql-5.7.17/logtouch /data/database/mysql-5.7.17/log/mysqld.log# pid目录和记录mysqld进程pid的文件mkdir /data/database/mysql-5.7.17/pidtouch /data/database/mysql-5.7.17/pid/mysqld.pid5. 更改所属的组和用户chown -R mysql:mysql /data/database/mysql-5.7.176. 在etc下新建配置文件my.cnf从MySQL-3.X开始，MySQL的配置文件加载顺序最优先就是/etc/my.cnf。# 查找my.cnf的位置/data/database/mysql-5.7.17/bin/mysqld --verbose --help |grep -A 1 'Default options'# MySQL寻找my.cnf的顺序为/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf /home/mysql-5.7.17/my.cnf ~/.my.cnf 新建配置文件my.cnf。cd /etctouch my.cnfvi my.cnf在my.cnf里输入以下配置信息。[client]default-character-set=utf8[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]skip-name-resolve#设置3306端口port = 3306 # 设置mysql的安装目录basedir=/data/database/mysql-5.7.17# 设置mysql数据库的数据的存放目录datadir=/data/database/mysql-5.7.17/data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB # 设置忽略大小写# lower_case_table_names=0 表名存储为给定的大小和比较是区分大小写的# lower_case_table_names = 1 表名存储在磁盘是小写的，但是比较的时候是不区分大小写# lower_case_table_names=2 表名存储为给定的大小写但是比较的时候是小写的lower_case_table_names=1max_allowed_packet=200Msql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES# 定期清理日志expire_logs_days=3log-error=/data/database/mysql-5.7.17/log/mysqld.logpid-file=/data/database/mysql-5.7.17/pid/mysqld.pid7. 初始化数据库有两种方式，在5.7.6之前初始化的方法是：cd /data/database/mysql-5.7.17/bin./mysql_install_db \\--user=mysql \\--basedir=/data/database/mysql-5.7.17/ \\--datadir=/data/database/mysql-5.7.17/data/5.7.6之后的版本初始化数据库不再使用mysql_install_db：cd /data/database/mysql-5.7.17/bin./mysqld \\--user=mysql \\--basedir=/data/database/mysql-5.7.17 \\--datadir=/data/database/mysql-5.7.17/data \\--lower-case-table-names=1 \\--initialize# --lower-case-table-names=1是因为my.cnf中，我们要开启表名大小写敏感# 这个不能在后期设置，必须在安装阶段初始化时进行设置# 否则my.cnf中不可以配置该属性，配置了库会启动失败。如果出现如下图所示则为安装成功，红线部分为生成的默认密码：默认密码一定要记住，一会要用。默认密码在mysqld.log日志里，如果忘记了可以到日志里找。初始化完成后把/etc/my.cnf复制到/data/database/下，然后删除/etc/my.cnf，启动时加载/data/database/my.cnf，防止损坏数据库。8. 配置启动文件cp /data/database/mysql-5.7.17/support-files/mysql.server /etc/init.d/mysqld# 或创建软链ln -s /data/database/mysql-5.7.17/support-files/mysql.server /etc/init.d/mysql9. 创建软链mysqld_safe默认会从/usr/local/mysql/bin目录中去寻找启动脚本mysqld，但是我安装mysql的目录是/data/database/mysql-5.7.17，因此可以在/usr/local/mysql/bin/目录下创建一个/home/mysql-5.7.17/bin/mysqld的软链。mkdir -p /usr/local/mysql/binln -s /data/database/mysql-5.7.17/bin/mysqld /usr/local/mysql/bin/mysqld 10. 配置启动脚本startMySQL.sh#!/bin/shLANG=en_US.UTF-8MYSQL_HOME=/data/database/mysqlPATH=$MYSQL_HOME/bin:$PATH mysqld --defaults-file=/data/database/my.cnf &amp;stopMySQL.sh#!/bin/sh LANG=en_US.UTF-8MYSQL_HOME=/data/database/mysqlPATH=$MYSQL_HOME/bin:$PATHmysqladmin --defaults-file=/data/database/my.cnf  -uroot -p  shutdown echo '查询进程ID和端口监听,没有正常退出的话，自己kill吧！'echo 'ps -ewf | grep mysqld'ps -ewf | grep mysqld echo 'netstat -na |grep 13306'11. 配置环境变量su mysqlvi ~/.bash_profile# 添加以下内容export MYSQL_HOME=/data/database/mysql-5.7.17/export PATH=$PATH:$MYSQL_HOME/bin# 刷新环境变量source ~/.bash_profile  关于环境变量      etc目录下存放系统管理和配置文件 (系统配置)              /etc/profile：为所有的用户设置系统范围的环境变量和启动顺序，当用户登录时读取该文件，该文件被执行并从/etc/profile.d目录的配置文件中搜集shell的设置，这个文件对每个shell都有效。        /etc/bashrc：为每一个运行bash shell的用户执行此文件，当bash shell被打开时该文件被读取。也就是说，当用户shell执行了bash时，运行这个文件。              用户配置              ~/.profile：每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。默认情况下，它设置一些环境变量，然后执行用户的.bashrc文件。        ~/.bashrc：该文件包含专用于某个用户的bash shell的bash信息，当该用户登录时以及每次打开新的shell时，该文件被读取。        ~/.bash_profile：文件中内容调用的是~/.bashrc文件。            12. 修改临时密码su mysql# 用临时密码登录mysqlmysql -u root –p# 修改成新的密码mysql&gt; set password for root@localhost = password('root');13. 开放远程连接use mysql;# GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '远程连接密码'; grant all privileges on *.* to 'root'@'%' identified by 'root';# 刷新授权flush privileges;# 退出quit;14. 开放3306端口su root# 开启3306firewall-cmd --zone=public --add-port=3306/tcp --permanent# 重启防火墙firewall-cmd --reload# 查看已经开放的端口firewall-cmd --list-ports 15. 设置开机自启# 将服务文件拷贝到init.d下，并重命名为mysql，这一步前面已经做过cp /home/mysql-5.7.17/support-files/mysql.server /etc/init.d/mysqld# 赋予可执行权限chmod +x /etc/init.d/mysqld# 添加服务chkconfig --add mysqld# 显示服务列表chkconfig --list至此，CentOS7安装MySQL-5.7.17完成。16. 新建MySQL用户并授权# 新建用户test1，密码test1mysql&gt; CREATE USER 'test1'@'localhost' IDENTIFIED BY 'test1';# 授予普通DBA管理某个MySQL数据库的权限mysql&gt; grant all privileges on testdb to test1@'localhost'"
  },
  
  {
    "title": "CentOS安装MySQL - 生产环境MySQL安装规划及调优",
    "url": "/posts/centos-anzhuang-mysql-shengchanhuanjing-guihua-ji-tiaoyou/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-03-01 01:47:00 +0800",
    





    
    "snippet": "一、生产环境MySQL部署问题  生产环境MySQL使用yum安装部署，这是大忌，因为生产环境的系统，通常硬件维护、操作系统维护都是分在不同的管理部门进行管理。作为应用厂商使用的自行维护的数据库，使用yum或rpm包安装方式安装，就意味着每次维护都需要root级别的权限，因为不管是my.cnf，还是MySQL的主程序文件，基本都在root用户权限下。每次要进行升级及维护，都需要申请root或...",
    "content": "一、生产环境MySQL部署问题  生产环境MySQL使用yum安装部署，这是大忌，因为生产环境的系统，通常硬件维护、操作系统维护都是分在不同的管理部门进行管理。作为应用厂商使用的自行维护的数据库，使用yum或rpm包安装方式安装，就意味着每次维护都需要root级别的权限，因为不管是my.cnf，还是MySQL的主程序文件，基本都在root用户权限下。每次要进行升级及维护，都需要申请root或sudo权限，这种流程是非常复杂的，因为操作系统root权限太敏感。其次即使你有了root权限，由于是生产系统，你也不大可能在升级的时候，直接yum升级，万一升级失败毫无退路可言。  第二个大忌，就是MySQL的目录没有规划，配置文件内容混乱，没有任何注释。目录不进行合理规划，后期很难升级，打补丁。二、生产环境的特点及约束  业务连续性，数据库作为后端最重要的设施，其重要程度非常高。不论做什么操作，全库不可访问的时间，都应尽量的短，甚至是不能中断。  MySQL这种数据库，需要根据不同的业务场景，专门进行定向优化，所以只要你是会用到MySQL的开发人员，MySQL库从部署、升级、使用、调优，必须完全掌握。  生产操作系统root权限，一般都是被回收管控的，不可以轻易申请到。三、生产环境MySQL部署原则  规避root权限问题，MySQL应在普通用户权限下以二进制包方式或编译方式部署。  MSQL的部署应做到程序、配置、数据三分离，做好良好的目录路径规划。通常如果不是版本跃迁式的升级，MySQL的data路径下的库存储数据文件是通用的，比如8.0.2版本的MySQL库的data路径，可以被8.0.29的直接访问，不会有什么问题。大版本内的库版本升级，通常不需要做全库导出和导入的恢复性操作。  数据库是非常重要的生产设施，MySQL虽然在网上有很多双主、一主多从等等的部署方案。其实在日常使用中，最稳定可靠的方案，还是主从方案。故障率最高的是双主方案。主从方案中，也不建议配置自动化的浮动IP飘动方案或切换方案。生产环境的数据库非常重要，自动化的浮动IP飘动和切换方案，经常会因为网络波动、安全扫描等各种因素，发生IP频繁飘切，影响业务稳定性，诱发业务数据层级问题。  要考虑到并行双测的场景。往往跨大版本数据库升级，除了在测试环境先要做演练之外。生产环境的MySQL部署时，需要考虑到多版本多实例服务器并存的要求。即为了保证秒切，或者瞬间切换，通常的做法是在MySQL所在的服务器上，再装一套目标版本MySQL实例，并且启动起来监听端口设置在不同的端口，进行调试、测试、配置、如果硬盘空间允许，还要进行数据的核查和比对，确保大部分历史数据都一致，以及比对一致点的binlog位置。然后切换时，只是把原主库停止，新库用对应的端口配置文件直接拉起，10秒左右完成切换。四、生产环境MySQL部署知识点4.1 MySQL的配置文件加载顺序（Linux）从MySQL-3.X开始，MySQL的配置文件加载顺序最优先就是/etc/my.cnf，这个很关键，所以为了适应生产环境部署的特点，/etc下的MySQL配置文件最好是全部清除，会为以后多实例并行，多版本并行，安全补丁升级验证带来巨大方便。同时，把/etc/my.cnf等系统默认公共路径的配置文件删掉可以防止误操作搞坏当前库。MySQL服务启动需要读取配置文件，如果存在多个my.cnf 配置文件时，注意加载顺序。不同的大版本加载顺序稍微有差异，但基本就是这几个位置：系统公共配置路径/etc、MySQL程序安装路径、用户HOME路径、其他自定义路径下的my.cnf：/etc/my.cnf/etc/mysql/my.cnf$MYSQL_HMOE/my.cnf~/.my.cnf注意默认是优先匹配原则，即如果它遇到了/etc/my.cnf后面的配置它就不会再去找了。不管是mysqld服务器端程序，还是MySQL客户端程序，都可以采用下面两个参数来强制指定要读取的配置文件路径：-defaults-file=XXX，只读取指定的文件（不再读取其他配置文件）-defaults-extra-file=XXX从其他优先级更高的配置文件中读取全局配置后，再读取指定的配置文件（有些选项可以覆盖掉全局配置从的设定值）不建议使用，除非你能搞清楚多个配置文件之间加载覆盖的关系，否则容易发生混乱。加载细节说明：  没有/etc/my.cnf、/etc/mysql/my.cnf、/usr/etc/my.cnf、 ~/.my.cnf文件，且/usr/bin/mysqld_safe和/usr/sbin/mysqld都没有指定–defaults-file的情况下，也就是没有任何配置文件的情况下所有的配置都是默认值；  my.cnf会覆盖mysql.server里的basedir和datadir配置；  mysqld和mysqld_safe指定–defaults-file的话，那么MySQL的配置文件就是–defaults-file对应的文件，而不是默认的/etc/my.cnf文件；  mysqld或mysqld_safe命令行参数里指定的配置参数最大，其次是–defaults-file指定的my.cnf配置文件参数最大；  mysqld或mysqld_safe指定参数比如–datadir参数则会覆盖/etc/my.cnf的配置；  mysql.server把默认的/etc/my.cnf中的参数传递给mysqld_safe，mysqld_safe再传递给mysqld；  mysql --help | grep ‘Default options’ -A 1查看my.cnf配置文件的读取顺序。4.2 操作系统环境变量知识点环境变量的加载顺序：系统级–&gt;用户级–&gt;脚本会话级，覆盖顺序刚好倒过来，越靠后的会覆盖前面的。我们修改了系统级或者用户级的环境变量时，Windows会当场立即生效（已经打开的cmd或powershell需要关闭再重开才会生效）。Linux一般是远程操作，需要关闭会话窗口重新登录使配置文件生效，或使用source 配置文件全名重新装载环境配置，例如source /etc/bashrc，使其当前立即生效。五、生产环境MySQL安装规划及调优5.1 安装路径规划通常生产环境的主机都是性能比较强的PC服务器，本次安装的目标服务器CPU 48逻辑核，内存376GB，存储2TB。生产环境主机的操作系统通常安装在独立的物理盘，数据盘通常会以RAID 5或者RAID 10来组盘。程序、数据通常都不放在系统盘，要安装在数据盘。本次安装的目标服务器，数据盘挂载在/data下，我们将所有的程序和数据都有规划性的安装在数据盘里。通常数据盘的挂载路径也是直接分配给应用数据方的。/data路径下我们规划MySQL的安装路径：            路径      描述                  /data/database      历代MySQL实例程序的安装根路径。所有的MySQL不同版本实例、data数据、pid、日志、bin-log文件、sock文件全部存于此路径。              /data/database/mysql      软连接，链接到当前正在主用的MySQL实例程序文件夹。也就是tar.gz解开后的二进制版程序文件夹。              /data/database/data      datadir，数据库数据文件存放文件夹。初始化二进制安装程序时，指定该路径，之后初始化过程中会自动创建。              /data/database/log      log-error，MySQL的日志路径，注意这个不是bin-log。              /data/database/binlog      log-bin，MySQL的binlog存储路径，用于保存数据操作日志，用于库的恢复或者主从同步。              /data/database/mysql_data_back      MySQL备份、导入导出等相关数据文件存储的路径。              /data/database/mysql_loaddata      MySQL的数据装载与导出路径。用于业务场景，有时候直接装载文件比insert要快。              /data/database/my.cnf      MySQL实例的配置文件，手动创建编写。              /data/database/mysql.sock      socket，MySQL的socket文件。配置在my.cnf中，MySQL运行后会自动创建。              /data/database/mysql.pid      pid-file，MySQL的pid进程号文件。配置在my.cnf中，MySQL运行后会自动创建。              /data/database/startMysql.sh      MySQL实例的启动脚本，手动创建编写。              /data/database/stopMysql.sh      MySQL实例的启动脚本，手动创建编写。              /data/database/mysql-8.0.29-el7-x86_64      二进制安装包解压后的路径，解压tar包自动会创建。      以上规划路径，除加粗的路径会在操作过程中自动生成外，其它路径均需要手动提前创建好。如果你自己也需要安装，建议你从database层开始使用该路径规划方案。这样做的好处是。首先，每次下载下来的不同版本的MySQL安装tar.gz，二进制包只会在它解压缩的文件夹位置。数据的配置文件、数据文件data、bin-log等都不在其文件夹下。当新版的实例解压测试好之后，只需要切换database/mysql的软连接指向，即可完成数据库的切换。然后放心的把以前解压的mysql-8.0.xx-el7-x86_64路径删除，生产系统路径下除了在升级时会出现两个不同版本的实例文件夹，平时不会显得乱七八糟。很多生产环境，前仆后继的人员折腾之后，后人根本不敢清理相关文件或文件夹，因为搞不清依赖关系。其次，如果是小版本的升级或者打补丁，我们要在测试环境复原生产场景。这时，只需要把MySQL软连接指向的MySQL版本实例程序tar一份到测试环境，然后将生产的MySQL库配置导出，my.cnf拿下来参数改小。就可以做升级测试。测试无误后，就可以先部署新版本程序，然后修改软连接指向，再重启数据库即可！会给以后的运维带来极大的方便。如果遇到大版本升级，比如8.0升级到9.X或者10.X,当然它们现在都还没诞生，我们假设它向后是不兼容的。那么依然用这种路径规划。由于/etc/my.cnf已经被删除，所以我们可以很容易的在database路径下安装9.X的二进制版本，并且临时性的先将它的配置文件、数据库data路径、bin-log等都先指向到临时目录，启动脚本也可以单独写好，将实例在其它不冲突的端口拉起来，非常简单的就可以实现两个库实例的并行运行，方便生产业务、数据的迁移和并行。等到测试期、并行期结束，再进行正式割接，将文件按规划重新梳理好，将旧的MySQL删除即可。由于startMysql.sh来启动MySQL，因此我们将MySQL依赖的重要的系统环境变量，全部设置在shell会话级，这样不管其它应用怎么魔改操作系统，都不会影响到我部署的MySQL的正常运行，因为那些有问题的环境变量，到了启动脚本就会被覆盖掉！对于stopMysql.sh，有些人会说，不需要那么麻烦，直接kill就可以了。这是生产数据库，直接Kill，很可能会导致库表文件损坏，数据丢失等各种问题。因此专业的做法是mysqladmin命令去shutdown数据库。除非shutdown关闭不掉的挂死的情况下，也要先想办法切断MySQL的监听，比如停掉应用，或者让网络防火墙把端口挡住，过一阵CPU利用率，I/O都回落了，再kill。防止数据或表损坏。  生产环境mysql安装规划及调优实践–mysql8.0.29为例"
  },
  
  {
    "title": "Tomcat设置通过IP+PORT访问项目",
    "url": "/posts/tomcat-shezhi-ipheduankou-fangwen-xiangmu/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2023-02-27 13:47:00 +0800",
    





    
    "snippet": "&lt;!-- 在`&lt;host&gt;`之间增加下列代码，docBase改成webapps下面放的项目名称 --&gt;&lt;Context path=\"\" docBase=\"projectName\" debug=\"0\" reloadable=\"true\" /&gt;",
    "content": "&lt;!-- 在`&lt;host&gt;`之间增加下列代码，docBase改成webapps下面放的项目名称 --&gt;&lt;Context path=\"\" docBase=\"projectName\" debug=\"0\" reloadable=\"true\" /&gt;"
  },
  
  {
    "title": "VMware虚拟机CentOS7磁盘扩容",
    "url": "/posts/vmware-centos-kuorong/",
    "categories": "Knowledge, VMware",
    "tags": "VMware",
    "date": "2023-02-26 13:47:00 +0800",
    





    
    "snippet": "1、给虚拟机添加硬盘将虚拟机关机，然后点6VM顶部菜单栏中的显示或隐藏控制台视图按钮来显示已建立的虚拟机的配置信息然后左边菜单栏点击硬盘，在弹出的对话框选中硬盘，并点击扩展按钮，然后在弹出框中的最大磁盘大小修改未所需要的磁盘大小，比如我现在需要扩容30G，原本的磁盘大小是20G，所以我这里将原本的20G修改成50G，然后点击扩展之后会收到提示，然后开启虚拟机，对磁盘进行进一步的配置2、在系统...",
    "content": "1、给虚拟机添加硬盘将虚拟机关机，然后点6VM顶部菜单栏中的显示或隐藏控制台视图按钮来显示已建立的虚拟机的配置信息然后左边菜单栏点击硬盘，在弹出的对话框选中硬盘，并点击扩展按钮，然后在弹出框中的最大磁盘大小修改未所需要的磁盘大小，比如我现在需要扩容30G，原本的磁盘大小是20G，所以我这里将原本的20G修改成50G，然后点击扩展之后会收到提示，然后开启虚拟机，对磁盘进行进一步的配置2、在系统中挂载磁盘开启虚拟机并登录后，使用命令查看当磁盘状态# df -h可看到当前还是原本的20G，并未扩容，首先先通过命令查看到新磁盘的分区# ls /dev/或者使用# fdisk -l然后对新加的磁盘进行分区操作# fdisk /dev/sda期间，如果需要将分区类型的Linux修改为Linux LVM的话需要在新增了分区之后，选择t，然后选择8e，之后可以将新的分区修改为linux LVM，之后我们可以再次用以下命令查看到磁盘当前情况# fdisk -l重启虚拟机格式化新建分区# reboot，然后将新添加的分区添加到已有的组实现扩容，首先查看卷组名# vgdisplay初始化刚刚的分区# pvcreate /dev/sda3将初始化过的分区加入到虚拟卷组名# vgextend 虚拟卷组名 新增的分区# vgextend centos /dev/sda3再次查看卷组情况# vgdisplay这里可以看到，有30G的空间是空闲的，# df -h查看当前磁盘情况并记下需要扩展的文件系统名，我这里因为要扩展根目录，所以我记下的是/dev/mapper/centos-root扩容已有的卷组容量（这里有个细节，就是不能全扩展满，比如空闲空间是30G，然后这里的话30G不能全扩展上，这里我扩展的是29G）# lvextend -L +需要扩展的容量 需要扩展的文件系统名 # lvextend -L +29G /dev/mapper/centos-root然后我们用命令查看当前卷组# pvdisplay这里可以看到，卷组已经扩容了，以上只是卷的扩容，然后我们需要将文件系统扩容# resize2fs 文件系统名# resize2fs /dev/mapper/centos-root这个是网上很多参考资料的用法，但是在这里报错了解决办法是，首先查看文件系统的格式# cat /etc/fstab | grep centos-root这里可以看到，文件系统是xfs，所以需要xfs的命令来扩展磁盘空间# xfs_growfs 文件系统名# xfs_growfs /dev/mapper/centos-root之后我们再次用命令查看磁盘状态# df -h，可以看到，现在已经扩容成功了！"
  },
  
  {
    "title": "Ant打包时报内存溢出",
    "url": "/posts/ant-dabao-bao-neicunyichu/",
    "categories": "Knowledge, Ant",
    "tags": "Ant",
    "date": "2023-02-26 13:47:00 +0800",
    





    
    "snippet": "报错信息Ant编译任务报错Java Heap Space。解决方法      修改Ant命令脚本    找到Ant的安装目录，进入bin目录，根据不同的环境，修改对应的脚本。Linux下面打开ant脚本，在ant_exec_args=之前加一行代码export ANT_OPTS=-Xmx1024m；Windows下面打开ant.bat， 在@echo off之后加一行代码set ANT_OP...",
    "content": "报错信息Ant编译任务报错Java Heap Space。解决方法      修改Ant命令脚本    找到Ant的安装目录，进入bin目录，根据不同的环境，修改对应的脚本。Linux下面打开ant脚本，在ant_exec_args=之前加一行代码export ANT_OPTS=-Xmx1024m；Windows下面打开ant.bat， 在@echo off之后加一行代码set ANT_OPTS=-Xmx1024m。        更改Ant的javac指令参数    新增以下参数fork=\"true\" memoryMaximumSize=\"1024m\"。注意fork=\"true\"必须与memoryMaxinumSize配套使用。fork=\"true\"是指单独起一个Java进程才处理编译任务。  "
  },
  
  {
    "title": "CentOS安装Oracle",
    "url": "/posts/centos-anzhuang-oracle/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-02-26 01:47:00 +0800",
    





    
    "snippet": "一、Oracle安装1.1 Oracle 11g版本选择建议下载11.2.0.4版本，11.2.0.1版本有一些BUG会影响安装。CentOS7安装11.2.0.1遇到的坑：  操作系统内核参数semmni明明设置正确，先决条件检查以然会提示参数不正确。  一些程序包，已经安装过了，先决条件检查以然会提示没有安装。  安装到68%会报错：makefile '/home/oracle/app/...",
    "content": "一、Oracle安装1.1 Oracle 11g版本选择建议下载11.2.0.4版本，11.2.0.1版本有一些BUG会影响安装。CentOS7安装11.2.0.1遇到的坑：  操作系统内核参数semmni明明设置正确，先决条件检查以然会提示参数不正确。  一些程序包，已经安装过了，先决条件检查以然会提示没有安装。  安装到68%会报错：makefile '/home/oracle/app/oracle/product/11.2.0/dbhome_1/ctx/lib/ins_ctx.mk'的目标'install'时出错。另外，11.2.0.4版本普通用户在官网是下载不到的，可以从网盘找资源。1.2 安装和配置VNC安装VNC图形化的操作环境即可进行VNC远程或者直接本地图形化操作，比静默安装更直观。root执行以下命令，直接整体复制粘贴到终端就行。#图形界面必备`X Window System`yum -y groupinstall \"X Window System\"#安装epel源yum -y install epel-release#安装VNC+图形需要的软件yum -y install tigervnc-server openbox xfce4-terminal tint2 cjkuni-ukai-fonts network-manager-applet#自动修改/etc/xdg/openbox/autostart配置文件echo 'if which dbus-launch &gt;/dev/null &amp;&amp; test -z \"$DBUS_SESSION_BUS_ADDRESS\"; then' &gt; /etc/xdg/openbox/autostartecho '       eval `dbus-launch --sh-syntax --exit-with-session`' &gt;&gt; /etc/xdg/openbox/autostartecho 'fi' &gt;&gt; /etc/xdg/openbox/autostartecho 'tint2 &amp;' &gt;&gt; /etc/xdg/openbox/autostartecho 'nm-applet  &amp;' &gt;&gt; /etc/xdg/openbox/autostartecho 'xfce4-terminal &amp;' &gt;&gt; /etc/xdg/openbox/autostartecho ' ' &gt;&gt; /etc/xdg/openbox/autostart#防火墙放行VNC端口firewall-cmd --add-port=5901/tcpfirewall-cmd --add-port=5901/tcp --permanent1.3 创建用户为了安全起见，不建议使用root做为vnc用户。单独创建一个用户比较安全。既然安装Oracle，这里用户名我使用oracle。root执行以下命令，直接整体复制粘贴到终端就行。#创建database用户组groupadd database#创建oracle用户并放入database组中useradd oracle -g database#设置oracle密码passwd oracle #密码我设置的是database@20211.4 开启VNC服务切换到oracle用户。su oracle#首次运行，生成~/.vnc/xstartup等配置文件vncserver :1 -geometry 1920x1080#我这里设置的密码是vnc@2021 oracle用户执行以下命令，直接整体复制粘贴到终端就行。#配置VNC默认启动openboxecho \"openbox-session &amp;\" &gt; ~/.vnc/xstartup# 停止服务vncserver -kill :1#重新开启vnc服务vncserver :1 -geometry 1920x10801.5 客户端连接VNC实现远程控制使用VNC客户端连接，我用的是VNC Viewer ，我的地址如下：172.16.184.5:5901然后输入上面设置的连接密码就可以了。我这里设置的密码是vnc@2021。如果你连接的时候发现没有界面，是黑屏的，只有一个鼠标，那么可以重启一下VNC服务试试。切换到oracle用户su oracle命令：vncserver -kill :1vncserver :1 -geometry 1024x7681.6 安装中文字体解决中文乱码问题默认情况下，因CentOS中缺少中易宋体18030所以会导致中文显示成□□□□□的问题。增加所需字体就行了。下载字体：https://m.rkxy.com.cn/down.php?id=71266 ，root执行以下命令：#新建文件夹mkdir -p /usr/share/fonts/zh_CN/TrueType#zysong.ttf上传到/usr/share/fonts/zh_CN/TrueType目录并赋权chmod 75 /usr/share/fonts/zh_CN/TrueType/zysong.ttf字体安装完成，这样安装Oracle就不会中文乱码了。如果不想用中文界面安装，安装前运行以下命令，临时使用英文环境。LANG=en_US1.7 上传并解压安装包上传安装包到CentOS7服务器。只需要*1of7.zip,*2of7.zip两个压缩包即可。我上传到/home/oracle/目录了。上传以后，文件路径和名称如下：[oracle@localhost ~]$ pwd/home/oracle[oracle@localhost ~]$ lsp13390677_112040_Linux-x86-64_1of7.zip  p13390677_112040_Linux-x86-64_2of7.zip如果没有unzip工具，安装unzip用于文件解压，root执行以下命令：yum install unziporacle用户登录vnc，执行下面命令，解压出database，已备安装使用：#解压第1个zipunzip p13390677_112040_Linux-x86-64_1of7.zip#解压第2个zipunzip p13390677_112040_Linux-x86-64_2of7.zip文件如下：[oracle@localhost ~]$ lsdatabase  p13390677_112040_Linux-x86-64_1of7.zip  p13390677_112040_Linux-x86-64_2of7.zip1.8 安装Oracle安装程序依赖程序包root用户执行以下命令su root：yum -y install binutils compat-libcap1  compat-libstdc++-33 compat-libstdc++-33*.i686 elfutils-libelf-devel gcc gcc-c++ glibc*.i686 glibc glibc-devel glibc-devel*.i686 ksh libgcc*.i686 libgcc libstdc++ libstdc++*.i686 libstdc++-devel libstdc++-devel*.i686 libaio libaio*.i686 libaio-devel libaio-devel*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686 libXp1.9 开始安装Oracleoracle用户登录vnc远程桌面，进入~/database/目录。#进入安装目录cd ~/database/#运行安装程序./runInstaller配置安全更新，根据需要设置，我这里就不设置了。下载软件更新，根据个人需要选择，我这里选择跳过软件更新（S）。网络安装选项，选择创建和配置数据库（C）。桌面类or服务器类，描述中已经说的很清楚了，根据自己需要选择。这里我选择的是服务器类（S）。安装类型，我选默认的，单实例数据库安装（S）根据实际需要选择。典型安装，默认典型安装（T）即可。典型安装配置，主要设置一下密码，其他默认即可。这里密码要在大写字母+小写字母+数字组合。比如：我设置的是Database123。创建产品清单，默认即可。执行先决条件检查，这一步要稍花一些时间处理。每个人的显示可能略有不同。比如：物理内存的检测，我这个1G内存就会提示小于预期。处理方法：  根据提示信息做处理即可，比如：内存小了，加大内存。  执行修补并再次检查（F）可以自动修复  以上都解决不了，百度一下基本都是有解决办法的。没解决之前我的显示如下：执行修补并再次检查（F），方法上面描述的很清楚。root权限执行：/tmp/CVU_11.2.0.4.0_oracle/runfixup.sh执行完后，点击上面对话框中的确定（O）这里发现大部分都修复了。如下：剩下的警告尽量解决，如果自己知道影响不大直接点右上角☐全部忽略即可。比如：我的虚拟机内存，比预期值差30MB左右，影响不大直接忽略也可以。解决方法也很简单，加大内存即可。  解决缺失包：pdksh-5.2.14警告这个警告，我猜测直接忽略就行了。因为本机已经安装了ksh-20120801-142.el7.x86_64。yum search pdksh中搜索没的搜索到它。只能手动安装了。#如果没有wget就安装一下 yum install wget#下载安装包wget  http://vault.centos.org/5.11/os/x86_64/CentOS/pdksh-5.2.14-37.el5_8.1.x86_64.rpm执行安装操作。rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm执行结果如下，与已经安装的冲突了，安装失败了。rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm 警告：pdksh-5.2.14-37.el5_8.1.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥ID e8562897: NOKEY错误：依赖检测失败：    pdksh 与 (已安裝) ksh-20120801-142.el7.x86_64 冲突卸载冲突。rpm -e ksh-20120801-142.el7.x86_64再次安装。rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm全过程如下：[root@localhost ~]# rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm 警告：pdksh-5.2.14-37.el5_8.1.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥ID e8562897: NOKEY错误：依赖检测失败：    pdksh 与 (已安裝) ksh-20120801-142.el7.x86_64 冲突[root@localhost ~]# rpm -e ksh-20120801-142.el7.x86_64[root@localhost ~]# rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm警告：pdksh-5.2.14-37.el5_8.1.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥ID e8562897: NOKEY准备中...                          ################################# [100%]正在升级/安装...1:pdksh-5.2.14-37.el5_8.1          ################################# [100%]重新检测，发现警告消失了。  Swap分区设置如果Oracle安装文件检查发现Swap空间不足。大小一般设置为内存的1.5倍。root权限查询当时Swap分区设置情况。swapon -s结果如下：[root@localhost ~]# swapon -m文件名         类型       大小   已用   权限/dev/dm-1   partition  2097148   0      -2或者使用free工具来查看内存和Swap情况。free -m结果如下单位（MB）：[root@localhost ~]# free -m        total   used     free   shared  buff/cache   availableMem:    1475     439     171     13         865         877Swap:   2047      0      2047创建Swap文件，接下来我们将在文件系统上创建Swap文件。我们要在根目录/下创建一个名叫swapfile的文件，当然你也可以选择你喜欢的文件名。该文件分配的空间将等于我们需要的Swap空间。一般为内存的1.5倍以上就好了。也可以根据安装程序的提示来。root执行以下命令，创建swap分区。#创建swap文件 bs=2300的设置的值一般为内存的1.5倍以上 dd if=/dev/zero of=/var/swap bs=2500 count=1000000#需要更改swap文件的权限，确保只有root才可读chmod 600 /var/swap#告知系统将该文件用于swapmkswap /var/swap#开始使用该swapswapon /var/swap#使Swap文件永久生效,/etc/fstab加入配置echo \"/var/swap   swap    swap    sw  0   0\" &gt;&gt; /etc/fstab如果上面创建后发现大小创建错误了。如何重置呢？swapoff -a rm /var/swap上面命令就可以删除了，然后重新创建合适的swap文件就行了。经过我们的不断努力，所有警告都消失了。概要，这里显示了安装配置的概要部分，检查一下是否正确。没问题就开始安装。安装产品，上面折腾了这么久终于迎来了真正的安装操作了。进度70% ins_emagent.mk错误弹框。编辑/home/oracle/app/oracle/product/11.2.0/dbhome_1/sysman/lib/ins_emagent.mk约176行，可以搜索$(MK_EMAGENT_NMECTL)关键字快速找到。修改后如下：#===========================#  emdctl#===========================$(SYSMANBIN)emdctl:\t$(MK_EMAGENT_NMECTL) -lnnz11#===========================#  nmocat#===========================修改完成后，点击重试（R）。复制数据库文件，上面的问题解决后，安装一会儿就会出现如下的界面。耐心等待即可。数据库创建完成，经过一段时间的等待，终于弹出如下界面。执行配置脚本。据上图提示，切换root用户执行上面两个脚本就可以了。执行结果如下：[root@localhost ~]# /home/oracle/app/oraInventory/orainstRoot.sh 更改权限/home/oracle/app/oraInventory.添加组的读取和写入权限。删除全局的读取, 写入和执行权限。更改组名/home/oracle/app/oraInventory 到 database.脚本的执行已完成。[root@localhost ~]# /home/oracle/app/oracle/product/11.2.0/dbhome_1/root.sh Performing root user operation for Oracle 11g The following environment variables are set as:    ORACLE_OWNER= oracle    ORACLE_HOME=  /home/oracle/app/oracle/product/11.2.0/dbhome_1Enter the full pathname of the local bin directory: [/usr/local/bin]:    Copying dbhome to /usr/local/bin ...   Copying oraenv to /usr/local/bin ...   Copying coraenv to /usr/local/bin ...Creating /etc/oratab file...Entries will be added to the /etc/oratab file as needed byDatabase Configuration Assistant when a database is createdFinished running generic part of root script.Now product-specific root actions will be performed.Finished product-specific root actions.[root@localhost ~]# 执行完成这两个脚本，点击确定。Oracle Database的安装已成功。点击关闭即可。1.10 防火墙放行1521# 默认端口是1521，防火墙放行1521端口firewall-cmd --zone=public --add-port=1521/tcp --permanentfirewall-cmd --reload1.11 配置环境变量su oracle切换到oracle用户操作。编辑配置文件。vi ~/.bash_profile文件末尾加入以下内容，ORACLE_HOME中换成你实际安装的路径。export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1/export ORACLE_SID=orclexport PATH=$PATH:$ORACLE_HOME/bin使用配置文件立即生效。source ~/.bash_profile1.12 启动Oraclesu oraclesqlplus /nologSQL&gt; connect /as sysdbaSQL&gt; startup1.13 sys用户登录[oracle@localhost ~]$ sqlplus /nologSQL*Plus: Release 11.2.0.4.0 Production on Tue Feb 2 02:59:38 2021Copyright (c) 1982, 2013, Oracle.  All rights reserved.SQL&gt; connect as sysdbaEnter user-name: sysEnter password: Connected.SQL&gt; select 1 from dual;\t 1----------\t 1SQL&gt; 没有问题，说明本地连接Oracle成功。1.14 启动监听lsnrctl start1.15 PLSQL连接测试使用其他机器连接我们刚安装好的Oracle进行连接测试。修改配置文件C:\\app\\itkey\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora（路径根据实际情况来）CentOS7ORCL =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.184.5)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl)    )  )二、Oracle创建数据库我们很多操作都是可以通过命令行的形式来完成，但是由于不支持图形模式，在一些需要图形界面的时候就很麻烦。本次设置可以在SecureCRT中直接使用netca\\dbca命令，通过xmanager的passive来显示图形界面。设置display变量，设置的IP为安装xmanager的客户端IP, 例如本地ip为：192.168.1.2[root@test ~]# export DISPLAY=192.168.1.2:0.0其次，我们要在客户端启动Xmanager - Passive程序，最后，我们就可以在SecureCRT工具中直接使用命令来启动图形化界面了。以oracle用户登录系统，打开终端输入dbca，点击下一步点击创建数据库，下一步默认即可，下一步在全局数据库输入你要定义的名称，例如：myoracl，数据库实例名(SID)默认与全局数据库名相同，下一步不勾选配置Enterprise Manager，下一步数据库身份证明，可以为不同的账户分别设置不同的管理口令，也可以为所有账户设置同一口令，单击下一步数据库文件所在位置，默认存储类型：文件系统，存储位置：使用模版中的数据库文件位置，也可以自己指定存储路径，单击下一步恢复配置，指定快速恢复区，默认即可，有需要的可以配置，下一步内存、调整大小、字符集、连接模式可以根据自己的需要设置，下一步数据库存储，控制文件、数据文件、重做日志文件位置设置，单击下一步，创建选项，创建数据库，生成脚本，单击完成，开始创建数据库点击退出即完成数据库创建三、Oracle创建表空间并授权用户-- 登录sys用户sqlplus / as sysdba-- 查询用户表空间文件的路径，然后在此目录下创建新的表空间select name from v$datafile; -- 创建表空间，永久性表空间：一般保存表、视图、过程和索引等的数据create tablespace TESTSERVICESPACE datafile '/home/oracle/app/oracle/oradata/orcl/TESTSERVICESPACE.dbf' size 1024m autoextend on next 100m maxsize unlimited;-- 查询用户临时表空间文件的路径，然后在此目录下创建新的临时表空间select name from v$tempfile;-- 创建临时表空间，临时性表空间：只用于保存系统中短期活动的数据，如计算的中间结果等create temporary tablespace TESTSERVICESPACE_TEMP tempfile '/home/oracle/app/oracle/oradata/orcl/TESTSERVICESPACE_TEMP.dbf' size 200m autoextend on next 40m maxsize unlimited;-- 创建用户、密码并关联表空间和临时表空间create user orauser identified by \"1qaz!QAZ\" default tablespace TESTSERVICESPACE temporary tablespace TESTSERVICESPACE_TEMP;-- 授权，初始建立的用户没有任何权限，不能执行任何数据库操作，因此必须为用户设置权限或者角色grant connect,resource to orauser;-- 授予远程登录权限grant create session to orauser;-- 给表空间配额ALTER USER orauser QUOTA 100M ON TESTSERVICESPACE;-- 表空间配额（三选一即可）-- 您可以给用户，例如username在xxxx表空间中的无限配额ALTER USER orauser QUOTA UNLIMITED ON TESTSERVICESPACE;-- 您还可以定义允许用户在表空间上分配的空间最大值ALTER USER orauser QUOTA 100M ON TESTSERVICESPACE;-- 您还可以授予用户UNLIMITED TABLESPACE系统权限-- 这意味着他对数据库中的任何表空间都有无限的配额GRANT UNLIMITED TABLESPACE TO orauser;四、Oracle的重启4.1 重启监听  以Oracle身份登录数据库：su - oralce  进入监听器控制台：lsnrctl  关闭监听：stop  启动监听：start  查看监听状态：status  退出监听器控制台：exit4.2 重启数据库  以Oracle身份登录数据库：su - oralce  进入sqlplus控制台：sqlplus /nolog  以系统管理员登录：connect / as sysdba  关闭数据库：shutdown immediate          Normal：需要等待所有的用户断开连接      Immediate：等待用户完成当前的语句，并不允许新用户连接      Transactional：等待用户完成当前的事务，并不允许新用户连接      Abort：不做任何等待，直接关闭数据库        启动数据库：startup  退出Sqlplus控制台：exit4.3 重启实例  以Oracle身份登录数据库：su - oralce  查看当前实例：echo $ORACLE_SID  切换需要启动的数据库实例：export ORACLE_SID=ORCL  进入sqlplus控制台：sqlplus /nolog  以系统管理员登录：connect / as sysdba  关闭实例：shutdown abort  启动实例：startup  退出Sqlplus控制台：exit五、一些问题5.1 sqlplus / as sysdba：未找到命令      报错原因    shell环境变量未配置（使用shell远程登录）        解决方法    切换登录用户环境su - oracle，为什么普通切换su oracle仍登录不了，su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell，而后者连用户和Shell环境一起切换了。只有切换了Shell环境才不会出现PATH环境变量错误。          su oracle登录：切换到Oracle身份后用户的home目录和PATH仍然是原先用户的home目录和PATH。      su - oracle登录：相当于重新登陆，此时用户的home目录和PATH等信息会发生改变。        参考：https://github.com/lxyoucan/CentOS7Oracle11gInstallHelper"
  },
  
  {
    "title": "ifconfig命令无法使用",
    "url": "/posts/ifconfig-mingling-wufa-shiyong/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2023-02-24 01:47:00 +0800",
    





    
    "snippet": "修改网络配置，末尾的ifcfg-ens33可根据实际情况更改，有的可能为ifcfg-eth0 或者其他，可先切换到上级目录查看vi /etc/sysconfig/network-scripts/ifcfg-ens33将ONBOOT=no改为ONBOOT=yes，代表系统启动时，网卡也随之启动...DEVICE=ens33ONBOOT=yes...重启网络服务service network r...",
    "content": "修改网络配置，末尾的ifcfg-ens33可根据实际情况更改，有的可能为ifcfg-eth0 或者其他，可先切换到上级目录查看vi /etc/sysconfig/network-scripts/ifcfg-ens33将ONBOOT=no改为ONBOOT=yes，代表系统启动时，网卡也随之启动...DEVICE=ens33ONBOOT=yes...重启网络服务service network restart查询相关软件包yum provides ifconfig安装 net-tools，中间有几步需要手动确认的地方，输入y即可。yum install net-tools"
  },
  
  {
    "title": "WebLogic部署项目",
    "url": "/posts/weblogic-bushu-xiangmu/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2023-01-30 13:47:00 +0800",
    





    
    "snippet": "一种是通过网页部署，另一种是通过目录部署，类似于Tomcat的部署。网页部署登陆之后点击部署 -&gt; 安装选中项目的根路径(G:\\自己的struts项目的适配\\weblogic下调好的项目\\Struts是一个完整的项目，是项目的根路径)点击下一步输入项目的项目名称点击完成即可完成部署，查看项目概述最后查看部署成功的项目浏览器访问进行测试至此，第一种部署方式成功，我门到缓存目录查看发现目录...",
    "content": "一种是通过网页部署，另一种是通过目录部署，类似于Tomcat的部署。网页部署登陆之后点击部署 -&gt; 安装选中项目的根路径(G:\\自己的struts项目的适配\\weblogic下调好的项目\\Struts是一个完整的项目，是项目的根路径)点击下一步输入项目的项目名称点击完成即可完成部署，查看项目概述最后查看部署成功的项目浏览器访问进行测试至此，第一种部署方式成功，我门到缓存目录查看发现目录已经发布到缓存目录目录部署通过将war或者解压后的目录拷贝到%base%\\user_projects\\domains\\base_domain\\autodeploy目录，此目录相当于Tomcat的webapps目录登陆网页查看部署信息访问进行测试通过war包部署将项目打成war包，将war包扔到%base%\\user_projects\\domains\\base_domain\\autodeploy目录下查看部署信息访问测试Weblogic部署项目为默认项目(去除项目名称 = 只能用目录部署)有时候我门希望访问项目不带项目名称，类似于Tomcat的默认项目。我们可以增加一个weblogic.xml目录在WEB-INF目录下，与web.xml同级目录weblogic.xml内容如下&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE weblogic-web-app PUBLIC \"-//BEA Systems, Inc.//DTD Web Application 8.1//EN\"     \"http://www.bea.com/servers/wls810/dtd/weblogic810-web-jar.dtd\"&gt; &lt;weblogic-web-app&gt;  &lt;jsp-descriptor&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;GBK&lt;/param-value&gt;      &lt;/jsp-param&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;pageCheckSeconds&lt;/param-name&gt;        &lt;param-value&gt;-1&lt;/param-value&gt;      &lt;/jsp-param&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;compilerSupportsEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;      &lt;/jsp-param&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;verbose&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;      &lt;/jsp-param&gt;    &lt;/jsp-descriptor&gt;    &lt;container-descriptor&gt;  　　　　&lt;prefer-web-inf-classes&gt;true&lt;/prefer-web-inf-classes&gt;  &lt;/container-descriptor&gt;   &lt;context-root&gt;/&lt;/context-root&gt; &lt;/weblogic-web-app&gt;&lt;prefer-web-inf-classes&gt;true&lt;/prefer-web-inf-classes&gt;是设置Weblogic优先加载WEB-INF/lib目录的lib。&lt;context-root&gt;/&lt;/context-root&gt;是设置项目的名称，/自然就是默认的项目了。"
  },
  
  {
    "title": "WebLogic目录介绍",
    "url": "/posts/weblogic-mulu-jieshao/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2023-01-29 13:47:00 +0800",
    





    
    "snippet": "日志目录每个Domain(域)都有自己的日志目录，一般启动日志是AdmiServer.log，存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\logs。项目发布目录每个域也都有自己的项目发布目录。存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\Adm...",
    "content": "日志目录每个Domain(域)都有自己的日志目录，一般启动日志是AdmiServer.log，存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\logs。项目发布目录每个域也都有自己的项目发布目录。存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_user。JSP编译之后的目录我们需要知道Weblogic编译JSP依赖自己的lib库，所以在编译之后的class文件头部引入自己的lib，而Tomcat也依赖于自己的lib。该目录存放的是JSP编译之后的目录，位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_user\\Struts\\km2umq\\jsp_servlet文件夹下面。而且JSP不会一次性全部编译，是我们第一次访问哪个JSP编译哪个JSP(JSP的延迟编译特性确实给性能带来了不大不小的影响，第一次访问超慢的那种状况给人的感觉非常不好)，而且项目的根目录的JSP编译之后的package是默认的，然后每个目录对应一个package。根目录下的JSP。编译之后的位置%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_user\\Struts\\km2umq\\jsp_servlet\\。目录下的JSP，一个目录相当于一个package。编译之后的位置。存放lib的目录存放一些公共项目使用的lib，存放位置在%base%\\user_projects\\domains\\base_domain\\lib。Weblogic自带的lib类似于Tomcat的lib目录，是Weblogic自己启动所需要的包，一般也是造成冲突包的存放位置在%base%\\wlserver\\modules。缓存目录有时候缓存造成发布问题，所以每次除了清掉缓存目录，还要清掉logs目录和项目tmp目录，也就是每次启动项目都清掉下面三个目录，每次启动都会重新生成下面三个目录。Weblogic位数查看在Weblogic安装目录下wlserver\\server\\native\\win。Weblogic启动Weblogic启动的程序是在%base%\\user_projects\\domains\\base_domain\\startWebLogic.cmd (其内部调用了%base%\\user_projects\\domains\\base_domain\\bin目录下的startWebLogic.cmd)，双击之后启动即可，启动可以访问登陆页面。Weblogic调整JVM参数　JDK7的参数设置-Xms1024m -Xmx1024m -XX:PermSize=512m -XX:MaxPermSize=512mJDK8的参数设置-Xms1024m -Xmx1024m -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512mWeblogic12.2.1.3大概在%base%\\user_projects\\domains\\base_domain\\bin\\setDomainEnv.cmd202行左右，Weblogic12.1.3在170行。例如下面是Weblogic12.2.1.3在JDK8环境中配置。重新启动，使用jps+jmap查看JVM参数。控制台查看参数"
  },
  
  {
    "title": "WebLogic基本概念",
    "url": "/posts/weblogic-jiben-gainian/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2023-01-29 13:47:00 +0800",
    





    
    "snippet": "  Domain: 域是个逻辑概念，用来组织管理一系列的应用服务器实例，也就是下面要解释的server。域是WebLogic应用服务器中最大的概念，WebLogic应用服务器启动的时候就是以某个域来启动的，它有一个中心配置文件叫config.xml。  Cluster: 族也是一个逻辑概念，用来分组用途相同的服务器实例，一个域中可以有多个族。  Machine: 机器是物理上的概念，代表一台...",
    "content": "  Domain: 域是个逻辑概念，用来组织管理一系列的应用服务器实例，也就是下面要解释的server。域是WebLogic应用服务器中最大的概念，WebLogic应用服务器启动的时候就是以某个域来启动的，它有一个中心配置文件叫config.xml。  Cluster: 族也是一个逻辑概念，用来分组用途相同的服务器实例，一个域中可以有多个族。  Machine: 机器是物理上的概念，代表一台运行WebLogic应用服务器的实在的机器，包括其IP地址等信息。一个域中可以包括多台机器。  Server: 服务器，也就是一个应用服务器的实例，用来部署和运行各种J2EE应用程序，也可以来配置各种服务程序。它是WebLogic应用服务器的基本服务单元。一个WebLogic域中一般有一个管理服务器和多个被管理服务器。  Administrative Server: 管理服务器是用来管理配置域的中心点，一般来说，管理服务器上是不部署应用程序的，而是用来统一管理、配置、监控被管理服务器以及部署应用程序到被管理服务器上。一个域中有一台管理服务器。  Managed Server: 被管理服务器是用来部署运行各种应用程序的。一个域中有一台或多台被管理服务器。  Node Manager: 节点管理器是一个单独运行的后台程序，一般运行在被管理服务器的机器上，用来提供远程启动和停止服务器（Server）的功能。"
  },
  
  {
    "title": "云计算的三种服务模式：IaaS，PaaS和SaaS",
    "url": "/posts/paas-iaas-saas/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-01-29 13:47:00 +0800",
    





    
    "snippet": "2008年，云计算的概念由Google率先提出，短时间内其核心理念在全球范围内迅速传播并发展。2010年在国内形成趋势，各大IT互联网商业巨头将目光聚焦在云计算，至目前，云计算在中国已经慢慢开始成熟起来。云计算指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户，因此任何一个在互联网上提供服务的公司，都可以...",
    "content": "2008年，云计算的概念由Google率先提出，短时间内其核心理念在全球范围内迅速传播并发展。2010年在国内形成趋势，各大IT互联网商业巨头将目光聚焦在云计算，至目前，云计算在中国已经慢慢开始成熟起来。云计算指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户，因此任何一个在互联网上提供服务的公司，都可以称之为云计算公司。然而，并不是所有的云计算公司的服务模式都是一样的，虽然云计算的服务模式在不断变化，在业界根据公司的提供的服务方式，划分为三类：  SaaS（Software as a Service – 软件即服务）  PaaS（Platform as a Service – 平台即服务）  IaaS（Infrastructure as a Service – 基础架构即服务）Iaas（基础设施即服务）IaaS是基础设施即服务。英文全称是Infrastructure as a server。基本属于偏底层，指把IT基础设施作为一种服务通过网络对外提供。在这种服务模型中，用户不用自己构建一个数据中心，而是通过租用的方式来使用基础设施服务，包括服务器、存储和网络等。例如我们可直接购买腾讯云云服务器来使用，而不用自己构建机房、网络、储存等设备。在使用模式上，IaaS与传统的主机托管有相似之处，但是在服务的灵活性、扩展性和成本等方面IaaS具有很强的优势。PaaS（平台即服务）PaaS是平台即服务，英文全称是Platform as a Server。意思就是云端把客户所需的软件的平台作出租。相当于就是云端已经给大家搭建好了平台。一般来说，在用户使用的时候，云端已经搭建好了操作系统、数据库、中间件，运行库等等。用户只需要在这个搭建好的平台上下载、安装并使用自己需要的软件就可以了。腾讯云也是提供PaaS服务的平台。相对IaaS来说，PaaS的自由度和灵活度比较低，不太适合专业性比较高的IT技术从业人员。相当于范围被限定，在特定的范围做一些事情。SaaS（软件即服务）SaaS是软件即服务。英文全称是Software as a Server。到了这个层次，云端已经把操作系统、中间件、数据库、运行库、软件应用都部署好了。大多数SaaS应用程序直接通过浏览器运行，不需要客户端安装。总结对于用户而言，他们之间的关系是独立的，因为他们面向的用户群体不同，如果从技术角度而言，他们也并不是简单的继承关系，SaaS基于PaaS，而PaaS基于IaaS，现在的技术和平台多元化，PaaS可直接构建物理机上。再简单的举个例子，方便更直观的了解三个模式，假如你要开发一个基于小程序商城系统。  第一种方案是：买服务器，买数据库、买域名、开发小程序商城，那这种模式就是IaaS模式  第二种方案是：小程序提供云开发服务，免去了服务器、存储、域名等，我只开发程序即可，这种模式就是PaaS模式。  第三种方案是：微信提供商城程序，你只需开通即可，这种模式就是SaaS模式。  参考：浅谈云计算的三种服务模式：IaaS，PaaS和SaaS"
  },
  
  {
    "title": "跨域问题",
    "url": "/posts/kuayu-wenti/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2022-12-13 13:47:00 +0800",
    





    
    "snippet": "一、跨域问题产生的原因浏览器的同源策略。二、没有同源策略限制的两大危险场景浏览器是从两个方面去做同源策略的，一是针对接口的请求，二是针对DOM的查询。试想一下没有这样的限制上述两种动作有什么危险。2.1、没有同源策略限制的接口请求Cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字...",
    "content": "一、跨域问题产生的原因浏览器的同源策略。二、没有同源策略限制的两大危险场景浏览器是从两个方面去做同源策略的，一是针对接口的请求，二是针对DOM的查询。试想一下没有这样的限制上述两种动作有什么危险。2.1、没有同源策略限制的接口请求Cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将Cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景：你准备去清空你的购物车，于是打开了买买买网站www.maimaimai.com，然后登录成功，你在看有什么东西买的过程中，你的朋友发给你一个链接www.nidongde.com，你饶有兴致地浏览着www.nidongde.com，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向www.maimaimai.com发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！这就是传说中的CSRF攻击。2.2、没有同源策略限制的DOM查询有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？// HTML&lt;iframe name=\"yinhang\" src=\"www.yinhang.com\"&gt;&lt;/iframe&gt;// JS// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Domconst iframe = window.frames['yinhang']const node = iframe.document.getElementById('你输入账号密码的Input')console.log('拿到了这个${node}，还拿不到刚刚输入的账号密码吗')三、同源策略限制下接口请求的正确打开方式3.1、JSONP在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以实现跨域通信。JSONP全称json with padding，填充式的JSON。3.1.1、JSONP的原理  首先是利用script标签的src属性来实现跨域。  通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。  由于使用script标签的src属性，因此只支持GET方法。3.1.2、支持跨域的标签&lt;img src=\"\"&gt; // 图片&lt;link href=\"\"&gt; // CSS&lt;script src=\"\"&gt; // 程序3.1.3、JQuery中的JSONPJQuery中的$.ajax()函数，除了可以发起真正的Ajax数据请求之外，还可以发起JSONP数据请求：$.ajax({    url: 'http://www.liulongbin.top:3006/api/jsonp?name=zs&amp;age=20',    dataType: 'jsonp',    success: function (res) {        console.log(res);    }})默认情况下，使用JQuery发起JSONP请求，会自动携带一个callback=jQueryxxx的参数，jQueryxxx是随机生成的一个回调函数的名称。在JQuery中如果想要自定义JQuery的回调函数名称及JSONP的参数，可通过以下两个参数来指定：$.ajax({    url: 'http://www.liulongbin.top:3006/api/jsonp?name=zs&amp;age=20',    dataType: 'jsonp',    jsonp: 'callback', // 自定义参数的名称  一般让它默认为callback不会做修改    jsonpCallback: 'abc',   // 自定义回调函数的名称    success: function (res) {        console.log(res);    }})JQuery中JSONP的实现过程：JQuery中的JSONP也是通过script标签的src属性来实现跨域数据访问的，只不过，JQuery采用的是动态创建和移除script标签的方式，来发起JSONP数据请求。在发起JSONP请求的时候，动态向&lt;header&gt;中append一个script标签；在JSONP请求成功以后，动态地移除刚刚append进去的script标签。3.2、空iframe加form3.3、CORSCORS是一个W3C标准，全称是跨域资源共享（Cross-origin resource sharing）。看名字就知道这是处理跨域问题的标准做法。浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。只要同时满足以下两大条件，就属于简单请求。  请求方法是以下三种方法之一          HEAD      GET      POST        HTTP的头信息不超出以下几种字段          Accept      Accept-Language      Content-Language      Last-Event-ID      Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain      3.4、代理Nginx配置：server{      # 监听9099端口    listen 9099;    # 域名是localhost    server_name localhost;    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871     location ^~ /api {        proxy_pass http: //localhost:9871;    }   }Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。"
  },
  
  {
    "title": "Vue打包时url-loader处理CSS中的图片资源遇到的问题",
    "url": "/posts/url-loader-chuli-tupian-ziyuan-wenti/",
    "categories": "Knowledge, Vue",
    "tags": "Vue",
    "date": "2022-12-05 13:47:00 +0800",
    





    
    "snippet": "处理CSS中的图片资源时，我们常用的两种loader是file-loader和url-loader，两者的主要差异在于：url-loader可以设置图片大小限制，当图片超过限制时，其表现行为等同于file-loader，而当图片不超过限制时，则会将图片以base64的形式打包进CSS文件，以减少请求次数。本文主要想说的是我们在使用file-loader或url-loader时经常出现的图片地...",
    "content": "处理CSS中的图片资源时，我们常用的两种loader是file-loader和url-loader，两者的主要差异在于：url-loader可以设置图片大小限制，当图片超过限制时，其表现行为等同于file-loader，而当图片不超过限制时，则会将图片以base64的形式打包进CSS文件，以减少请求次数。本文主要想说的是我们在使用file-loader或url-loader时经常出现的图片地址错误导致图片引用不到的情况，及相应解决办法。工程目录index页面目录-index  -1.jpg  -index.html  -index.js  -index.scsswebpack配置文件中，关于图片的处理{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: 'img/[name].[hash:7].[ext]'    }},index.js文件import './index.scss'index.html文件&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"pic\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;index.scss文件.pic{  width:100px;  height:100px;  background: url('./1.jpg');  background-size: 100px 100px;}打包和分析当我们执行npm run build后查看dist中的情况如下：-dist  -css    -index.min.css  -img    -1.d1efbb3.jpg  -js    -index.html我们通过服务打开index.html会发现页面中并没有图片，并且报错：Failed to load resource:the server responded with a status 1.d1efbb3.jpg of 404 (Not found)这时我们当然是要去看看打包后的CSS文件中的图片路径了：.pic {    width: 100px;    height: 100px;    background: url(img/1.d1efbb3.jpg);    background-size: 100px 100px}/*# sourceMappingURL=index.min.css.map?v=7b7c89f8*/background:url(img/1.d1efbb3.jpg);index.min.css文件竟然去自己的同级目录找img文件夹，当然找不到了，img文件夹位于index.min.css上层，如果是background:url(../img/1.d1efbb3.jpg);就对了。然后我们尝试去修改webpack的配置文件，以达到我们的预期：{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: '../img/[name].[hash:7].[ext]'    }},然后再npm run build，index.min.css内的background的图片地址的确变成了我们想要的：.pic {    width: 100px;    height: 100px;    background: url(../img/1.d1efbb3.jpg);    background-size: 100px 100px}/*# sourceMappingURL=index.min.css.map?v=eef74865*/但是img竟然被打包到了dist文件夹的外面，不再位于dist内了：-dist  -css    -index.min.css  -js    -index.html-img  -1.d1efbb3.jpg看来我们修改配置文件的方法是不对的。分析其中的原因：打包的时候webpack会把scss文件中的background url替换成我们webpack配置文件中的 options的name属性中设置的内容，同时把scss文件中的background url中的图片文件复制到 webpack配置文件中的options的name属性所指向路径下，关键就在这里了。webpack配置文件中的options的name属性所指向路径是相对路径，那么这个路径到底是相对于谁呢？仔细观察会发现它是相对于dist文件夹的，也就是webpack的出口路径。举个例子：{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: 'img/[name].[hash:7].[ext]'    }},上面的配置就会把图片复制到dist/img/1.jpg，然后将index.min.css的background属性改为background:url('img/1.png')，该路径也是相对路径，但是它不相对于dist，而是相对于dist/css，因为我的CSS文件并没有被输出到dist的直接路径下，而是输出到了dist/css下，所以CSS文件就会去dist/css/img/1.png去拿图片，但是图片却位于dist/img/1.png，这就最终导致了CSS文件找不到图片。配置文件复制图片是相对于webpack出口路径的，CSS文件引用图片是相对于CSS文件所在路径的，如果这两个路径相同，也就是webpack出口路径 = CSS文件所在路径，那么很幸运，你的图片是可以找到的。但是一般情况下是不同的，我们习惯于将出口路径定为dist/然后将CSS文件输出到dist/css/，最终导致了引用不到图片的结果。至此原因分析完毕。解决方法在配置项内加入publicPath属性，设置为部署时的绝对路径。比如你的页面会通过如下url方式让用户访问，所有前端文件都放置于http://localhost:63342/url-loader-test/dist/，那么pubilcPath的值就应该是/url-loader-test/dist/，也就是你的部署接口地址。{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: 'img/[name].[hash:7].[ext]'，        publicPath: \"/url-loader-test/dist/\"         // 该地址不是唯一的，根据你的代码实际路由地址进行修改    }},这样做的原因是，webpack打包时，还会将图片复制到dist/img/1.png，但是他会把CSS文件中的background url改写为publicPath + name，本例中最后生成的index.min.css 如下：.pic {    width: 100px;    height: 100px;    background: url(/url-loader-test/dist/img/1.d1efbb3.jpg);    background-size: 100px 100px}/*# sourceMappingURL=index.min.css.map?v=eef74865*/这时CSS文件中的url地址就变成了一个绝对路由。总结如果我们希望在页面引入图片（包括img的src和background的url）。当我们基于webpack进行开发时，引入图片会遇到一些问题。其中一个就是引用路径的问题。拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。另外，如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况：1.文件大小小于limit参数，url-loader将会把文件转为DataURL；2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。因此我们只需要安装url-loader即可。url-loaderloader中的参数上面提到url-loader的参数和file-loader的参数，那么loader的参数是个什么概念呢？loader的参数用来自定义loader处理文件时的工作特性。下面以url-loader为例，介绍一下webpack的loader中的参数。首先看下面的例子：module.exports = {    // 入口文件路径，__dirname是根目录    entry: __dirname + '/src/main.js',    // 打包生成文件    output: {        path: __dirname + '/output',        filename: 'main.js'    },     module: {        rules: [            {                test: /\\.css$/,                use: ['style-loader', 'css-loader']            },            {                test: /\\.jpeg$/,                use: [                    {                        loader: 'url-loader',                        options: {                            limit: '1024'                        }                    },                ]            }        ]    }}其中，url-loader配置中的options属性表示的就是url-loader的参数，还有一种等价的写法：{    test: /\\.jpeg$/,    use: 'url-loader?limit=1024'}如果有多个参数，就用&amp;连接起来。和http请求中的参数类似。正如前面介绍的，limit这个参数就是告诉url-loader，在文件小于多少个字节时，将文件编码并返回DataURL。url-loader的参数此外url-loader还有一些用于file-loader的参数。我们知道，file-loader的作用是将文件复制到其他目录。file-loader提供了一系列参数允许我们自定义诸如输出文件、文件名规则、发布路径等特性的参数。下面介绍一下这些参数。先看下配置好的代码：module.exports = {    // 入口文件路径，__dirname是根目录    entry: __dirname + '/src/main.js',    // 打包生成文件    output: {        path: __dirname + '/output',        filename: 'main.js'    },     module: {        rules: [            {                test: /\\.css$/,                use: ['style-loader', 'css-loader']            },            {                test: /\\.jpeg$/,                use: 'url-loader?limit=1024&amp;name=[path][name].[ext]&amp;                outputPath=img/&amp;publicPath=output/',            }        ]    }}这里涉及到了4个参数：limit、name、outputPath、publicPath。其中limit已经说明过。file-loader相关的是name、outputPath和publicPath。下面解释一下这3个参数：  name表示输出的文件名规则，如果不添加这个参数，输出的就是默认值：文件哈希。加上[path]表示输出文件的相对路径与当前文件相对路径相同，加上[name].[ext]则表示输出文件的名字和扩展名与当前相同。加上[path]这个参数后，打包后文件中引用文件的路径也会加上这个相对路径。  outputPath表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。比如outputPath=img/，图片被打包时，就会在输出文件夹下新建（如果没有）一个名为img的文件夹，把图片放到里面。  publicPath表示打包文件中引用文件的路径前缀，如果你的图片存放在CDN上，那么你上线时可以加上这个参数，值为CDN地址，这样就可以让项目上线后的资源引用路径指向CDN了。安装url-loadernpm install --save-dev url-loader推荐文档file-loader: https://github.com/webpack-contrib/file-loader  url-loader: http://www.cnblogs.com/ghost-xyx/p/5812902.htmldemohttps://github.com/KIDFUCKER/webpack-demo.git  参考：url-loader处理css中的图片资源遇到的问题"
  },
  
  {
    "title": "ECharts各个配置项详细说明总结",
    "url": "/posts/echarts-gepeizhixiang-shuoming/",
    "categories": "Knowledge, ECharts",
    "tags": "ECharts",
    "date": "2022-12-03 13:47:00 +0800",
    





    
    "snippet": "1、图表标题title: {    x: 'left',              // 水平安放位置，默认为左对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：     ...",
    "content": "1、图表标题title: {    x: 'left',              // 水平安放位置，默认为左对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    // textAlign: null      // 水平对齐方式，默认根据x设置自动调整    backgroundColor: 'rgba(0,0,0,0)',    borderColor: '#ccc',    // 标题边框颜色    borderWidth: 0,         // 标题边框线宽，单位px，默认为0（无边框）    padding: 5,             // 标题内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 主副标题纵向间隔，单位px，默认为10    textStyle: {        fontSize: 18,        fontWeight: 'bolder',        color: '#333'       // 主标题文字颜色    },    subtextStyle: {        color: '#aaa'       // 副标题文字颜色    }},2、图例legend: {    orient: 'horizontal',   // 布局方式，默认为水平布局，可选为：                            // 'horizontal' ¦ 'vertical'    x: 'center',            // 水平安放位置，默认为全图居中，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    backgroundColor: 'rgba(0,0,0,0)',    borderColor: '#ccc',    // 图例边框颜色    borderWidth: 0,         // 图例边框线宽，单位px，默认为0（无边框）    padding: 5,             // 图例内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 各个item之间的间隔，单位px，默认为10，                            // 横向布局时为水平间隔，纵向布局时为纵向间隔    itemWidth: 20,          // 图例图形宽度    itemHeight: 14,         // 图例图形高度    textStyle: {        color: '#333'       // 图例文字颜色    }},3、值域dataRange: {    orient: 'vertical',     // 布局方式，默认为垂直布局，可选为：                            // 'horizontal' ¦ 'vertical'    x: 'left',              // 水平安放位置，默认为全图左对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'bottom',            // 垂直安放位置，默认为全图底部，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    backgroundColor: 'rgba(0,0,0,0)',    borderColor: '#ccc',    // 值域边框颜色    borderWidth: 0,         // 值域边框线宽，单位px，默认为0（无边框）    padding: 5,             // 值域内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 各个item之间的间隔，单位px，默认为10，                            // 横向布局时为水平间隔，纵向布局时为纵向间隔    itemWidth: 20,          // 值域图形宽度，线性渐变水平布局宽度为该值 * 10    itemHeight: 14,         // 值域图形高度，线性渐变垂直布局高度为该值 * 10    splitNumber: 5,         // 分割段数，默认为5，为0时为线性渐变    color: ['#1e90ff','#f0ffff'], // 颜色     // text:['高','低'],    // 文本，默认为数值文本    textStyle: {        color: '#333'       // 值域文字颜色    }}, toolbox: {    orient: 'horizontal',   // 布局方式，默认为水平布局，可选为：                            // 'horizontal' ¦ 'vertical'    x: 'right',             // 水平安放位置，默认为全图右对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    color : ['#1e90ff','#22bb22','#4b0082','#d2691e'],    backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色    borderColor: '#ccc',    // 工具箱边框颜色    borderWidth: 0,         // 工具箱边框线宽，单位px，默认为0（无边框）    padding: 5,             // 工具箱内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 各个item之间的间隔，单位px，默认为10，                            // 横向布局时为水平间隔，纵向布局时为纵向间隔    itemSize: 16,           // 工具箱图形宽度    featureImageIcon : {},  // 自定义图片icon    featureTitle : {        mark : '辅助线开关',        markUndo : '删除辅助线',        markClear : '清空辅助线',        dataZoom : '区域缩放',        dataZoomReset : '区域缩放后退',        dataView : '数据视图',        lineChart : '折线图切换',        barChart : '柱形图切换',        restore : '还原',        saveAsImage : '保存为图片'    }},4、提示框tooltip: {    trigger: 'item',           // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'    showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms    hideDelay: 100,            // 隐藏延迟，单位ms    transitionDuration : 0.4,  // 动画变换时间，单位s    backgroundColor: 'rgba(0,0,0,0.7)',  // 提示背景颜色，默认为透明度为0.7的黑色    borderColor: '#333',       // 提示边框颜色    borderRadius: 4,           // 提示边框圆角，单位px，默认为4    borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）    padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，                               // 接受数组分别设定上右下左边距，同css    axisPointer : {            // 坐标轴指示器，坐标轴触发有效        type : 'line',         // 默认为直线，可选为：'line' | 'shadow'        lineStyle : {          // 直线指示器样式设置            color: '#48b',            width: 2,            type: 'solid'        },        shadowStyle : {                    // 阴影指示器样式设置            width: 'auto',                 // 阴影大小            color: 'rgba(150,150,150,0.3)' // 阴影颜色        }    },    textStyle: {        color: '#fff'    }},5、区域缩放控制器dataZoom: {    orient: 'horizontal',   // 布局方式，默认为水平布局，可选为：                            // 'horizontal' ¦ 'vertical'    // x: {number},         // 水平安放位置，默认为根据grid参数适配，可选为：                            // {number}（x坐标，单位px）    // y: {number},         // 垂直安放位置，默认为根据grid参数适配，可选为：                            // {number}（y坐标，单位px）    // width: {number},     // 指定宽度，横向布局时默认为根据grid参数适配    // height: {number},    // 指定高度，纵向布局时默认为根据grid参数适配    backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色    dataBackgroundColor: '#eee',            // 数据背景颜色    fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色    handleColor: 'rgba(70,130,180,0.8)'     // 手柄颜色},6、网格grid: {    x: 80,    y: 60,    x2: 80,    y2: 60,    // width: {totalWidth} - x - x2,    // height: {totalHeight} - y - y2,    backgroundColor: 'rgba(0,0,0,0)',    borderWidth: 1,    borderColor: '#ccc'},7、类目轴categoryAxis: {    position: 'bottom',    // 位置    nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'    boundaryGap: true,     // 类目起始和结束两端空白策略    axisLine: {            // 坐标轴线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle控制线条样式            color: '#48b',            width: 2,            type: 'solid'        }    },    axisTick: {            // 坐标轴小标记        show: true,        // 属性show控制显示与否，默认不显示        interval: 'auto',        // onGap: null,        inside : false,    // 控制小标记是否在grid里         length :5,         // 属性length控制线长        lineStyle: {       // 属性lineStyle控制线条样式            color: '#333',            width: 1        }    },    axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel        show: true,        interval: 'auto',        rotate: 0,        margin: 8,        // formatter: null,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    splitLine: {           // 分隔线        show: true,        // 默认显示，属性show控制显示与否        // onGap: null,        lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式            color: ['#ccc'],            width: 1,            type: 'solid'        }    },    splitArea: {           // 分隔区域        show: false,       // 默认不显示，属性show控制显示与否        // onGap: null,        areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']        }    }},8、数值型坐标轴默认参数valueAxis: {    position: 'left',      // 位置    nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'    nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式    boundaryGap: [0, 0],   // 数值起始和结束两端空白策略    splitNumber: 5,        // 分割段数，默认为5    axisLine: {            // 坐标轴线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle控制线条样式            color: '#48b',            width: 2,            type: 'solid'        }    },    axisTick: {            // 坐标轴小标记        show: false,       // 属性show控制显示与否，默认不显示        inside : false,    // 控制小标记是否在grid里         length :5,         // 属性length控制线长        lineStyle: {       // 属性lineStyle控制线条样式            color: '#333',            width: 1        }    },    axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel        show: true,        rotate: 0,        margin: 8,        // formatter: null,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    splitLine: {           // 分隔线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式            color: ['#ccc'],            width: 1,            type: 'solid'        }    },    splitArea: {           // 分隔区域        show: false,       // 默认不显示，属性show控制显示与否        areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']        }    }},polar : {    center : ['50%', '50%'],// 默认全局居中    radius : '75%',    startAngle : 90,    splitNumber : 5,    name : {        show: true,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    axisLine: {            // 坐标轴线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle控制线条样式            color: '#ccc',            width: 1,            type: 'solid'        }    },    axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel        show: false,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    splitArea : {        show : true,        areaStyle : {            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']        }    },    splitLine : {        show : true,        lineStyle : {            width : 1,            color : '#ccc'        }    }},9、柱形图默认参数bar: {    barMinHeight: 0,          // 最小高度改为0    // barWidth: null,        // 默认自适应    barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值    barCategoryGap : '20%',   // 类目间柱形距离，默认为类目间距的20%，可设固定值    itemStyle: {        normal: {            // color: '各异',            barBorderColor: '#fff',    // 柱条边线            barBorderRadius: 0,        // 柱条边线圆角，单位px，默认为0            barBorderWidth: 1,         // 柱条边线线宽，单位px，默认为1            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE            }        },        emphasis: {            // color: '各异',            barBorderColor: 'rgba(0,0,0,0)',   // 柱条边线            barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0            barBorderWidth: 1,                 // 柱条边线线宽，单位px，默认为1            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        }    }},10、折线图默认参数line: {    itemStyle: {        normal: {            // color: 各异,            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            lineStyle: {                width: 2,                type: 'solid',                shadowColor : 'rgba(0,0,0,0)', // 默认透明                shadowBlur: 5,                shadowOffsetX: 3,                shadowOffsetY: 3            }        },        emphasis: {            // color: 各异,            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        }    },    // smooth : false,    // symbol: null,         // 拐点图形类型    symbolSize: 2,           // 拐点图形大小    // symbolRotate : null,  // 拐点图形旋转控制    showAllSymbol: false     // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）},11、K线图默认参数k: {    // barWidth : null            // 默认自适应    // barMaxWidth : null         // 默认自适应     itemStyle: {        normal: {            color: '#fff',        // 阳线填充颜色            color0: '#00aa11',    // 阴线填充颜色            lineStyle: {                width: 1,                color: '#ff3200', // 阳线边框颜色                color0: '#00aa11' // 阴线边框颜色            }        },        emphasis: {            // color: 各异,            // color0: 各异        }    }},12、散点图默认参数scatter: {    // symbol: null,        // 图形类型    symbolSize: 4,          // 图形大小，半宽（半径）参数，当图形为                            // 方向或菱形则总宽度为symbolSize * 2    //symbolRotate : null,  // 图形旋转控制    large: false,           // 大规模散点图    largeThreshold: 2000,   // 大规模阀值，large为true且数据                            // 量&gt;largeThreshold才启用大规模模式    itemStyle: {        normal: {            // color: 各异,            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        },        emphasis: {            // color: '各异'            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        }    }},13、雷达图默认参数radar : {    itemStyle: {        normal: {            // color: 各异,            label: {                show: false            },            lineStyle: {                width: 2,                type: 'solid'            }        },        emphasis: {            // color: 各异,            label: {                show: false            }        }    },    // symbol: null,         // 拐点图形类型    symbolSize: 2            // 可计算特性参数，空数据拖拽提示图形大小    // symbolRotate : null,  // 图形旋转控制},14、饼图默认参数pie: {    center : ['50%', '50%'],    // 默认全局居中    radius : [0, '75%'],    clockWise : false,          // 默认逆时针    startAngle: 90,    minAngle: 0,                // 最小角度改为0    selectedOffset: 10,         // 选中是扇区偏移量    itemStyle: {        normal: {            // color: 各异,            borderColor: '#fff',            borderWidth: 1,            label: {                show: true,                position: 'outer'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            labelLine: {                show: true,                length: 20,                lineStyle: {                    // color: 各异,                    width: 1,                    type: 'solid'                }            }        },        emphasis: {            // color: 各异,            borderColor: 'rgba(0,0,0,0)',            borderWidth: 1,            label: {                show: false                // position: 'outer'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            labelLine: {                show: false,                length: 20,                lineStyle: {                    // color: 各异,                    width: 1,                    type: 'solid'                }            }        }    }},map: {    mapType: 'china',   // 各省的mapType暂时都用中文    mapLocation: {        x : 'center',        y : 'center'        // width    // 自适应        // height   // 自适应    },    showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效    itemStyle: {        normal: {            // color: 各异,            borderColor: '#fff',            borderWidth: 1,            areaStyle: {                color: '#ccc'      // rgba(135,206,250,0.8)            },            label: {                show: false,                textStyle: {                    color: 'rgba(139,69,19,1)'                }            }        },        emphasis: {                // 也是选中样式            // color: 各异,            borderColor: 'rgba(0,0,0,0)',            borderWidth: 1,            areaStyle: {                color: 'rgba(255,215,0,0.8)'            },            label: {                show: false,                textStyle: {                    color: 'rgba(139,69,19,1)'                }            }        }    }},force : {    // 数据map到圆的半径的最小值和最大值    minRadius : 10,    maxRadius : 20,    density : 1.0,    attractiveness : 1.0,    // 初始化的随机大小位置    initSize : 300,    // 向心力因子，越大向心力越大    centripetal : 1,    // 冷却因子    coolDown : 0.99,    // 分类里如果有样式会覆盖节点默认样式    itemStyle: {        normal: {            // color: 各异,            label: {                show: false                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            nodeStyle : {                brushType : 'both',                color : '#f08c2e',                strokeColor : '#5182ab'            },            linkStyle : {                strokeColor : '#5182ab'            }        },        emphasis: {            // color: 各异,            label: {                show: false                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            nodeStyle : {},            linkStyle : {}        }    }},chord : {    radius : ['65%', '75%'],    center : ['50%', '50%'],    padding : 2,    sort : 'none',    // can be 'none', 'ascending', 'descending'    sortSub : 'none', // can be 'none', 'ascending', 'descending'    startAngle : 90,    clockWise : false,    showScale : false,    showScaleText : false,    itemStyle : {        normal : {            label : {                show : true                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            lineStyle : {                width : 0,                color : '#000'            },            chordStyle : {                lineStyle : {                    width : 1,                    color : '#666'                }            }        },        emphasis : {            lineStyle : {                width : 0,                color : '#000'            },            chordStyle : {                lineStyle : {                    width : 2,                    color : '#333'                }            }        }    }},island: {    r: 15,    calculateStep: 0.1      // 滚轮可计算步长 0.1 = 10%}, markPoint : {    symbol: 'pin',          // 标注类型    symbolSize: 10,         // 标注大小，半宽（半径）参数，当图形为方向                            // 或菱形则总宽度为symbolSize * 2    // symbolRotate : null, // 标注旋转控制    itemStyle: {        normal: {            // color: 各异，            // borderColor: 各异,      // 标注边线颜色，优先于color             borderWidth: 2,            // 标注边线线宽，单位px，默认为1            label: {                show: true,                position: 'inside'     // 可选为'left'|'right'|'top'|'bottom'                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE            }        },        emphasis: {            // color: 各异            label: {                show: true                // position: 'inside'  // 'left'|'right'|'top'|'bottom'                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE            }        }    }},markLine : {    // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string    symbol: ['circle', 'arrow'],      // 标线起始和结束的symbol大小，半宽（半径）参数，当图    // 形为方向或菱形则总宽度为symbolSize * 2    symbolSize: [2, 4],    // 标线起始和结束的symbol旋转控制    // symbolRotate : null,    itemStyle: {        normal: {            // color: 各异,           // 标线主色，线色，symbol主色            // borderColor: 随color,  // 标线symbol边框颜色，优先于color             borderWidth: 2,           // 标线symbol边框线宽，单位px，默认为2            label: {                show: false,                // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'                position: 'inside',                  textStyle: {          // 默认使用全局文本样式，详见TEXTSTYLE                    color: '#333'                }            },            lineStyle: {                // color: 随borderColor,       // 主色，线色，优先级高于borderColor和color                // width: 随borderWidth,       // 优先于borderWidth                type: 'solid',                shadowColor : 'rgba(0,0,0,0)', // 默认透明                shadowBlur: 5,                shadowOffsetX: 3,                shadowOffsetY: 3            }        },        emphasis: {            // color: 各异            label: {                show: false                // position: 'inside' // 'left'|'right'|'top'|'bottom'                // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE            },            lineStyle : {}        }    }},textStyle: {    decoration: 'none',    fontFamily: 'Arial, Verdana, sans-serif',    fontFamily2: '微软雅黑',    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份    fontSize: 12,    fontStyle: 'normal',    fontWeight: 'normal'},15、默认标志图形类型列表symbolList : [    'circle', 'rectangle', 'triangle', 'diamond',    'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'],16、可计算特性配置，孤岛，提示颜色calculable: false,                        // 默认关闭可计算特性calculableColor: 'rgba(255,165,0,0.6)',   // 拖拽提示边框颜色calculableHolderColor: '#ccc',            // 可计算占位提示颜色nameConnector: ' &amp; ',valueConnector: ' : ',animation: true,animationThreshold: 2500,                 // 动画元素阀值，产生的图形原素超过2500不出动画addDataAnimation: true,                   // 动态数据接口是否开启动画效果animationDuration: 2000,animationEasing: 'ExponentialOut'         // BounceOut  参考：echarts——各个配置项详细说明总结"
  },
  
  {
    "title": "MySQL分页查询优化",
    "url": "/posts/mysql-fenye-chaxun-youhua/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2022-12-03 10:47:00 +0800",
    





    
    "snippet": "MySQL一般使用LIMIT实现分页，基本语句为：SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...-- 分页计算方法SELECT ... FROM ... WHERE ... ORDER BY ... (#{pageNum} - 1) * #{pageSize}, #{pageSize}  提示：  select from_user, ...",
    "content": "MySQL一般使用LIMIT实现分页，基本语句为：SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...-- 分页计算方法SELECT ... FROM ... WHERE ... ORDER BY ... (#{pageNum} - 1) * #{pageSize}, #{pageSize}  提示：  select from_user, realname, mobile from testtable LIMIT (1-1)*10, 10报错  You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near “(1-1)*10,10” at line 2  原因是limit后面是不能做计算，只能直接写limit x, x在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引。举例来说，如果实际SQL类似下面语句，那么在category_id，id两列上建立复合索引比较好：SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10;随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似下面这种：SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 10;可以看出，越往后分页，LIMIT语句的偏移量就会越大，速度也会明显变慢。此时，我们可以通过子查询的方式来提高分页效率：SELECT * FROM articles WHERE id &gt;=(SELECT id FROM articles  WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) AND category_id = 123 ORDER BY id LIMIT 10;还可以通过JOIN方式来实现分页查询：SELECT * FROM articles AS t1 JOIN (SELECT id FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) AS t2 WHERE t1.id &gt;= t2.id AND t1.category_id = 123 ORDER BY t1.id LIMIT 10;为什么会这样呢？因为子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。  参考：MySQL的分页查询SQL语句"
  },
  
  {
    "title": "SpringMVC",
    "url": "/posts/springmvc/",
    "categories": "Knowledge, SpringMVC",
    "tags": "SpringMVC",
    "date": "2022-12-02 13:47:00 +0800",
    





    
    "snippet": "SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。什么是SpringMVCSpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model、View、Controller分离，将Web层进行职责解耦，把复杂的Web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组...",
    "content": "SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。什么是SpringMVCSpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model、View、Controller分离，将Web层进行职责解耦，把复杂的Web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。SpringMVC运行流程及九大组件SpringMVC的运行流程  用户发送请求至前端控制器DispatcherServlet  DispatcherServlet收到请求调用HandlerMapping处理器映射器  处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet  DispatcherServlet通过HandlerAdapter处理器适配器调用处理器执行处理器(Controller，也叫后端控制器)  Controller执行完成返回ModelAndView  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet  DispatcherServlet将ModelAndView传给ViewReslover视图解析器  ViewReslover解析后返回具体View  DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。  DispatcherServlet响应用户。从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度SpringMVC的优点  可以支持各种视图技术，而不仅仅局限于JSP  与Spring框架集成(如IoC容器、AOP等)  清晰的角色分配：前端控制器(DispatcherServlet)，请求到处理器映射(HandlerMapping)，处理器适配器(HandlerAdapter)，视图解析器(ViewResolver)。SpringMVC的主要组件  前端控制器DispatcherServlet(不需要程序员开发) 作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet就减少了其它组件之间的耦合度。  处理器映射器HandlerMapping(不需要程序员开发) 作用：根据请求的URL来查找Handler  处理器适配器HandlerAdapter 注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。  处理器Handler(需要程序员开发)  视图解析器ViewResolver(不需要程序员开发) 作用：进行视图的解析，根据视图逻辑名解析成真正的视图(Vew)  视图View(需要程序员开发JSP) View是一个接口， 它的实现类支持不同的视图类型(JSP，Freemarker，PDF等等)SpringMVC和Struts2的区别有哪些  SpringMVC的入口是一个Servlet即前端控制器(DispatchServlet)，而Struts2入口是一个Filter过虑器(StrutsPrepareAndExecuteFilter)。  SpringMVC是基于方法开发(一个url对应一个方法)，请求参数传递到方法地形参，可以设计为单例或多例(建议单例)，Struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。  Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，SpringMVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。JSP视图解析器默认使用JSTL。"
  },
  
  {
    "title": "JDK和JRE",
    "url": "/posts/jdk-he-jre/",
    "categories": "Knowledge, JDK",
    "tags": "JDBC, JDK",
    "date": "2022-12-02 13:47:00 +0800",
    





    
    "snippet": "JDK是整个Java的核心，包括了Java运行环境JRE、Java开发工具和Java基础类库。利用JDK（调用JAVA API）开发了属于我们自己的Java程序后，通过JDK中的编译程序（javac）将我们的Java文件编译成Java字节码，在JRE上运行这些Java字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。",
    "content": "JDK是整个Java的核心，包括了Java运行环境JRE、Java开发工具和Java基础类库。利用JDK（调用JAVA API）开发了属于我们自己的Java程序后，通过JDK中的编译程序（javac）将我们的Java文件编译成Java字节码，在JRE上运行这些Java字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。"
  },
  
  {
    "title": "Git无法提交和更新",
    "url": "/posts/git-wufa-tiijaohegengxin/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2022-12-01 13:47:00 +0800",
    





    
    "snippet": "依次执行以下命令就可以正常push和pullgit config --global --unset http.proxy git config --global --unset https.proxy",
    "content": "依次执行以下命令就可以正常push和pullgit config --global --unset http.proxy git config --global --unset https.proxy"
  },
  
  {
    "title": "JS中获取alert代码的位置",
    "url": "/posts/js-zhong-huoqu-alert-weizhi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2022-12-01 10:47:00 +0800",
    





    
    "snippet": "找到弹窗出现的页面，在浏览器控制台输入：var oalert = window.alertwindow.alert = (...args) =&gt; { oalert(...args); console.error(new Error('someone alerted'))}然后复现弹窗，即可在控制台看到alert代码的位置。",
    "content": "找到弹窗出现的页面，在浏览器控制台输入：var oalert = window.alertwindow.alert = (...args) =&gt; { oalert(...args); console.error(new Error('someone alerted'))}然后复现弹窗，即可在控制台看到alert代码的位置。"
  },
  
  {
    "title": "JS发送POST JSON格式请求",
    "url": "/posts/js-fasong-postjson-geshi-qingqiu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2022-12-01 10:47:00 +0800",
    





    
    "snippet": "var xhr = new XMLHttpRequest();var sendData = {name:\"abc\"};xhr.open(\"POST\", \"/service/hello\", true);xhr.setRequestHeader('content-type', 'application/json');// 将用户输入值序列化成字符串xhr.send(JSON.stringify(...",
    "content": "var xhr = new XMLHttpRequest();var sendData = {name:\"abc\"};xhr.open(\"POST\", \"/service/hello\", true);xhr.setRequestHeader('content-type', 'application/json');// 将用户输入值序列化成字符串xhr.send(JSON.stringify(sendData));// 回调xhr.onreadystatechange = function() {    if (xhr.readyState == 4) {        // 根据服务器的响应内容格式处理响应结果        if(xhr.getResponseHeader('content-type') === 'application/json') {            var result = JSON.parse(xhr.responseText);\t            // 根据返回结果判断验证码是否正确            if(result.code === -1) {                alert('验证码错误');            }        }    } else {        console.log(xhr.responseText);    }}  参考：js 发送post json格式请求"
  },
  
  {
    "title": "收藏夹",
    "url": "/posts/shuqian-shoucangjia/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2022-11-24 13:47:00 +0800",
    





    
    "snippet": "                                    Knowledge                                                                    技术博客                                            纯洁的微笑                        友人C    ...",
    "content": "                                    Knowledge                                                                    技术博客                                            纯洁的微笑                        友人C                        靳闯博客                                                                                            知识汇总                                            数据库/运维/大数据/架构知识汇总                        JQL                        Spring框架入门教程                        保贝说保\t\t\t\t\t\t帆软信创产品\t\t\t\t\t\t山川软件信创产品\t\t\t\t\t\tAI副业                                                                                            教程                                            Bootstrap中文网                        Spring Cloud中文网                        Knife4j - swagger-bootstrap-ui                        人工智能教程                        菜鸟教程                        Python教程                        数据结构和算法动态可视化平台                        易百教程                                    \t\t\t\t                                        技术文档                                            GaussDB使用指南                                                                                            Resource                                                                    媒体资源                                            极简壁纸                        必应壁纸                        Awesome Wallpapers                        急速收录网 - 网址查询                        WebStack.cc - 设计师网址导航                        Pexels - 免费素材图片                        Stock Up - 免费素材图片                        沙沙野 - 免费素材图片                        Unsplash - 免费素材图片                        Pixabay - 免费素材图片                        StockSnap - 免费素材图片                        HiFiNi - 音乐磁场                        樱花动漫                        搜狗搜索 - 微信公众号搜索                                                                                            软件资源                                            9553下载                        绿盒下载站                        Bitbucket下载                        Atlassian全家桶以及插件破解详细教程                        为知笔记服务端Docker镜像使用说明                                                                                            WIN系统资源                                            Microsoft官网                        DLL下载站                        MSDN                        字体天下                                                                                            插件资源                                            Greasy Fork - 油猴脚本                        Atlassian插件市场                        Gitbook常用插件\t\t\t\t\t\tBeyond Compare插件\t\t\t\t\t\tCrx - 浏览器插件\t\t\t\t\t                                                                        文档资源                                            iSlide                                                                                            书籍资源                                            Jiumo Search 鸠摩搜索\t\t\t\t\t\tzlibrary\t\t\t\t\t\t熊猫搜书                                    \t\t\t\t                                        教育资源                                            答案圈 - 作业答案网\t\t\t\t\t\t\t\t\t\t\t电子课本                                                                                        Develop                                                                    API文档                                            uTools插件开发文档                        程序员手册大全                        JIRA-7.6.1 - API接口文档                        JIRA-5.1.3 - API接口文档                        Arthas-3.6.7 - 开发文档                        易源接口 - 互联网API入口                        微信开放文档                        Apache ECharts\t\t\t\t\t\t华为GaussDB语法                                                                                            图标                                            图标下载                        阿里巴巴矢量图标库                        Icon Ninja                        Free vector icons                        iconfinder                        Dribbble                        Free Icons                        Free Logo Maker - Namecheap\t\t\t\t\t\temoji表情                                                                                            仓库                                            Git                        JQuery                        Python                        RPM仓库 - Linux软件                        pkgs.org - Linux和Unix软件                        Maven仓库                        Maven仓库 - 阿里云                        Ruby                        Font Awesome - v4                        Font Awesome - v5                        Font Awesome - v6                        Tomcat历史版本\t\t\t\t\t\tGradle历史版本                                                                                            源码                                            站长素材                        懒人之家                                                                                            Git项目                                            mall项目 - 电商系统                        MM-Wiki - 轻量级的企业知识分享与团队协同软件                        GitHub开源的10个优秀后台管理面板                        25个国内顶级技术开发团队Github                                                                                        Tools                                                                    媒体工具                                            XDOC文档预览云服务                        图片剪裁                        Chrome Bookmarks Separator - 虚拟分隔符                        Palettes - 调色板                        Material Palette - 调色板                        Color Hunt - 调色板                        Simone Ferrari - 网页配色方案                        135编辑器 - 微信公众号编辑器\t\t\t\t\t\t在线改图\t\t\t\t\t\t微信Markdown编辑器\t\t\t\t\t\t苹果商店APP图标获取\t\t\t\t\t\t图片文字提取                                                                                            网盘搜索                                            Pan58                                                                                            数据生成工具                                            在线身份证号码生成器                        中国省市区编码对照表2020版                        Cron表达式生成器                        JVM配置工具                        经纬度查询 - 坐标拾取系统                        时间日期间隔计算器                        云际云短信 - 模拟接码                        草料二维码生成器\t\t\t\t\t\t临时邮箱\t\t\t\t\t\tAES加解密\t\t\t\t\t\tCorn表达式生成器\t\t\t\t\t\tSpring Boot banner在线生成工具\t\t\t\t\t\tText to ASCII\t\t\t\t\t\tUUID在线生成                                                                                            格式转换工具                                            时间戳转换工具                        在线代码格式化                        奇客PDF转Word                        PDF to DOC                        在线ico图标转换                        WEBP转JPG                        M4A转MP3                                                                                            开发工具                                            JS Bin                        Spring Initializr                        Sunny-Ngrok内网穿透服务                        微信公众平台                        微信公众平台接口调试工具                        Java命名/p8z                        SVG编辑器                        Hoppscotch - 在线Postman\t\t\t\t\t\tJSON转实体类                                                                                            工具集合                                            脚本之家在线工具                        JSON在线工具                        JSON在线                        PDF24 Tools                        WORTHSEE音频编辑工具箱\t\t\t\t\t\ttoolfk工具箱\t\t\t\t\t\t房贷计算器                                    \t\t\t\t                                        AI工具                                            Kimi                        Metaso - 秘塔搜\t\t\t\t\t\tTinyWow - AI工具\t\t\t\t\t\tAI网页生成工具                                    \t\t\t\t                                        理财工具                                            2024银行存款利率查询                                                                                        Gov                                                                    中国                                            政府 - 中国政府网 - 中央人民政府门户网站                        教育 - NTCE - 中国教育考试网                        继续教育 - 中国电子学会电子信息人才能力提升工程                         继续教育 - 现代专技继续教育网                        继续教育 - 终身教育平台                        税务 - 自然人电子税务局                        社保 - 国家社会保险公共服务平台                        医保 - 国家医保服务平台\t\t\t\t\t\t法律 - 国家法律法规数据库\t\t\t\t\t\t法律 - 国家药品监督管理局数据库\t\t\t\t\t\t教育 - 阳光高考_教育部高校招生阳光工程指定平台                                                                                            北京                                            继续教育 - 北京继续教育                        继续教育 - 北京市职业技能提升行动管理平台                        社保 - 北京市人力资源和社会保障局                        车辆 - 北京市小客车指标调控管理信息系统\t\t\t\t\t\t车辆 - 北京市公安局公安交通管理局                                                                                            河北                                            就业 - 河北人才网                        政府 - 张家口市人民政府\t\t\t\t\t\t政府 - 张家口经济技术开发区管理委员会                        社保 - 张家口人力资源和社会保障局                        医保 - 张家口市医疗保障局                        教育 - 张家口教师招聘考试网                        教育 - 河北省教育考试院                        教育 - 名校网 - 全国各省市学校大全                        教育 - 河北公务员考试网\t\t\t\t\t\t就业 - 人事招考中心                                                                                        My                            滴答清单                QQ邮箱                微信读书\t\t\t\tWPS\t\t\t\tApifox\t\t\t\tAnkiWeb                                                    Work                            EDS                EHR                企业管理平台\t\t\t\t灵犀邮箱                                "
  },
  
  {
    "title": "药典",
    "url": "/posts/yaoxiang/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2022-11-24 13:47:00 +0800",
    





    
    "snippet": "📃 药品清单            名称      批号      药箱      标签                  多维元素片      SC10611130713405      营养药箱      营养药              软铁糖      SC11337108200263      营养药箱      营养药              针叶樱桃维生素C软糖      S...",
    "content": "📃 药品清单            名称      批号      药箱      标签                  多维元素片      SC10611130713405      营养药箱      营养药              软铁糖      SC11337108200263      营养药箱      营养药              针叶樱桃维生素C软糖      SC11337108200263      营养药箱      营养药              小儿至宝丸      国药准字Z11020034      小药箱      中药类  风寒感冒  鼻塞  止咳  化痰  呕吐泄泻  清热              连花清瘟颗粒      国药准字Z20100040      小药箱      中药类  风热感冒  病毒感冒  止咳  鼻塞流涕              欧龙马口服溶液      国药准字ZJ20160013      小药箱      中药类  鼻塞  鼻窦炎              酪酸梭菌活菌散      国药准字S20040088      小药箱      西药类  胃肠道              小儿消积止咳口服液      国药准字Z10970022      小药箱      中药类  风热感冒  清热  消积  止咳  化痰              糠酸莫米松鼻喷雾剂      国药准字H20113481      小药箱      西药类  鼻塞  过敏性鼻炎              鼻渊通窍颗粒      国药准字Z20030071      小药箱      中药类  风寒感冒  鼻塞  头痛              阿奇霉素干混悬剂      国药准字20041122      小药箱      西药类  抗生素  消炎              孟鲁斯特纳颗粒      国药准字J20140167      小药箱      西药类  过敏性鼻炎  哮喘  荨麻疹              清宣止咳颗粒      国药准字Z19990066      小药箱      中药类  风热感冒  鼻塞流涕  止咳              蓝芩口服液      国药准字Z20063795      小药箱      中药类  风热感冒  利咽              感冒清热颗粒      国药准字Z13021863      小药箱      中药类  风寒感冒  鼻流清涕  咳嗽咽干              小儿咽扁颗粒      国药准字Z11020579      小药箱      中药类  风热感冒  清热解毒  利咽              氨溴特罗口服溶液      国药准字H20040317      小药箱      西药类  化痰平喘              小儿肺热咳喘颗粒      国药准字Z20053532      小药箱      中药类  风热感冒  清热解毒  祛痰止咳              羚羊感冒口服液      国药准字Z19991003      小药箱      中药类  风热感冒              头孢克肟干混悬剂      国药准字H20041122      小药箱      西药类  抗生素  消炎              银黄颗粒      国药准字Z51021284      小药箱      中药类  风热感冒  清热  利咽  解毒              开喉剑喷雾剂      国药准字Z20025142      小药箱      中药类  清热解毒  利咽              感冒清热颗粒      国药准字Z11020361      大药箱      中药类  风寒感冒  鼻流清涕  咳嗽咽干              小金胶囊      国药准字Z10970132      大药箱      中药类  散结消肿              红金消结片      国药准字Z20080199      大药箱      中药类  舒肝理气  散结消肿      📌 标签库清热  止咳  化痰  利咽  化痰平喘  鼻流清涕  咳嗽咽干  清热解毒  祛痰止咳  鼻塞  疏风镇惊  鼻塞流涕解毒  抗生素  消炎风热感冒  风寒感冒  病毒感冒营养药  中药类  西药类  消积  胃肠道  呕吐泄泻过敏性鼻炎  鼻窦炎  哮喘  荨麻疹  头痛散结消肿  舒肝理气📦 药箱小药箱开喉剑喷雾剂规格：15ml/瓶品牌：三力 生产厂商：贵州三力制药股份有限公司   生产批号：国药准字Z20025142 中药类  清热解毒  利咽  【成份】八爪金龙、山豆根、蝉蜕、薄荷脑。辅料：苯甲酸钠、枸橼酸、菠萝香精、乙醇、甜菊糖苷、聚山梨酯80。【性状】本品为喷雾剂，内容物为浅棕色至棕色液体；味甜、微苦、微麻，有薄荷的清凉感。【功能主治】中医：清热解毒，消肿止痛。用于急、慢性咽喉炎，扁桃体炎，咽喉肿痛，口腔炎，牙龈肿痛。苗医：旭嘎凯沓痂，泱安挡孟。陡：纳，蒙宁宫，蒙嘎宫昂，江杠房，水嘎果西。      八爪金龙味苦性平，清咽利喉、散瘀消肿，为君药。    山豆根药性苦寒，清热解毒、消肿止痛为臣药。    蝉蜕、薄荷脑清热利咽，为佐使药。  银黄颗粒规格：4g*12袋品牌：俏济堂 生产厂商：四川迪菲特药业有限公司   生产批号：国药准字Z51021284 中药类  风热感冒  清热  利咽  解毒  【成份】金银花提取物，黄芩提取物。辅料为：蔗糖，玉米淀粉。【性状】本品为淡黄色至棕黄色的颗粒；味甜、微苦。【用法用量】开水冲服。一次1~2袋，一日2次。【功能主治】清热疏风，利咽解毒。用于外感风热、肺胃热盛所致的咽干、咽痛、喉核肿大、口渴、发热；急慢性扁桃体炎、急慢性咽炎、上呼吸道感染见上述证候者。【规格】每袋装4克      金银花：性甘、寒；清热解毒，消炎退肿；金银花性寒，故脾胃虚寒及气虚疮疡脓清者不宜服    黄芩：味苦、性平、寒、无毒；主治诸热、黄痘，去水肿、恶疮、火疡等疾病    清热（外感风热、温病发热、肺胃热盛），利咽（咽干、咽痛、喉核肿大、口渴、发热），解毒（热毒血痢，痈肿疔疮、急慢性扁桃体炎、急慢性咽炎、上呼吸道感染）头孢克肟干混悬剂规格：50mg*6包品牌：立健克 生产厂商：深圳立健药业有限公司   生产批号：国药准字H20041122 抗生素  消炎  西药类  【成份】本品主要成份是头孢克肟【性状】本品为颗粒状粉末；气芳香，味甜。【适应症】对链球菌属（肠球菌除外）、肺炎球菌、淋球菌、卡他布兰汉球菌、大肠杆菌、克雷伯杆菌属、沙雷菌属、变形杆菌属、流感杆菌中头孢克肟敏感菌引起的以下感染有效。（详见说明书）【用法用量】服用时加水20ml冲服。成人及体重30公斤以上儿童：口服，每次50~100mg，每日二次；儿童：口服，用量按成人减半，或按每公斤1.5-3.0mg计算给药量，每日二次。或遵医嘱。（详见说明书） 【禁忌】对本品或其他头孢类抗生素过敏者。【注意事项】为防止耐药菌株的出现，在使用本品前原则上应确认敏感性，将剂量控制在控制疾病所需最小剂量。  抗生素类药物，易产生耐药性。羚羊感冒口服液规格：10ml*6支品牌：同仁堂/乐家老铺 生产厂商：南京同仁堂药业有限责任公司   生产批号：国药准字Z19991003 风热感冒  中药类  【成份】羚羊角、牛蒡子、金银花、荆芥、淡竹叶、桔梗、淡豆豉、连翘、薄荷脑、甘草。辅料为蔗糖、山梨酸钾。【性状】本品为棕红色液体；味微苦、辛、微甜。 【功能主治】清热解表。用于流行性感冒，伤风咳嗽，头晕发热，咽喉肿痛。【规格】每支装10毫升【用法用量】口服。每次10毫升（1支），一日3次。请摇匀服用。【包装】玻璃管制口服液体瓶包装，10毫升×10支/盒。      羚羊角：头晕、肝火、清除热毒、镇静、抗惊厥    牛蒡子：味辛、苦，性寒，归肺、胃经。疏风散热（感冒、咳嗽、咽喉肿痛等症状，尤其适用于风热感冒初期）。解毒利咽。滑肠通便（改善便秘情况，尤其是在热毒引发的病症伴有便秘时）。    荆芥：味辛（意味着它具有辛辣的味道，能够促进气血的运行）、性微温（表示其性质温和带热，有助于驱散体内的寒邪）、归肺、肝经（指它主要影响人体的肺和肝系统）。解表散风（治疗外感风寒或风热引起的症状，如感冒、发热、头痛等）。与金银花、连翘配伍用于治疗风热感冒，与防风配伍用于治疗风热感冒。    淡竹叶：味甘、性寒。清热除烦（清除体内因热邪导致的心火过盛，适用于治疗热病引起的心烦、口渴等症状）。淡竹叶具有一定的抗病原微生物作用。    桔梗：味苦辛、性微温或平，归肺经，有时也归胃经。开宣肺气，舒缓胸闷，促进痰液的排出，适用于咳嗽痰多的情况。对于咽喉疼痛、声音嘶哑以及肺部脓痰、肺痈等病症，桔梗有较好的治疗效果。有助于行气和消除体内结块。可以与其他中药如荆芥、紫菀、陈皮、桑叶、菊花、杏仁、浙贝母、黄芩、枇杷叶等配伍使用，以增强治疗效果，针对不同类型的咳嗽和呼吸系统疾病。    淡豆豉：解表，宣发郁热。    连翘：性微寒，味苦，归心、肺、小肠经。具有清热解毒、消肿散结、利尿等功效，主要用于治疗温热病发热、疮痈肿毒、丹毒、瘰疬痰核、热淋涩痛等症状。    薄荷脑：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    甘草：清热解毒、祛痰止咳。常与其他药物如桂枝、党参、黄芩、白术等配伍使用，以增强疗效或调和药性。  小儿肺热咳喘颗粒规格：3g*8袋品牌：葵花 生产厂商：黑龙江葵花药业股份有限公司   生产批号：国药准字Z20053532 中药类  风热感冒  清热解毒  祛痰止咳  【功能主治】清热解毒，宣肺止咳，化痰平喘。用于感冒，支气管炎属痰热壅肺证者。【成分】麻黄、苦杏仁、生石膏、甘草、金花、连翘、知母、黄芩、板篮根、麦冬、鱼腥草。辅料为蔗糖、糊精。【用法用量】开水冲服年龄                 用量               次数三周岁以下      一次3克        一日3次三周岁以上      一次3克        一日4次七周岁以上      一次6克        一日3次      麻黄：味辛、性温，归肺、膀胱经。麻解表发汗，宣肺平喘，利水消肿。用于风寒感冒，哮喘，水肿。用量2-10克。慎用于高血压、失眠。    苦杏仁：归肺、大肠经，其性味苦、微温，具有小毒。止咳平喘，润肠通便。    生石膏：性甘、辛、大寒。归肺、胃经。与麻黄、杏仁配伍，用于肺热喘咳。    甘草：清热解毒、祛痰止咳。常与其他药物如桂枝、党参、黄芩、白术等配伍使用，以增强疗效或调和药性。    金花：即金银花，性甘、寒；清热解毒，消炎退肿；金银花性寒，故脾胃虚寒及气虚疮疡脓清者不宜服。    连翘：性微寒，味苦，归心、肺、小肠经。具有清热解毒、消肿散结、利尿等功效，主要用于治疗温热病发热、疮痈肿毒、丹毒、瘰疬痰核、热淋涩痛等症状。    知母：味苦、微甘，性寒，归肺、胃、肾经。清热泻火，滋阴润燥。    黄芩：味苦、性平、寒、无毒；主治诸热、黄痘，去水肿、恶疮、火疡等疾病。    板篮根：味苦，性寒，归心、肝、胃经。清热解毒，凉血利咽。用于温病发热，咽痛。    麦冬：养阴，润肺，清心，益胃。    鱼腥草：清热解毒，利尿通淋。用于肺热咳嗽，尿路感染。  氨溴特罗口服溶液规格：120ml/瓶品牌：易坦静 生产厂商：北京韩美药品有限公司   生产批号：国药准字H20040317 西药类  化痰平喘  【适应症】用于治疗急、慢性呼吸道疾病（如急、慢性支气管炎、支气管哮喘、肺气肿等）引起的咳嗽、痰液粘稠、排痰困难、 喘息等。【禁忌】肥厚型心肌病患者：对本品过敏者禁用。【注意事项】运动员慎用。甲状腺机能亢进症、高血压、心脏疾病、糖尿病、重度肾功能不全患者慎用。其他详见说明书。      盐酸氨溴索：一种黏液溶解剂，能够降低呼吸道分泌物的粘稠度，促进痰液的排出，从而改善呼吸道状况，帮助患者更容易地呼吸。    盐酸克仑特罗：一种选择性的β2肾上腺素受体激动剂，它能够扩张支气管，减少呼吸道阻力，缓解哮喘和其他呼吸系统疾病引起的呼吸困难症状。  小儿咽扁颗粒规格：8g*10袋品牌：同仁堂生产厂商：北京同仁堂 生产批号：国药准字Z11020579 中药类  风热感冒  清热解毒  利咽  【成份】金银花、射干、金果榄、桔梗、玄参、麦冬、人工牛黄、冰片。辅料为蔗糖、糊精。【功能主治】清热利咽，解毒止痛。用于小儿肺卫热盛所致的喉痹、乳蛾，症见咽喉肿痛、咳嗽痰盛、口舌糜烂；急性咽炎、急性扁桃腺炎见上述证候者。【用法用量】开水冲服。一岁至二岁一次半袋（4克），一日2次：三岁至五岁一次半袋（4克），一日3次；六岁至十四岁一次1袋（8克），一日2~3次。【包装】复合膜袋装，每袋装8克，每盒装10袋。      金银花：性甘、寒；清热解毒，消炎退肿；金银花性寒，故脾胃虚寒及气虚疮疡脓清者不宜服。    射干：味苦，性寒，归肺经。清热解毒，利咽消痰。    金果榄：味苦，性寒，归肺、胃经。清热解毒，利咽止痛。    桔梗：味苦辛、性微温或平，归肺经，有时也归胃经。开宣肺气，舒缓胸闷，促进痰液的排出，适用于咳嗽痰多的情况。对于咽喉疼痛、声音嘶哑以及肺部脓痰、肺痈等病症，桔梗有较好的治疗效果。有助于行气和消除体内结块。可以与其他中药如荆芥、紫菀、陈皮、桑叶、菊花、杏仁、浙贝母、黄芩、枇杷叶等配伍使用，以增强治疗效果，针对不同类型的咳嗽和呼吸系统疾病。    玄参：味甘、苦、咸，性微寒。归肺、胃、肾经。清热凉血，滋阴降火，解毒散结。    麦冬：养阴，润肺，清心，益胃。    人工牛黄：味甘，性凉。归心、肝经。清热解毒，化痰定惊。    冰片：开窍醒神，清热止痛。  感冒清热颗粒规格：12g*6袋品牌：乖宝宝生产厂商：葵花药业集团有限公司 生产批号：国药准字Z13021863 中药类  风寒感冒  鼻流清涕  咳嗽咽干  【成份】荆芥穗、薄荷、防风、柴胡、紫苏叶、葛根、桔梗、苦杏仁、白芷、苦地丁、芦根。辅料为蔗糖、糊精。【性状】本品为棕黄色的颗粒，味甜、微苦。【功能主治】疏风散寒，解表清热。用于风寒感冒，头痛发热，恶寒身痛，鼻流清涕，咳嗽咽干。【规格】每袋装12克 【用法用量】开水冲服。一次1袋，一日2次。      荆芥穗：解表散风、透疹消疮。与防风、羌活配伍治疗风寒表证。与银花、连翘、薄荷配伍治疗风热表证。与牛蒡子、桔梗、生甘草配伍治疗咽喉肿痛。    薄荷：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    防风：祛风解表、胜湿止痛。    柴胡：解表散热、疏肝解郁。    紫苏叶：性温辛散，入肺经。能够疏解表寒，适用于治疗风寒感冒引起的症状，如恶寒、发热、头痛、鼻塞等，常与苦杏仁、桔梗等药物配伍。    葛根：甘、辛，凉。主要用途包括解肌退热、透疹、生津止渴、升阳止泻、通经活络、解酒毒等。    桔梗：味苦辛、性微温或平，归肺经，有时也归胃经。开宣肺气，舒缓胸闷，促进痰液的排出，适用于咳嗽痰多的情况。对于咽喉疼痛、声音嘶哑以及肺部脓痰、肺痈等病症，桔梗有较好的治疗效果。有助于行气和消除体内结块。可以与其他中药如荆芥、紫菀、陈皮、桑叶、菊花、杏仁、浙贝母、黄芩、枇杷叶等配伍使用，以增强治疗效果，针对不同类型的咳嗽和呼吸系统疾病。    苦杏仁：归肺、大肠经，其性味苦、微温，具有小毒。止咳平喘，润肠通便。    白芷：祛风解表。    苦地丁：清热解毒，凉血消肿。    芦根：清热生津，止呕，利尿。  蓝芩口服液规格：10毫升/支*7支/盒品牌：扬子江生产厂商：扬子江药业集团有限公司 生产批号：国药准字Z20063795 中药类  风热感冒  利咽  【成份】板蓝根，黄芩、栀子、黄柏、胖大海，辅料为蔗糖、苯甲酸钠、聚山梨酯80。【性状】本品为棕红色液体：味甜、微苦。【功能主治】清热解毒，利咽消肿，用于急性咽炎、肺胃实热证所致的咽痛、咽干、咽部灼热。【规格】每1毫升相当于饮片2.12克【用法用量】口服，一次10毫升，一日3次【不良反应】个别患者服药后出现轻度腹泻，一般可自行缓解。      板蓝根：清热解毒，预防感冒，抗病毒。    黄芩：味苦、性平、寒、无毒；主治诸热、黄痘，去水肿、恶疮、火疡等疾病。    栀子：味苦，性寒，归心、肺、三焦经。它具有清热泻火、凉血解毒、利湿退黄等功效。在临床中常与其他药材配伍使用，如与黄芩、连翘等药物合用，可以增强清热解毒的功效；与茵陈蒿、赤茯苓等药材配伍，则可加强利湿退黄的作用。    黄柏：味苦，性寒，归肾、膀胱经。它具有较强的清热燥湿、泻火解毒的功效。在临床上常与其他药材配伍使用，如与黄连、黄芩等一起使用，可以增强清热燥湿的效果；与茵陈蒿、车前子等药物配伍，可用于治疗湿热黄疸。    胖大海：味甘，性寒，归肺、大肠经。其主要功效在于清热润肺、利咽开音、润肠通便。与其他药材如菊花、金银花等配合使用，增强清热解毒的效果。  清宣止咳颗粒规格：10g*9袋品牌：苏中药业生产厂商：苏中药业集团股份有限公司 生产批号：国药准字Z19990066中药类  风热感冒  鼻塞流涕  止咳  【成份】桑叶、薄荷、苦杏仁（炒）、桔梗、白芍、枳壳、陈皮、紫菀、甘草，辅料为蔗糖、糊精。【性状】本品为浅褐色或棕褐色的颗粒；气芳香，味甜、微苦。【功能主治】疏风清热，宣肺止咳。用于小儿外感风热咳嗽，证见：咳嗽，咯痰，发热或鼻塞，流涕，微恶风寒，咽红或痛。【用法用量】开水冲服，1~3岁：每次1/2包；4~6岁：每次3/4包；7~14岁：每次1包；一日3次。【禁忌】糖尿病患儿禁服。      桑叶：性味甘、苦，凉，归肺、肝经，疏散风热、润肺止咳。    薄荷：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    苦杏仁（炒）：归肺、大肠经，其性味苦、微温，具有小毒。止咳平喘，润肠通便。    桔梗：味苦辛、性微温或平，归肺经，有时也归胃经。开宣肺气，舒缓胸闷，促进痰液的排出，适用于咳嗽痰多的情况。对于咽喉疼痛、声音嘶哑以及肺部脓痰、肺痈等病症，桔梗有较好的治疗效果。有助于行气和消除体内结块。可以与其他中药如荆芥、紫菀、陈皮、桑叶、菊花、杏仁、浙贝母、黄芩、枇杷叶等配伍使用，以增强治疗效果，针对不同类型的咳嗽和呼吸系统疾病。    白芍：味苦、酸，性微寒，归肝、脾经。与柴胡合用，可以疏肝解郁，治疗肝气郁结；与黄芩、黄连等药同用，则能增强清热止痢的作用。    枳壳：味苦、辛，性温，归脾、胃经。枳壳常与其他药材配伍使用，如与陈皮、厚朴等药材一起使用，可加强行气消胀的效果；与麦芽、山楂等搭配，则有助于消化积滞的食物。    陈皮：味辛、苦，性温，归肺、脾经。能行气化湿，健脾开胃。    紫菀：味苦、辛，性温，归肺经。它的主要功效是润肺下气、止咳化痰。常与其他药材配伍使用，例如与款冬花、百部等共同使用，可以增强润肺止咳的效果；与桔梗、贝母等搭配，有助于化痰止咳。    甘草：清热解毒、祛痰止咳。常与其他药物如桂枝、党参、黄芩、白术等配伍使用，以增强疗效或调和药性。  孟鲁斯特纳颗粒规格：10袋品牌：辛泰生产厂商：江苏正大丰海制药有限公司 生产批号：国药准字J20140167西药类  过敏性鼻炎  哮喘  荨麻疹  【适应症】本品适用于1岁以上儿童哮喘的预防和长期治疗，包括预防白天和夜间的哮喘症状，治疗对阿司匹林敏感的哮喘患者以及预防运动诱发的支气管收缩。本品适用于减轻过敏性鼻炎引起的症状（2岁至5岁儿童的季节性过敏性鼻炎和常年性过敏性鼻炎）。  孟鲁司特钠的长期使用对儿童和成人的健康影响主要体现在其对哮喘和过敏性鼻炎的有效预防和治疗上，但同时也存在一定的安全性问题，特别是与神经精神系统的不良反应相关的问题。因此，在使用孟鲁司特钠时，医生和患者需要权衡其利弊，谨慎选择是否长期使用。阿奇霉素干混悬剂规格：0.1g*6袋品牌：希舒美生产厂商：辉瑞制药有限公司 生产批号：国药准字20041122小药箱 | 西药类  抗生素  消炎  【性状】本品为颗粒或粉末；气芳香，味甜【适应症】该药品可用于治疗敏感细菌所引起的感染：1.支气管炎、肺炎等下呼吸道感染；皮肤和软组织感染；中耳炎；鼻窦炎、咽炎、扁桃体炎等上呼吸道感染。2.男女性传播疾病中由沙眼衣原体所致的单纯性生殖器感染。3.阿奇霉素亦可用于由非多重耐药淋球菌所致的单纯性生殖器感染及由杜克嗜血杆菌引起的软下疳。 【用法用量】将本品倒入杯中，加入适量凉开水，溶解摇匀后口服，在饭前1小时或饭后2小时服用。 成人用量： 1.沙眼衣原体或敏感淋病奈瑟菌所致性传播疾病，仅需单次口服本品1.0g。 2.对其他感染的治疗：第1日，0.5g顿服，第2～5日，一日0.25g顿服；或一日0.5g顿服，连服3日。   小儿用量： 1.治疗中耳炎、肺炎，第1日，按体重10mg/kg顿服（一日最大量不超过0.5g），第2～5日，每日按体重5mg/kg顿服（一日最大量不超过0.25g）。【不良反应】本品一般耐受性良好，不良反应发生率低，多为轻到中度可逆性反应。   1.常见不良反应有：⑴胃肠道反应：腹泻、腹痛、稀便、呕吐等；⑵皮肤反应：皮疹、瘙痒等；⑶其他反应：如厌食、阴道炎、头晕或呼吸困难等；   2.临床中还观察到下列＜1%的不良反应：⑴消化系统：消化不良、胃肠胀气、粘膜炎、口腔念珠菌病、胃炎等；⑵神经系统：头痛、嗜睡等；⑶过敏反应：支气管痉挛等；⑷其他反应：未觉异常等。   3.上市后口服制剂还观察到以下不良反应，其与本品相关性尚不清楚。⑴过敏反应：关节痛、血管神经性水肿、荨麻疹、光过敏；⑵心血管系统。【禁忌】对阿奇霉素、红霉素或其他任何一种大环内酯类药物过敏者禁用。【注意事项】1.进食可影响阿奇霉素的吸收，故需在饭前1小时或饭后2小时口服。    2.轻度肾功能不全患者（肌酐清除率＞40ml/分钟）不需作剂量调整，但阿奇霉素对较严重肾功能不全患者中的使用尚无资料，给这些患者使用阿奇霉素时应慎重。    3.由于肝胆系统是阿奇霉素排泄的主要途径，肝功能不全者慎用，严重肝病患者不应使用。用药期间定期随访肝功能。     4.用药期间如果发生过敏反应（如血管神经性水肿、皮肤反应、Stevens-Johnson综合征及毒性表皮坏死等），应立即停药，并采取适当措施。【儿童注意事项】治疗小于6个月小儿中耳炎、社区获得性肺炎及小于2岁小儿咽炎或扁桃体炎的疗效【妊娠与哺乳期注意事项】动物实验显示本品对胎儿无影响，但在人类孕妇中应用尚缺乏经验，故在孕妇中应用须充分权衡利弊。尚无资料显示本品是否可分泌至母乳中，故哺乳期妇女应用须谨慎考虑。【老人注意事项】给药方法及剂量同成人。  阿奇霉素干混悬剂为临床常用的抗生素：      阿奇霉素干混悬剂属于大环内酯类抗生素。    可用于治疗多种对阿奇霉素敏感的细菌感染。    主要通过抑制细菌蛋白质合成达到抗菌效果。  鼻渊通窍颗粒规格：6g*10袋品牌：诺斯通生产厂商：山东新时代药业有限公司 生产批号：国药准字Z20030071中药类  风寒感冒  鼻塞  头痛  【成份】辛夷、炒苍耳子、麻黄、白芷、薄荷、藁本、黄芩、连翘、野菊花、天花粉、地黄、丹参、茯苓、甘草【性状】本品为棕色至棕褐色的颗粒；气微香，味甜、微苦【功能主治】疏风清热，宣肺通窍。用于急鼻渊（急性鼻窦炎）属外邪犯肺证，症见前额或颧骨部压痛，鼻塞时作，流涕黏白或黏黄，或头痛，或发热，苔薄黄或白，脉浮【用法用量】开水冲服。一次1袋，一日3次【不良反应】偶见腹泻      辛夷：性温味辛，归肺、胃经，散风寒，通鼻窍。    炒苍耳子：外感风寒、鼻渊、头痛。    麻黄：味辛、性温，归肺、膀胱经。麻解表发汗，宣肺平喘，利水消肿。用于风寒感冒，哮喘，水肿。用量2-10克。慎用于高血压、失眠。    白芷：祛风解表。    薄荷：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    藁本：外感风寒、鼻渊、头痛。    黄芩：味苦、性平、寒、无毒；主治诸热、黄痘，去水肿、恶疮、火疡等疾病。    连翘：性微寒，味苦，归心、肺、小肠经。具有清热解毒、消肿散结、利尿等功效，主要用于治疗温热病发热、疮痈肿毒、丹毒、瘰疬痰核、热淋涩痛等症状。    野菊花：清热解毒，治疔疮痈肿、目赤咽痛。    天花粉：清热生津，解毒消肿。    地黄：滋阴补肾，清热凉血。    丹参：活血化瘀，清心除烦。    茯苓：利水、健脾、安神。    甘草：清热解毒、祛痰止咳。常与其他药物如桂枝、党参、黄芩、白术等配伍使用，以增强疗效或调和药性。  糠酸莫米松鼻喷雾剂规格：60揿/瓶品牌：逸青生产厂商：浙江线琚制药股份有限公司 生产批号：国药准字H20113481西药类  鼻塞  过敏性鼻炎  【适应症】本品适用于治疗成人、青少年和3至11岁儿童季节性或常年性鼻炎，对于曾有中至重度季节性过敏性鼻炎症状的12岁以上的患者，主张在花粉季节开始前2~4周用本品作预防性治疗【规格】每瓶60揿，每揿含糠酸莫米松50μg，药液浓度为0.05％（g/g）【用法用量】季节过敏性或常年性鼻炎：通常先手揿喷雾器6~7次作为启动，直至看到均匀的喷雾，然后鼻腔给药，每揿喷出糠酸莫米松混悬液约100mg，内含糠酸莫米松50μg，如果喷雾器停用14日或14日以上，则在下一次应用时应重新启动。在每次用药前充分振摇容器。成人（包括老年患者）和青年：用于预防和治疗的常用推荐量为每侧鼻孔2揿（每揿为50μg），一日1次（总量为200μg），一旦症状被控制后，剂量可减至每侧鼻孔1揿（总量100μg），即能维持疗效。如果症状未被有效控制，可增加剂量至每侧鼻孔4揿的最大每日剂量，一日1次（总量400g），在症状控制后减小剂量。在首次给药后12小时即能产生明显的临床效果  3至11岁儿童：常用推荐量为每侧鼻孔1揿（每揿为50μg），一日1次（总量为100μg）  主要有效成分为糠酸莫米松，辅料包括山梨醇、甘油、聚山梨酯80等。该药物是一种糖皮质激素类药物，通过调节免疫反应和抑制细胞因子的产生来减轻炎症，适用于过敏性鼻炎的治疗。糠酸莫米松鼻喷雾剂在医生的指导下一般最多可以用3个月。小儿消积止咳口服液规格：10ml*10袋品牌：宁宝 生产厂商：鲁南厚普制药有限公司 生产批号：国药准字Z10970022中药类  风热感冒  清热  消积  止咳  化痰  【成份】炒山楂、槟榔、枳实、蜜枇杷叶、瓜蒌、炒菜菔子、炒葶苈子、桔梗、连翘、蝉蜕【功能主治】清热肃肺，消积止咳。用于小儿饮食积滞、痰热蕴肺所致的咳嗽、夜间加重、喉间痰鸣、腹胀、口臭【用法用量】一周岁以内一次5ml，一至二岁一次10ml，三至四岁一次15ml，五岁以上一次20ml，一日3次；5天为一疗程【不良反应】监测数据显示，本品可见以下不良反应：恶心、呕吐、腹泻、腹痛、腹部不适等胃肠系统表现；皮疹、瘙痒、呼吸困难等过敏反应表现；头晕、头痛等神经系统表现等。本品有用药后出现肝酶升高的个例病案报告【注意事项】1.本品具有清热导滞的功效，服用后可能出现排便频次增加或腹泻，如症状严重应停药并及时就诊2.如出现严重不良反应，应立即就医3.本品处方中含“瓜蒌”，不宜与含有乌头（包括川乌、草乌、附子）的中药方剂或成药同时服用4.如正在使用其他药品，使用本品前请咨询医师      炒山楂：助消化、行气散瘀。    槟榔：消积食、行气。    枳实：消积、行气。    蜜枇杷叶：清肺热、止咳。    瓜蒌：清热化痰。    炒菜菔子：消积、化痰、行气。    炒葶苈子：利水消肿、宣肺平喘。    桔梗：味苦辛、性微温或平，归肺经，有时也归胃经。开宣肺气，舒缓胸闷，促进痰液的排出，适用于咳嗽痰多的情况。对于咽喉疼痛、声音嘶哑以及肺部脓痰、肺痈等病症，桔梗有较好的治疗效果。有助于行气和消除体内结块。可以与其他中药如荆芥、紫菀、陈皮、桑叶、菊花、杏仁、浙贝母、黄芩、枇杷叶等配伍使用，以增强治疗效果，针对不同类型的咳嗽和呼吸系统疾病。    连翘：性微寒，味苦，归心、肺、小肠经。具有清热解毒、消肿散结、利尿等功效，主要用于治疗温热病发热、疮痈肿毒、丹毒、瘰疬痰核、热淋涩痛等症状。    蝉蜕：疏散风热、利咽。  欧龙马口服溶液规格：50ml/瓶品牌：仙璐贝生产厂商：北奥罗历加欧洲股份有限公司 生产批号：国药准字ZJ20160013中药类  鼻塞  鼻窦炎  【成份】欧龙胆、报春花、酸模、洋接骨木、马鞭草、辅料乙醇的含量为19％【性状】本品为黄色至棕黄色的澄明液体气芬香、味微苦【适应症】分泌物化解药，用于急性鼻窦炎（含慢性鼻窦炎急性发作）【用法用量】口服，一日3次第1~5天：一次约6.2ml（100滴）第6~10天:一次约3.1ml（50滴）  一种分泌物化解药，可促进鼻腔内一些分泌物的化解。清热解毒、稀释痰液、促进痰液排出      欧龙胆：欧龙胆通常用来刺激消化系统的功能，因为它能够促进胃液分泌，增加食欲，并帮助消化。此外，它也被认为具有抗炎、抗菌、利胆以及轻度的解热作用。    报春花：清热解毒、利尿消肿。常用于治疗感冒发热、咽喉肿痛、咳嗽、黄疸、水肿等症状。    酸模：性寒、味酸，归肝、脾经。主要用于清热解毒、利尿通淋、凉血止血。    洋接骨木：缓解喉咙痛、咳嗽和其他呼吸道症状。    马鞭草：性寒、味苦，归肺、胆、膀胱经。具有清热燥湿、泻火解毒、止血安胎等多种功效。  小儿至宝丸规格：1.5g*10颗品牌：同仁堂生产厂商：北京同仁堂股份有限公司同仁堂制药厂 生产批号：国药准字Z11020034中药类  风寒感冒  鼻塞  止咳  化痰  呕吐泄泻  清热  疏风镇惊  【成份】紫苏叶、广藿香、薄荷、羌活、陈皮、白附子(制)、胆南星、芥子(炒)、川贝母、槟榔、山楂(炒)、茯苓、六神曲(炒)、麦芽(炒)、琥珀、冰片、天麻、钩藤、僵蚕(炒)、蝉蜕、全蝎、人工牛黄、雄黄、滑石、朱砂  【性状】本品为橙黄色至棕黄色的大蜜丸：气微香，味微苦，有辛凉感【功能主治】疏风镇惊，化痰导滞。用于小儿风寒感冒，停食停乳，发热鼻塞，咳嗽痰多，呕吐泄泻【规格】每丸重1.5g【用法用量】口服。一次1丸，一日2~3次【不良反应】尚不明确      紫苏叶：性温辛散，入肺经。能够疏解表寒，适用于治疗风寒感冒引起的症状，如恶寒、发热、头痛、鼻塞等，常与苦杏仁、桔梗等药物配伍。    广藿香：化湿、止呕、解暑。    薄荷：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    羌活：解表散寒、祛风除湿、止痛。    陈皮：理气健脾。    白附子(制)：化痰、祛风。    胆南星：清热化痰、息风定惊。    芥子(炒)：化痰、利气。    川贝母：润肺止咳。    槟榔：消积食、行气。    山楂(炒)：助消化、行气散瘀。    茯苓：利水、健脾、安神。    六神曲(炒)：助消化、调理脾胃。    麦芽(炒)：助消化。    琥珀：安神、利尿。    冰片：开窍醒神，清热止痛。    天麻：祛风、抗惊厥。    钩藤：抗惊厥。    僵蚕(炒)：散风清热、化痰止痉、治疗风热感冒引起的头痛、咳嗽、咽喉肿痛等症状。    蝉蜕：疏散风热、利咽。    全蝎：性平，味辛、微寒，归肝经，主要用于急慢惊风、抽搐痉挛、中风口歪、破伤风等症状。    人工牛黄：味甘，性凉。归心、肝经。清热解毒，化痰定惊。    雄黄：解毒。    滑石：清热利湿、解暑止渴、收涩止泻。    朱砂：镇静安神、清心解毒、明目消炎。  连花清瘟颗粒规格：6g*10袋品牌：连花生产厂商：北京以岭药业有限公司生产批号：国药准字Z20100040 中药类  病毒感冒  风热感冒  咳嗽  流涕  【功能主治】清瘟解毒，宣肺泄热。用于治疗流行性感冒属热毒袭肺证，症见发热，恶寒，肌肉酸痛，鼻塞流涕，咳嗽，头痛，咽干咽痛，舌偏红，苔黄或黄腻。在新型冠状病毒肺炎的常规治疗中，可用于轻型、普通型引起的发热、咳嗽、乏力。【成份】连翘、金银花、炙麻黄、炒苦杏仁、石膏、板蓝根、綿马贯众、鱼腥草、广藏香、大黄、红景天、薄荷脚、甘草【规 格】每袋装6g【用法用量】口服。一次1袋，一日3次。新型冠状病毒肺炎轻型、普通型疗程7-10天      连翘：性微寒，味苦，归心、肺、小肠经。具有清热解毒、消肿散结、利尿等功效，主要用于治疗温热病发热、疮痈肿毒、丹毒、瘰疬痰核、热淋涩痛等症状。    金银花：性甘、寒；清热解毒，消炎退肿；金银花性寒，故脾胃虚寒及气虚疮疡脓清者不宜服。- 射干：味苦，性寒，归肺经。清热解毒，利咽消痰。    炙麻黄：发汗解表、宣肺平喘。    炒苦杏仁：归肺、大肠经，其性味苦、微温，具有小毒。止咳平喘，润肠通便。    石膏：性甘、辛、大寒。归肺、胃经。与麻黄、杏仁配伍，用于肺热喘咳。    板蓝根：清热解毒，预防感冒，抗病毒。    绵马贯众：清热解毒，驱虫。    鱼腥草：清热解毒，利尿通淋。用于肺热咳嗽，尿路感染。    广藿香：化湿和胃，解暑发表。    大黄：泻热通便，活血祛瘀。    红景天：益气活血，抗疲劳，增强免疫力。    薄荷脑：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    甘草：清热解毒、祛痰止咳。常与其他药物如桂枝、党参、黄芩、白术等配伍使用，以增强疗效或调和药性。  酪酸梭菌活菌散规格：500mg*15袋品牌：宝乐安生产厂商：青岛东海药业有限公司生产批号：国药准字S20040088 西药类  胃肠道  【适应症】因肠道菌群紊乱引起的各种消化道症状及相关的急、慢性腹泻和消化不良等。 【用法用量】口服、儿童，一次1袋，一天2-3次，用温开水冲服。急性腹泻，疗程3-7天；慢性腹泻，疗程14~21天。  酪酸梭菌能够在肠道环境中生长，并产生酪酸（丁酸）作为其代谢产物之一。酪酸梭菌在维持肠道健康、抑制病原体生长以及改善营养吸收方面被认为具有一定的益处。营养药箱多维元素片规格：90g/瓶品牌：首儿生产厂商：北京首儿康恩益科技有限公司 生产批号：SC10611130713405营养药  【配料表】全脂乳粉、甜橙粉（甜橙、麦芽糊精）、葡萄糖、麦芽糊精、维生素C（L-抗坏血酸钠）、焦磷酸铁、烟酸（烟酰胺）、氧化锌、醋酸维生素A（醋酸视黄酯）、维生素D3（胆钙化醇）、维生素B1（盐酸硫胺素）、维生素B2（核黄素）、维生素B6（盐酸吡哆醇）【食用方法】直接咀嚼服用。无咀嚼能力的婴幼儿，可以将本品碾碎后加入辅食中食用【食用量】每日2片【适宜人群】6-60月龄儿童【注意事项】本品添加多种微量营养素，与其他同类产品同时食用时应注意用量；本品不能代替母乳及婴幼儿辅助食品软铁糖规格：120g(3g*40)/瓶品牌：首儿生产厂商：北京首儿康恩益科技有限公司 生产批号：SC11337108200263营养药  【配料表】麦芽糖醇液、麦芽糖醇、水、果胶、乙二胺四乙酸铁钠、柠檬酸、柠檬酸钠、金桔浓缩液、紫胡萝卜浓缩汁、复配被膜剂（辛，癸酸甘油酯、巴西棕榈蜡）【推荐食用方法及食用量】直接嚼食，每天1-3粒【温馨提示】食用时应充分咀嚼勿一口吞食儿童需在成人监督下食用，无咀嚼能力的儿童不宜食用。软糖受温度影响，出现粘连、变形属正常现象，不影响食用，长时间放置可能出现轻微返砂，属于正常现象；本品添加果蔬汁，若出现轻微脱色，属正常现象，请放心食用。针叶樱桃维生素C软糖规格：120g(3g*40)/瓶品牌：首儿生产厂商：北京首儿康恩益科技有限公司 生产批号：SC11337108200263营养药  【配料表】麦芽糖醇液、麦芽糖醇、水、针叶樱桃粉（针叶樱桃粉、麦芽糊精）、果胶、柠檬酸、柠檬酸钠、紫胡萝卜浓缩汁、葡萄浓缩液、复配被膜剂（辛，癸酸甘油酯、巴西棕榈蜡）【推荐食用方法及食用量】直接嚼食，每天2-4粒【温馨提示】食用时应充分咀嚼，勿一口吞食，儿童需在成人监督下食用，无咀嚼能力的儿童不宜食用。软糖受温度影响，出现粘连、变形属正常现象，不影响食用，长时间放置可能出现轻微返砂，属于正常现象；本品添加果蔬汁，若出现轻微脱色，属正常现象，请放心食用。大药箱感冒清热颗粒规格：12g*12袋品牌：同仁堂生产厂商：北京同仁堂科技发展股份有限公司制药厂 生产批号：国药准字Z11020361中药类  风寒感冒  鼻流清涕  咳嗽咽干  【成份】荆芥穗、薄荷、防风、柴胡、紫苏叶、葛根、桔梗，苦杏仁、白芷、苦地丁、芦根。辅料为蔗糖、糊精。【性状】本品为棕黄色的颗粒：味甜、微苦。【功能主治】疏风散寒，解表清热。用于风寒感冒，头痛发热，恶寒身痛，鼻流清涕，咳嗽咽干。【规格】每袋装12克【用法用量】开水冲服。一次1袋，一日2次。      荆芥穗：解表散风、透疹消疮。与防风、羌活配伍治疗风寒表证。与银花、连翘、薄荷配伍治疗风热表证。与牛蒡子、桔梗、生甘草配伍治疗咽喉肿痛。    薄荷：主要用于治疗风热感冒、头痛、目赤、咽喉肿痛、皮肤瘙痒等症状。    防风：祛风解表、胜湿止痛。    柴胡：解表散热、疏肝解郁。    紫苏叶：性温辛散，入肺经。能够疏解表寒，适用于治疗风寒感冒引起的症状，如恶寒、发热、头痛、鼻塞等，常与苦杏仁、桔梗等药物配伍。    葛根：甘、辛，凉。主要用途包括解肌退热、透疹、生津止渴、升阳止泻、通经活络、解酒毒等。    桔梗：味苦辛、性微温或平，归肺经，有时也归胃经。开宣肺气，舒缓胸闷，促进痰液的排出，适用于咳嗽痰多的情况。对于咽喉疼痛、声音嘶哑以及肺部脓痰、肺痈等病症，桔梗有较好的治疗效果。有助于行气和消除体内结块。可以与其他中药如荆芥、紫菀、陈皮、桑叶、菊花、杏仁、浙贝母、黄芩、枇杷叶等配伍使用，以增强治疗效果，针对不同类型的咳嗽和呼吸系统疾病。    苦杏仁：归肺、大肠经，其性味苦、微温，具有小毒。止咳平喘，润肠通便。    白芷：祛风解表。    苦地丁：清热解毒，凉血消肿。    芦根：清热生津，止呕，利尿。  小金胶囊规格：12粒*2板/盒品牌：健民集团生产厂商：健民药业集团股份有限公司 生产批号：国药准字Z10970132中药类  散结消肿  【成份】人工麝香、木鳖子（去壳去油）、制草乌、枫香脂、乳香（制）、当归（酒炒）、没药（制）、五灵脂（醋炒）、地龙、香墨。【性状】本品为胶囊剂，内容物为黄褐色粉末；气香，味微苦。  【功能主治】散结消肿，化瘀止痛。用于阴疽初起，皮色不变，肿硬作痛，多发性脓肿，瘿瘤，瘰疬，乳岩，乳癖 【用法用量】口服。一次4～10粒，一日2次。红金消结片规格：12片/板*3板/盒品牌：美消丹生产厂商：四川维奥制药有限公司 生产批号：国药准字Z20080199中药类  舒肝理气  散结消肿  【成份】三七、香附、八角莲、鼠妇虫、黑蚂蚁、五香血藤、鸡矢藤、金荞麦、大红袍、柴胡。【性状】本品为薄膜衣片，除去包衣显棕色或棕褐色；气微香，味微苦。【功能主治】中医：舒肝理气、软坚散结、活血化瘀、消肿止痛。用于气滞血瘀所致乳腺小叶增生，子宫肌瘤，卵巢囊肿。彝医：补知凯扎诺，且凯色土，哈息黑。【用法用量】口服。一次4片，一日3次。📋 实际用药流行性感冒咳嗽、有黄色痰、发烧、流绿色鼻涕            名称      批号      药箱      用量                  欧龙马口服溶液      国药准字ZJ20160013      小药箱      1次20滴，1日3次              酪酸梭菌活菌散      国药准字S20040088      小药箱      1次1袋，1日3次              小儿消积止咳口服液      国药准字Z10970022      小药箱      1次1袋半，1日3次              糠酸莫米松鼻喷雾剂      国药准字H20113481      小药箱      1次1下，1日1次              鼻渊通窍颗粒      国药准字Z20030071      小药箱      1次半袋，1日3次              孟鲁斯特纳颗粒      国药准字J20140167      小药箱      1次1袋，1日1次，睡前服用      发烧、排绿色的稀便、带有黏液脓血、咳嗽防止脱水，补充水分，轻食，比如稀饭、面条等容易消化的食物。避免辛辣、油腻食物。头孢呋辛钠是第二代头孢菌素类抗生素，是一种广谱的抗菌药物，对肺炎链球菌、流感嗜血杆菌、克雷白杆菌属、金黄色葡萄球菌、化脓性链球菌、大肠杆菌、流感嗜血杆菌、淋病奈瑟菌等均有较好的抗菌作用。            名称      批号      药箱      用量                  小儿消积止咳口服液      国药准字Z10970022      小药箱      1次1袋半，1日3次              氨溴特罗口服溶液      国药准字H20040317      小药箱      1次7.5ml，1日2次              开喉剑喷雾剂      国药准字Z20025142      小药箱      1日4次      其他            名称      批号      药箱      用量                  氨溴特罗口服溶液      国药准字H20040317      小药箱      1日2次，1次5ml              小儿肺热咳喘颗粒      国药准字Z20053532      小药箱      1日4次，1次1袋              羚羊感冒口服液      国药准字Z19991003      小药箱      1日3次，1次2/3瓶              头孢克肟干混悬剂      国药准字H20041122      小药箱      1日2次，1次1袋，温水冲服              银黄颗粒      国药准字Z51021284      小药箱      1日2次，1次半袋      📚 用药研究中药的性味中药的性味是指药物的性质和气味，主要包括四气五味。四气指的是寒、热、温、凉四种不同的药性，又称四性；五味指的是酸、苦、甘、辛、咸五种不同的药味，又称五味。耐药性经常服用同一种感冒药确实有可能导致身体产生适应性，尤其是对于含有抗病毒或抗生素成分的药物。如果感冒药中含有抗生素成分，并且不是由细菌感染引起的感冒（因为感冒大多数是由病毒引起的），不当使用抗生素不仅无效，还会促进细菌耐药性的产生。对于非处方的感冒药，它们通常包含缓解症状的成分，如退烧药（对乙酰氨基酚）、止咳药（如右美沙芬）、抗组胺药（如马来酸氯苯那敏）等，这些成分不直接作用于病毒，而是帮助缓解感冒伴随的症状。长期或不当使用这些药物，虽然不会引起传统意义上的“耐药性”，但可能导致身体对药物的反应减弱，或因药物副作用影响健康，比如长期大量使用对乙酰氨基酚可能对肝脏造成损害。经常吃一种中药制剂，一般情况下不太容易形成类似于西药中的耐药性问题。中药制剂多为复方，包含多种药材，每种药材又含有多种活性成分，这样的复合成分使得病原体较难对所有成分同时产生耐受性。相比单一成分的西药，中药的作用机理更为复杂，往往是通过多途径、多靶点发挥作用，因此耐药性的发展相对较低。然而，这并不意味着可以无限制地长期使用同一种中药制剂。长期或不当使用中药也可能带来其他问题，如药物蓄积导致的毒性反应、对身体机能的干扰、以及可能的药物-药物相互作用等。特别是那些具有生物活性、能够影响机体生理功能的中药，长期服用应当遵循医嘱，并定期评估身体状况。此外，对于某些具有抗菌、抗病毒作用的中药，如果长期或不当地使用，理论上也不能完全排除病原体逐渐产生适应性变化的可能性，尽管这种情况相对较少见。为了避免这些问题，建议在使用感冒药时遵循以下原则：  根据自己的具体症状选择药物，不要盲目服用全效型的复方感冒药。  避免不必要的药物使用，轻微的感冒可以通过休息和充分饮水自然恢复。  不要随意增加剂量或延长用药时间。  若感冒症状持续不见好转或加重，应及时就医，以便准确判断是否需要调整治疗方案或使用其他药物。  在医生指导下使用处方药物，特别是抗生素，确保合理用药。抗组胺抗组胺药指组胺受体的阻断药，这种药物会通过抗组胺作用缓解和消除由组胺介导的过敏反应，主要用于治疗过敏性疾病，服药后可降低神经和毛细血管细胞上组胺受体的活性，常用于治疗过敏性鼻炎、接触性皮炎、荨麻疹等，同时具有镇静作用，能抑制中枢神经的活动，起到镇静效果。目前抗组胺药物分为三代，第一代抗组胺药物有异丙嗪片、马来酸氯苯那敏片，第二代抗组胺药物为氯雷他定片、盐酸西替利嗪片，而第三代抗组胺药物为盐酸非索非那定片、盐酸左旋西替利嗪片等，具体用药遵医嘱。抗生素抗生素是一类用于治疗细菌、真菌、某些寄生虫及其他微生物感染的药物，它们源自自然界的微生物（如细菌、真菌）或通过化学合成及半合成方法得到。以下列举了一些常见的抗生素类别及其代表药物：  β-内酰胺类：          青霉素类：如青霉素G、氨苄西林、阿莫西林。      头孢菌素类：包括不同代的头孢，如头孢氨苄（第一代）、头孢克洛（第二代）、头孢曲松（第三代）、头孢吡肟（第四代）。      其他β-内酰胺类：如碳青霉烯类（美罗培南）、单环β-内酰胺类（氨曲南）及β-内酰胺酶抑制剂复合物（如阿莫西林克拉维酸钾）。        大环内酯类：如红霉素、阿奇霉素、克拉霉素、罗红霉素。  氨基糖苷类：如链霉素、庆大霉素、阿米卡星，这类药物因具有耳毒性和肾毒性，临床使用需谨慎。  四环素类：包括四环素、多西环素（强力霉素）、米诺环素等，由于耐药性问题，现较少使用。  喹诺酮类：虽然严格意义上不属于抗生素，但常按抗生素管理使用，如诺氟沙星、环丙沙星、左氧氟沙星，主要用于治疗泌尿道、呼吸道等感染。  磺胺类和TMP-SMX（复方新诺明，磺胺甲恶唑+甲氧苄啶）：虽为人工合成抗菌药，但也常被归入广义的抗生素讨论。  林可酰胺类：如克林霉素。  硝基咪唑类：如甲硝唑、替硝唑，主要用于抗厌氧菌和某些原虫感染。  糖肽类：如万古霉素、替考拉宁，主要用于治疗革兰氏阳性菌，特别是耐甲氧西林金黄色葡萄球菌（MRSA）感染。  多肽类：如 polymyxins（如多粘菌素B和E/粘菌素），用于对付多重耐药的革兰阴性菌。请注意，抗生素不应对病毒感染有效，因为病毒的生命周期和复制方式与细菌不同。此外，不当使用抗生素会导致细菌耐药性的增加，因此在使用时应严格遵医嘱。抗生素的使用时长并非固定不变，而是依据患者的具体病情、感染的类型、感染部位、致病菌的敏感性以及患者的身体状况等因素综合决定。一旦症状缓解且实验室检查（如血常规、病原学检查）显示感染已得到有效控制，应当及时停药。因此，最佳的用药时长应在医生的指导下确定，并定期评估治疗效果以调整治疗方案。以下是一些普遍原则：  轻度感染：如扁桃体炎、咽炎、轻度皮肤感染等，抗生素通常使用3-5天即可控制病情。  中度至重度感染：例如肺炎、泌尿系感染，可能需要服用抗生素1-2周。  特定感染：如细菌性心内膜炎，抗生素的使用时间可能长达4周以上。  特殊情况：对于某些门诊患者，抗生素治疗一般不超过3天，最多不超过7天；住院患者若病情较重或病原体难以清除，可能需要连续使用抗生素直至症状好转后，再继续服用3-5天以巩固疗效。中药制剂的服药时间中药制剂的最长服用时间并非固定不变，而是依据个人病情、体质以及所用药物的性质来决定。一般情况下，对于急性疾病，中药可能连续服用几天到一周左右；而对于慢性疾病，治疗周期可能长达数周至数月，甚至更久，但通常会分成多个疗程进行，每个疗程之间可能有间歇期。以下是几个参考点：  外感疾病一般建议服用3-5天。  慢性疾病调理，一个疗程可能为7天，视病情需要可能连续几个疗程。  一些特殊情况，如补益药或活血化瘀药，可能连续服用一个月左右。  总体而言，中药连续服用时间一般在2周到4周，最长不超过1个月，除非特定病情需要并在医生指导下延长。重要的是，患者应该遵循中医师的指导，根据病情的变化适时调整用药。在服用过程中，一旦症状得到缓解或出现不良反应，应及时复诊，由医生评估是否继续服用或调整药方。自我调整用药剂量和时长可能会对健康造成不利影响。同时，合理的饮食习惯和生活方式也是配合中药治疗、促进康复的重要因素。中药不可同服原理不能同服的主要原理涉及药物之间的相互作用，这些相互作用可能会影响药物的吸收、分布、代谢和排泄过程，从而改变药物原有的疗效或产生意外的毒副作用。具体来说，中药不能同服的原因主要包括以下几点：      药效拮抗：某些中药成分可能会与西药或其他中药成分发生拮抗作用，导致一种或多种药物的治疗效果减弱。例如，感冒药板蓝根颗粒与某些降压药同服时，可能拮抗降压药的效果。        药效增强：一些中药可能增强其他药物的作用，包括西药，这种增强有时会超出安全范围，导致毒性增加。比如，含麻黄碱的中药与某些强心药同服，可能增强强心药的毒性，引起心律失常或心力衰竭。        影响代谢：中药中的成分可能影响肝脏中负责药物代谢的酶系统（如CYP450酶系），从而影响西药的代谢速率，可能导致血药浓度异常增高或降低，影响药效或安全性。        药理作用叠加：不同中药或中药与西药之间可能存在相似的药理作用，同服时可能叠加作用，造成过度治疗，如某些具有降糖作用的中药与西药降糖药同服可能导致血糖过低。        配伍禁忌：传统中医药理论中有“十八反”与“十九畏”的概念，指特定中药组合使用时可能产生剧烈的不良反应或毒性，这是基于长期临床实践总结出的经验规则。        物理化学反应：在极少数情况下，中药与西药混合可能在物理或化学层面上产生反应，影响药物稳定性或形成新的有害物质。  综上所述，中药不能随意同服，需考虑药物间可能的相互作用以及患者的具体情况。在实际应用中，应当遵循医嘱，避免不必要的药物相互作用，确保治疗安全有效。“十八反”和”十八畏”“十八反”和”十八畏”是中国传统中医药理论中的概念，用于指导中药配伍禁忌，避免药物之间产生不利的相互作用，保障用药安全。“十八反”是指十八组药物相互之间不能同用，否则可能引起剧烈的毒副作用。具体的十八反组合如下：  甘草反甘遂、大戟、海藻、芫花。  乌头（川乌、草乌、附子）反半夏、瓜蒌（全瓜蒌、瓜蒌皮、瓜蒌仁、天花粉）、贝母（川贝、浙贝）、白蔹、白及。  藜芦反人参、沙参、丹参、玄参、细辛、芍药（赤芍、白芍）。相较于“十八反”，“十八畏”的危害性相对较轻，指的是某些药物合用时虽不一定会立即产生剧烈毒性，但可能降低疗效或引起不适。不过，“十八畏”的具体内容在不同古籍中有不同的记载，没有像“十八反”那样统一明确的十八种组合，常见的有以下一些畏忌搭配：  硫磺畏朴硝（芒硝）  水银畏砒霜  巴豆畏牵牛  丁香畏郁金  牙硝（芒硝）畏三棱  川乌、草乌畏犀角  肉桂畏赤石脂需要注意的是，随着现代药理学的发展，部分传统禁忌的科学依据被重新评估，但在中医临床实践中，这些原则仍然作为重要的参考标准来指导药物的合理配伍。患者在使用中药时，务必遵循中医师的专业指导，不可自行决定药物的搭配使用。如何区分风热感冒和风寒感冒区分风热感冒和风寒感冒主要基于中医学的理论，这两种感冒类型反映了不同的病因和病理变化，因此其症状、治疗方式以及预后都有所不同。以下是一些关键点帮助你区分两者：  风寒感冒特征：          发病原因：由风寒邪气侵袭引起，常见于寒冷季节或环境。      症状：                  恶寒重于发热，即感觉更冷而不是热。          无汗或汗少，身体难以自行散热。          头痛，尤其是后脑部。          身体酸痛，包括肌肉和关节。          流清水样鼻涕，鼻塞。          咳嗽，痰液稀白。          口不渴或渴喜热饮。          舌苔薄白。                      风热感冒特征：          发病原因：由风热邪气侵袭引起，常见于温暖或炎热季节。      症状：                  发热重于恶寒，体温升高显著。          有汗，但可能伴有口渴。          头痛，有时伴有面部或眼部胀痛。          咽喉疼痛和红肿。          鼻涕和痰液颜色偏黄，质地粘稠。          舌体红，舌苔薄黄或黄厚。          口渴喜冷饮。                      其他区别：          发病季节：风寒感冒多发于冬季，而风热感冒多发于春夏季节。      预后：风热感冒可能伴有更明显的炎症反应，如咽喉炎。      治疗：风寒感冒治疗以辛温解表为主，常用药物如风寒感冒颗粒、麻黄、桂枝等。风热感冒治疗以辛凉解表和清热解毒为主，常用药物如银翘解毒片、板蓝根颗粒等。      如果你或他人出现上述症状，最好咨询医生或中医师，以便得到正确的诊断和治疗建议。自我诊断并尝试自我治疗可能不会解决根本问题，尤其是在症状严重或持续恶化的情况下。如何区分普通感冒和病毒性感冒  普通感冒的症状相对较轻，主要包括流鼻涕、打喷嚏、鼻塞、咽痛、咳嗽等上呼吸道卡痰症状，一般不发热或仅低热（＜38℃），全身症状较轻。普通感冒一般在7-10天内自行消失，很少出现并发症。  病毒性感冒的症状较为严重，起病急，早期可能有咽干、咽痒或烧灼感，随后出现打喷嚏、流鼻涕、鼻塞等症状。此外，还可能伴有高热、寒战、头痛、全身肌肉酸痛、乏力等全身症状。病毒性感冒病情较重，可能需要更长时间恢复，并且容易引发并发症。头孢的分类  第一代头孢：第一代头孢菌素类药物的特点比较明显，能够更加显著地抑制革兰氏阳性菌，如金黄色葡萄球菌，对革兰氏阴性菌的作用不明显，如痢疾杆菌。但对β-内酰胺酶的稳定性比较低，头孢菌素酶与β-内酰胺酶将会对其结构产生一定的破坏。第一代头孢和其他头孢相比，往往具有较高的肾脏毒性，头孢拉定制剂、头孢氨苄制剂等药物，是第一代头孢的主要代表；  第二代头孢：第二代头孢类主要有头孢呋辛制剂、头孢呋辛酯制剂以及头孢西丁制剂等，第二代头孢既可以治疗革兰氏阳性菌，也可以用于治疗革兰氏阴性杆菌，比第一代头孢抗菌谱广，肾毒性比第一代要小；  第三代头孢：临床较为常用的第三代头孢为头孢曲松制剂、头孢他啶制剂及头孢哌酮制剂等，第三代头孢主要用于大肠杆菌感染，具有抗菌谱广的特性，但是对于革兰阳性菌的作用不如第一代头孢；  第四代头孢：第四代头孢是在保持第三代头孢特性的同时，增强对革兰氏阴性菌的抗菌活性，同时提高了β－内酰胺酶的稳定性，在较低药物浓度时，即可抑制细菌细胞壁合成，保持了强效的抗菌活力。常见的第四代头孢有头孢匹罗制剂、头孢吡肟制剂等；  第五代头孢：头孢吡普制剂、头孢洛林制剂等是第五代头孢的常见药物，抗菌谱、抗菌活性以及抗β-内酰胺酶水解性能方面都优于前四代产品，但对超广谱β-内酰胺酶稳定性稍差，一般无肾毒性。伏天如何排除体内湿气在中医理论中，三伏天是一年中阳气最为旺盛的时候，因此很多人比较注重在三伏天排湿祛寒，但是需要注意的是，掌握正确的方法才能有比较好的效果，三伏天排湿气寒气可以这样做：  通过食物排湿祛寒：食疗是比较安全、健康、有效的方法。通过摄入发汗、利水的食物，通过增加排汗、排尿等方式，促进新陈代谢，有效排出体内的湿气。发汗、利水的食物有赤小豆、绿豆、冬瓜等。  增加运动量：三伏天天气炎热，人的活动量明显减少。其实在三伏天，湿气重的人群在医师指导下适当运动，通过大量的排汗，加快身体的新陈代谢，有助于湿气的排出。  坚持用温水泡脚：温水泡脚不仅有助于睡眠，还有助于疏通身体的经络，健脾除湿。  刮痧、拔罐：刮痧、拔罐也是常用的去湿气寒气的方法。"
  },
  
  {
    "title": "食谱",
    "url": "/posts/shipu/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2022-11-24 13:47:00 +0800",
    





    
    "snippet": "🏡 果蔬仓库水果梨7月、8月、9月、10月 功效：润肺、止咳、清热、降压、富含维生素建议：雪花梨、库尔勒香梨、香蕉梨、秋月梨荔枝5月、6月、7月、8月 功效：荔枝补脾益肝、生津止渴、促循环、增免疫、美容颜、但易上火、糖高慎食  建议：妃子笑荔枝龙眼6月、7月、8月 功效：补血、安神、益智、美容  建议：红荔龙眼芒果5月、6月、7月、8月 功效：助消化、增免疫、美肤、降脂、抗氧化  建议：小台...",
    "content": "🏡 果蔬仓库水果梨7月、8月、9月、10月 功效：润肺、止咳、清热、降压、富含维生素建议：雪花梨、库尔勒香梨、香蕉梨、秋月梨荔枝5月、6月、7月、8月 功效：荔枝补脾益肝、生津止渴、促循环、增免疫、美容颜、但易上火、糖高慎食  建议：妃子笑荔枝龙眼6月、7月、8月 功效：补血、安神、益智、美容  建议：红荔龙眼芒果5月、6月、7月、8月 功效：助消化、增免疫、美肤、降脂、抗氧化  建议：小台芒葡萄7月、8月、9月、10月 功效：补能、促眠、润肠、抗氧化建议：巨峰、马奶葡萄桑葚4月、5月、6月 功效：滋阴补血、生津润燥、明目乌发、降脂防癌、增强免疫建议：红果1号山竹5月、6月、7月、8月、9月 功效：清热、滋补、健脾、抗氧化、助消化建议：泰国山竹圣女果5月、6月、7月 功效：生津、健胃、清热、抗氧化、促消化、美容、增免疫  建议：千禧石榴9月、10月 功效：补水、抗氧化、助消化、护心、防老化  建议：大青皮甜石榴香瓜4月、5月、6月、7月、8月 功效：清热、解暑、利尿、助消化  建议：羊角蜜、伊丽莎白香蕉9月、10月、11月 功效：缓解抑郁、防贫血、降血压、解酒、助减肥、增免疫、防胃病  建议：海南香蕉杨梅5月、6月、7月 功效：生津、消食、止泻、抗菌、降脂、美容  建议：东魁杨梅樱桃4月、5月、6月 功效：补血、美容、抗炎、促消化  建议：烟台樱桃柚子1月、2月、10月、11月、12月 功效：降火、助消化、降血糖、富含维C  建议：三红蜜柚橘子1月、2月、3月、4月、10月、11月、12月 功效：润肺、止咳、降脂、醒酒、富含维C  建议：耙耙柑、砂糖橘菠萝蜜6月、7月、8月、9月、10月、11月 功效：补充营养、改善低血糖、缓解便秘、美容养颜、促消化、抗炎、补中益气、滋养补虚建议：红肉菠萝蜜草莓2月、3月、4月、5月 功效：抗氧化、促消化、美容、防癌、补血、护心、润肺建议：京藏香草莓哈密瓜7月、8月、9月、10月 功效：补水、清热、润肺、助消化、抗氧化、舒缓神经、调节情绪建议：楼兰瓜火龙果7月、8月、9月、10月、11月 功效：排毒、美容、防便秘、补铁、抗氧化建议：红心火龙果、台湾青皮红肉火龙果菠萝1月、4月、5月、6月、7月、10月、11月、12月 功效：促消化、利尿、增食欲、美白、减肥建议：金钻菠萝、海南菠萝榴莲6月、7月 功效：补身、促消化、增免疫、缓痛经、改善寒性体质、但热量高、需适量建议：猫山王榴莲、金枕榴莲西瓜5月、6月、7月、8月功效：清热、解渴、利尿、消肿、美容、降压、解酒毒建议：麒麟西瓜杏6月、7月 功效：生津、润肺、降脂、通便、美颜、抗癌、保护视力、预防慢性病建议：香白杏桃6月、7月、8月 功效：生津、润肠、益气、美肤、降压建议：黄桃、蟠桃、油桃百香果8月、9月、10月 功效：清肺润燥、镇痛、美容、润肠、排毒、缓解紧张、焦虑、抑郁情绪、改善睡眠质量建议：紫红色百香果橙子10月、11月功效：补维C、助消化、降脂压、润肠、防癌建议：赣南脐橙、血橙苹果7月、8月、9月、10月、11月功效：助消化、降脂压、润肠、醒酒、益胃、生津、防癌  建议：阿克苏冰糖心苹果、红富士苹果、烟台苹果、黄元帅、国光蔬菜白菜1月、2月、7月、8月、10月、11月 功效：清热、助消化、富含维生素C 建议：醋溜白菜、白菜炖豆腐白萝卜5月、6月 功效：助消化、降脂、抗炎建议：白萝卜炖羊肉、萝卜丸子、凉拌萝卜丝、白萝卜汤菠菜1月、4月、5月、6月、7月、8月、9月、10月、11月、12月 功效：补铁、护眼、强骨建议：老醋菠菜、土豆熬菠菜菜花9月、10月 功效：抗癌、助消化、强免疫建议：干锅菜花彩椒1月、2月、3月、4月、5月、6月、7月 功效：富含维生素C、抗氧化、助消化建议：拌沙拉春笋2月、3月、4月、5月 功效：助消化、清热、利尿  建议：油焖春笋豆角6月、7月、8月、9月、10月 功效：健脾和胃、补肾、促消化  建议：熬豆角、干煸豆角冬瓜8月、9月、10月 功效：利尿、减肥、降压、降脂  建议：冬瓜汤青椒9月、10月 功效：促消化、增食欲、抗氧化、降血脂  建议：青椒土豆丝、青椒肉丝、青椒鸡蛋黄瓜6月、7月、8月 功效：清热解毒、利水消肿、美容养颜、减肥  建议：黄瓜炒鸡蛋、凉拌黄瓜胡萝卜1月、2月、3月、10月、11月、12月 功效：补肝明目、增强免疫、降血糖  建议：胡萝卜丝炒土豆丝红薯8月、9月、10月、11月、12月 功效：通便、降压、护心血管、美容  建议：烤红薯海带5月、6月、7月、8月、9月 功效：补碘、降压、降脂、抗辐射  建议：凉拌海带丝黄豆芽4月、5月、6月、7月、8月、9月、10月 功效：清热利湿、减肥降脂  建议：黄豆芽炒肉🍃 应季果蔬            月份      水果                  1月      菠萝、柚子、橘子              2月      草莓、柚子、橘子              3月      草莓、橘子              4月      菠萝、草莓、桑葚、香瓜、樱桃、橘子              5月      西瓜、菠萝、草莓、荔枝、芒果、桑葚、山竹、圣女果、香瓜、杨梅、樱桃              6月      桃、杏、西瓜、榴莲、菠萝、菠萝蜜、荔枝、龙眼、芒果、桑葚、山竹、圣女果、香瓜、杨梅、樱桃              7月      苹果、桃、杏、西瓜、榴莲、菠萝、火龙果、哈密瓜、菠萝蜜、梨、荔枝、龙眼、芒果、葡萄、山竹、圣女果、香瓜、杨梅              8月      百香果、苹果、桃、西瓜、火龙果、哈密瓜、菠萝蜜、梨、荔枝、龙眼、芒果、葡萄、山竹、香瓜              9月      百香果、苹果、火龙果、哈密瓜、菠萝蜜、梨、葡萄、山竹、石榴、香蕉              10月      百香果、橙子、苹果、菠萝、火龙果、哈密瓜、菠萝蜜、梨、葡萄、石榴、香蕉、柚子、橘子              11月      橙子、苹果、菠萝、火龙果、菠萝蜜、香蕉、柚子、橘子              12月      菠萝、柚子、橘子                  月份      蔬菜                  1月      白菜、菠菜、彩椒、胡萝卜、蒜黄              2月      白菜、彩椒、春笋、胡萝卜、蒜黄              3月      彩椒、春笋、胡萝卜、蒜黄、香椿              4月      菠菜、彩椒、春笋、黄豆芽、蒜苔、蒜黄、莴苣、西兰花、香椿              5月      白萝卜、菠菜、彩椒、春笋、海带、黄豆芽、蒜苔、土豆、莴苣、西兰花、西葫芦、圆白菜、洋葱、油菜              6月      白萝卜、菠菜、彩椒、豆角、黄瓜、海带、黄豆芽、茄子、丝瓜、土豆、娃娃菜、西红柿、西葫芦、圆白菜、洋葱、油菜、紫甘蓝              7月      白菜、菠菜、彩椒、豆角、黄瓜、海带、黄豆芽、茄子、丝瓜、山药、土豆、娃娃菜、西红柿、圆白菜、洋葱、紫甘蓝              8月      白菜、菠菜、豆角、冬瓜、黄瓜、红薯、海带、黄豆芽、茄子、芹菜、丝瓜、山药、圆白菜、油麦菜              9月      菠菜、菜花、豆角、冬瓜、青椒、红薯、海带、黄豆芽、莲藕、芹菜、丝瓜、山药、圆白菜、油菜、油麦菜              10月      白菜、菠菜、菜花、豆角、冬瓜、青椒、胡萝卜、红薯、黄豆芽、莲藕、芹菜、丝瓜、山药、土豆、娃娃菜、西兰花、圆白菜、油菜、油麦菜、紫甘蓝              11月      白菜、菠菜、胡萝卜、红薯、山药、蒜黄、土豆、娃娃菜、西兰花、圆白菜、紫甘蓝              12月      菠菜、胡萝卜、红薯、蒜黄、土豆      🔎 果蔬研究酸的水果酸味的水果通常含有丰富的维生素C和多种有机酸，这些成分对人体健康有很多益处。并不是所有酸的水果都可以助眠，酸枣是特例，有药用价值，可以助眠，助消化，神经放松。📙 菜谱油闷大虾辅料：姜丝、葱丝料汁：生抽2勺、醋半勺、糖半勺、料酒1勺、盐少许做法：中火煎虾，下葱姜，下料汁，焖2分钟烧茄子辅料：葱、蒜末、青红椒、西红柿料汁：1勺糖、3勺醋、1勺‌生抽、少量盐、3勺水淀粉做法：滚刀茄子用盐杀水，裹淀粉油煎，下料汁紫菜蛋花汤辅料：葱花、香菜、西红柿、紫菜料汁：盐、香油、胡椒粉、鸡精做法：碗里加辅料和料汁，水开转小火飞蛋花，转大火煮，将蛋花盛到碗中📘 菜单主食姜丝肉末面  土豆熬茄子拌莜面  西红柿鸡蛋面  饺子  豆包  米饭  小米粥  豆角焖面  炒米饭  炒饼  紫菜蛋花汤茄丁面素菜耗油蒿子杆  葱烧豆腐  土豆丝  醋溜白菜  粉丝拌黄瓜  西红柿炒鸡蛋  炒豆角青椒鸡蛋  土豆熬豆角  拌豆腐  西兰花炒鸡蛋  拍黄瓜  青椒土豆片  芹菜土豆片  芹菜豆干  青椒豆皮西葫芦炒鸡蛋  韭菜炒鸡蛋  土豆丝炒胡萝卜丝虎皮尖椒  土豆熬豆腐  青椒炒茄子  老醋菠菜  土豆熬菠菜炒扁豆丝荤菜土豆炖鸡架  炖排骨  鸡蛋羹  炖鱼  炖鸡翅  炖猪蹄  炖鸡爪  火锅  鱼香肉丝  油闷大虾"
  },
  
  {
    "title": "Log4j漏洞修复",
    "url": "/posts/log4j-loudong-xiufu/",
    "categories": "Knowledge, Log4j",
    "tags": "Log4j",
    "date": "2022-09-28 13:47:00 +0800",
    





    
    "snippet": "升级官方版本（推荐）目前Apache官方已发布最新版升级包，Java7版本升级至log4j-2.12.4版本，Java8及以上版本升级至log4j-2.17.0版本，升级包中移除了对lookup功能的支持，默认禁用了JNDI方法。移除Log4j包中JndiLookup类（可能存在未知影响）移除log4j-core包中JndiLookup类文件，并重启服务，具体方法如下：  Linux系统zi...",
    "content": "升级官方版本（推荐）目前Apache官方已发布最新版升级包，Java7版本升级至log4j-2.12.4版本，Java8及以上版本升级至log4j-2.17.0版本，升级包中移除了对lookup功能的支持，默认禁用了JNDI方法。移除Log4j包中JndiLookup类（可能存在未知影响）移除log4j-core包中JndiLookup类文件，并重启服务，具体方法如下：  Linux系统zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class  Windows系统jar包解压缩，删除org/apache/logging/log4j/core/lookup/路径下JndiLookup.class文件。修改Log4j配置（需评估是否影响业务）通过更改Log4j配置达到缓解作用，具体更改配置如下：  JVM启动参数添加-Dlog4j2.formatMsgNoLookups=True  在应用classpath下添加log4j2.component.properties配置文件，文件内容为log4j2.formatMsgNoLookups=true需注意该方法的两项措施在log4j-2.10.0以下版本无效，可采取第二种修复方式。"
  },
  
  {
    "title": "Eclipse更换工作空间的步骤",
    "url": "/posts/eclipse-genghuan-gongzuokongjian-buzhou/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-28 01:47:00 +0800",
    





    
    "snippet": "一、指定新工作空间位置二、设置编码设置工作空间编码UTF-8设置JSP编码三、指定JDK位置四、配置Tomcat五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件指定maven插件指定maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入.abcdefghijklmnopqrstuvwxyz十二、校验的删...",
    "content": "一、指定新工作空间位置二、设置编码设置工作空间编码UTF-8设置JSP编码三、指定JDK位置四、配置Tomcat五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件指定maven插件指定maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入.abcdefghijklmnopqrstuvwxyz十二、校验的删除十三、Debug十四、修改背景颜色Window -&gt; preference -&gt; general -&gt; editors -&gt; test editors -&gt; background color -&gt; 色调85、饱和度120、亮度208"
  },
  
  {
    "title": "Spring Boot切换多环境配置文件",
    "url": "/posts/springboot-qiehuan-duohuanjing-peizhiwenjian/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2022-09-23 13:47:00 +0800",
    





    
    "snippet": "在项目开发的过程中，我们难免会遇到开发、测试、生产等环境的切换，而各个环境的配置肯定是不同的。传统的办法是在项目打包的时候修改配置文件。但人为做的事情难免产生意外。Spring Boot为我们提供了一种多环境配置文件同时存在，而运行打包时仅运行所选的配置文件的方式。spring.profiles.activespring:  profiles:    # active: yaya    ac...",
    "content": "在项目开发的过程中，我们难免会遇到开发、测试、生产等环境的切换，而各个环境的配置肯定是不同的。传统的办法是在项目打包的时候修改配置文件。但人为做的事情难免产生意外。Spring Boot为我们提供了一种多环境配置文件同时存在，而运行打包时仅运行所选的配置文件的方式。spring.profiles.activespring:  profiles:    # active: yaya    active: keats指定激活哪个文件，值是application-{profileName}.yml中的profileName，用于区分不同的运行环境。如果application.yml和被激活的yml中同时配置了一个相同的键，被激活的yml中的值会覆盖application.yml中的值。spring.profiles.includespring:  profiles:    include: yayaDB, yayaRedis指定包含(合并)多个yml的内容一起启动。这样有助于同环境下yml文件的分类管理。像上面include值是多个的情况，除了使用,分隔的输入方式外，还可以使用换行- profileName的方式，这是yml 的一种语法。spring:  profiles:    include:      - yayaDB      - yayaRedis按照以上的yml配置之后，就可以通过注释与放开不同的active，来实现环境的切换了。  参考：SpringProfile轻松切换多环境配置文件"
  },
  
  {
    "title": "DBCP、C3P0、Proxool、BoneCP方式创建数据源连接",
    "url": "/posts/sizhong-peizhi-shujuyuan-de-fangshi/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2022-09-23 13:47:00 +0800",
    





    
    "snippet": "Apache DBCP以这种方式创建数据源必须先准备两个jar文件：commons-dbcp.jar和commons-pool.jar，将这两个jar包放到WEB-INF/lib目录下。以这种方式创建的数据源就不再是javax.sql.DataSource了，而是org.apache.commons.dbcp.BasicDataSource。而且不再需要配置任何文件就可以直接使用。// 创建...",
    "content": "Apache DBCP以这种方式创建数据源必须先准备两个jar文件：commons-dbcp.jar和commons-pool.jar，将这两个jar包放到WEB-INF/lib目录下。以这种方式创建的数据源就不再是javax.sql.DataSource了，而是org.apache.commons.dbcp.BasicDataSource。而且不再需要配置任何文件就可以直接使用。// 创建BasicDataSource对象BasicDataSource ds = new BasicDataSource();ds.setDriverClassName(\"com.mysql.jdbc.Driver\");ds.setUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUsername(\"[用户名]\");ds.setPassword(\"[密码]\");//指定数据库连接池中初始化连接数的个数ds.setInitialSize(50);//指定最大的连接数: 同一时刻可以同时向数据库申请的连接数ds.setMaxActive(100);//指定最大连接数: 在数据库连接池中保存的最大的空闲连接的数量ds.setMaxIdle(30);//指定最小连接数：在数据库连接池中保存的最小的空闲连接的数量ds.setMinIdle(5);//指定等待时间：等待数据库连接池中给分配的连接，等待时间，超过之后会报异常ds.setMaxWait(10000);//毫秒单位// 关闭数据源连接ds.close();C3P0使用C3P0方式创建数据源应该首先准备一个jar文件：c3p0-0.9.1.2.jar，将其放到WEB-INF/lib目录下，就可以在项目中使用C3P0创建数据源了，C3P0创建的数据源对象也不是DataSource对象，而是ComboPooledDataSource。// 创建ComboPooledDataSource对象ComboPooledDataSource ds = new ComboPooledDataSource();ds.setDriverClass(\"com.mysql.jdbc.Driver\");ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUser(\"[用户名]\");ds.setPassword(\"[密码]\");ds.setInitialPoolSize(50);ds.setMaxPoolSize(100);ds.setMaxIdleTime(10000);Proxool采用该方式创建数据源需要准备的jar包：proxool-01.9.0RC3.jar，将其放到WEB-INF/lib目录下，之后就可以项目中创建ProxoolDataSource对象。// 创建ProxoolDataSource对象ProxoolDataSource ds = new ProxoolDataSource();ds.setDriver(\"com.mysql.jdbc.Driver\");ds.setDriverUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUser(\"[用户名]\");ds.setPassword(\"[密码]\");BoneCPBoneCP是一个快速高效，开源免费的Java数据库接池。创作者称，BoneCP在性能上会完全超越所有主流的Java连接池。它可以帮你管理数据连 接，让你的应用程序能更快速地访问数据库。比C3P0/DBCP连接池快25倍。这个数据库连接池采用Google Collection作为内部的集合类框架，而且现在的版本已经很稳定。要使用BoneCP，必须用到的jar文件有：bonecp-0.6.5.jargoogle-collections-1.0.jarslf4j-api-1.5.11.jarslf4j-log4j12-1.5.11.jarlog4j-1.2.15.jar将这些jar包放到WEB-INF/lib目录下，就可以在程序中创建BoneCPDataSource对象。// 创建BoneCPDataSource对象BoneCPDataSource ds = new BoneCPDataSource();ds.setDriverClass(\"com.mysql.jdbc.Driver\");ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUsername(\"[用户名]\");ds.setPassword(\"[密码]\");ds.setAcquireIncrement(1);ds.setAcquireRetryDelay(10000);ds.setIdleConnectionTestPeriod(100);ds.setMinConnectionsPerPartition(2);ds.setMaxConnectionsPerPartition(20);ds.setPartitionCount(2);"
  },
  
  {
    "title": "如何在Word中打出带勾的方框",
    "url": "/posts/word-ruhe-dachu-daigoudekuang/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2022-09-23 08:47:00 +0800",
    





    
    "snippet": "在Word文档中输入数字2611，然后按下键盘上的快捷键ALT + X，此时，这几个数字就会转换成方框内打钩符号。",
    "content": "在Word文档中输入数字2611，然后按下键盘上的快捷键ALT + X，此时，这几个数字就会转换成方框内打钩符号。"
  },
  
  {
    "title": "Linux配置防火墙",
    "url": "/posts/linux-peizhi-fanghuoqiang/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2022-09-23 01:47:00 +0800",
    





    
    "snippet": "CentOS6用service iptables status查看，CentOS7系统iptables叫firewalld，使用systemctl status firewalld查看。# 查看防火墙状态systemctl status firewalld# 如果不是显示active状态，需要打开防火墙systemctl start firewalld# 查看所有已开放的临时端口（默认为空）...",
    "content": "CentOS6用service iptables status查看，CentOS7系统iptables叫firewalld，使用systemctl status firewalld查看。# 查看防火墙状态systemctl status firewalld# 如果不是显示active状态，需要打开防火墙systemctl start firewalld# 查看所有已开放的临时端口（默认为空）firewall-cmd --list-ports# 查看所有永久开放的端口（默认为空）firewall-cmd --list-ports --permanent# 添加临时开放端口firewall-cmd --add-port=223/tcp# 添加永久开放的端口firewall-cmd --add-port=223/tcp --permanent# 关闭临时端口firewall-cmd --remove-port=80/tcp# 关闭永久端口firewll-cmd --remove-port=80/tcp --permanent# 配置结束后需要输入重载命令并重启防火墙以生效配置firewall-cmd --reloadsystemctl restart firewalld"
  },
  
  {
    "title": "Eclipse如何显示行号",
    "url": "/posts/eclipse-ruhe-xianshi-hanghao/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-23 01:47:00 +0800",
    





    
    "snippet": "一、快捷键法打开一个代码页面，直接输入快捷键CTRL + F10，就会调出一个菜单，勾选show line numbers即可显示行号。二、右侧边栏法打开一个代码页面，右键点击其侧边栏，如图所示的位置，就会显示一个菜单，勾选show line numbers即可显示行号。三、通用设置法在Eclipse菜单栏选择Window -&gt; Prenference，在打开的左侧设置窗口，依次展开W...",
    "content": "一、快捷键法打开一个代码页面，直接输入快捷键CTRL + F10，就会调出一个菜单，勾选show line numbers即可显示行号。二、右侧边栏法打开一个代码页面，右键点击其侧边栏，如图所示的位置，就会显示一个菜单，勾选show line numbers即可显示行号。三、通用设置法在Eclipse菜单栏选择Window -&gt; Prenference，在打开的左侧设置窗口，依次展开Window -&gt; Preferences -&gt; Gerenal -&gt; Editors -&gt; Text Editors，然后勾选右侧的show line numbers即可显示行号。"
  },
  
  {
    "title": "Windows10彻底关闭自动更新",
    "url": "/posts/chedi-guanbi-windows-gengxin/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2022-09-09 13:47:00 +0800",
    





    
    "snippet": "一、禁用Windows Update服务  打开运行对话框，输入services.msc，点击确定打开服务。  找到Windows Update这一项，双击打开。  点击停止，把启动类型选为禁用，最后点击应用。  接下再切换到恢复选项，将默认的重新启动服务改为无操作，然后点击应用。二、在组策略里关闭Win10自动更新相关服务  打开运行对话框，输入gpedit.msc，点击确定打开组策略编辑...",
    "content": "一、禁用Windows Update服务  打开运行对话框，输入services.msc，点击确定打开服务。  找到Windows Update这一项，双击打开。  点击停止，把启动类型选为禁用，最后点击应用。  接下再切换到恢复选项，将默认的重新启动服务改为无操作，然后点击应用。二、在组策略里关闭Win10自动更新相关服务  打开运行对话框，输入gpedit.msc，点击确定打开组策略编辑器。  在组策略编辑器中，依次展开计算机配置 -&gt; 管理模板 -&gt; Windows组件 -&gt; Windows更新。  然后在右侧配置自动更新设置中，将其设置为已禁用并点击下方的应用。  之后还需要再找到删除使用所有Windows更新功能的访问权限，选择已启用，完成设置后，点击应用。三、禁用任务计划里边的Win10自动更新  打开运行对话框，输入taskschd.msc，点击确定打开任务计划程序。  在任务计划程序的设置界面，依次展开任务计划程序库 -&gt; Microsoft -&gt; Windows -&gt; WindowsUpdate，把里面的项目都设置为禁用就可以了。四、在注册表中关闭Win10自动更新  打开运行对话框，输入regedit，点击确定打开注册表。  在注册表设置中，找到并定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UsoSvc，然后在右侧找到Start键。  点击修改，把Start值改为十六进制，值改为4，然后点击确定保存数据。  继续在右侧找到FailureActions键，右键点击修改该键的二进制数据，将0010、0018行的左起第5个数值由原来的01改为00，完成后，点击下方的确定即可。至此彻底关闭win10自动更新的操作步骤就全部完成了。"
  },
  
  {
    "title": "vi/vim下如何搜索字符串",
    "url": "/posts/linux-vi-xia-ruhe-sousuo-zifu/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2022-09-09 01:47:00 +0800",
    





    
    "snippet": "  命令模式下，输入/字符串，比如搜索user，输入/user，按下回车之后，可以看到vim已经把光标移动到该字符处和高亮了匹配的字符串  查看下一个匹配，按下n（小写n）  跳转到上一个匹配，按下N（大写N）",
    "content": "  命令模式下，输入/字符串，比如搜索user，输入/user，按下回车之后，可以看到vim已经把光标移动到该字符处和高亮了匹配的字符串  查看下一个匹配，按下n（小写n）  跳转到上一个匹配，按下N（大写N）"
  },
  
  {
    "title": "Eclipse中将Java项目转换成Web项目的方法",
    "url": "/posts/eclipse-zhong-jiangxiangmu-zhuanwei-webxiangmu-de-fangfa/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-09 01:47:00 +0800",
    





    
    "snippet": "用Eclipse开发项目的时候，把一个Web项目导入到Eclipse里会变成一个Java工程，将无法在Tomcat中进行部署运行，所以要转为Web项目。      找到.project文件，找到里面的&lt;natures&gt;标签，查看是否有下面的代码，没有则复制进去，如果Properties配置中有Project Facets选项则忽略此步骤。     &lt;nature&gt;or...",
    "content": "用Eclipse开发项目的时候，把一个Web项目导入到Eclipse里会变成一个Java工程，将无法在Tomcat中进行部署运行，所以要转为Web项目。      找到.project文件，找到里面的&lt;natures&gt;标签，查看是否有下面的代码，没有则复制进去，如果Properties配置中有Project Facets选项则忽略此步骤。     &lt;nature&gt;org.eclipse.wst.common.project.facet.core.nature&lt;/nature&gt; &lt;nature&gt;org.eclipse.wst.common.modulecore.ModuleCoreNature&lt;/nature&gt; &lt;nature&gt;org.eclipse.jem.workbench.JavaEMFNature&lt;/nature&gt;        Java项目中只有下面一句     &lt;nature&gt;org.eclipse.jdt.core.javanature&lt;/nature&gt;        刷新导入的项目。      在项目上点击右键，进入Properties配置，点击Project Facets，再点击Convert to faceted form进入属性设置。            勾选Dynamic Web Module和Java，选择相应的版本，并点击下方出现的Further configuration available。            配置Modify Faceted Project，此处是设置web.xml文件的路径，我们输入src/main/webapp，Generate web.xml deployment descriptor自动生成web.xml文件，可选可不选。        点击OK--&gt;Apply应用设置，Java项目即转换为了Web项目。注：如果忘记点击Further configuration available，即忘记修改WebContent为webapp，可以点击Deployment Assembly选项，然后将WebContent删除，将webapp添加进去。该选项的功能：部署项目时，设置文件发布的路径以及jar包发布的路径。"
  },
  
  {
    "title": "Eclipse已经导入jar包，但还是出现ClassNotFound异常",
    "url": "/posts/eclipse-yiijng-daoru-jarbao-danhaishi-xianshi-classnotfound/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-09 01:47:00 +0800",
    





    
    "snippet": "问题描述最近在部署一个Web项目，jar包在lib目录下新建了子目录放置，在Java类中直接通过import能导入使用，并且单独运行一个Java类的main方法可以正常运行，但是在运行Web项目时却会报ClassNotFound的错误。问题原因对于普通的Java类，编译jar包时，就直接在导入的包中查找就可以了，但是对于Web项目，由于它们是借助了Tomcat或者其他的容器发布，基于Tomc...",
    "content": "问题描述最近在部署一个Web项目，jar包在lib目录下新建了子目录放置，在Java类中直接通过import能导入使用，并且单独运行一个Java类的main方法可以正常运行，但是在运行Web项目时却会报ClassNotFound的错误。问题原因对于普通的Java类，编译jar包时，就直接在导入的包中查找就可以了，但是对于Web项目，由于它们是借助了Tomcat或者其他的容器发布，基于Tomcat本身，它会在Web项目中的WEB-INF下的lib中进行编译jar包，而之前导入的jar包却不在这里，所以，就会报错。解决办法把需要的jar包拷贝进入WEB-INF下的lib就可以了。"
  },
  
  {
    "title": "Maven使用阿里云镜像下载jar包失败",
    "url": "/posts/aliyun-jingxiang-xiazai-jar-shibai/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2022-08-08 13:47:00 +0800",
    





    
    "snippet": "将旧版阿里云映像&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/...",
    "content": "将旧版阿里云映像&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;替换成新版映像地址&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;"
  },
  
  {
    "title": "Spring Boot使用PageHelper",
    "url": "/posts/springboot-shiyong-pagehelper/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "      引入依赖      &lt;dependency&gt;      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;      &lt;version&gt;4.1.0&lt;/version&gt;  &lt;/dep...",
    "content": "      引入依赖      &lt;dependency&gt;      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;      &lt;version&gt;4.1.0&lt;/version&gt;  &lt;/dependency&gt;            在application.yml中做如下配置      # 分页配置  pagehelper:      helper-dialect: mysql      reasonable: true      support-methods-arguments: true      params: count=countSql            在代码中使用      PageHelper.startPage(pageNum, pageSize); // 表示从pageNum页开始，每页pageSize条数据  List&lt;Tools&gt; list = toolsMapper.findAll();  PageInfo&lt;Tools&gt; pageInfo = new PageInfo&lt;Tools&gt;(list);  return ServerResponse.createBySuccess(\"查询成功\",pageInfo);      "
  },
  
  {
    "title": "Python下载yaml模块报错",
    "url": "/posts/xiazai-yaml-baocuo/",
    "categories": "Knowledge, Python",
    "tags": "Python",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "报错信息cmd安装yaml，网上大部分写的都是pip install yaml，可是，执行完报错Could not find a version that satisfies the requirement yaml No matching distribution found for yaml.，但是执行pip install pyyaml就可以成功。报错原因python3.X只能使用pi...",
    "content": "报错信息cmd安装yaml，网上大部分写的都是pip install yaml，可是，执行完报错Could not find a version that satisfies the requirement yaml No matching distribution found for yaml.，但是执行pip install pyyaml就可以成功。报错原因python3.X只能使用pip install pyyaml来安装。"
  },
  
  {
    "title": "MyBatis报错，无效的列索引",
    "url": "/posts/mybatis-baocuo-wuxiao-de-liesuoyin/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "报错信息nested exception is org.apache.ibatis.type.TypeException: Could not set parameters for mapping: ParameterMapping{property= ‘groupid’,mode=IN, javaType=class java.lang.Object, jdbcType=null,nume...",
    "content": "报错信息nested exception is org.apache.ibatis.type.TypeException: Could not set parameters for mapping: ParameterMapping{property= ‘groupid’,mode=IN, javaType=class java.lang.Object, jdbcType=null,numericScale=null, resultMapld=‘null’, jdbcTypeName-=‘nl’,expression= 'null}. Cause: org.apache.ibatis.type.TypeException: Errorsetting non null for parameter #3 with JdbcType null. Try setting adifferent JdbcType for this parameter or a different configurationproperty. Cause: org.apache.ibatis.type.TypeException: Error setting nonnull for parameter #3 with JdbcType null . Try setting a differentJdbcType for this parameter or a different configuration property. Cause:java.sql.SQL Exception:无效的列索引报错原因使用了/*… */注释解决方法SQL本身没有问题，换一种注释方式即可  参考：SQL报错：无效的列索引"
  },
  
  {
    "title": "金融监管、监管科技以及银行业监管报送概述",
    "url": "/posts/jinrongjianguan-jianguankeji-yinhangyejianguan/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "上周金融科技前沿课程的主题是《监管科技》，韩海燕老师从金融监管引入，介绍了我国的金融监管体系，接着进入监管科技的详细讲解。我觉得最主要的是弄清楚监管科技的定义，以及在实际的银行业应用场景中具体的运作流程是怎么样的。韩老师讲的很全面，将ABCD等金融科技手段在监管系统中是如何运作的讲的很清楚，收获颇丰，但是比较少涉及到监管的对象和内容，仍没有很清楚监管机构是要监管什么东西？监管机构要求银行金融...",
    "content": "上周金融科技前沿课程的主题是《监管科技》，韩海燕老师从金融监管引入，介绍了我国的金融监管体系，接着进入监管科技的详细讲解。我觉得最主要的是弄清楚监管科技的定义，以及在实际的银行业应用场景中具体的运作流程是怎么样的。韩老师讲的很全面，将ABCD等金融科技手段在监管系统中是如何运作的讲的很清楚，收获颇丰，但是比较少涉及到监管的对象和内容，仍没有很清楚监管机构是要监管什么东西？监管机构要求银行金融业机构报送的资料有哪些？这些报送要求的目的分别是什么？所以这篇文章分为三个部分，一是介绍金融监管，二是介绍监科技，三是对银行业监管报送进行概述。文章目录      一、金融监管              1.1 什么是金融监管        1.2 金融监管的作用和意义        1.3 我国的金融监管体系              二、监管科技              2.1 什么是监管科技        2.2 监管科技的发展概况        2.3 监管科技的技术支撑                      2.3.1 云计算            2.3.2 大数据            2.3.3 人工智能            2.3.4 区块链            2.3.5 API                          2.4 监管科技的主要应用场景及案例                      2.4.1 反洗钱领域应用            2.4.2 地方金融监管应用            2.4.3 用户身份识别            2.4.4 市场交易行为监测            2.4.5 支付行为监测和风险防控                                三、银行业监管报送              3.1 理财与资金信托报送        3.2 反假币报送        3.3 个人银行账户申报        3.4 1104报表        3.5 人行大集中        3.6 EAST（监管数据标准化规范）        3.7 客户风险报送        3.8 对外金融资产负债及交易统计        3.9 征信报送        3.10 反洗钱报送        3.11 人行存贷款标准化报送        3.12 支付统计报送        3.13 金融基础数据报送            一、金融监管1.1 什么是金融监管金融监管是指政府通过特定的机构（如中央银行）对金融交易行为主体进行的某种限制或规定。顾名思义，监是监督，管是管理。  谁来监管 ：政府，并且是通过特定的机构（如中央银行）。  监管谁 ：监管的对象也在逐步扩大，从银行、非银行金融机构 –&gt; 准金融机构（如集体投资机构、贷款协会、 银行附属公司） –&gt; 整个金融体系。  监管啥 ：监管的主要内容包括对对证券业、保险业、信托业、商业银行的监管；对金融机构设立、资产负债业务的监管；对会计结算、外汇外债的监管等等，总之，监管的内容很多，其中，对商业银行的监管是监管的重点。  用什么方式进行监管：公告监管、准则监管、实体监管。（这里涉及一个“四结合的监管方法”，意思是外部监管与内部自律相结合、全面监管与重点监管相结合…）1.2 金融监管的作用和意义  减少金融风险。促进金融和经济健康发展，社会稳定。  保证公平。保障存款人和投资者的利益。同时有监督，避免暗箱操作，贪污腐败。  帮助金融机构不倒闭，不然像金融危机一样会危害整个社会。  宏观调控，进行货币政策，财政政策等的一种方式。（存款准备金）1.3 我国的金融监管体系一委一行两会一局二、监管科技2.1 什么是监管科技什么是监管科技简单地说，监管科技是为了应对金融科技创新发展中不断暴露出的风险与问题而采取的监管解决方案。监管科技分为两个方面  金融监管机构使用的“监管科技”（科技+监管，SupTech）  金融机构使用的“合规科技”（科技+合规，CompTech）监管科技参与主体这个过程涉及到金融监管机构（第一部分介绍过）、金融机构、金融科技公司/专业的监管科技公司。监管科技与金融科技的关系这两者具有交叉李生的关系，是同类信息技术在不同需求场景下的应用。比如，当科技应用于金融创新发展之时，称之为金融科技，但这可能引发金融风险与侵害消费者权益，而当科技应用于有效防范金融风险与保护消费者权益时，称为监管科技。监管科技的作用与意义简单来说，“科技+监管”能够有效应对“科技+金融”的风险。2.2 监管科技的发展概况国内外学者将监管科技的演变划分为三个阶段。当前，全球监管科技正处于从2.0到3.0时代的关键时期。  1.0: 2000年左右，金融机构引入新技术来监视和分析特定法规或流程的风险。  2.0：从2008年全球金融危机后大概十年间，实现了监管合规义务和技术的结合。  3.0：从“了解您的客户”到 “了解您的数据”的转变。当前，我国各级金融监管机构都十分重视以大数据、云计算、区块链、人工智能为代表的新兴信息科技研发，并已在很多重要领域实现了监管科技的落地应用。2.3 监管科技的技术支撑  这一节主要对云计算、大数据、人工智能、区块链、API技术做一个概述。都是很基础的概念知识。2.3.1 云计算基本原理云计算的商业运用至今己超过十年，是金融科技和监管科技各项技术应用中成熟度最高的。目前广为接受的是美国国家标准与技术研究院（NIST）给予的定义：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进人可配置的计算资源共享池。按照服务类型，可以分为  基础设施即服务（IaaS）：是指用户可以通过网络直接获取虚拟机或者其他资源等服务，比如比如我现在写文章的个人网站就是基于阿里云服务器搭建的，这里的阿里云其实就是IaaS。  平台即服务（PaaS）：是服务商可以给用户提供一个开发平台以及相应的配套服务。  软件即服务 （SaaS）：提供的是应用程序，用户直接使用。发展现状随着云计算产业的发展，中国已经成为全球最大的半导体市场，也成为增长最快的云计算市场之一。在监管科技领域的应用与实践云计算作为基础设施，可为监管科技提供良好的运营平台、开发平台。2.3.2 大数据基本原理大数据我们都比较熟悉了。泛指超出传统常规数据库软件工具能力范围的需要新处理模式的海量、多样化的数据集合和信息资产，包括传统结构化数据、半结构化数据和非结构化数据。大数据技术是伴随数据处理周期发展的一系列技术合集，包括数据采集、数据预处理、数据存储、数据挖掘和数据可视化等。其战略意义不在于庞大信息数据本身，而是要通过加工实现数据的“增值”，有助于促进统筹监管、实时监管和监管决策。在监管科技领域的应用与实践大数据在监管科技领域应用广泛，已落地多个应用场景。从业务流程看，大数据在监管科技领域的应用可分为数据收集和数据分析两大方面；从应用场景看，大数据可应用于用户身份识别、市场交易监控、合规数据报送、法律法规跟踪、风险数据融合分析、金融机构压力测试、信息系统安全等多个领域。2.3.3 人工智能基本原理人工智能是计算机科学的一个分支，全称是Artificial Intelligence，简称AI。它是一门结合了自然科学、社会科学、技 术科学的新兴交叉学科。本质是对人的思维进行模拟，从运算智能到感知智能最后到认知智能。主流技术包括计算机视觉、语音识别、机器学习、自然语言处理、知识图谱、任务规划、联邦学习等在监管科技领域的应用与实践当前人工智能技术突破、应用广泛。当前，AI已落地多个监管领域场景应用。  用户身份识别：OCR识别、人脸识别  可疑交易监测：机器学习、知识图谱  数据安全：联邦学习  欺诈用户识别：知识图谱  舆情监控：机器学习、自然语言处理  合规监管：机器学习、自然语言处理2.3.4 区块链基本原理区块链也称分布式账本（Distributrd Ledger），是由包含交易信息的区块从后向前有序链接起来的数据结构。区块链已经讲了很多，这里不再赘述了。  主要特征： 分布协作、难以篡改、强制执行、扩展性高。  主流技术：区块链技术是点对点传输、分布式数据存储、加密技术、共识机制、智能合约等多项技术要素的组合。发展现状区块链技术潜在的应用价值巨大，国内外政府组织、金融机构和科技公司均在不同程度上关注并开展区块链技术的研究 和应用。目前，主要体现在如下三个方面：  建应用，在具体的应用场景中应用区块链：国际标准化组织（ISO）设立了区块链和分布式记账技术委员会（ISO/TC 307）；国内金融领域，中国人民银行发布了《金融分布式账本技术安全规范》（JR/T0184-2020）等。  搭平台，发展区块链技术并对外相关服务：在公益、政务民生、电子存证、供应链协同、资产管理、证券交易等，区块链场景应用不断丰富。  定标准，制定区块链行业标准：国内外多个大型科技公司，通过底层区块链架设和基础设施搭建，对外提供数据上链服务，包括BaaS（Blockchain as a Service）平台、电子存证云服务等。在监管科技领域的应用与实践区块链技术在金融监管领域发挥重要作用，为降低合规成本、提高监管效率创造了条件，是监管科技重要的技术手段之一。在监管科技领域主要应用于关键信息存证、信息流转与共享，并已在多个应用场景实践，如反洗钱、票据交易、证券交易、 风险监测、合同存证、中小企业融资等。随着技术的发展，区块链与监管科技的契合度必然会越来越高，在未来的金融发展和金融监管方面，在注重区块 链技术突破的同时，一方面会探索更多的应用场景，另一方面也会更重视树立标准标杆、制定国际标准，并建立 完善的适合区块链发展的法律法规体系。2.3.5 API基本原理API全称是Application Programming Interface，即应用程序编程接口。其本质是一些预先定义好的函数，主要目的 是提供应用程序与开发人员以访问一组例程的能力 ，而使其无需访问源码或理解内部工作机制的细节 。主要包含内部 API、企业定制API、开放API（OpenAPI）三大类。在监管科技领域的应用与实践API已应用于监管科技领域的诸多场景，如支付API监控、开放银行的OpenAPI等，有效提升金融服务效能 同时，监管侧也强化对银行开放服务的合规管理，国内外监管机构均纷纷发布API相关规范文件，作为API开放的指导政策。API其实现在的应用场景也很多，比如前段时间我需要使用到天眼查的大样本数据，天眼查就提供了API可以供调用数据，但是太贵了…我只能通过爬虫解决问题。未来这种通过API接口提供服务会越来越多。2.4 监管科技的主要应用场景及案例  这一节主要简单概述了监管科技在反洗钱领域、地方金融监管、用户身份识别、市场交易行为监测、支付行为监测和风险防控五个方面的应用场景。案例引用自《中国监管科技发展报告（2020）》。此部分只涉及基本介绍，具体实现仍需探索。2.4.1 反洗钱领域应用应用背景及痛点分析反洗钱监管工作面临的痛点和问题主要集中如下两方面：  监管机构侧，面对报告机构上报的海量可疑交易报告和大额交易报告等业务数据，处理效率亟待提升。(据统计，2018年中国反洗钱中心共接收报告机构报送的 大额交易9.19亿份，可疑交易报告160.20万份。)  被监管机构侧，面临海量数据存储与计算难 、可疑交易识别难、传统交易监控系统易产生误报 、数据质量 管控难、缺少可视化工具等问题应用案例：基于Hadoop分布式架构大数据平台的反洗钱报送系统架构从日益增长的海量交易数据中高效甄别出可疑的洗钱实体、可疑洗钱实体的团伙关系、对客户进行风险评级，并通过可视化的交互方式，高效进行案宗核查。基于Hadoop分布式架构的大数据平台，在分层架构的基础 上，计算规则模型，解决数据计算和存储问题，保障报送时 效性；同时引入机器学习、深度学习等AI技术，提升可疑交易识别准确度，具有以下的特点：  海量数据存储与计算  按主题分类汇总数据，灵活构建用户画像  基于分布式架构，准实时监测和快速查询  机器学习和深度学习的应用2.4.2 地方金融监管应用应用背景及痛点分析近几年金融业态不断丰富，金融创新激增，金融乱象也随之屡有发生。相对大型持牌金融机构，地方金融经营主题普遍存在风险防范意识和风险管理能力较弱的情况，业务活动的风险系数整体偏高，给地方金融监督管理局的监管工作带来巨大挑战，主要体现在如下几点：  监管数量庞大，信息不对称：位于地方市区一级的地方金融机构，少则几千家多则数万家，靠传统现场检查基本难以覆盖。  专业人员的匮乏：监管对象复杂程度高，监管事项多，专业人员不足。  缺少技术手段支撑。应用案例：全国首创基于区块链的网贷风险处置应用——网络投票决策平台近年来网贷机构风险显露，监管部门及时引导网贷机构良性退出，其中，退出方案需通过网络投票方式表决，而普通的投票系统无法满足要求。某银行在市地方金融监督管理局的指导下，建设网络投票决策平台，运用区块链技术解决网贷机构清退流程中的互不信任问题，运用人脸识别技术解决身份验证问题，运用智能语音机器人解决公告送达问题。应用案例：智慧信访处理平台2018年7月，P2P风险集中爆发，某金融局信访量急剧增加。另一方面， 重复上报同一问题也引发大量重复性工作，传统人工回复耗时久、效率较低，信访工作人员回复时效压力激增。某银行在该金融局的指导下，运用AI等前沿科技，建设智慧信访处理平台，运用自然语言处理技术，自动检索出信访问题中的关键字，智能匹配最优答复内容，解 了人工操作需耗费大量时间的问题，大幅提升信访回复效率。上线首月，回复效率提升1倍，每周办结数上升30%，平均处理时间节省80%。2.4.3 用户身份识别应用背景及痛点分析近几年来，随着互联网高速发展，越来越多的金融服务和交易在线上进行，技术的发展带来了便利，但也给了不法分子伪造、隐藏身份的机会。不法分子盗用账号、盗用银行卡的行为日益猖獗 ，并随着灰黑产线上网络的扩张，泄露的账号、银行卡信息得以快速传播，被更多不法分子利用，极大损害消费者的权益。如何准确、有效地识别用户身份？是当下金融机构和监管部门急需解决的问题。应用案例：KYC充分利用人脸识别、图像OCR识别等技术，有效识别客户身份，提升识别和核验的准确性、有效性。2.4.4 市场交易行为监测应用背景及痛点分析科技进步促进了金融创新，互联网高速发展便利了市场交易线上化，但也滋生了大量新型金融欺诈犯罪，身份伪冒、信贷诈骗、薅羊毛、电信诈骗等欺诈案件层出不穷，欺诈风险已成为市场交易行为风险识别的重要内容。同时，监管机构为防止金融风险的发生，对金融机构也提出更高的合规要求，给金融机构的市场交易行为监测监督工作带来巨大挑战，集中体现在如下三个方面：  海量交易数据处理难：庞大客户群产生的海量交易数据，且数据来源分散、数据格式多样，超出了传统监管手段的处理能力  欺诈手段变化多，风险识别难：欺诈黑色产业链逐年增长，黑产规模庞大，互相助攻，欺诈手段不断变化，传统反欺诈技术手段难以识别风险  传统人工处理成本高、效率低、风险大：传统人工识别误判率较高、人工复核运营成本高、监控策略人为泄露损失风险大。应用案例：基于深度学习的反欺诈实时交易监测从制度标准、防控能力等方面建立面向客户的覆盖多产品、全渠道、全流程的企业级反欺诈平台。基于神经网络交易欺诈评分模型，结合大数据挖掘能力，进行交易的实时评分决策。应用案例：基于知识图谱的反欺诈黑产挖掘  黑产信息采集：充分利用内外部数据资源，采集与识别行业反欺诈黑产联盟数据，如：举报数据、公安数据等。  知识图谱黑产挖掘：基于知识图谱，挖掘潜在黑产网络路径。  知识图谱可视化辅助风险识别：通过可视化技术，直观展示黑产关联路径，辅助风险识别决策。2.4.5 支付行为监测和风险防控应用背景及痛点分析近几年，随着科技日新月异发展，我国第三方支付开启飞速发展，线上线下支付应用场景日益丰富，移动支付市场规模随之不断扩大。科技创新带来便利的同时，也带来了新的风险隐患，加大了金融机构和监管部门的风险防控和监管难度。集中体现在如下三个方面：  支付用户身份识别难，线上支付、移动支付过程中，身份伪冒风险大；  欺诈、洗钱等异常支付行为难识别；  客户信息、支付交易信息等存在泄露风险。应用案例：智能可疑交易监控科技基于“案例特征化、特征指标化、指标模型化”的推动方式，建立“立体监控+生态联防”的可疑交易风险防控体系，贯穿于事 前、事中和事后全流程环节。三、银行业监管报送  这部分主要回答这个问题：监管机构要求银行金融业机构报送的资料有哪些？这些报送要求的目的分别是什么？前面已经讲过，金融监管机构采用现场检查与非现场监管相结合的监管方式，其中又以非现场监管为主要形式。而非现场监管的主要手段即银行业各类监管数据的报送，当前，银行业的监管报送主要包括：            报送信息      监管部门                  理财与资金信托报送      人民银行              反假币报送      人民银行              个人银行账户申报      人民银行              1104 报表      银保监              人行大集中      人民银行              EAST报送      银保监              客户风险报送      银保监              对外金融资产负债及交易统计      国家外汇管理局              征信报送      人民银行              反洗钱报送      人民银行              人行存贷款标准化报送      人民银行              风险信息及特约商户信息报送      中国支付清算协会              理财信息报送      银保监              支付统计报送      人民银行              非居民金融账户涉税报送      人民银行              金融基础数据报送      人民银行              区域特色报表      各区域人行、银保监 区域化报表      3.1 理财与资金信托报送【主要业务概述】报送信息包括理财及资金信托产品的资产池及产品信息、产品募集信息、股票及其他股权资产中资金信托、理财产品投资明细信息等资产负债信息。可分为  日常：填报产品（资产池）成立信息和终止信息。  月末：填报产品的资金募集、资产池的资产负债信息。【报送目的】  全面、准确监测货币供应量与金融机构信贷规模  综合评估金融机构理财业务、资金信托业务的发展对现行货币政策传导机制的影响  参考资料：理财、资金信托专项统计制度3.2 反假币报送【主要业务概述】根据《中国人民银行货币鉴别及假币收缴、鉴定管理办法》（中国人民银行令〔2019〕第3号）第五章第三十一条：金融机构应当按照中国人民银行有关规定，对现金机具、人员培训、冠字号码以及假币收缴鉴定业务等进行数据管理，并将相关数据报送中国人民银行或其分支机构。【报送目的】规范货币鉴别及假币收缴、鉴定行为，保护货币持有人的合法权益3.3 个人银行账户申报【主要业务概述】根据《人民币银行结算账户管理系统业务处理办法》（银办发［2007］74号）第二十八条：银行应对存款人的开户申请书填写的事项和证明文件的真实性、完整性、合规性进行认真审查。开户申请书填写的事项齐全，符合开立基本存款账户、临时存款账户和预算单位专用存款账户条件的，银行应将存款人的开户申请书、相关的证明文件和银行审核意见等开户资料报送中国人民银行当地分支行，经其核准后办理开户手续；符合开立一般存款账户、其他专用存款账户和个人银行结算账户条件的，银行应办理开户手续，并于开户之日起5个工作日内向中国人民银行当地分支行备案。【报送目的】规范人民币银行结算账户的开立和使用，维护经济金融秩序稳定3.4 1104报表【主要业务概述】1104报表是指“1104工程”指定的报表，而“1104工程”又是指2003年11月4日银监会召开的“银行业金融机构监管信息系统建设”主席办公会和监管信息系统建设领导小组会议上决定启动的银行业金融机构监督信息系统这一重大举措。 这是我国银行业监管方式的一次革命。根据银保监《关于做好2022年银行业非现场监管报表填报工作的通知》，要求各金融机构报送的主要报表，包括资产负债，表外业务、流动性风险、贷款质量、投向行业和地区、重点客户等。2022年新增了四大类全新报表：  《G05个人存贷款情况统计表》：目前只报送贷款情況，由此可见，我国网络借货行业引发监管关注，国家正在不断加大对网络借货的监管力度。  《G27主要负债项目明细表》  《G53_VI域存货款情况表》：该表统计县域地区的存贷款业务，是为了继续做好原金融精准扶贫贷款存量统计、信贷支持脱贫地区、统计脱贫人口情況  《S68 绿色融资情况表》：要推进绿色融资【报送目的】帮助监管人员更加准确地识别银行机构的风险和抵御风险的能力，以帮助监管人员更加全面地对风险进行评价和预警。  参考资料：2022年度1104报表填报“浅析”3.5 人行大集中【主要业务概述】人民银行金融统计数据大集中自动化报送系统（简称PBOC Report），是基于现代计算机网络技术应用基础上，由人行总行设置金融统计数据服务器，建立的一个全国统一的金融统计数据库。人行针对各银行存贷款、中间业务、网点人员、互联网金融等汇总报表统计，贷款类报表较多，从行业、期限、业务种类分别进行统计。人行大集中报表主要包括常规报表和临时报表。  常规报表根据报送频度又分为日报、月报、季报和年报，月报根据报送日期先后分为月报一批和月报二批，共报送37张报表  临时报表主要是人行或者其他国家机关出于宏观经济调控等的需要，由人行营管部调统处发布通知，组织填报的报表【报送目的】通过采集和处理所有金融机构上报的金融统计数据，生成金融机构县级以上各层次的金融统计报表和数据，并实现对金融统计数据的统一管理、统一维护与共享。有很强的监管意义。比如公安部在16个城市试点基础上，在全国推广机动车检验标志电子化，为机动车所有人、驾驶人以及相关行业和管理部门提供电子证照服务。  参考资料: 一文读懂【人行大集中+金标】之【概念定义、报送内容、校验规则、监管意义】3.6 EAST（监管数据标准化规范）【主要业务概述】EAST系统全称Examination and Analysis Technology，是银监会在2008年开发的具有自主知识产权的检查分析系统，旨在顺应大数据发展趋势需求，并帮助监管部门提高检查效能。系统包含银行标准化数据提取、现场检查项目管理、数据模型生成工具、数据模型发布与管理等功能模块。2019年9月29日，中国银行保险监督管理委员会办公厅（以下简称“银保监会”）颁布关于印发《银行业金融机构监管数据标准化规范》（2019年版）的通知（以下简称“EAST 4.0”）。EAST作为1104之后的又一重量级监管报送系统，与1104报送汇总数据的维度明显不同。EAST报送的是数据明细，涵盖十个监管主题域、66张数据表、1852个数据项，包括客户、账户、交易、机构、合同、中间业务等所有明细数据，但这些明细又与1104报表有着严密的校验关系，EAST报送是将各银行千差万别的数据结构映射成统一的标准监管格式数据，以实现标准监管数据的采集和处理。EAST的报送明细数据量非常大。【报送目的】EAST报送将中小银行千差万别的数据结构映射成统一的标准监管格式数据，以实现标准监管数据的采集和处理统一的监管数据更利于机构之间的比对，有利于银行业风险的整体把控。3.7 客户风险报送【主要业务概述】银监会决定从2013年起实行新版客户风险统计制度，对各政策性银行、国有商业银行、股份制商业银行、邮储银行（目前邮储银行已经并入国有银行）进行客户信息汇总统计。客户风险数据报送包括对公及同业客户授信和表内外业务统计表、集团客户、供应链融资基本信息统计表、单一法人客户基本信息统计表、对公客户担保情况统计表、个人贷款违约情况统计表、个人违约贷款担保情况统计表相关客户风险信息，共计6张大表，18张子表。【报送目的】实现对主要银行业金融机构表内外信用风险的全面监测，重点加强集团客户授信风险监测能力，逐步完善前瞻性的风险识别信息3.8 对外金融资产负债及交易统计【主要业务概述】主要采集中国居民（包括境内机构和个人）与非中国居民之间各项国际收支交易的流量以及对外金融资产负债的存量数据。对外金融资产负债及交易申报业务大体归为两个部分：  国际收支交易：即中国居民与非中国居民之间的各项交易，包括货物买卖、服务贸易、股息利息收支、无偿捐赠以及赔偿，直接投资、证券投资、金融衍生产品以及存贷款等其他投资交易。  对外金融资产、负债：指中国居民对非中国居民拥有的金融资产，包括对外直接投资、证券投资、金融衍生产品投资、存款、发放贷款及各类应收款等；对外负债指中国居民对非中国居民承担的负债，包括吸收直接投资、发行有价证券、金融衍生产品投资、吸收存款、接受贷款及各类应付款等。【报送目的】进一步完善对外金融资产负债及交易统计3.9 征信报送【主要业务概述】目前正处于一代征信到二代征信的过渡阶段。2018年6月，中国人民银行征信中心发布了《人民银行征信系统数据采集规范（二代试行）》系统列标准，对个人征信、企业征信、征信查询等采集要求做了整体变更，对于银行的监管也愈发严格。二代征信分企业征信和个人征信：  个人征信报送基本信息、借贷信息、担保信息三大类报表  企业征信报送基本信息、借贷交易信息、担保交易信息、抵质押物信息、财务报表信息五大类报表【报送目的】  与现阶段的征信系统相比，二代征信系统采集业务范围更广、数据项更多  重新制定通用数据采集标准，全面支持商业银行新兴信贷业务数据采集  提供更方便、更规范的征信信息服务  建立更健全的数据质量管控体系及合规管理体系3.10 反洗钱报送【主要业务概述】反洗钱报送主要报送大额交易和可疑交易，  大额交易：指个人之间人民币5万，美元1万以上的交易，个人和单位之间50万以上人民币，或5万美元以上交易，单位客户之间200万人民币或20万美元之间的交易。  可疑交易：要求金融机构发现或者有合理理由怀疑客户、客户的资金或者其他资产、客户的交易或者试图进行的交易与洗钱、恐怖融资等犯罪活动相关的，不论所涉资金金额或者资产价值大小，应当提交可疑交易报告。【报送目的】规范金融机构大额交易和可疑交易报告行为3.11 人行存贷款标准化报送【主要业务概述】为了加强对金融机构存、贷款业务的及时监测和管理，人民银行在《存款统计分类及编码（试行）》、《贷款统计分类及编码（试行）》的基础上，拟定了《存款数据元（试行）》、《贷款数据元（试行）》，采用抽样统计的方法，建立《标准化存贷款综合抽样统计监测制度（试行）》，简称“金标”。包括存款余额、贷款余额、贷款发生额三张报文，部分银行根据自身业务属性，划分出活期存款余额、非活期存款余额、贷款余额、贷款发生额四类报文。【报送目的】逐月报送存贷款数据，以便及时、准确、系统地反映金融机构存款和贷款的结构、风险、利率水平等相关信息。3.12 支付统计报送【主要业务概述】支付信息统计分析(Statistical analysis of payment information)简称PISA，自2015年起，支付业务数据通过支付信息统计分析系统报送，取消支付业务报表手工报送方式。根据中国人民银行关于发布〈支付业务统计指标〉行业标准的通知。报送内容包括：支付环境统计指标、支付服务组织统计指标、人民币银行结算账户类统计指标、支付工具统计指标、支付系统统计指标、其它支付指标等。共计31张报表，1张年报，6张季报，24张月报。【报送目的】支付体系运行中形成的支付信息，是一国经济金融活动的原始记录，蕴含着社会资金运动的规律，是宏观经济运行的“晴雨表”，相对其他数据而言，具有准确性、实时性、客观性特点，有利于完善支付体系监督管理，促进支付研究和领导决策3.13 金融基础数据报送【主要业务概述】为了全面落实和实现国务院办公厅下发《关于全面推进金融业综合统计工作的意见》中的综合统计工作的总体目标，中国人民银行调查统计司于2020年6月12日下发了《关于建立金融基础数据统计制度的通知（试行）》。金融基础数据报送涵盖贷款、存款、债券、股权投资和特定目的载体投资等四方面，涉及交易对手管理、业务存量管理、合同管理、风险控制等各方面，统计内容细、要素多、数据量庞大。【报送目的】通过准确及时的全量逐笔明细采集，逐步实现金融业综合统计工作全覆盖，对高效赋能金融数据生产力、维护国家金融稳定具有重要意义，是打造国家金融基础数据库的重要组成部分。免责声明：监管报送是非常专业的领域，笔者仅根据所学知识整理资料，资料来源包括银保监会、人民银行、外管局、人行征信中心的监管发文、行业研究报告、公司研究报告、网络文章等，不做任何商业用途，旨在督促自己进步的同时，逐渐将知识沉淀下来。  参考：【金融科技前沿】【长文】金融监管、监管科技以及银行业监管报送概述"
  },
  
  {
    "title": "MySQL安全模式",
    "url": "/posts/mysql-anquan-moshi/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2022-07-21 10:47:00 +0800",
    





    
    "snippet": "MySQL安全模式要求不能对非主键的条件查询做update和delete操作报错信息update activity set type = 1 where title = 'aa' Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses ...",
    "content": "MySQL安全模式要求不能对非主键的条件查询做update和delete操作报错信息update activity set type = 1 where title = 'aa' Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Editor and reconnect. 0.000 sec解决方法查看安全模式开关状态show variables like 'SQL_SAFE_UPDATES';关闭安全模式SET SQL_SAFE_UPDATES = 0;  参考：MySQL安全模式"
  },
  
  {
    "title": "解决无法复制代码的问题",
    "url": "/posts/jiejue-wufa-fuzhi-daima-wenti/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2022-07-21 08:47:00 +0800",
    





    
    "snippet": "$(\"#content_views pre\").css(\"user-select\", \"text\");$(\"#content_views pre code\").css(\"user-select\", \"text\");",
    "content": "$(\"#content_views pre\").css(\"user-select\", \"text\");$(\"#content_views pre code\").css(\"user-select\", \"text\");"
  },
  
  {
    "title": "正计时",
    "url": "/posts/jinianri/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2022-07-12 13:47:00 +0800",
    





    
    "snippet": "            \t    ",
    "content": "            \t    "
  },
  
  {
    "title": "如何给Tomcat指定JDK和JRE",
    "url": "/posts/ruhe-gei-tomcat-zhiding-jdk/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "在Tomcat安装目录下的bin目录下找到setclasspath.sh，在最开始添加以下代码export JAVA_HOME=\"/home/jdk-1.8\"export JRE_HOME=\"/home/jdk-1.8/jre\"",
    "content": "在Tomcat安装目录下的bin目录下找到setclasspath.sh，在最开始添加以下代码export JAVA_HOME=\"/home/jdk-1.8\"export JRE_HOME=\"/home/jdk-1.8/jre\""
  },
  
  {
    "title": "Spring Boot配置Redis哨兵模式连接",
    "url": "/posts/springboot-peizhi-redis-shaobing-moshi-zhixing-lianjie/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "spring:    redis:        database: 0        # host: 127.0.0.1 # 哨兵模式无效youxiao        port: 6379        password: root # 哨兵模式有效        # 连接超时时长（毫秒）        pingInterval: 100000        timeout: 100000...",
    "content": "spring:    redis:        database: 0        # host: 127.0.0.1 # 哨兵模式无效youxiao        port: 6379        password: root # 哨兵模式有效        # 连接超时时长（毫秒）        pingInterval: 100000        timeout: 100000        sentinel:            master: mymaster            # 哨兵节点列表            nodes: 192.168.1.1:6371,192.168.1.1:6372,192.168.1.1:6373        jedis:            pool:                 # 连接池最大连接数（使用0表示没有限制）                max-active: 100                # 连接池最大阻塞等待时间（使用-1表示没有限制），超时报异常                max-wait: -1                # 连接池种的最大空闲连接（使用0表示没有限制）                max-idle: 10                # 连接池中的最小空闲连接（使用0表示没有限制）                min-idle: 5"
  },
  
  {
    "title": "Redis哨兵模式执行select 0命令报错： (error) ERR unknown command select, with args beginning with：0",
    "url": "/posts/redis-shaobing-moshi-zhixing-select0-baocuo/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "报错信息Redis哨兵模式执行select 0命令报错。(error) ERR unknown command select, with args beginning with: 0解决办法三个node节点为：10.12.168.68:6395,10.12.168.69:6395,10.12.168.70:6396redis-cli -h 10.12.168.68 -p 6395 -a 12...",
    "content": "报错信息Redis哨兵模式执行select 0命令报错。(error) ERR unknown command select, with args beginning with: 0解决办法三个node节点为：10.12.168.68:6395,10.12.168.69:6395,10.12.168.70:6396redis-cli -h 10.12.168.68 -p 6395 -a 1234   # 通，但是执行 select 0 报错redis-cli -h 10.12.168.69 -p 6395 -a 1234   # 通，但是执行 select 0 报错redis-cli -h 10.12.168.70 -p 6396 -a 1234   # 通，但是执行 select 0 报错虽然不能执行select 0，但是可以执行info，找到主节点信息，然后连接主节点再进行操作即可。产生原因因为哨兵的nodes不是主节点，也不是从节点，也就是说不是数据节点，而是监控节点，主要为了当主节点挂掉之后，选举新的主节点。所以在该nodes节点是无法运行select、keys等命令的。  参考：redis哨兵模式执行select 0命令报错： (error) ERR unknown command select, with args beginning with: 0"
  },
  
  {
    "title": "Maven连接私服如何配置",
    "url": "/posts/maven-lianjie-sifu-de-peizhi/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "Maven的setting.xml文件配置，该配置中使用了一个id为nexusProfile的profile，这个profile包含了相关的仓库配置，同时配置中又使用了activeProfile元素将这个profile激活，这样当执行Maven构件的时候，激活的profile会将仓库配置应用到项目中去。&lt;profiles&gt;    &lt;profile&gt;        &l...",
    "content": "Maven的setting.xml文件配置，该配置中使用了一个id为nexusProfile的profile，这个profile包含了相关的仓库配置，同时配置中又使用了activeProfile元素将这个profile激活，这样当执行Maven构件的时候，激活的profile会将仓库配置应用到项目中去。&lt;profiles&gt;    &lt;profile&gt;        &lt;!-- profile的id --&gt;        &lt;id&gt;nexusProfile&lt;/id&gt;        &lt;repositories&gt;            &lt;repository&gt;                &lt;!-- 仓库id，repositories可以配置多个仓库，保证id不重复 --&gt;                &lt;id&gt;nexus&lt;/id&gt;                &lt;!-- 仓库地址，即Nexus仓库组的地址 --&gt;                &lt;url&gt;http://nexus.m2plat.cn/repository/maven-public/&lt;/url&gt;                &lt;!-- 是否下载releases构件 --&gt;                &lt;releases&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                &lt;/releases&gt;                &lt;!-- 是否下载snapshots构件 --&gt;                &lt;snapshots&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                &lt;/snapshots&gt;            &lt;/repository&gt;        &lt;/repositories&gt;        &lt;pluginRepositories&gt;            &lt;!-- 插件仓库，Maven的运行依赖插件，也需要从私服下载插件 --&gt;            &lt;pluginRepository&gt;                &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt;                &lt;id&gt;nexus&lt;/id&gt;                &lt;url&gt;http://nexus.m2plat.cn/repository/maven-public/&lt;/url&gt;                &lt;releases&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                &lt;/releases&gt;                                &lt;snapshots&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                    &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;                    &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;                &lt;/snapshots&gt;            &lt;/pluginRepository&gt;        &lt;/pluginRepositories&gt;    &lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt;    &lt;activeProfile&gt;nexusProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt;配置镜像让Maven只使用私服，配置后本机所有的Maven项目都会从Nexus私服下载构件：&lt;!-- Maven对全部仓库的访问全部拦截到私服的public仓库中去 --&gt;&lt;!-- 如果私服关闭，那么就不能访问中央工厂了--&gt;&lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;nexus&lt;/id&gt;        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;        &lt;name&gt;Local Repository&lt;/name&gt;        &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;&lt;/mirrors&gt;配置Maven部署构件到Nexus：&lt;!-- 项目部署到私服配置 --&gt;&lt;distributionManagement&gt; &lt;!-- 远程部署管理信息 --&gt;    &lt;repository&gt; &lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt;        &lt;id&gt;releases&lt;/id&gt;        &lt;name&gt;Nexus Release Repository&lt;/name&gt;        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/releases/&lt;/url&gt;    &lt;/repository&gt;    &lt;snapshotRepository&gt; &lt;!-- 如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt;        &lt;id&gt;snapshots&lt;/id&gt;        &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/snapshots/&lt;/url&gt;    &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;  Nexus仓库对匿名用户是只读的，所以为了能够部署构件，还需要在setting.xml文件中配置认证信息：&lt;!--私服的验证信息--&gt;&lt;servers&gt;    &lt;server&gt;        &lt;id&gt;releases&lt;/id&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;admin123&lt;/password&gt;    &lt;/server&gt;    &lt;server&gt;        &lt;id&gt;snapshots&lt;/id&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;admin123&lt;/password&gt;    &lt;/server&gt;&lt;/servers&gt;配置好以后，就可以通过Maven的deploy命令，将项目的jar包部署到Nexus上，供其他项目组模块使用。大大加快了项目组的开发效率。  参考：为什么要用远程仓库（私服）maven 私服的使用及settings.xml的配置"
  },
  
  {
    "title": "JQuery格式化时间",
    "url": "/posts/jquery-geshihua-shijian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2022-04-19 13:47:00 +0800",
    





    
    "snippet": "$(function(){    alert(getDateString(new Date(\"2022-04-19\")));});function getDateString(time) {    var datetime = new Date();    datetime.setTime(time);    var year = datetime.getFullYear();    var...",
    "content": "$(function(){    alert(getDateString(new Date(\"2022-04-19\")));});function getDateString(time) {    var datetime = new Date();    datetime.setTime(time);    var year = datetime.getFullYear();    var month = datetime.getMonth() + 1 &lt; 10 ? \"0\"                 + (datetime.getMonth() + 1) : datetime.getMonth() + 1;    var date = datetime.getDate() &lt; 10 ? \"0\"                 + datetime.getDate() : datetime.getDate();    var hour = datetime.getHours() &lt; 10 ? \"0\"                 + datetime.getHours() : datetime.getHours();    var minute = datetime.getMinutes() &lt; 10 ? \"0\"                 + datetime.getMinutes() : datetime.getMinutes();    var second = datetime.getSeconds() &lt; 10 ? \"0\"                 + datetime.getSeconds() : datetime.getSeconds();    return year + \"-\" + month + \"-\" + date + \" \" + hour + \":\" + minute + \":\" + second;}"
  },
  
  {
    "title": "Kali拿取路由器pin码",
    "url": "/posts/kali-qu-luyouqi-pinma/",
    "categories": "Knowledge, SECURITY",
    "tags": "SECURITY",
    "date": "2022-04-10 13:47:00 +0800",
    





    
    "snippet": "网卡监听模式airmon-ng start wlan0　　扫描wash -i wlan0mon跑pin            网卡          物理地址         信道reaver -i wlan0mon -b 00:5A:13:40:AA:F8 -c 11 -vv -K 0通过pin获得wifi密码            网卡          物理地址           p...",
    "content": "网卡监听模式airmon-ng start wlan0　　扫描wash -i wlan0mon跑pin            网卡          物理地址         信道reaver -i wlan0mon -b 00:5A:13:40:AA:F8 -c 11 -vv -K 0通过pin获得wifi密码            网卡          物理地址           pin码reaver -i wlan0mon -b 78:A1:06:B6:2A:42 -p 92975934  参考：kali拿取路由器pin码"
  },
  
  {
    "title": "Kali暴力破解wifi密码",
    "url": "/posts/kali-pojie-wifi/",
    "categories": "Knowledge, SECURITY",
    "tags": "SECURITY",
    "date": "2022-04-09 13:47:00 +0800",
    





    
    "snippet": "查看本机网卡名称ifconfig  eth0有线网卡  wlan0无线网卡虚拟机无法访问网卡，所以需要使用外接的USB无线网卡。查看是否支持监听模式airmon-ng如果该命令没有任何输出则表示没有可以支持监听模式的网卡。开启无线网卡的监听模式airmon-ng start wlan0如果airmon-ng显示的是wifi0，就把wlan0改为wifi0，这时候再输入ifconfig，会发现...",
    "content": "查看本机网卡名称ifconfig  eth0有线网卡  wlan0无线网卡虚拟机无法访问网卡，所以需要使用外接的USB无线网卡。查看是否支持监听模式airmon-ng如果该命令没有任何输出则表示没有可以支持监听模式的网卡。开启无线网卡的监听模式airmon-ng start wlan0如果airmon-ng显示的是wifi0，就把wlan0改为wifi0，这时候再输入ifconfig，会发现wlan0变为了wlan0mon，这表明网卡监听模式已开启。搜索附近的WiFiairodump-ng wlan0mon使用airodump-ng命令列出无线网卡扫描到的WiFi热点详细信息，包括信号强度，加密类型，信道等，BSSID为MAC地址，PWR为信号强度（越小信号越强），CH为信道，#DATA为数据量，越大使用的人就越多。这里我们记下要破解WiFi的BSSID和信道。当搜索到我们想要破解的WiFi热点时可以Ctrl+C停止搜索。抓取握手包使用网卡的监听模式抓取周围的无线网络数据包，其中我们需要用到的数据包是包含了WiFi密码的握手包，当有新用户连接WiFi时会发送握手包。airodump-ng -c 10 --bssid D4:EE:07:12:57:80 -w ~/ wlan0mon  -c指定信道  -bssid指定目标路由器的BSSID  -w指定抓取数据包保存的目录强制连接到wifi的设备重连路由器现在我们使用aireplay-ng命令给连接到wifi的设备发送一个反认证包，使设备强制断开连接，随后它会自动再次连接wifi，这个自动连接过程会进行三次握手，会发送TCP包（里面包含加密的密码数据）。不难看出，airplay-ng生效的前提是WiFi热点中必须至少已经接入一个设备。由于刚刚打开的终端一直在执行抓包工作，所以我们重新打开一个终端，输入命令。aireplay-ng -0 5 -a D4:EE:07:12:57:80 -c AC:CF:85:B6:81 wlan0mon  -a指定目标路由器的BSSID  -c指定要攻击设备的MAC地址  -0为用deauth洪水攻击WiFi设备的次数，-0 0为无限，-0 5则攻击5次结束无线网卡的监听模式此时返回前一个终端，当窗口右上角出现WPA handshake时说明抓包成功，这个时候使用Ctrl+C命令停止抓包，同时结束无线网卡的监听模式。airmon-ng stop wlan0mon解压字典文件Kali本身就有字典文件，我们把它解压出来。gzip -d /usr/share/wordlists/rockyou.txt.gz暴力破解上面已经成功抓取到了握手包，现在要做的工作就是将握手包的密码和字典文件中的密码进行匹配。aircrack-ng -w /usr/share/wordlist/rockyou.txt ~/*.cap  -w字典路径 握手包路径生成字典文件如果Kali自带的字典文件不够用，可以通过crunch自己制作字典。crunch 10 10 012 xy &gt; /root/12345.txt   10 10表示制作一个10位数的密码  012 xy表示密码中包含数字012、xy这些元素  /root/12345.txt表示密码文本储存的路径以及名字"
  },
  
  {
    "title": "如何去除有道云笔记广告",
    "url": "/posts/ruhe-quchu-youdaoyun-de-guanggao/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2022-04-06 08:47:00 +0800",
    





    
    "snippet": "一、适用于6.0之前版本你只需要找到有道云笔记的安装路径*\\Youdao\\YoudaoNote\\theme\\build.xml，把下面的代码删掉&lt;PanelAd type=\"adpanel\" css=\"public\" ass=\"mainform panelclient PanelAd\"&gt;         &lt;panelTopLine type=\"panel\" css=\"AdP...",
    "content": "一、适用于6.0之前版本你只需要找到有道云笔记的安装路径*\\Youdao\\YoudaoNote\\theme\\build.xml，把下面的代码删掉&lt;PanelAd type=\"adpanel\" css=\"public\" ass=\"mainform panelclient PanelAd\"&gt;         &lt;panelTopLine type=\"panel\" css=\"AdPanel\" Dockstyle=\"top\"                        Bounds=\"0,0,0,1\"/&gt;         &lt;AdPhoto type=\"photo\" css=\"Ad AdPhoto\" ass=\"common fill\"/&gt;         &lt;AdText type=\"label\" css=\"AdText\" AnchorStyle=\"topleft\"                  Bounds=\"20,135,25,10\" Margin=\"0,0,0,0\"/&gt;&lt;/PanelAd&gt;之后保存，重启有道云笔记，就可以了。二、6.0及以后版本找到有道云笔记的安装路径*\\Youdao\\YoudaoNote\\theme\\build.xml，找到PanelAd标签&lt;PanelAd type=\"adpanel\" css=\"public\" ass=\"mainform PanelAd\"&gt;    &lt;panelTopLine type=\"panel\" css=\"AdPanel\" Dockstyle=\"top\" Bounds=\"0,0,0,1\"/&gt;    &lt;MiddlePhotoPanel type=\"panel\" css=\"public\" DockStyle=\"top\"                       Bounds=\"0,0,250,160\" Margin=\"0,13,0,13\"&gt;        &lt;AdPhoto type=\"photo\" css=\"Ad AdPhoto\" AnchorStyle=\"center\"                  AutoZoom=\"ZoomEqual\" Bounds=\"0,0,200,130\"&gt;            &lt;AdClose type=\"button\" css=\"adclear\" AnchorStyle=\"topright\"                      Bounds=\"-1,1,24,24\" /&gt;            &lt;AdText type=\"label\" css=\"AdText\" AnchorStyle=\"bottomleft\"                      Bounds=\"6,-6,25,10\"/&gt;        &lt;/AdPhoto&gt;    &lt;/MiddlePhotoPanel&gt;&lt;/PanelAd&gt;删除ass属性里面的panelclient这个值，我上面的截图是删除之后的。然后找到AdWraperMid这个标签，大概在466行，修改bounds属性值为0，0，0，0。&lt;!-- 底部广告--&gt;&lt;AdWraperMid type=\"panel\" css=\"public\" dockstyle=\"bottom\"              visible=\"false\" bounds=\"0,0,0,0\"&gt;    &lt;PanelAdMid type=\"control\" control=\"PanelAd\"&gt;    &lt;/PanelAdMid&gt;    &lt;LeftShadow type=\"control\" control=\"MidPanelLeftShadow\"/&gt;&lt;/AdWraperMid&gt;之后保存，重启有道云笔记，就可以了。  参考：如何去除有道云笔记广告（windows）"
  },
  
  {
    "title": "如何查看和修改Redis密码",
    "url": "/posts/ruhe-chakan-he-xiugai-redis-mima/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-03-24 13:47:00 +0800",
    





    
    "snippet": "打开redis.windows.conf文件，默认是没有requirepass root这句话的，因为默认密码是”“，加上这句话意思就是密码修改为root。",
    "content": "打开redis.windows.conf文件，默认是没有requirepass root这句话的，因为默认密码是”“，加上这句话意思就是密码修改为root。"
  },
  
  {
    "title": "Redis启动报错：The Windows version of Redis allocates a memory ...",
    "url": "/posts/redis-qidong-baocuo/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-03-24 13:47:00 +0800",
    





    
    "snippet": "报错信息The Windows version of Redis allocates a memory mapped heap for sharing with the forked process used for persistence operations. In order to share this memory, Windows allocates from the system...",
    "content": "报错信息The Windows version of Redis allocates a memory mapped heap for sharing with the forked process used for persistence operations. In order to share this memory, Windows allocates from the system paging file a portion equal to the size of the Redis heap. At this time there is insufficient contiguous free space available in the system paging file for this operation (Windows error 0x5AF). To work around this you may either increase the size of the system paging file, or decrease the size of the Redis heap with the --maxheap flag.Sometimes a reboot will defragment the system paging file sufficiently for this operation to complete successfully.Please see the documentation included with the binary distributions for more details on the --maxheap flag.Redis can not continue. Exiting.产生原因系统内存不足解决办法可以通过添加启动参数解决redis-server.exe  redis.windows.conf  --maxheap 1gbmaxheap参数可以带单位也可以不带单位，不带单位默认为字节"
  },
  
  {
    "title": "JSESSIONID什么时候生成并传递到前端的",
    "url": "/posts/jsessionid-shenme-shihou-shengcheng/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2022-03-03 13:47:00 +0800",
    





    
    "snippet": "如果客户端请求的cookie中不包含JSESSIONID，服务端调用request.getSession()时就会生成并传递给客户端，此次响应头会包含设置cookie的信息。如果客户端请求的cookie中包含JSESSIONID，服务端调用request.getSession()时就会根据JSESSIONID进行查找对象，如果能查到就返回，否则就跟没传递JSESSIONID一样。如果是彻底动...",
    "content": "如果客户端请求的cookie中不包含JSESSIONID，服务端调用request.getSession()时就会生成并传递给客户端，此次响应头会包含设置cookie的信息。如果客户端请求的cookie中包含JSESSIONID，服务端调用request.getSession()时就会根据JSESSIONID进行查找对象，如果能查到就返回，否则就跟没传递JSESSIONID一样。如果是彻底动静分离的时候session怎么标识？彻底的动静分离，对session并无影响，无论是直接浏览器url请求还是Ajax请求都会在客户端cookie生成sessionid；如果要通过缓存进行自行管理session也是可以的。  参考：jsessionid什么时候生成并传递到前端的？"
  },
  
  {
    "title": "Vue怎么将表单的值传给后台",
    "url": "/posts/ruhe-jiang-vueform-de-zhi-chuandao-houtai/",
    "categories": "Knowledge, Vue",
    "tags": "Vue",
    "date": "2022-02-22 13:47:00 +0800",
    





    
    "snippet": "...let form = null;form = this.questionForm;const params = form;const res = this.saveSubject(params);...",
    "content": "...let form = null;form = this.questionForm;const params = form;const res = this.saveSubject(params);..."
  },
  
  {
    "title": "Error Code：1175. You are using safe update mode and you tried to update a table without a WHERE tha",
    "url": "/posts/error-code-1175/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2022-02-22 10:47:00 +0800",
    





    
    "snippet": "MySQL在执行删除、更新语句时报这种错误，是因为在MySQL处于safe-updates模式中，如果where后跟的条件不是主键id，那么就会提示这种错误。解决方式有两种。  SET SQL_SAFE_UPDATES = 0;执行该命令更改MySQL数据库模式。  在where判断条件中跟上主键id，例如：delete from firstmysqldatabase.user where ...",
    "content": "MySQL在执行删除、更新语句时报这种错误，是因为在MySQL处于safe-updates模式中，如果where后跟的条件不是主键id，那么就会提示这种错误。解决方式有两种。  SET SQL_SAFE_UPDATES = 0;执行该命令更改MySQL数据库模式。  在where判断条件中跟上主键id，例如：delete from firstmysqldatabase.user where UserName='zhangsan' and ID&gt;=0;  参考：Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE tha"
  },
  
  {
    "title": "Java去掉JSON数据中值为null的属性字段",
    "url": "/posts/qudiao-json-hong-wei-null-de-yuansu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2022-02-18 01:47:00 +0800",
    





    
    "snippet": "@JsonInclude(JsonInclude.Include.NON_NULL) 此方法集成于Springboot2.0中，此方法的配置意在实体类与JSON互转的时候属性值为null的不参与序列化。使用时用注解的方式：放在标记类@JsonInclude(JsonInclude.Include.NON_NULL) public class HandlePayResponse {    pr...",
    "content": "@JsonInclude(JsonInclude.Include.NON_NULL) 此方法集成于Springboot2.0中，此方法的配置意在实体类与JSON互转的时候属性值为null的不参与序列化。使用时用注解的方式：放在标记类@JsonInclude(JsonInclude.Include.NON_NULL) public class HandlePayResponse {    private String platform_order_id;    private String order_id;    ...}属性public class HandlePayResponse {    ...    @JsonInclude(JsonInclude.Include.NON_NULL)     private String remark1;    private String remark2;    ...}配置文件中添加全局配置jackson.default-property-inclusion:non_null不过这配置要慎用，不然你项目中所有的实体类转为JSON需要显示时，值为null的都不会显示。使用前效果：{\"platform_order_id\":\"20191025112603731\",\"order_id\":\"12345\",\"merchant_id\":\"1\",\"sign\":\"3b8944f68fd2a3ef54dc349cba207e457435bd653375d10043adec832d9db14c\",\"sign_type\":\"SHA256\",\"total_amount\":\"1\",\"remark1\":null,\"remark2\":null,\"qrUrl\":\"https://qr.chinaums.com/bills/qrCode.do?id=30471910253040324116767159\",\"code\":\"SUCCESS\",\"errorMassage\":null}使用后效果：{\"platform_order_id\":\"20191025104352324\",\"order_id\":\"12345\",\"merchant_id\":\"1\",\"sign\":\"388db8c52c86b4843f676340fb12c10ee1ca2674eeb4057dd0cb58d00adc0e17\",\"sign_type\":\"SHA256\",\"total_amount\":\"1\",\"qrUrl\":\"https://qr.chinaums.com/bills/qrCode.do?id=30471910256385241102482750\",\"code\":\"SUCCESS\"}  参考：Java取掉json数据中值为null的属性字段"
  },
  
  {
    "title": "前端到后端400错误（The server cannot or will not process the request due to...）",
    "url": "/posts/qianduan-dao-houtai-400-cuowu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2022-01-21 01:47:00 +0800",
    





    
    "snippet": "错误信息The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request ...",
    "content": "错误信息The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).错误原因      第一种情况    前端提交的内容在后端一般都用String类型来接收，用Date类型接收会报错。        第二种情况    在提交表单的时候，填写的数据类型与Controller层的接收类型不一致导致400错误，可以检查一下代码，看看是不是请求参数错误，表单传过去的数据无法与pojo对象匹配。        第三种情况    Controller代码方法中使用了@RequestParam注解，但是在jsp中没有对应的@RequestParam注解name属性参数值，而且@RequestParam注解的required属性默认为true，也就是说，JSP中参数值必须对应@RequestParam注解的name属性值。  "
  },
  
  {
    "title": "表单中name相同的元素在后台如何获取",
    "url": "/posts/biaodan-zhong-name-xiangtong-ruhe-zaihoutai-huoqu-shuju/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2022-01-21 01:47:00 +0800",
    





    
    "snippet": "name相同的多个元素只需要在后台用String[] param = request.getParameterValues(\"param\")就可以了。",
    "content": "name相同的多个元素只需要在后台用String[] param = request.getParameterValues(\"param\")就可以了。"
  },
  
  {
    "title": "在静态方法中调用Spring注入的类",
    "url": "/posts/zaijingtaifangfa-zhong-diaoyong-spring-zhuru-de-lei/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-12-24 01:47:00 +0800",
    





    
    "snippet": "@Componentpublic class FileUtil {    @Autowired    FileConfig fileConfig;    @Autowired    private static FileConfig staticFileConfig;    @PostConstruct    public void init() {        staticFileCon...",
    "content": "@Componentpublic class FileUtil {    @Autowired    FileConfig fileConfig;    @Autowired    private static FileConfig staticFileConfig;    @PostConstruct    public void init() {        staticFileConfig = fileConfig;    }    public static void test() {        // getPath()是FileConfig中的方法        String path = staticFileConfig.getPath();    }}@PostConstruct注解被用来修饰一个非静态的void()方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。该注解的方法在整个Bean初始化中的执行顺序：Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)  参考：在静态方法中调用Spring注入的类的方法"
  },
  
  {
    "title": "图片转BASE64",
    "url": "/posts/tupian-zhuan-base64/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-12-24 01:47:00 +0800",
    





    
    "snippet": "public static String getImageStr(File file, String fileType)             throws IOException {    String fileContentBase64 = null;    String base64Str = \"data:\" + fileType + \";base64,\";    String co...",
    "content": "public static String getImageStr(File file, String fileType)             throws IOException {    String fileContentBase64 = null;    String base64Str = \"data:\" + fileType + \";base64,\";    String content = null;    //将图片文件转化为字节数组字符串，并对其进行Base64编码处理    InputStream in = null;    byte[] data = null;    //读取图片字节数组    try {        in = new FileInputStream(file);        data = new byte[in.available()];        in.read(data);        in.close();        //对字节数组Base64编码        if (data == null || data.length == 0) {            return null;        }        content = Base64.encodeBytes(data);        if (content == null || \"\".equals(content)) {            return null;        }        fileContentBase64 = base64Str + content;    } catch (IOException e) {        e.printStackTrace();    } finally {        if (in != null) {            in.close();        }    }    return fileContentBase64;}public static void main(String[] args) throws IOException {    String base64_str = getImageStr(new File(\"D:\\\\test.jpg\"), \"jpg\");}"
  },
  
  {
    "title": "Java工具类把URL转换成二维码",
    "url": "/posts/java-zhong-url-zhuan-erweima/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-12-24 01:47:00 +0800",
    





    
    "snippet": "&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;import java.awt.image.Bu...",
    "content": "&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;import javax.imageio.ImageIO;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.common.BitMatrix;public class CodeUtil {    private static final int BLACK = 0xFF000000;    private static final int WHITE = 0xFFFFFFFF;    public static String createQrCode(String url, String path, String fileName) {        try {            Map&lt;EncodeHintType, String&gt; hints = new HashMap&lt;&gt;();            hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\");            BitMatrix bitMatrix = new MultiFormatWriter().encode(url,                 BarcodeFormat.QR_CODE, 400, 400, hints);            File file = new File(path, fileName);            if (file.exists()                 || ((file.getParentFile().exists()                 || file.getParentFile().mkdirs()) &amp;&amp; file.createNewFile())) {                writeToFile(bitMatrix, \"jpg\", file);                return file.toString();            }        } catch (Exception e) {            e.printStackTrace();        }        return null;    }     static void writeToFile(BitMatrix matrix, String format, File file)                 throws IOException {        BufferedImage image = toBufferedImage(matrix);        if (!ImageIO.write(image, format, file)) {            throw new IOException(\"Could not write an image of format \"                 + format + \" to \" + file);        }    }     static void writeToStream(BitMatrix matrix, String format, OutputStream stream)                 throws IOException {        BufferedImage image = toBufferedImage(matrix);        if (!ImageIO.write(image, format, stream)) {            throw new IOException(\"Could not write an image of format \" + format);        }    }     private static BufferedImage toBufferedImage(BitMatrix matrix) {        int width = matrix.getWidth();        int height = matrix.getHeight();        BufferedImage image = new BufferedImage(width, height,             BufferedImage.TYPE_INT_RGB);        for (int x = 0; x &lt; width; x++) {            for (int y = 0; y &lt; height; y++) {                image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE);            }        }        return image;    }    public static void main(String[] args) {        createQrCode(\"www.baidu.com\",\"D:\\\\\",\"code.jpg\");    }}  参考：把url链接转换成二维码的工具类"
  },
  
  {
    "title": "Windows10下当前目录右键添加CMD快捷方式",
    "url": "/posts/win10-xia-dangqian-mulu-youjian-tianjia-cmd-kuaijiefangshi/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2021-12-23 13:47:00 +0800",
    





    
    "snippet": "Win10下Shift + 右键不能打开CMD，只能打开PowerShell。首先，在桌面新建一个文本文档。Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here]@=\"在此处打开命令行\"\"Icon\"=\"cmd.exe\"[HKEY_...",
    "content": "Win10下Shift + 右键不能打开CMD，只能打开PowerShell。首先，在桌面新建一个文本文档。Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here]@=\"在此处打开命令行\"\"Icon\"=\"cmd.exe\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\"\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt]@=\"在此处打开命令行\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\" \\\"cd %1\\\"\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here]@=\"在此处打开命令行\"\"Icon\"=\"cmd.exe\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\"\"然后将上面内容粘贴到该文本文档中，保存并将该文本文档以.reg结尾即可，名字可以随意取。（PS：@=”此处打开命令行”  该引号内文字可以随意修改成你想要显示的文字）。最后，双击注册一下就可以了，结果右键菜单中就有了。  参考：win10下当前目录右键添加CMD快捷方式"
  },
  
  {
    "title": "PowerDesigner中，修改了某个字段的name，其code也跟着修改",
    "url": "/posts/powerdesigner-zhong-xiugai-mouge-ziduan-de-name-code-yegenzhe-xiugai/",
    "categories": "Knowledge, PowerDesigner",
    "tags": "PowerDesigner",
    "date": "2021-12-13 13:47:00 +0800",
    





    
    "snippet": "  选择Tools -&gt; GeneralOptions…菜单，出现General Options对话框。  从Category中选择Dialog项。  取消右边“Name to Code mirroring”复选框。  参考：PowerDesigner中，修改了某个字段的name，其code也跟着修改",
    "content": "  选择Tools -&gt; GeneralOptions…菜单，出现General Options对话框。  从Category中选择Dialog项。  取消右边“Name to Code mirroring”复选框。  参考：PowerDesigner中，修改了某个字段的name，其code也跟着修改"
  },
  
  {
    "title": "PowerDesigner中name和comment的互相转换",
    "url": "/posts/powerdesigner-zhong-namehecomment-xianghu-zhuanhuan/",
    "categories": "Knowledge, PowerDesigner",
    "tags": "PowerDesigner",
    "date": "2021-12-13 13:47:00 +0800",
    





    
    "snippet": "在【Tools】-【Execute Commands】-【Edit/Run Script】下。输入下面你要选择的语句即可，也可以保存起来，以便下次使用，后缀为.vbs。需要注意的问题是：运行语句时必须在Module模式下，如果是导出报表时执行会出现错误提示。name转到comment注释字段'如果comment为空，则填入name；如果不为空，则保留不变，这样可以避免已有的注释丢失。Opti...",
    "content": "在【Tools】-【Execute Commands】-【Edit/Run Script】下。输入下面你要选择的语句即可，也可以保存起来，以便下次使用，后缀为.vbs。需要注意的问题是：运行语句时必须在Module模式下，如果是导出报表时执行会出现错误提示。name转到comment注释字段'如果comment为空，则填入name；如果不为空，则保留不变，这样可以避免已有的注释丢失。Option ExplicitValidationMode = TrueInteractiveMode = im_BatchDim mdl 'the current model'get the current active model Set mdl = ActiveModelIf (mdl Is Nothing) Then  MsgBox \"There is no current Model \"ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then  MsgBox \"The current model is not an Physical Data model. \"Else  ProcessFolder mdlEnd If' This routine copy name into comment for each table, each column and each view ' of the current folder Private Sub ProcessFolder(folder)  Dim Tab 'running   table    For Each Tab In folder.tables    If Not tab.isShortcut Then    '如果有表的注释，则不改变它.如果没有表注释.则把name添加到注释里面    If Trim(tab.comment) = \"\" Then     tab.comment = tab.name    End If    Dim col ' running column      For Each col In tab.columns    '如果col的comment为空，则填入name，如果已有注释，则不添加;这样可以避免已有注释丢失    If Trim(col.comment) = \"\" Then     col.comment = col.name    End If  NextEnd IfNextDim view 'running view  For Each view In folder.ViewsIf Not view.isShortcut And Trim(view.comment) = \"\"  Then  view.comment = view.nameEnd IfNext'go into the sub-packages  Dim f 'running folder  For Each f In folder.PackagesIf Not f.IsShortcut Then  ProcessFolder fEnd IfNextEnd Subcomment注释字段转到nameOption ExplicitValidationMode = TrueInteractiveMode = im_BatchDim mdl 'the current model  'get the current active model  Set mdl = ActiveModelIf (mdl Is Nothing) Then  MsgBox \"There is no current Model \"ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then  MsgBox \"The current model is not an Physical Data model. \"Else  ProcessFolder mdlEnd IfPrivate Sub ProcessFolder(folder)  On Error Resume Next  Dim Tab 'running table    For Each Tab In folder.tables    If Not tab.isShortcut Then    tab.name = tab.comment    Dim col 'running column      For Each col In tab.columns      If col.comment = \"\" Then      Else        col.name = col.comment      End If    Next    End If  Next    Dim view 'running view    For Each view In folder.Views    If Not view.isShortcut Then    view.name = view.comment    End If  Next    'go into the sub-packages    Dim f 'running folder    For Each f In folder.Packages    If Not f.IsShortcut Then    ProcessFolder f    End If  NextEnd Sub  参考：PowerDesigner中NAME和COMMENT的互相转换，需要执行语句"
  },
  
  {
    "title": "PowerDesigner 16.5逆向工程，从远程Oracle 11g数据库导出PDM",
    "url": "/posts/powerdesigner-cong-yuancheng-oracle-daochu-pdm/",
    "categories": "Knowledge, PowerDesigner",
    "tags": "PowerDesigner",
    "date": "2021-12-13 13:47:00 +0800",
    





    
    "snippet": "本文使用工具：  Oracle 11g  PowerDesigner 16.5第一步首先打开PowerDesigner，点击新建模型输入模型名称并选择数据库Oracle第二步选中当前模型，然后在菜单栏database -&gt; configure Connections在弹出窗口，点击Add Data Source按钮选择系统数据源选择Oracle Database Client Driv...",
    "content": "本文使用工具：  Oracle 11g  PowerDesigner 16.5第一步首先打开PowerDesigner，点击新建模型输入模型名称并选择数据库Oracle第二步选中当前模型，然后在菜单栏database -&gt; configure Connections在弹出窗口，点击Add Data Source按钮选择系统数据源选择Oracle Database Client Driver点击完成输入Data Source Name，选择TNS Service Name，输入UserID，点击Test Connection按钮参数说明：  Data Source Name：为数据源命名  Description：添加描述，可不填写  TNS Service Name：TNS服务名，若没有配置，可直接填写&lt;IP&gt;:&lt;端口号&gt;/&lt;实例名&gt;，如：127.0.0.1:1521/orcl  User ID：用户名输入Oracle数据库的用户名和密码，点击OK弹出Connection Successful提示然后回到Configure Data Connections界面，会看到增加了一个名为Oracle 11g的Data Source第三步在菜单上选择Database -&gt; Update Model From Database选择Using a data source，然后点击右侧的按钮从下拉列表框中选择刚才添加的Data Source ：Oracle 11g，然后输入Oracle登录的用户名和密码点击Connect，连接数据库，然后会显示数据库中所有的表选择要导出为模型的表，然后点击OK，执行导出操作  参考：powerdesigner16.5逆向工程，从远程oracle11g数据库导出PDM"
  },
  
  {
    "title": "Git使用规范",
    "url": "/posts/git-shiyong-guifan/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-12-08 13:47:00 +0800",
    





    
    "snippet": "Git分支命名规范Git分支分为集成分支、功能分支和修复分支，分别命名为develop、feature和hotfix，均为单数。不可使用features、future、hotfixes、hotfixs等错误名称。  master（主分支，永远是可用的稳定版本，不能直接在该分支上开发）  develop（开发主分支，所有新功能以这个分支来创建自己的开发分支，该分支只做只合并操作，不能直接在该分...",
    "content": "Git分支命名规范Git分支分为集成分支、功能分支和修复分支，分别命名为develop、feature和hotfix，均为单数。不可使用features、future、hotfixes、hotfixs等错误名称。  master（主分支，永远是可用的稳定版本，不能直接在该分支上开发）  develop（开发主分支，所有新功能以这个分支来创建自己的开发分支，该分支只做只合并操作，不能直接在该分支上开发）  feature-xxx（功能开发分支，在develop上创建分支，以自己开发功能模块命名，功能测试正常后合并到develop分支）  feature-xxx-fix（功能bug修复分支，feature分支合并之后发现bug，在develop上创建分支修复，之后合并回develop分支。PS:feature分支在申请合并之后，未合并之前还是可以提交代码的，所以feature在合并之前还可以在原分支上继续修复bug）  hotfix-xxx（紧急bug修改分支，在master分支上创建，修复完成后合并到master）注意事项：  一个分支尽量开发一个功能模块，不要多个功能模块在一个分支上开发。  feature分支在申请合并之前，最好是先pull一下develop主分支下来，看一下有没有冲突，如果有就先解决冲突后再申请合并。Git提交记录规范每个git commit记录都需要按照固定格式，具体格式为：  第一行：作者: 功能模块名称（或 功能模块ID）  第二行：提交描述，中英文皆可  参考：git 分支命名规范"
  },
  
  {
    "title": "如何在Excel中锁定行和列",
    "url": "/posts/excel-duoding-hanghelie/",
    "categories": "Knowledge, Excel",
    "tags": "Excel",
    "date": "2021-12-08 13:47:00 +0800",
    





    
    "snippet": "首先确定要锁定的行和列（图片中蓝色框住的部分），然后选定行和列所交接的单元格（图片中用红色框住的部分）然后选定菜单栏窗口—&gt;冻结窗口（如图）  参考：如何在excel中锁定行和列",
    "content": "首先确定要锁定的行和列（图片中蓝色框住的部分），然后选定行和列所交接的单元格（图片中用红色框住的部分）然后选定菜单栏窗口—&gt;冻结窗口（如图）  参考：如何在excel中锁定行和列"
  },
  
  {
    "title": "Jira修改默认时间格式",
    "url": "/posts/jira-xiugai-moren-shijian-geshi/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-10-11 08:47:00 +0800",
    





    
    "snippet": "日期显示格式我们希望看到2017-10-10、2017-10-05 01:34这样的格式，可以如下设置：管理-系统-外观，找到日期时间格式设置，如下图：修改保存后再次查看，会发现样式已修改：提示时间  服务端进入Jira的安装目录，默认为/opt/atlassian/jira/atlassian-jira/WEB-INF/classes文件夹  找到jpm.xml文件  找到对应的参数(ke...",
    "content": "日期显示格式我们希望看到2017-10-10、2017-10-05 01:34这样的格式，可以如下设置：管理-系统-外观，找到日期时间格式设置，如下图：修改保存后再次查看，会发现样式已修改：提示时间  服务端进入Jira的安装目录，默认为/opt/atlassian/jira/atlassian-jira/WEB-INF/classes文件夹  找到jpm.xml文件  找到对应的参数(key)jira.lf.date.relativize  将对应的值default-value改为false  重新启动Jira进入Jira中查看，发现已修改：表单填写格式调整我们在创建问题时，如果有字段为填写时间或日期的，会发现填写表单的时候发现日期时间字段信息依然是系统原有的格式，如下图：如果也需要调整为我们习惯的格式，可以通过以下步骤进行调整：管理-系统-一般配置-高级设置，修改以下项：  参考：Jira篇:Jira修改默认时间格式"
  },
  
  {
    "title": "Oracle 当前时间加一天、一分钟......",
    "url": "/posts/oracle-shijian-jisuan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-10-11 01:47:00 +0800",
    





    
    "snippet": "sysdate+1 -- 加1天sysdate+1/24 -- 加1小时sysdate+1/(24*60) -- 加1分钟sysdate+1/(24*60*60) -- 加1秒钟-- 加法 select add_months(sysdate, 12) from dual; -- 加1年 select add_months(sysdate, 1) from dual; -- 加1月 selec...",
    "content": "sysdate+1 -- 加1天sysdate+1/24 -- 加1小时sysdate+1/(24*60) -- 加1分钟sysdate+1/(24*60*60) -- 加1秒钟-- 加法 select add_months(sysdate, 12) from dual; -- 加1年 select add_months(sysdate, 1) from dual; -- 加1月 select to_char(sysdate+7, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1星期 select to_char(sysdate+1, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1天 select to_char(sysdate+1/24, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1小时 select to_char(sysdate+1/24/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1分钟 select to_char(sysdate+1/24/60/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1秒 -- 减法 select add_months(sysdate, -12) from dual; -- 减1年 select add_months(sysdate, -1) from dual; -- 减1月 select to_char(sysdate-7, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1星期 select to_char(sysdate-1, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1天 select to_char(sysdate-1/24, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1小时 select to_char(sysdate-1/24/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1分钟 select to_char(sysdate-1/24/60/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1秒  参考：Oracle 当前日期加一天、一分钟……"
  },
  
  {
    "title": "Oracle 如何查看版本信息",
    "url": "/posts/oracle-ruhe-chakan-banben/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-10-11 01:47:00 +0800",
    





    
    "snippet": "首先打开PLSQL并登录Oracle，新建一个SQL窗口输入select * from v$version，执行查询即可。",
    "content": "首先打开PLSQL并登录Oracle，新建一个SQL窗口输入select * from v$version，执行查询即可。"
  },
  
  {
    "title": "将时间转化为天小时分秒字符串",
    "url": "/posts/jiang-shijian-zhuanwei-hanzishifenmiao/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-10-11 01:47:00 +0800",
    





    
    "snippet": "public String formatSeconds(String secondsStr) {    Long seconds = new BigDecimal(secondsStr).longValue();    String timeStr = seconds + \"秒\";    if (seconds &gt; 60) {        long second = seconds ...",
    "content": "public String formatSeconds(String secondsStr) {    Long seconds = new BigDecimal(secondsStr).longValue();    String timeStr = seconds + \"秒\";    if (seconds &gt; 60) {        long second = seconds % 60;        long min = seconds / 60;        if (second == 0) {            timeStr = min + \"分钟\";        } else {            timeStr = min + \"分钟\" + second + \"秒\";        }        if (min &gt; 60) {            min = (seconds / 60) % 60;            long hour = (seconds / 60) / 60;            if (second == 0) {                if (min == 0) {                    timeStr = hour + \"小时\";                } else {                    timeStr = hour + \"小时\" + min + \"分钟\";                }            } else {                timeStr = hour + \"小时\" + min + \"分钟\" + second + \"秒\";            }            if (hour &gt; 24) {                hour = ((seconds / 60) / 60) % 24;                long day = (((seconds / 60) / 60) / 24);                timeStr = day + \"天\" + hour + \"小时\" + min + \"分钟\" + second + \"秒\";                if (second == 0) {                    if (min == 0) {                        if (hour == 0) {                            timeStr = day + \"天\";                        } else {                            timeStr = day + \"天\" + hour + \"小时\";                        }                    } else {                        timeStr = day + \"天\" + hour + \"小时\" + min + \"分钟\";                    }                } else {                    timeStr = day + \"天\" + hour + \"小时\" + min + \"分钟\" + second + \"秒\";                }            }        }    }    return timeStr;}"
  },
  
  {
    "title": "MySQL如何重置密码",
    "url": "/posts/mysql-ruhe-zhongzhi-mima/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-09-15 10:47:00 +0800",
    





    
    "snippet": "      修改my.ini文件    在my.ini文件的[mysqld]栏下添加skip-grant-tables，如下：     [mysql] # 设置MySQL客户端默认字符集 default-character-set=utf8  [mysqld] skip-grant-tables # 设置3306端口 port = 3306  # 设置MySQL的安装目录 basedir=D...",
    "content": "      修改my.ini文件    在my.ini文件的[mysqld]栏下添加skip-grant-tables，如下：     [mysql] # 设置MySQL客户端默认字符集 default-character-set=utf8  [mysqld] skip-grant-tables # 设置3306端口 port = 3306  # 设置MySQL的安装目录 basedir=D:\\MySQL\\mysql-5.7.27-winx64\\bin # 设置MySQL数据库的数据的存放目录 datadir=D:\\MySQL\\mysql-5.7.27-winx64\\data # 允许最大连接数 max_connections=200 # 设置MySQL服务端默认字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB             启动MySQL服务。     net start mysql        执行命令mysqld --skip-grant-tables，绕过权限启动MySQL。      重置账户密码。    进入MySQL安装目录cd D:\\MySQL\\mysql-5.7.27-winx64\\bin，执行命令mysql跳过权限验证连接数据库，update mysql.user set authentication_string=\"\" where user=\"root\";重置 root 用户的密码。        刷新权限表、设置新密码    设置新密码的语句：update user set password=password('新密码') where user='root' and host='localhost';，如：     mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec) mysql&gt; use mysql;  mysql&gt; update user set password=password('root')       &gt; where user='root' and host='localhost'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec)        参考：Windows MySQL重置root密码"
  },
  
  {
    "title": "Jira not show Rich text editor Jira不显示富文本编辑框解决方案",
    "url": "/posts/jira-buxianshi-fuwenbenkuang-de-jiejue-fangan/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-09-15 10:47:00 +0800",
    





    
    "snippet": "首先，后台系统界面，左侧进入Rich text editor，启用Enable rich text editor for users开关。然后，进入顶部的Issue标签，进入左侧的Field Configurations：进入Default Field Configuration后的Configure，定位需要启用富文本编辑框的字段，如Comment，点后面的Renderers：切换到Wik...",
    "content": "首先，后台系统界面，左侧进入Rich text editor，启用Enable rich text editor for users开关。然后，进入顶部的Issue标签，进入左侧的Field Configurations：进入Default Field Configuration后的Configure，定位需要启用富文本编辑框的字段，如Comment，点后面的Renderers：切换到Wiki style renderer：   参考：Jira not show Rich text editor Jira 不显示富文本编辑框解决方案"
  },
  
  {
    "title": "JS如何从后台返回的Map中取数据",
    "url": "/posts/js-ruhe-conghoutai-fanhuide-map-zhong-qushuju/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-09-15 10:47:00 +0800",
    





    
    "snippet": "&lt;script&gt;    var a = '{\"1\":\"100\"}';    b = 1;    var json = JSON.parse(a);     console.log(json[b]);&lt;/script&gt;",
    "content": "&lt;script&gt;    var a = '{\"1\":\"100\"}';    b = 1;    var json = JSON.parse(a);     console.log(json[b]);&lt;/script&gt;"
  },
  
  {
    "title": "Hibernate实体类注解配置",
    "url": "/posts/Hibernate-shitilei_shujie-peizhi/",
    "categories": "Knowledge, Hibernate",
    "tags": "Hibernate",
    "date": "2021-08-12 13:23:00 +0800",
    





    
    "snippet": "一、类级别注解1、@Entity(name=”EntityName”)必须，name为可选，对应数据库中一的个表。2、@Table(name=””, catalog=””, schema=””)可选，通常和@Entity配合使用，只能标注在实体的class定义处，表示实体对应的数据库表的信息。  name：可选，表示表的名称，默认表名和实体名称一致，只有在不一致的情况下才需要指定表名。  c...",
    "content": "一、类级别注解1、@Entity(name=”EntityName”)必须，name为可选，对应数据库中一的个表。2、@Table(name=””, catalog=””, schema=””)可选，通常和@Entity配合使用，只能标注在实体的class定义处，表示实体对应的数据库表的信息。  name：可选，表示表的名称，默认表名和实体名称一致，只有在不一致的情况下才需要指定表名。  catalog：可选，表示Catalog名称，默认为Catalog(“”)。  schema：可选，表示Schema名称，默认为Schema(“”)。二、属性级别注解1、@id必须，定义映射到数据库表的主键的属性，一个实体只能有一个属性被映射为主键，置于getXxxx()前。2、@GeneratedValue(strategy=GenerationType, generator=””)可选，strategy：表示主键生成策略，有AUTO，INDENTITY，SEQUENCE和TABLE4种，分别表示让ORM框架自动选择，根据数据库的Identity字段自动生成（主要是自动增长类型的主键，适用于SQL Server，MySQL，DB2，MS等数据库中，Oracle不适用），根据数据库表的Sequence字段生成（Oracle，DB2使用该种），使用一个特定的数据库表格来保存主键，默认为AUTO。  generator：表示主键生成器的名称，这个属性通常和ORM框架相关，例如，Hibernate可以指定uuid、native等主键生成方式。示例：@Id@GeneratedValues(strategy=StrategyType.INDETITY)public int getId() {    return id;}3、@Basic(fetch=FetchType, optional=true)可选，@Basic表示一个简单的属性到数据库表的字段的映射，对于没有任何标注的getXxxx()方法，默认即为@Basic。  fetch：表示该属性的读取策略，有EAGER和LAZY两种，分别表示主支抓取和延迟加载，默认为EAGER。  optional：表示该属性是否允许为null，默认为true。示例：@Basic(optional=false)public String getAddress() {    return address;}4、@Column可选，@Column描述了数据库表中该字段的详细定义，这对于根据JPA注解生成数据库表结构的工具非常有作用。  name：表示数据库表中该字段的名称，默认情形属性名称一致。  nullable：表示该字段是否允许为null，默认为true。  unique：表示该字段是否是唯一标识，默认为false。  length：表示该字段的大小，仅对String类型的字段有效。  insertable：表示在ORM框架执行插入操作时，该字段是否应出现INSETRT语句中，默认为true。  updateable：表示在ORM框架执行更新操作时，该字段是否应该出现在UPDATE语句中，默认为true，对于一经创建就不可以更改的字段，该属性非常有用，如对于birthday字段。  columnDefinition：表示该字段在数据库中的实际类型，通常ORM框架可以根据属性类型自动判断数据库中字段的类型，但是对于Date类型仍无法确定数据库中字段类型究竟是DATE，TIME还是TIMESTAMP，此外，String的默认映射类型为VARCHAR，如果要将String类型映射到特定数据库的BLOB或TEXT字段类型，该属性非常有用。示例：@Column(name=\"BIRTH\", nullable=\"false\", columnDefinition=\"DATE\")public String getBithday() {    return birthday;}5、@Temporal可选，用于定义映射到数据库的时间精度。@Temporal(TemporalType=DATE)       // 日期@Temporal(TemporalType=TIME)       // 时间@Temporal(TemporalType=TIMESTAMP)  // 两者兼具6、@Transient可选，@Transient表示该属性并非一个到数据库表的字段的映射，ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient，否则，ORM框架默认其注解为@Basic。示例：// 根据birth计算出age属性@Transientpublic int getAge() {    return getYear(new Date()) - getYear(birth);}三、映射继承关系1、@Inheritance(strategy)定义所选择的策略，这个注解需要在每个类层次结构(class hierarchy)最顶端的实体类上使用。strategy继承类所选策略，InheritanceType.TABLE_PER_CLASS，InheritanceType.SINGLE_TABLE，InheritanceType.JOINED。2、@MappedSuperclass可选，将超类的JPA注解传递给子类，使子类能够继承超类的JPA注解。标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。标注为@MappedSuperclass的类不能再标注@Entity或@Table注解，也无需实现序列化接口。示例：@MappedSuperclasspublic class Employee() {    ....} @Entity@Table(name=\"engineer\")public class Engineer extends Employee {     .....} @Entity@Table(name=\"manager\")public class Manager extends Employee {     .....}3、@Embedded可选，@Embedded将几个字段组合成一个类，并作为整个Entity的一个属性。例如User包括id，name，city，street，zip属性。我们希望city，street，zip属性映射为Address对象，这样，User对象将具有id，name和address这三个属性。Address对象必须定义为@Embededable。示例：@Embeddablepublic class Address {city, street, zip} @Entity@Table(name=\"user\")public class User {    @Embedded    @AttributeOverrides( {@AttributeOverride(name=\"firstName\",         column=@Column(name=\"first_name\")), ...})    public Address getAddress() {        ..........    }}   四、映射实体bean的关联关系1、共有属性  fetch  配置加载方式Fetch.EAGER -  及时加载，多对一默认是Fetch.EAGERFetch.LAZY - 延迟加载，一对多默认是Fetch.LAZY  cascade  设置级联方式CascadeType.PERSIST - 保存CascadeType.REMOVE - 删除CascadeType.MERGE - 修改CascadeType.REFRESH - 刷新CascadeType.ALL - 全部  targetEntity配置集合属性类型，如：@OneToMany(targetEntity=Book.class)2、@JoinColumn可选，@JoinColumn和@Column类似，这里描述的不是一个简单字段，而是一个关联字段（通常是外键），例如，描述一个@ManyToOne的字段。  name：该字段的名称。由于@JoinColumn描述的是一个关联字段，如ManyToOne，则默认的名称由其关联的实体决定。例如，实体Order有一个user属性来关联实体User，则Order的user属性为一个外键，其默认的名称为实体User的名称+下划线+实体User的主键名称。3、@ManyToOne(fetch=FetchType, cascade=CascadeType)可选，表示一个多对一的映射，该注解标注的属性通常是数据库表的外键。  optional：是否允许该字段为null，该属性应该根据数据库表的外键约束来确定，默认为true。  fetch：表示抓取策略，默认为FetchType.EAGER。  cascade：表示默认的级联操作策略，可以指定为ALL，PERSIST，MERGE，REFRESH和REMOVE中的若干组合，默认为无级联操作。  targetEntity：表示该属性关联的实体类型，该属性通常不必指定，ORM框架根据属性类型自动判断targetEntity。示例：// 订单Order和用户User是一个ManyToOne的关系，@JoinColumn定义外键列名// 在Order类中定义@ManyToOne()@JoinColumn(name=\"userid\")public User getUser() {    return user;}4、@OneToMany(fetch=FetchType, cascade=CascadeType)可选，描述一个一对多的关联，该属性应该为集体类型，在数据库中并没有实际字段。默认会使用连接表做一对多关联，添加@JoinColumn(name=”xxx_id”) 后，就会使用外键关联，而不使用连接表了。  fetch：表示抓取策略，默认为FetchType.LAZY，因为关联的多个对象通常不必从数据库预先读取到内存。  cascade：表示级联操作策略，对于OneToMany类型的关联非常重要，通常该实体更新或删除时，其关联的实体也应当被更新或删除。例如：实体User和Order是OneToMany的关系，则实体User被删除时，其关联的实体Order也应该被全部删除。示例：// 用户User和订单Order是一个OneToMany的关系，@JoinColumn(name=\"对方的数据库表外键列名\") // 在User类中定义@OneToMany(mappyedBy=\"user\")@JoinColumn(name=\"userid\")public &lt;Set&gt;Order getOrders() {    return orders;}5、@OneToOne(fetch=FetchType, cascade=CascadeType)可选，描述一个一对一的关联。  fetch：表示抓取策略，默认为FetchType.LAZY。  cascade：表示级联操作策略。          主表类A与从表类B的主键值相对应。        // 主表：@OneToOne(cascade=CascadeType.ALL)@PrimaryKeyJoinColumnpublic B getB(){    Return b;}// 从表：无              主表A中有一个从表属性是B类型的b        // 主表：@OneToOne(cascade=CascadeType.ALL)@JoinColumn(name=\"主表外键\")   //这里指定的是数据库中的外键字段。public B getB(){    return b;}// 从表：无              主表A中有一个从表属性是B类型的b，同时，从表B中有一个主表属性是A类型的a        // 主表：@OneToOne(cascade=CascadeType.ALL)@JoinColumn(name=\"主表外键\")   //这里指定的是数据库中的外键字段。public B getB(){    return b;}// 从表：@OneToOne(mappedBy=\"主表类中的从表属性\")public 主表类 get主表类(){    return 主表对象}        注意：@JoinColumn是可选的。默认值是从表变量名+”_“+从表的主键（注意，这里加的是主键。而不是主键对应的变量）。示例：    @OneToOne(fetch=FetchType.LAZY)public Blog getBlog() {    return blog;}      6、@ManyToMany可选，描述一个多对多的关联.多对多关联上是两个一对多关联，但是在ManyToMany描述中，中间表是由ORM框架自动处理。  targetEntity：表示多对多关联的另一个实体类的全名，例如：package.Book.class。  mappedBy：表示多对多关联的另一个实体类的对应集合属性名称。  fetch：表示抓取策略。  cascade：表示级联操作策略。示例：Teacher实体表示教师，Student实体表示学生，为了描述教师和学生关系，可以在Teacher和Student之间建立ManyToMany关联。public class Student{    private Set&lt;Teacher&gt; teachers = new HashSet&lt;Teacher&gt;();    @ManyToMany    @JoinTable(name=\"teacher_student\", joinColumns={@JoinColumn(name=\"sid\")},         inverseJoinColumns={@JoinColumn(name=\"tid\")})    public Set&lt;Teacher&gt; getTeachers() {        return teachers;    }}public class Teacher{    private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();    @ManyToMany(mappedBy=\"teachers\")    public Set&lt;Student&gt; getStudents() {        return students;    }}7、@JoinTable通过表关联的方式来映射一对多或者多对多的关系时，要使用@JoinTable这个标记。无注解属性的默认值。  如果属性为单一类型，则映射为@Basic。  如果属性对应的类型定义了@Embeddable注解，则映射为@Embedded。  如果属性对应的类型实现了Serializable， 则属性被映射为@Basic并在一个列中保存该对象的serialized版本。  如果该属性的类型为java.sql.Clob 或 java.sql.Blob，则作为@Lob并映射到适当的LobType。"
  },
  
  {
    "title": "Hibernate概述",
    "url": "/posts/Hibernate-gaishu/",
    "categories": "Knowledge, Hibernate",
    "tags": "Hibernate",
    "date": "2021-08-12 13:23:00 +0800",
    





    
    "snippet": "知识点  Hibernate概述数据持久化、ORM概念及原理、Hibernate编程步骤  Hibernate基础实体映射、ID生成器、Hibernate数据类型，Hibernate对象生命周期  关联映射一对一、一对多、多对多  高级映射组合映射、继承映射、值集合映射  事务管理事务传播性、事务隔离级别、事务控制  高级查询Criteria、HQL一、对象持久化1、持久（Persisten...",
    "content": "知识点  Hibernate概述数据持久化、ORM概念及原理、Hibernate编程步骤  Hibernate基础实体映射、ID生成器、Hibernate数据类型，Hibernate对象生命周期  关联映射一对一、一对多、多对多  高级映射组合映射、继承映射、值集合映射  事务管理事务传播性、事务隔离级别、事务控制  高级查询Criteria、HQL一、对象持久化1、持久（Persistence）  数据保存到可掉电设备中。  企业级应用中，即把内存中（瞬时）的数据保存到磁盘中加以“固化”。2、对象持久化技术  Java对象序列化和反序列化：数据查询困难，效率低  通过XML保存对象：复杂的xml操作，用于应用或公司间进行数据传输  JDBC：关系型数据库（RDBMS）,SQL(DDL, DML)：低水平的数据操作  对象关系映射(ORM)二、JDBC的缺点1、JDBC编程步骤  注册驱动  建立到数据库的连接  创建statement  执行SQL语句  处理ResultSet  关闭JDBC对象缺点：重复的编程步骤2、JDBC数据封装JDBC数据封装过程缺点：编程人员大部分精力花费在对ResultSet数据封装。三、ORM1、概念Object Relational Mapping（对象关系映射），通过使用描述对象和数据库之间映射的元数据，将Java程序中的对象自动持久化到关系数据库中。2、ORM包括四个部分  一个对持久类对象进行CRUD操作的API  一个语言或API用来规定与类和类属性相关的查询  一个规定元数据映射的工具  一种技术可以让ORM的实现同事务对象一起进行dirty checking, lazy association fetching以及其他的优化功能3、为什么采用ORM模式  提高生产率（Productivity）  可维护性（Maintainability）  更好的性能（Performance）  厂商独立性（Vendor independence）4、ORM主流框架  Hibernate：开源、性能、稳定性  TopLink：Oracle商业商业产品  Ibatis、MyBatis：开源、开放性  Apache OJB：开源、性能、稳定性、支持各种标准规范四、Hibernate简介Hibernate强大功能，按照Java基础语义（关联、继承、多态、组合及Java集合框架）的持久层开发，面对对象查询语言（HQL）。1、Hibernate 环境配置库文件包  antlr.jar — HQL转换工具  asm.jar, asm-attrs.jar — generate and transform classes  cglib.jar — 实现PO字节码的动态生成  dom4j.jar — 读写xml  hibernate3.jar — 核心包  jta.jar — JAVA 事务处理接口  commons-collections.jar — Apache Commons包中的一个，开发的集合类  commons-logging.jar — Apache Commons包中的一个，日志功能  ojdbc14.jar — oracle驱动包  c3p0.jar — 数据库连接池  ejb3-persistence.jar, hibernate-annotations.jar — 注解基础包  hibernate-entitymanager.jar — JPA支持包  javassit.jar — 代码生成包  jboss-archive-browsing.jar — support JPA entity manager2、Hibernate应用组成  DDL（可选） — sql  POJO（plain object java obiect） —  持久化类          Id      需映射属性的get/set方法      空参构造方法        Hibernate配置文件 — hibernate.cfg.xml or hibernate.properties  创建对象-关系映射 — .hbm.xml or 注解  通过Hibernate API访问数据库的代码3、Hibernate项目结构4、Hibernate开发步骤—API应用步骤  创建Hibernate配置，读取Hibernate配置文件及信息  用读取的配置信息生成SessionFactory对象  从SessionFactory对象获取一个Session对象  用Session对象生成事务  通过Session对象的方法进行操作  提交或回滚事务  释放session and session factory资源5、Hibernate核心API  Session是数据连接与事务管理 间的中间接口，它是非线程安全的，所以一个线程只创建一个Session对象。save()/beginTrasaction()/close()/delete()/get()/load()/persist()/saveOrUpdate()/update()  SessionFactory负责创建Session对象， SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。可以通过Configuration对象创建SessionFactory对象。openSession()/close()  Configuration配置hibernate，启动hibernate 时读取cfg.xml ，创建SessionFactory对象。config()  Transaction数据库事务接口, 可选接口，将应用代码从底层的事务实现中抽象出来，可能会是：JDBC事务、JTA用户事务commit()/rollback()  Query查询接口，query实例包装了HQL查询语句。list()/setXXX()  Criteria查询接口，用于创建和执行条件查询，更面向对象。list()/add()/createCriteria()6、Hibernate对象生命周期对象生命周期：一个对象从被创建开始，到不再使用，被垃圾回收期回收为止。一个持久化类的实例可能处于三种不同状态中的某一种。 这三种状态的定义则与所谓的持久化上下文(persistence context)有关:  瞬时状态 (Transient)  持久状态(Persistent)  脱管状态(Detached)Hibernate的Session对象就是这个所谓的持久化上下文  瞬时对象由new操作符创建，且尚未与Hibernate Session 关联的对象被认定为瞬时(Transient)的瞬时(Transient)对象不会被持久化到数据库中，也不会被赋予持久化标识(identifier)如果瞬时(Transient)对象在程序中没有被引用，它会被垃圾回收器(garbage collector)销毁使用Hibernate Session可以将其变为持久(Persistent)状态  持久对象持久(Persistent)的实例在数据库中有对应的记录，并拥有一个持久化标识(identifier)Hibernate会检测到处于持久(Persistent)状态的对象的任何改动，在当前操作单元(unit of work)执行完毕时将对象数据(state)与数据库同步(synchronize) 在默认情况下，Hibernate会在UPDATE中包含所有的列如果只更新那些被修改的列，可以通过修改配置dynamic-update=\"true\"来实现  脱管对象实例曾经与某个持久化上下文发生过关联，不过那个上下文被关闭了， 或者这个实例是被序列化(serialize)到另外的进程。 它拥有持久化标识，并且在数据库中存在一个对应的行 脱管(Detached)对象不在持久化管理之内，但对脱管对象的引用依然有效，对象可继续被修改Detached状态的对象可以再次与某个Session实例相关联而成为Persistent对象7、Hibernate对象状态转换"
  },
  
  {
    "title": "Hibernate笔记",
    "url": "/posts/Hibernate-biji/",
    "categories": "Knowledge, Hibernate",
    "tags": "Hibernate",
    "date": "2021-08-12 13:23:00 +0800",
    





    
    "snippet": "一、JavaProject配置过程（TestHibernate）1、加入Hibernate支持，即拷贝Hibernate支持jar包；创建hiberante.cfg.xml文件。（注解配置方式）&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC    \"-//Hiber...",
    "content": "一、JavaProject配置过程（TestHibernate）1、加入Hibernate支持，即拷贝Hibernate支持jar包；创建hiberante.cfg.xml文件。（注解配置方式）&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC    \"-//Hibernate/Hibernate Configuration DTD//EN\"    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库连接 --&gt;        &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;        &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/bbs_db&lt;/property&gt;        &lt;property name=\"connection.username\"&gt;root&lt;/property&gt;        &lt;property name=\"connection.password\"&gt;root&lt;/property&gt;               &lt;!-- 方言dialect --&gt;        &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;               &lt;!-- 是否显示sql语句 --&gt;        &lt;property name=\"show_sql\"&gt;true&lt;/property&gt;               &lt;!-- 数据库更新方式 --&gt;        &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt;               &lt;!-- 实体关系映射 --&gt;        &lt;mapping class=\"com.bbs.bean.User\"/&gt;           &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;2、创建持久化类Admin、User等，并通过注解配置“实体关系映射”。（重点）  涉及多个知识点，如：@Many To One映射关系，@One To Many等。（重点）  @GeneratedValue主键生成策略，常用strategy = GenerationType.AUTO（重点）  fetch=FetchType.LAZY懒加载设置及级联配置cascade设置。（重点）（此处为系统设计部分，初级工程师先关注具体使用。）package com.bbs.bean; import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table; // 用户注册实体类，对应t_user表@Entity@Table(name = \"t_user\")public class User {    private int userid;    private String username;    private String password;    private String sex;    private String hobbys;    private String birthday;    private String city;    private String email;    private String qq;    private String createtime;    @Id    @GeneratedValue(strategy = GenerationType.AUTO)    public int getUserid() {      return userid;    }    @Column(name = \"username\")    public String getUsername() {      return username;    }    @Column(name = \"password\")    public String getPassword() {      return password;    }    @Column(name = \"sex\")    public String getSex() {      return sex;    }    @Column(name = \"hobbys\")    public String getHobbys() {      return hobbys;    }    @Column(name = \"birthday\")    public String getBirthday() {      return birthday;    }    @Column(name = \"city\")    public String getCity() {      return city;    }    @Column(name = \"email\")    public String getEmail() {      return email;    }    @Column(name = \"qq\")    public String getQq() {      return qq;    }    @Column(name = \"createtime\")    public String getCreatetime() {      return createtime;    }    public void setUserid(int userid) {      this.userid = userid;    }    public void setUsername(String username) {      this.username = username;    }    public void setPassword(String password) {      this.password = password;    }    public void setSex(String sex) {      this.sex = sex;    }    public void setHobbys(String hobbys) {      this.hobbys = hobbys;    }    public void setBirthday(String birthday) {      this.birthday = birthday;    }    public void setCity(String city) {      this.city = city;    }    public void setEmail(String email) {      this.email = email;    }    public void setQq(String qq) {      this.qq = qq;    }    public void setCreatetime(String createtime) {      this.createtime = createtime;    } }3、JavaProject工程项目下，需要通过工厂类，获取session对象：（代码片段）package com.bbs.util; import org.hibernate.SessionFactory;import org.hibernate.cfg.AnnotationConfiguration;import org.hibernate.cfg.Configuration; /** * 自定义工厂类 单例模式 * Hibernate五大核心接口 * configuration接口、 * sessionFactory接口、 * session接口、 * Transaction接口、 * query接口 */public class MySessionFactory {    /**      * 1.设置私有的构造函数      * 2.定义一个静态变量      * 3.定义一段静态代码块      * 4.定义一个方法用于获取单例模式对象      * 5.单例模式分为饿汉模式和懒汉模式两种      */    private static SessionFactory sessionFactory;    static {        // 使用configuration接口获取hibernate配置文件 /hibernate.cfg.xml\"        // 第一种读取注解，第二种关系映射配置文件形式        Configuration configuration = new AnnotationConfiguration();        configuration.configure(\"hibernate.cfg.xml\");        // 获取工厂类        if (sessionFactory == null) {            sessionFactory = configuration.buildSessionFactory();        }    }    // 单例模式下具有一个私有的构造函数    private MySessionFactory() {    }    // 该方法用于获取工厂类    public static SessionFactory getSessionFactory() {        return sessionFactory;    }}4、调用HibernateAPI五大接口，SessionFactory、Session、Transaction，完成对象持久化过程，即保存操作。SessionFactory factory = MySessionFactory.getSessionFactory();Session session = factory.openSession();// 开启事务session.beginTransaction();Admin admin = new Admin();admin.setAdminname(\"zhangsan\");admin.setAdminpassword(\"123456\");// 临时状态（瞬时状态）Transientsession.save(admin);// 提交事务 session.getTransaction().commit(); session.close();及Query接口，HQL语句执行。Session session = factory.openSession();Query q = session.createQuery(\"from Admin e where e.adminid=:id\");q.setInteger(\"id\", 1);session.close();package com.bbs.test; import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import com.bbs.bean.User;import com.bbs.util.MySessionFactory; public class TestOpenSession {    public static void main(String[] args) {        SessionFactory factory = MySessionFactory.getSessionFactory();        Session session = factory.openSession();        // 开启事务        session.beginTransaction();        // 临时对象        User user = new User();        user.setCreatetime(\"1995-15-15\");        user.setPassword(\"123\");        user.setSex(\"1\");        user.setUsername(\"zhong\");        // 临时状态        // 持久化过程就是一个数据保存的过程        session.save(user);        // 提交事务        session.getTransaction().commit();        session.close();                //执行HQL语句        Session session1 = factory.openSession();        Query q = session1.createQuery(\"from User u where u.userid=:id\");        q.setInteger(\"id\", 8);        User user1 = (User) session1.get(User.class, 8);        System.out.println(\"1.\" + ((User)(q.list().get(0))).getUsername());        System.out.println(\"2.\" + user1.getUsername());        session1.close();    }}二、真实项目使用情况（TestHibernate1）对以上项目架构做分析，其中factory.openSession()的使用，在实际项目中，每次访问都产生一个session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session(每次都需要关闭；增加服务器负担)，所以，我们通常使用factory.getCurrentSession，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession就是，如果有已经使用的，用旧的，如果没有，建新的。getCurrentSession是在事务提交时自动调用close方法。实际项目中，我们选择使用getCurrentSession，并且此方法的使用，必须开启事务。使用SessionFactory.getCurrentSession()需要在hibernate.cfg.xml中如下配置：      如果采用jdbc独立引用程序配置如下    &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;            如果采用了JTA事务配置如下    &lt;property name=\"hibernate.current_session_context_class\"&gt;jta&lt;/property&gt;      具体使用步骤，如下：      需要上下文配置（即在hibernate.cfg.xml）中，需要配置     &lt;property name=\"current_session_context_class\"&gt;thread&lt;/property&gt;            代码如下     // 必须加入事务，线程安全 Session session = factory.getCurrentSession(); // 开启事务 session.beginTransaction(); Message e = (Message) session.get(Message.calss, 39); // 提交 自动close session.getTransaction().commit();        小提示：事务的处理，可以通过动态代理简化代码量，并可统一管理。  在实际项目中，我们还需要考虑数据库访问时效性。需要使用“JDBC连接池”。我们选择C3P0，具体配置如下，同时导入C3P0的jar包支持：&lt;!-- 连接池Jdbc connection pool C3P0 --&gt;&lt;property name=\"connection.pool_size\"&gt;1&lt;/property&gt;三、WebProject配置过程（TestSH1.1&amp;TestSH1.2）Hibernate的使用我们在JavaProject中已经充分展示了；在WebProject项目中，使用Hibernate的方式和Java项目中没有太多区别。我们在实际项目中，是通过Spring整合Hibernate的方式集成使用；总体来说写的代码绝对比单独用Hibernate然后在DAO类里写的代码要少；使用Spring整合Hibernate，配置较多。使用getCurrentSession，所有的操作都必须开启事务，所以需要我们注意，使用Spring框架的声明式事务，不再需要自动创建sessionFactory和session，不再需要手动控制事务的开启和关闭。（重点）具体实现步骤如下：  在Spirng配置文件中，装配一个org.springframework.orm.hibernate3.LocalSessionFactoryBean类。          方法一、配置数据源，读取配置文件，获取连接信息；设置hibernate配置信息。         &lt;bean id=\"dataSource\" destory-method=\"close\"      class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;     &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;     &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;     &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;     &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\"      class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\"&gt;     &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;     &lt;property name=\"annotatedClasses\"&gt;         &lt;list&gt;             &lt;value&gt;com.hp.model.User&lt;/value&gt;             &lt;value&gt;com.hp.model.Log&lt;/value&gt;         &lt;/list&gt;     &lt;/property&gt;     &lt;property name=\"hibernateProperties\"&gt;         &lt;props&gt;             &lt;prop key=\"hibernate.dialect\"&gt;               org.hibernate.dialect.OracleDialect             &lt;prop&gt;             &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;         &lt;/props&gt;     &lt;/property&gt; &lt;/bean&gt;        或者hibernate3版本的AnnotationSessionFactoryBean     &lt;bean id=\"sessionFactory\"   class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\"&gt;     &lt;property name=\"dataSource\"&gt;         &lt;ref bean=\"dataSource\"/&gt;     &lt;/property&gt;     &lt;property name=\"hibernateProperties\"&gt;         &lt;props&gt;             &lt;prop key=\"hibernate.dialect\"&gt;                 org.hibernate.dialect.MySQLDialect             &lt;/prop&gt;             &lt;!-- 加入事务，就不需要此处配置 --&gt;             &lt;prop key=\"hibernate.current_session_context_class\"&gt;thread&lt;/prop&gt;             &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;         &lt;/props&gt;     &lt;/property&gt;     &lt;property name=\"packagesToScan\"&gt;         &lt;list&gt;             &lt;value&gt;com.bbs.bean&lt;/value&gt;         &lt;/list&gt;     &lt;/property&gt; &lt;/bean&gt;            方法二、可以通过configLocation属性，加载hibernate.cfg.xml文件。    &lt;bean id=\"sessionFactory\"     class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;    &lt;property name=\"configLocation\" value=\"file:src/hibernate.cfg.xml\"&gt;    &lt;/property&gt;&lt;/bean&gt;            2. 在spring环境下，新建一个操作类TestSpringDao，需要继承HibernateDaoSupport。        public void test1() {    Session session = this.getSessionFactory().getCurrentSession();    session.beginTransaction();    Message e = (Message) session.get(Message.class, 35);    session.getTransaction().commit();}            在spring配置文件中，装配一个bean，必须注入属性sessioniFactory值。     &lt;bean id=\"testDao1\" class=\"com.bbs.test.TestSpringDao\"&gt;     &lt;property name=\"sessionFactory\"&gt;         &lt;ref bean=\"sessionFactory\"/&gt;     &lt;/property&gt; &lt;/bean&gt;            单元测试，此时可以获取Message对象，才成功。     ApplicationContext ac =      new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 如何获取类的实例 TestSpringDao dao1 = (TestSpringDao) ac.getBean(\"testDao1\"); dao1.test1();      四、实际项目使用（TestSH2）在Spring整合Hibernate框架中，方法中需要开启事务，以及提交事务。这部分代码基本都是模板化的，那么，我们如何在编写过程中把这部分代码省略，或者让系统自动为我们添加。这时，我们考虑到动态代理模式及SpringAOP。我们在实际项目中是如何做的？demo演示如下，在实际项目中我们选择Spring3.0及Hibernate3.0，我们选择注解的形式：      首先从配置文件开始：     &lt;!-- apache下的BasicDataSource，数据库连接池 --&gt; &lt;bean id=\"dataSource\" destory-method=\"close\"      class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;     &lt;property name=\"driverClassName\"&gt;         &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;     &lt;/property&gt;     &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;     &lt;property name=\"username\" value=\"root\"/&gt;     &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\"   class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\"&gt;     &lt;property name=\"dataSource\"&gt;         &lt;ref bean=\"dataSource\"/&gt;     &lt;/property&gt;     &lt;property name=\"hibernateProperties\"&gt;         &lt;props&gt;             &lt;prop key=\"hibernate.dialect\"&gt;                 org.hibernate.dialect.MySQLDialect             &lt;/prop&gt;             &lt;!-- 加入事务，就不需要此处配置 --&gt;             &lt;prop key=\"hibernate.current_session_context_class\"&gt;thread&lt;/prop&gt;             &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;         &lt;/props&gt;     &lt;/property&gt;     &lt;property name=\"packagesToScan\"&gt;         &lt;list&gt;             &lt;value&gt;com.bbs.bean&lt;/value&gt;         &lt;/list&gt;     &lt;/property &lt;/bean&gt;            设计dao层具体实现：    按照MVC的设计思想，我们创建UserDao层，com.bbs.dao.impl，创建类UserDaoImpl，继承HibernateDaoSupport，这个类是Spring框架提供的，我们使用其中的getHibernateTemplate方法(其中还有一个getSession方法，不常用)，getHibernateTemplate方法提供非常多的常用方法来完成基本的操作。而getSession方法是没有经过Spring包装的，Spring会把最原始的Session给你，在使用完之后必须自己调用相应的close方法，而且也不会对声明式事务进行相应的管理，一旦没有及时关闭连接，就会导致数据库连接池的连接数溢出；getHibernateTemplate()方法是经过Spring封装的，例如添加相应的声明式事务管理，由Spring管理相应的连接。    在实际的使用过程中发现的确getHibernateTemplate()比getSession()方法要好很多，但是有些方法在getHibernateTemplate()并没有提供，这时我们用HibernateCallback回调的方法操作数据库（比如对原生sql语句的执行）。    继承HibernateDaoSupport是可以的，但这种方式还是不太好，还是用到了继承，也就是没有降低所谓的耦合度。解决方案：                  Spring为我们提供了一个hibernateTemplate，你只需在配置文件中配置一个bean，并传入一个sessionFactory。        &lt;bean id=\"hibernateTemplate\"     class=\"com.springframework.orm.hibernate3.HibernateTemplate\"&gt;    &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt;                            然后在使用dao的时候注入该hibernateTemplate的bean即可。通过注解实现，因此@Component相当于&lt;bean id=\"\" class=\"\"/&gt;        @Componentpublic class UserDaoImpl implements UserDao {    @Autowired    private HibernateTemplate hibernateTemplate;    public HibernateTemplate getHibernateTemplate() {        return hibernateTemplate;    }    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {        this.hibernateTemplate = hibernateTemplate;    }}                            在方法中直接使用hibernateTemplate提供的get、load、find等方法。              事务管理，Spring提供的事务管理可以分为两类：编程式、声明式，编程式，其实就是在代码里面来控制，像Hibernate操作数据一样，开启事务，提交事务，这种方式有一定的局限性，所以我们一般是用声明式来配置我们的事务。在Spring和Hibernate整合架构中，声明式事务配置，包括以下三项：          事务管理类，我们选择DataSourceTransactionManager或HibernateTransactionManager；      以及声明式事务隔离级别及传播特性，我们通过advice通知拦截；（其中包括五部分，重点，难点）传播行为隔离级别  isolation=”default”        &lt;tx:method name=\"add\" propagation=\"REQUIRED\"     isolation=\"default\" read-only=\"false\"/&gt;                只读  read-only=”false”事务超时 timeout=”-1”        &lt;tx:method name=\"add\" timeout=\"-1\"&gt;                回滚规则 rollback-for=””  /  no-rollback-for=””        &lt;tx:method name=\"update\" no-rollback-for=\"\"&gt;                    以及哪些类和方法参与事务，我们通过SpringAOP实现。        经过以上配置，我们可以实现特定的业务，执行不同的事务策略。程序员只需要关心业务代码实现即可，极大的减轻了程序员额外代码。当然，事务切入点，我们是在sevice层去配置。        Spring配置中定义扫描器，把这些类，纳入Spring容器管理中。     &lt;!-- 扫描注解类 --&gt; &lt;context:component-scan base-package=\"com.bbs\"/&gt;            至此，我们的整合工作就基本完成了。我们可以通过一个单元测试，验证一下：     ApplicationContext ac =          new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 如何获取类的实例 UserDao dao1 = (UserDao) ac.getBean(\"userDaoImpl\"); User user = dao1.findUserById(9); System.out.println(user.getUsername());            业务层service改造，及注解实现：          @Service用于标注业务层组件，即service层类      @Controller用于标注控制层组件（如spingMVC中的控制类）      @Repository用于标注数据访问组件，即dao层类              @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。         @Service public class UserService implements IuserService {   @Autowired   private IUserDao userDao;   public IUserDao getUserDao() {     return userDao;   }   public void setUserDao(IUserDao userDao) {     this.userDao = userDao;   } }                          控制层改造及实现，及代码片段：使用@controller注解     @Controller public class LoginServlet {   @Autowired   IUserService userService;   public IUserService getUserService() {     return userService;   }   public void setUserService(IUserService userService) {     this.userService = uerService;   }   @RequestMapping(value=\"login\", method=RequestMethod.POST) }      五、BBS论坛项目，升级为SpringMVC3.0 + Hibernate3.0 + Mysql5.1 + DBCP数据源项目，升级项目名SH_BBSV4.0具体实现步骤，参考以为配置。六、Hibernate二级缓存  一级缓存及Session缓存，是事务级别的，由Hibernate去管理，一般不去干涉。  二级缓存是sessionFactroy缓存，我们可以根据业务访问及修改频次去设置缓存级别，及设置缓存文字。"
  },
  
  {
    "title": "Java静态代理与动态代理",
    "url": "/posts/jingtaidiali-he-dongtaidaili/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-08-12 01:47:00 +0800",
    





    
    "snippet": "代理概念为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。从图中可以看出，代理接口（Subject）、代理类（ProxySubject）、委托类（RealSubject）形成一个“品”字结构。根据代理类的生成时间不同可以...",
    "content": "代理概念为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。从图中可以看出，代理接口（Subject）、代理类（ProxySubject）、委托类（RealSubject）形成一个“品”字结构。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。下面以一个模拟需求说明静态代理和动态代理：委托类要处理一项耗时较长的任务，客户类需要打印出执行任务消耗的时间。解决这个问题需要记录任务执行前时间和任务执行后时间，两个时间差就是任务执行消耗的时间。静态代理由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。代理接口// 代理接口，处理给定名字的任务。 public interface Subject {      // 执行给定名字的任务，taskName 任务名     public void dealTask(String taskName);   } 委托类，具体处理业务// 真正执行任务的类，实现了代理接口。 public class RealSubject implements Subject {      // 执行给定名字的任务。这里打印出任务名    // 并休眠500ms模拟任务执行了很长时间     @Override      public void dealTask(String taskName) {          System.out.println(\"正在执行任务：\" + taskName);          try {             Thread.sleep(500);          } catch (InterruptedException e) {             e.printStackTrace();          }      }  }  静态代理类// 代理类，实现了代理接口。  public class ProxySubject implements Subject {          // 代理类持有一个委托类的对象引用      private Subject delegate;         public ProxySubject(Subject delegate) {          this.delegate = delegate;      }        // 将请求分派给委托类执行    // 记录任务执行前后的时间，时间差即为任务的处理时间     @Override      public void dealTask(String taskName) {          long stime = System.currentTimeMillis();           // 将请求分派给委托类处理          delegate.dealTask(taskName);          long ftime = System.currentTimeMillis();           System.out.println(\"执行任务耗时\" + (ftime - stime) + \"毫秒\");      } } 生成静态代理类工厂public class SubjectStaticFactory {     // 客户类调用此工厂方法获得代理对象。      // 对客户类来说，其并不知道返回的是代理类对象还是委托类对象。      public static Subject getInstance() {           return new ProxySubject(new RealSubject());      }  }  客户类public class Client1 {      public static void main(String[] args) {          Subject proxy = SubjectStaticFactory.getInstance();          proxy.dealTask(\"DBQueryTask\");      }     }  静态代理的优缺点  优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。  缺点：          代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。      如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。      动态代理动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。先看看与动态代理紧密关联的Java API。      java.lang.reflect.Proxy    这是Java动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。      // Proxy类的静态方法   // 方法 1: 该方法用于获取指定代理对象所关联的调用处理器    static InvocationHandler getInvocationHandler(Object proxy)         // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象    static Class getProxyClass(ClassLoader loader, Class[] interfaces)         // 方法 3：该方法用于判断指定类对象是否是一个动态代理类    static boolean isProxyClass(Class cl)         // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例    static Object newProxyInstance(ClassLoader loader,           Class[] interfaces, InvocationHandler h)               java.lang.reflect.InvocationHandler    这是调用处理器接口，它自定义了一个invoke方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。      // InvocationHandler的核心方法   // 该方法负责集中处理动态代理类上的所有方法调用。  // 第一个参数既是代理类实例，第二个参数是被调用的方法对象    // 第三个方法是调用参数。  // 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行    Object invoke(Object proxy, Method method, Object[] args)              java.lang.ClassLoader    这是类装载器类，负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class文件中。每次生成动态代理类对象时都需要指定一个类装载器对象。  动态代理实现步骤具体步骤是：  实现InvocationHandler接口创建自己的调用处理器  给Proxy类提供ClassLoader和代理接口类型数组创建动态代理类  以调用处理器类型为参数，利用反射机制得到动态代理类的构造函数  以调用处理器对象为参数，利用动态代理类的构造函数创建动态代理类对象// 分步骤实现动态代理 // InvocationHandlerImpl 实现了InvocationHandler接口// 并能实现方法调用从代理类到委托类的分派转发  // 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用  InvocationHandler handler = new InvocationHandlerImpl(..);     // 通过Proxy为包括Interface接口在内的一组接口动态创建代理类的类对象  Class clazz = Proxy.getProxyClass(        classLoader, new Class[] { Interface.class, ... });     // 通过反射从生成的类对象获得构造函数对象  Constructor constructor = clazz.getConstructor(        new Class[] { InvocationHandler.class });     // 通过构造函数对象创建动态代理类实例  Interface Proxy = (Interface)constructor.newInstance(        new Object[] { handler });   Proxy类的静态方法newProxyInstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。// 简化后的动态代理实现 // InvocationHandlerImpl实现了InvocationHandler接口// 并能实现方法调用从代理类到委托类的分派转发  InvocationHandler handler = new InvocationHandlerImpl(..);     // 通过Proxy直接创建动态代理类实例  Interface proxy = (Interface)Proxy.newProxyInstance( classLoader,       new Class[] { Interface.class },  handler );   动态代理实现示例创建自己的调用处理器//  动态代理类对应的调用处理程序类  public class SubjectInvocationHandler implements InvocationHandler {         // 代理类持有一个委托类的对象引用      private Object delegate;      public SubjectInvocationHandler(Object delegate) {          this.delegate = delegate;      }         @Override      public Object invoke(Object proxy, Method method, Object[] args)             throws Throwable {          long stime = System.currentTimeMillis();           // 利用反射机制将请求分派给委托类处理        // Method的invoke返回Object对象作为方法执行结果。          // 因为示例程序没有返回值，所以这里忽略了返回值处理          method.invoke(delegate, args);          long ftime = System.currentTimeMillis();           System.out.println(\"执行任务耗时\"+(ftime - stime)+\"毫秒\");          return null;      }  }   生成动态代理对象的工厂工厂方法列出了如何生成动态代理类对象的步骤// 生成动态代理对象的工厂public class DynProxyFactory {      //客户类调用此工厂方法获得代理对象。      //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。      public static Subject getInstance(){           Subject delegate = new RealSubject();          InvocationHandler handler = new SubjectInvocationHandler(delegate);          Subject proxy = null;          proxy = (Subject)Proxy.newProxyInstance(              delegate.getClass().getClassLoader(),               delegate.getClass().getInterfaces(),               handler);          return proxy;      }  }  动态代理客户类public class Client {      public static void main(String[] args) {          Subject proxy = DynProxyFactory.getInstance();          proxy.dealTask(\"DBQueryTask\");      }   }  动态代理机制特点首先是动态生成的代理类本身的一些特点。  包：如果所代理的接口都是public的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非public的接口（因为接口不能被定义为protect或 private，所以除public之外就是默认的package访问级别），那么它将被定义在该接口所在包（假设代理了com.ibm.developerworks包中的某非public接口A，那么新生成的代理类所在的包就是com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；  类修饰符：该代理类具有final和public修饰符，意味着它可以被所有的类访问，但是不能被再度继承；  类名：格式是“$ProxyN”，其中N是一个逐一递增的阿拉伯数字，代表Proxy类第N次生成的动态代理类，值得注意的一点是，并不是每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。      类继承关系：该类的继承关系如图：        由图可见，Proxy类是它的父类，这个规则适用于所有由Proxy创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。  接下来让我们了解一下代理类实例的一些特点。每个实例都会关联一个调用处理器对象，可以通过Proxy提供的静态方法getInvocationHandler去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的invoke方法执行，此外，值得注意的是，代理类的根类java.lang.Object中有三个方法也同样会被分派到调用处理器的invoke方法执行，它们是hashCode，equals和toString，可能的原因有：  一是因为这些方法为public且非final类型，能够被代理类覆盖；  二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。接着来了解一下被代理的一组接口有哪些特点。首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过65535，这是JVM设定的限制。最后再来了解一下异常处理方面的特点。从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于Throwable接口，但事实是否如此呢？答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛Throwable异常。那么如果在invoke方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Java动态代理类已经为我们设计好了解决方法：它将会抛出UndeclaredThrowableException异常。这个异常是一个RuntimeException类型，所以不会引起编译错误。通过该异常的getCause方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。总结一个典型的动态代理创建对象过程可分为以下四个步骤：  通过实现InvocationHandler接口创建自己的调用处理器IvocationHandler handler = new InvocationHandlerImpl(...);  通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});  通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});  通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法Object result = method.invoke(proxied,args)动态代理的优缺点  优点：动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。      缺点： 诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在 Java中本质上就行不通。    有很多条理由，人们可以否定对class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。  "
  },
  
  {
    "title": "Struts2中通配的使用",
    "url": "/posts/struts2-zhongde-tongpei/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 13:47:00 +0800",
    





    
    "snippet": "在struts.xml文件（配置PersonAction的配置文件）中修改成如下：第一个*的意思是调用的类，第二个*的意思是所用的类中的方法，花括号内的数字就是所用的第几个*。例如请求地址：http://localhost:8080/Struts2MVCDemo/Person_liming?name=liming，代表调用PersonAction类中的lingming()方法。",
    "content": "在struts.xml文件（配置PersonAction的配置文件）中修改成如下：第一个*的意思是调用的类，第二个*的意思是所用的类中的方法，花括号内的数字就是所用的第几个*。例如请求地址：http://localhost:8080/Struts2MVCDemo/Person_liming?name=liming，代表调用PersonAction类中的lingming()方法。"
  },
  
  {
    "title": "MVC",
    "url": "/posts/mvc/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 13:47:00 +0800",
    





    
    "snippet": "MVC的优点  多个视图可以共享一个模型，提高代码重用性。  三个模块相互独立，改变其中一个不会影响其他两个，降低了模块之间的耦合度，提高了模块的可拓展性。  控制器提高了程序的灵活性和可配置性，把不同的模型和不同的视图结合到一起。  在使用MVC进行Web项目开发时，系统分工很明确。系统分工  美工、网页设计人员 — view  Java开发人员 — controller  数据库开发人员...",
    "content": "MVC的优点  多个视图可以共享一个模型，提高代码重用性。  三个模块相互独立，改变其中一个不会影响其他两个，降低了模块之间的耦合度，提高了模块的可拓展性。  控制器提高了程序的灵活性和可配置性，把不同的模型和不同的视图结合到一起。  在使用MVC进行Web项目开发时，系统分工很明确。系统分工  美工、网页设计人员 — view  Java开发人员 — controller  数据库开发人员、高级开发人员、领域专家 — model核心部分"
  },
  
  {
    "title": "关于Struts2",
    "url": "/posts/guanyu-struts2/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 13:47:00 +0800",
    





    
    "snippet": "Struts2实现的MVC模式核心控制器：Filter拦截器。将Servlet解耦，可以用单元测试来对Action控制层进行测试。Struts2执行流程  定义FilterDispatcher，一般出现的过滤器最后。  FilterDispatcher将请求转发给ActionMapper，ActionMapper负责识别当前请求是否需要Struts2做出处理，如果需要处理的话，ActionM...",
    "content": "Struts2实现的MVC模式核心控制器：Filter拦截器。将Servlet解耦，可以用单元测试来对Action控制层进行测试。Struts2执行流程  定义FilterDispatcher，一般出现的过滤器最后。  FilterDispatcher将请求转发给ActionMapper，ActionMapper负责识别当前请求是否需要Struts2做出处理，如果需要处理的话，ActionMapper告诉FilterDispatcher需要处理这个请求，FilterDispatcher就建立ActionProxy对象，ActionProxy对象代理Action的运行及处理过程。  ActionProxy在创建时不知运行哪个Action，只知道url请求，会从ConfigurationManager中询问要调取哪个Action（struts.xml定义）。  ActionProxy取得Action对象同时获取相关拦截器以及可能使用的Result结果信息，着手建立ActionInvocation对象，ActionInvocation对象描述了Action运行的整个过程，并且调用相关的拦截器（Action调用之前部分），ActionInvocation做了一个很重要的工作，把Request请求的参数封装到ActionContext对象里，具体是封装到ActionContext中的值栈（ValueStack）。  调用Action类，执行Action中默认的execute方法（可以自定义），返回一个结果Result，然后选择在struts.xml中配置的页面。  按照相反次序执行拦截器链。  ActionInvocation对象执行完获得HttpServletResponse对象，然后以与过滤器配置定义相反的顺序执行过滤器向用户展示响应的结果。必须的jar包struts-core.xxx.jarxwork-core.xxx.jar。"
  },
  
  {
    "title": "StrutsMVCDemo6 - Struts2中的重定向（2.2.3）",
    "url": "/posts/struts2-zhongde-chongdingxiang/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 06:47:00 +0800",
    





    
    "snippet": "PersonAction.javapublic String execute() {     return \"p1_p2\";}  struts.xml&lt;!-- 公共配置包 --&gt;&lt;package name=\"default\" namespace=\"\" extends=\"struts-default\"&gt;    &lt;interceptors&gt;        &l...",
    "content": "PersonAction.javapublic String execute() {     return \"p1_p2\";}  struts.xml&lt;!-- 公共配置包 --&gt;&lt;package name=\"default\" namespace=\"\" extends=\"struts-default\"&gt;    &lt;interceptors&gt;        &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;        &lt;interceptor-stack name=\"myStack\"&gt;            &lt;!-- 19个拦截器 其中一个是自定义的 --&gt;            &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;            &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;        &lt;/interceptor-stack&gt;    &lt;/interceptors&gt;          &lt;default-interceptor-ref name=\"myStack\"&gt;&lt;/default-interceptor-ref&gt;            &lt;!-- 重定向 --&gt;    &lt;global-results&gt;        &lt;result name=\"index\" type=\"redirect\"&gt;/index.jsp&lt;/result&gt;        &lt;result name=\"p1_p2\" type=\"redirectAction\"&gt;p2&lt;/result&gt;    &lt;/global-results&gt;&lt;/package&gt;  运行结果"
  },
  
  {
    "title": "StrutsMVCDemo5 - Struts2拦截器的使用（2.2.3）",
    "url": "/posts/struts2-lanjieqi-de-shiyong/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 05:47:00 +0800",
    





    
    "snippet": "目录结构LogInterceptor.javapackage com.bbs.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;// 日志拦截器public class LogInterceptor impleme...",
    "content": "目录结构LogInterceptor.javapackage com.bbs.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;// 日志拦截器public class LogInterceptor implements Interceptor {    private static final long serialVersionUID = 1L;    public void destroy() {    }    public void init() {    }    public String intercept(ActionInvocation invocation) throws Exception {    // ActionInvocation实例，直接调用invoke方法，把当前拦截器执行过程交给    // 下一个拦截器，或者调用action的方法    System.out.println(\"执行了logInterceptor拦截器。。。上部分 \");    String rs = invocation.invoke();    System.out.println(\"执行了logInterceptor拦截器。。。下部分 \");    return rs;    }}struts.xml&lt;package name=\"animal\" namespace=\"/animal\" extends=\"person\"&gt;    &lt;interceptors&gt;        &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;    &lt;/interceptors&gt;            &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\" method=\"login\"&gt;        &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;    &lt;/action&gt;        &lt;action name=\"a2\" class=\"com.bbs.action.AnimalAction\" method=\"admin\"&gt;        &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;运行结果  经过测试，如果没有设置Struts核心拦截器，用户请求数据无法获取。  配置核心拦截器或拦截器栈。  其他的action或package不受影响，自定义的拦截器配置只对本action或包生效。解决方法需要配置核心拦截器或拦截器栈，如果自定义拦截器位于Struts核心拦截器前面，并且直接return视图名，可能会不经过核心拦截器，造成某些业务无法正常执行。&lt;interceptors&gt;    &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;&lt;/interceptors&gt;&lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\" method=\"login\"&gt;    &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;    &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;    &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;    &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;&lt;/action&gt;升级配置&lt;interceptors&gt;    &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;    &lt;interceptor-stack name=\"myStack\"&gt;        &lt;!-- 19个拦截器 其中一个是自定义的 --&gt;        &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;        &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;    &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;default-interceptor-ref name=\"myStack\"&gt;&lt;/default-interceptor-ref&gt;&lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\" method=\"login\"&gt;    &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;    &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;&lt;/action&gt;再次升级配置配置一个公共配置包，其他包中继承该公共配置包。&lt;!-- 公共配置包 --&gt;&lt;package name=\"default\" namespace=\"\" extends=\"struts-default\"&gt;    &lt;interceptors&gt;        &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;        &lt;interceptor-stack name=\"myStack\"&gt;            &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;            &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;        &lt;/interceptor-stack&gt;    &lt;/interceptors&gt;        &lt;default-interceptor-ref name=\"myStack\"&gt;&lt;/default-interceptor-ref&gt;&lt;/package&gt;  日志拦截器LogInterceptor.javapackage com.bbs.interceptor; import java.lang.reflect.Method;import javax.management.DescriptorKey;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor; // 日志拦截器public class LogInterceptor implements Interceptor {    private static final long serialVersionUID = 1L;    public void destroy() {      }    public void init() {       }    public String intercept(ActionInvocation invocation) throws Exception {        // ActionInvocation实例，直接调用invoke方法，把当前拦截器执行过程交给        // 下一个拦截器，或者调用action的方法        System.out.println(\"执行了logInterceptor拦截器。。。上部分 \");        String rs = invocation.invoke();        // 获取已经执行的action，以及执行的具体方法，        // 并且获取注解标记(注解中有针对相关操作的说明)        Object action = invocation.getAction();        String method = invocation.getProxy().getMethod();        // 通过反射，method是String类型，获取具体对象        Method m = action.getClass().getMethod(method, null);                DescriptorKey dk = m.getAnnotation(DescriptorKey.class);                String value = \"\";        if (dk != null) {            value = dk.value();        }        System.out.println(\"执行了：\" + value + \"操作\");                System.out.println(\"执行了logInterceptor拦截器。。。下部分 \");        return rs;   } }AnimalAction.java@DescriptorKey(\"执行了admin方法\")public String admin() {    System.out.println(admin);    return SUCCESS;}运行结果"
  },
  
  {
    "title": "StrutsMVCDemo4 - Struts2传递对象的方式（2.2.3）",
    "url": "/posts/struts2-chuandi-duixiang-de-fangshi/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 04:47:00 +0800",
    





    
    "snippet": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocati...",
    "content": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;    &lt;!-- 开发阶段，struts配置修改，重新加载 --&gt;    &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\"&gt;&lt;/constant&gt;        &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello2\" class=\"com.bbs.action.PersonAction\" method=\"zhangxueyou\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello3\" class=\"com.bbs.action.PersonAction\" method=\"liming\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;    &lt;include file=\"struts*.xml\"&gt;&lt;/include&gt;&lt;/struts&gt;struts1.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;package name=\"animal\" namespace=\"\" extends=\"person\"&gt;        &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;            &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;action name=\"a2\" class=\"com.bbs.action.AnimalAction\" method=\"admin\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;            &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action;// struts2 Action层public class PersonAction {    private String name;        // 视图从值栈中获取name    public String getName() {        System.out.println(\"调用getName方法\");        return name;    }        public void setName(String name) {        System.out.println(\"调用setName方法，在actionContext中记录值栈信息\");        this.name = name;    }        // 默认执行    public String execute() {        // 返回result结果,视图名字        return \"success\";    }        public String zhangxueyou() {        if (true) {            return \"success\";        } else {            return \"error\";        }    }        public String liming() {        System.out.println(\"获取页面参数：\" + name);        if (name == null || name.equals(\"\")) {            return \"error\";        }        return \"success\";    }    }Admin.javapackage com.bbs.action;/** * 管理员实体类，对应t_admin表  * @author Administrator * */public class Admin {    private int adminid;    private String adminname;    private String adminpassword;    public int getAdminid() {        return adminid;    }    public void setAdminid(int adminid) {        this.adminid = adminid;    }    public String getAdminname() {        return adminname;    }    public void setAdminname(String adminname) {        this.adminname = adminname;    }    public String getAdminpassword() {        return adminpassword;    }    public void setAdminpassword(String adminpassword) {        this.adminpassword = adminpassword;    }    public String toString() {       return \"adminid=\" + adminid + \", adminname=\"        + adminname + \", adminpassword=\" + adminpassword;    }}AnimalAction.javapackage com.bbs.action;import com.opensymphony.xwork2.ActionSupport;/** * action 模型，处理animal方法 * ActionSupport类不仅实现了action接口。还实现了： * validateable      提供校验功能 * validationAware   提供校验功能 * textprovider      提供国际化支持 * localprovider     提供国际化支持 * serializable      序列化接口 * 所以，更多情况下，我们需要继承ActionSupport类 * @author Administrator */public class AnimalAction extends ActionSupport {    private static final long serialVersionUID = 1L;    private String name;    private String pwd;    private Admin admin;        public String getName() {        return name;    }    public String getPwd() {        return pwd;    }    public void setName(String name) {        this.name = name;    }    public void setPwd(String pwd) {        this.pwd = pwd;    }    public String login() {        if (name.trim().equals(\"mayi\") &amp;&amp; pwd.trim().equals(\"123\")) {            return SUCCESS;        } else {            return ERROR;        }    }        public void validate() {        // 验证        if (name == null || pwd == null) {            addFieldError(name, \"不能为空！\");        }    }    public String admin() {        System.out.println(admin);        return SUCCESS;    }    }success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;%@  taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;    &lt;title&gt;Success页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    success    获取值栈属性值：${name }&lt;br/&gt;    id : ${admin.adminid }&lt;br/&gt;    username : ${admin.adminname }&lt;br/&gt;    password : ${admin.adminpassword }&lt;br/&gt;    &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;请求地址http://localhost:8080/Struts2MVCDemo/a2?name=mayi&amp;pwd=123&amp;admin.adminname=zhong&amp;admin.adminid=456&amp;admin.adminpassword=789运行结果控制台浏览器"
  },
  
  {
    "title": "StrutsMVCDemo3 - Struts2后台验证（2.2.3）",
    "url": "/posts/struts2-houtai-yanzheng/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 03:47:00 +0800",
    





    
    "snippet": "Struts2提供的后台效验流程  拦截器调用指定的方法validate()方法；  判断保存错误的Map集合是否为空，为null，才执行action的execute()方法；  如果不为null, 说明验证有错误，不放行。数据效验原理public synchronized void addFieldError(String fieldName, String errorMessage) {...",
    "content": "Struts2提供的后台效验流程  拦截器调用指定的方法validate()方法；  判断保存错误的Map集合是否为空，为null，才执行action的execute()方法；  如果不为null, 说明验证有错误，不放行。数据效验原理public synchronized void addFieldError(String fieldName, String errorMessage) {    // 保存所有的错误信息的map集合    // 同一个key，可以对应多个值    final Map&gt; errors = internalGetFieldErrors();    // 先根据当前错误的key，去错误的map集合中查找，看是否已经存在！    List thisFieldErrors = errors.get(fieldName);    // 当前错误的key，在map集合不存在    if (thisFieldErrors == null) {        thisFieldErrors = new ArrayList();        errors.put(fieldName, thisFieldErrors);    }    // 设置错误信息！    thisFieldErrors.add(errorMessage);}错误处理配置错误视图标记input对应的JSP页面，出现错误跳转到index.jsp，合理显示错误信息。&lt;package name=\"animal\" namespace=\"\" extends=\"person\"&gt;    &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\"&gt;        &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;    &lt;!-- 开发阶段，struts配置修改，重新加载 --&gt;    &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\"&gt;&lt;/constant&gt;        &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello2\" class=\"com.bbs.action.PersonAction\" method=\"zhangxueyou\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello3\" class=\"com.bbs.action.PersonAction\" method=\"liming\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;    &lt;include file=\"struts*.xml\"&gt;&lt;/include&gt;&lt;/struts&gt;struts1.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;package name=\"animal\" namespace=\"\" extends=\"person\"&gt;        &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;            &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action;// struts2 Action层public class PersonAction {    private String name;        // 视图从值栈中获取name    public String getName() {        System.out.println(\"调用getName方法\");        return name;    }        public void setName(String name) {        System.out.println(\"调用setName方法，在actionContext中记录值栈信息\");        this.name = name;    }        // 默认执行    public String execute() {        // 返回result结果,视图名字        return \"success\";    }        public String zhangxueyou() {        if (true) {            return \"success\";        } else {            return \"error\";        }    }        public String liming() {        System.out.println(\"获取页面参数：\" + name);        if (name == null || name.equals(\"\")) {            return \"error\";        }        return \"success\";    }    }AnimalAction.javapackage com.bbs.action;import com.opensymphony.xwork2.ActionSupport;/** * action 模型，处理animal方法 * ActionSupport类不仅实现了action接口。还实现了： * validateable      提供校验功能 * validationAware   提供校验功能 * textprovider      提供国际化支持 * localprovider     提供国际化支持 * serializable      序列化接口 * 所以，更多情况下，我们需要继承ActionSupport类 * @author Administrator */public class AnimalAction extends ActionSupport {    private static final long serialVersionUID = 1L;    private String name;    private String pwd;        public String getName() {        return name;    }    public String getPwd() {        return pwd;    }    public void setName(String name) {        this.name = name;    }    public void setPwd(String pwd) {        this.pwd = pwd;    }    public String login() {        if (name.trim().equals(\"mayi\") &amp;&amp; pwd.trim().equals(\"123\")) {            return \"success\";        } else {            return \"error\";        }    }        public void validate() {        // 验证        if (name == null || pwd == null) {            addFieldError(name, \"不能为空！\");        }    }    }success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;%@  taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;    &lt;title&gt;Success页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    success获取值栈属性值：${name }    &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "StrutsMVCDemo2 - 获取Struts2值栈中的值（2.2.3）",
    "url": "/posts/huoqu-struts2-zhizhan-zhongde-zhi/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 02:47:00 +0800",
    





    
    "snippet": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocati...",
    "content": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;        &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello2\" class=\"com.bbs.action.PersonAction\" method=\"zhangxueyou\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello3\" class=\"com.bbs.action.PersonAction\" method=\"liming\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action;// struts2 Action层public class PersonAction {    private String name;        // 视图从值栈中获取name    public String getName() {        System.out.println(\"调用getName方法\");        return name;    }        public void setName(String name) {        System.out.println(\"调用setName方法，在actionContext中记录值栈信息\");        this.name = name;    }        // 默认执行    public String execute() {        // 返回result结果,视图名字        return \"success\";    }        public String zhangxueyou() {        if (true) {            return \"success\";        } else {            return \"error\";        }    }        public String liming() {        System.out.println(\"获取页面参数：\" + name);        if (name == null || name.equals(\"\")) {            return \"error\";        }        return \"success\";    }    }success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;%@  taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;    &lt;title&gt;Success页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    success获取值栈属性值：${name }    &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "StrutsMVCDemo - Struts2配置步骤（2.2.3）",
    "url": "/posts/struts2-peizhi-buzhou/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 01:47:00 +0800",
    





    
    "snippet": "步骤  导入jar包，核心包struts2-core.xxx.jar、xwork-core.xxx.jar。      在Web项目上，支持Struts2特性：在web.xml中定义一个filter。这个filter就是FilterDispatcher类的具体实现类：StrutsPrepareAndExecuteFilter     &lt;filter&gt;     &lt;filter...",
    "content": "步骤  导入jar包，核心包struts2-core.xxx.jar、xwork-core.xxx.jar。      在Web项目上，支持Struts2特性：在web.xml中定义一个filter。这个filter就是FilterDispatcher类的具体实现类：StrutsPrepareAndExecuteFilter     &lt;filter&gt;     &lt;filter-name&gt;struts2&lt;/filter-name&gt;     &lt;filter-class&gt;         org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter     &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt;     &lt;filter-name&gt;struts2&lt;/filter-name&gt;     &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;        创建视图层，我们使用JSP技术，创建了三个不同的页面。  创建Action模型类，PersonAction类。  创建配置文件struts.xml文件，名字默认“struts.xml”。  过滤器会读取“struts.xml”。      struts.xml文件中，继承struts-default。     &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        相当于我们有了Struts2提供的默认的拦截器或拦截器栈配置。例如：          处理乱码      封装请求数据      国际化      ServletContext      ServletConfig      Session      Request        配置action，对应url和action类；以及返回的result视图。  启动Tomcat。目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理Struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;        &lt;!-- hello1请求               必须要指定name属性;              namespace命名空间             package就是要区分请求包名    --&gt;    &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;            &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;                    &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action; // struts2 Action层public class PersonAction {             // 默认执行       public String execute() {              // 返回result结果，视图名字              return \"success\";       }      }index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Success页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;异常由于我们使用的是独立的Struts2的jar包，所以关闭使用Spring的管理即可解决以上异常。正常的项目中是不需要关闭的。&lt;!-- 不需要默认Spring容器管理struts --&gt;&lt;constant name=\"struts.objectFactory\"           value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;"
  },
  
  {
    "title": "Topic，Topic分片和Queue",
    "url": "/posts/topic-topicfenpian-queue/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "Queue是RocketMQ中的另一个重要概念。在对该概念进行分析介绍前，我们先来看一张图：为了简化分析过程，在这张图中没有包含Slave Broker。Broker1，Broker2和Broker3都是Master Broker。如果各Master Broker有Slave Broker，Slave Broker中的结构和其对应的Master Broker完全相同。从本质上来说，Rocke...",
    "content": "Queue是RocketMQ中的另一个重要概念。在对该概念进行分析介绍前，我们先来看一张图：为了简化分析过程，在这张图中没有包含Slave Broker。Broker1，Broker2和Broker3都是Master Broker。如果各Master Broker有Slave Broker，Slave Broker中的结构和其对应的Master Broker完全相同。从本质上来说，RocketMQ中的Queue是数据分片的产物。为了更好地理解Queue的定义，我们还需要引入一个新的概念：Topic分片。在分布式数据库和分布式缓存领域，分片概念已经有了清晰的定义。同理，对于RocketMQ，一个Topic可以分布在各个Broker上，我们可以把一个Topic分布在一个Broker上的子集定义为一个Topic分片。对应上图，TopicA有3个Topic分片，分布在Broker1，Broker2和Broker3上，TopicB有2个Topic分片，分布在Broker1和Broker2上，TopicC有2个Topic分片，分布在Broker2和Broker3上。将Topic分片再切分为若干等分，其中的一份就是一个Queue。每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定。我们知道，数据分片的主要目的是突破单点的资源（网络带宽，CPU，内存或文件存储）限制从而实现水平扩展。RocketMQ在进行Topic分片以后，已经达到水平扩展的目的了，为什么还需要进一步切分为Queue呢。解答这个问题还需要从负载均衡说起。以消息消费为例，借用RocketMQ官方文档中的Consumer负载均衡示意图来说明：如图所示，TOPIC_A在一个Broker上的Topic分片有5个Queue，一个ConsumerGroup内有2个Consumer按照集群消费的方式消费消息，按照平均分配策略进行负载均衡得到的结果是：第一个Consumer消费3个Queue，第二个Consumer消费2个Queue。如果增加Consumer，每个Consumer分配到的Queue会相应减少。RocketMQ的负载均衡策略规定：Consumer数量应该小于等于Queue数量，如果Consumer超过Queue数量，那么多余的Consumer将不能消费消息。在一个ConsumerGroup内，Queue和Consumer之间的对应关系是一对多的关系：一个Queue最多只能分配给一个Consumer，一个Cosumer可以分配得到多个Queue。这样的分配规则，每个Queue只有一个消费者，可以避免消费过程中的多线程处理和资源锁定，有效提高各Consumer消费的并行度和处理效率。由此，我们可以给出Queue的定义：Queue是Topic在一个Broker上的分片等分为指定份数后的其中一份，是负载均衡过程中资源分配的基本单元。"
  },
  
  {
    "title": "Spring集成RocketMQ",
    "url": "/posts/spring-jicheng-rocketmq/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "Maven依赖fastjson-1.2.44.jarnetty-all-4.1.19.Final.jarrocketmq-client-4.2.0.jarrocketmq-common-4.2.0.jarrocketmq-remoting-4.2.0.jarslf4j-api-1.7.25.jarslf4j-nop-1.7.25.jar&lt;!-- RocketMQ --&gt;&lt;d...",
    "content": "Maven依赖fastjson-1.2.44.jarnetty-all-4.1.19.Final.jarrocketmq-client-4.2.0.jarrocketmq-common-4.2.0.jarrocketmq-remoting-4.2.0.jarslf4j-api-1.7.25.jarslf4j-nop-1.7.25.jar&lt;!-- RocketMQ --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-common&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-remoting&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.19.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.44&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;RocketMQ配置文件spring-rokectmq.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"rocketmqProduct\"         class=\"org.apache.rocketmq.client.producer.DefaultMQProducer\"         init-method=\"start\"        destroy-method=\"shutdown\"&gt;        &lt;property name=\"producerGroup\" value=\"concurrent_producer\"/&gt;        &lt;property name=\"namesrvAddr\" value=\"192.168.0.103:9876\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"consumerSpringListener\"         class=\"com.ju.biz.mq.rokectmq.quickstartspring.ConsumerSpringListener\" /&gt;    &lt;bean id=\"rocketmqConsumer\"         class=\"org.apache.rocketmq.client.consumer.DefaultMQPushConsumer\"         init-method=\"start\" destroy-method=\"shutdown\"&gt;        &lt;property name=\"consumerGroup\" value=\"concurrent_consumer\"/&gt;        &lt;property name=\"namesrvAddr\" value=\"192.168.0.103:9876\"/&gt;        &lt;property name=\"messageListener\" ref=\"consumerSpringListener\"/&gt;        &lt;property name=\"subscription\"&gt;            &lt;map&gt;                &lt;entry key=\"TopicTest\"&gt;                &lt;value&gt;*&lt;/value&gt;                &lt;/entry&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;生产者ProducerSpring.javaApplicationContext context =             new ClassPathXmlApplicationContext(\"/spring/spring-rokectmq.xml\"); DefaultMQProducer producer = (DefaultMQProducer) context.getBean(\"rocketmqProduct\");try {    Message msg = new Message(\"TopicTest\", \"TagA\",                     (\"Hello RocketMQ\").getBytes(RemotingHelper.DEFAULT_CHARSET));    SendResult sendResult = producer.send(msg);} catch (Exception e) {    e.printStackTrace();    Thread.sleep(1000);}消费者ConsumerSpringListener.javapublic class ConsumerSpringListener implements MessageListenerConcurrently {      @Override     public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,                 ConsumeConcurrentlyContext context) {         System.out.printf(\"%s Receive New Messages: %s %n\",                     Thread.currentThread().getName(), msgs);         return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;     } }"
  },
  
  {
    "title": "如何搭建RocketMQ集群 - 双主集群部署",
    "url": "/posts/ruhe-dajian-rocketmq-jiqun/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "服务器环境            IP      角色      模式                  192.168.2.222      nameServer1,brokerServer1      Master1              192.168.2.223      nameServer2,brokerServer2      Master2      修改配置文件两台机器...",
    "content": "服务器环境            IP      角色      模式                  192.168.2.222      nameServer1,brokerServer1      Master1              192.168.2.223      nameServer2,brokerServer2      Master2      修改配置文件两台机器执行相同的操作，并注意，brokerName的值跟配置文件一致vi /usr/local/rocketmq/conf/2m-noslave/broker-a.propertiesvi /usr/local/rocketmq/conf/2m-noslave/broker-b.properties这里把常用的参数配置基本都列了出来，具体意思在注释里#所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，注意此处不同的配置文件填写的不一样 brokerName=broker-a|broker-b #0 表示 Master，&gt;0 表示 Slave brokerId=0 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876 # 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 defaultTopicQueueNums=4 # 是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true # 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true # Broker 对外服务的监听端口 listenPort=10911 # 删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=120 #commitLog每个文件的大小默认1G mapedFileSizeCommitLog=1073741824 #ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 #destroyMapedFileIntervalForcibly=120000 #redeleteHangedFileInterval=120000 #检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 #存储路径 storePathRootDir= /usr/local/rocketmq/store #commitLog 存储路径 storePathCommitLog= /usr/local/rocketmq/store /commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小，默认4MmaxMessageSize=65536 #flushCommitLogLeastPages=4 #flushConsumeQueueLeastPages=2 #flushCommitLogThoroughInterval=10000 #flushConsumeQueueThoroughInterval=60000 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=ASYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH #checkTransactionMessageEnable=false #发消息线程池数量 #sendMessageThreadPoolNums=128 #拉消息线程池数量 #pullMessageThreadPoolNums=128启动要先启动NameServer，再启Broker，两台机器执行相同的操作。启动BrokerServer（节点1用的是a.properties，节点2用的是b.properties）数据清理首先停一下服务cd /usr/local/rocketmq/binsh mqshutdown brokersh mqshutdown namesrv然后清一下store，但别忘记重新建一下rm -rf /usr/local/rocketmq/storemkdir /usr/local/rocketmq/storemkdir /usr/local/rocketmq/store/commitlogmkdir /usr/local/rocketmq/store/consumequeuemkdir /usr/local/rocketmq/store/indexBroker重启对客户端的影响Broker重启可能会导致正在发往这台机器的的消息发送失败，RocketMQ提供了一种优雅关闭Broker的方法，通过执行以下命令会清除Broker的写权限，过40s后，所有客户端都会更新Broker路由信息，此时再关闭Broker就不会发生发送消息失败的情况，因为所有消息都发往了其他Broker。sh mqadmin wipeWritePerm -b brokerName -n namesrvAddr"
  },
  
  {
    "title": "RocketMQ术语",
    "url": "/posts/rocketmq-shuyu/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "Producer消息生产者，生产者的作用就是将消息发送到MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到MQ。Producer Group生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。Consumer消息消费者，简单来说，消费MQ上的消息的应用程序就是...",
    "content": "Producer消息生产者，生产者的作用就是将消息发送到MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到MQ。Producer Group生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。Consumer消息消费者，简单来说，消费MQ上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。Consumer Group消费者组，和生产者类似，消费同一类消息的多个Consumer实例组成一个消费者组。TopicTopic是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单Topic存放订单相关的消息，一个是库存Topic存储库存相关的消息。MessageMessage是消息的载体。一个Message必须指定Topic，相当于寄信的地址。Message还有一个可选的Tag设置，以便消费端可以基于Tag进行过滤消息。也可以添加额外的键值对，例如你需要一个业务Key来查找Broker上的消息，方便在开发过程中诊断问题。Tag标签可以被认为是对Topic进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。BrokerBroker是RocketMQ系统的主要角色，其实就是前面一直说的MQ。Broker接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。通过提供轻量级的Topic和Queue机制来处理消息存储,同时支持推（push）和拉（pull）模式以及主从结构的容错机制。NameServerNameServer为Producer和Consumer提供路由信息。提供轻量级的服务发现和路由。每个NameServer记录完整的路由信息，提供等效的读写服务，并支持快速存储扩展。由这张图可以看到有四个集群，分别是NameServer集群、Broker集群、Producer集群和Consumer集群：简单说明一下图中箭头含义，从Broker开始，Broker Master1和Broker Slave1是主从结构，它们之间会进行数据同步，即Date Sync。同时每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer中。Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Broker发送心跳。Producer只能将消息发送到Broker master，但是Consumer则不一样，它同时和提供Topic服务的Master和Slave建立长连接，既可以从Broker Master订阅消息，也可以从Broker Slave订阅消息。RocketMQ集群部署模式单Master模式也就是只有一个Master节点，称不上是集群，一旦这个Master节点宕机，那么整个服务就不可用，适合个人学习使用。多Master模式多个Master节点组成集群，单个Master节点宕机或者重启对应用没有影响。  优点：所有模式中性能最高。  缺点：单个Master节点宕机期间，未被消费的消息在节点恢复之前不可用，消息的实时性就受到影响。  注意：使用同步刷盘可以保证消息不丢失，同时Topic相对应的queue应该分布在集群中各个节点，而不是只在某各节点上，否则，该节点宕机会对订阅该Topic的应用造成影响。多Master多Slave异步复制模式在多Master模式的基础上，每个Master节点都有至少一个对应的Slave。Master节点可读可写，但是Slave只能读不能写，类似于MySQL的主备模式。  优点：在Master宕机时，消费者可以从Slave读取消息，消息的实时性不会受影响，性能几乎和多Master一样。  缺点：使用异步复制的同步方式有可能会有消息丢失的问题。多Master多Slave同步双写模式同多Master多Slave异步复制模式类似，区别在于Master和Slave之间的数据同步方式。  优点：同步双写的同步模式能保证数据不丢失。  缺点：发送单个消息RT会略长，性能相比异步复制低10%左右。  刷盘策略：同步刷盘和异步刷盘（指的是节点自身数据是同步还是异步存储）。  同步方式：同步双写和异步复制（指的一组Master和Slave之间数据的同步）。  注意：要保证数据可靠，需采用同步刷盘和同步双写的方式，但性能会较其他方式低。"
  },
  
  {
    "title": "RocketMQ实际部署",
    "url": "/posts/rocketmq-shiji-bushu/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "      上传安装包        解压RocketMQ压缩包        在安装目录下创建存储路径      mkdir -p data/store/{commitlog,consumequeue,index}            进入conf目录下修改日志配置文件      mkdir -p /home/weblogic/apache-rocketmq/logs  sed -i '...",
    "content": "      上传安装包        解压RocketMQ压缩包        在安装目录下创建存储路径      mkdir -p data/store/{commitlog,consumequeue,index}            进入conf目录下修改日志配置文件      mkdir -p /home/weblogic/apache-rocketmq/logs  sed -i 's#${user.home}#/home/apache-rocketmq#g' *.xml            修改RocketMQ的配置文件，以下为主要参数      # nameServer地址，分号分割  namesrvAddr = 9.23.28.145:9876  # Broker 对外服务的监听端口  listenPort = 10911            修改启动脚本，指定JDK        启动mqnamesrv      nohup sh mqnamesrv &amp;            启动Broker      nohup sh mqbroker -c /home/weblogic/apache-rocketmq/conf/broker.conf &gt;/dev/null 2&gt;&amp;1 &amp;        自动创建Topic      nohup sh mqbroker -c /home/weblogic/apache-rocketmq/conf/broker.conf autoCreateTopicEnable=true &gt;/dev/null 2&gt;&amp;1 &amp;            安装RocketMQ-Console    修改配置文件rocketmq-console的配置      server.port = 8099  rocketmq.config.namesrvAddr = 9.23.28.145:9876            启动控制台      nohup /home/weblogic/apache-rocketmq/jdk/jdk1.8/bin/java -jar rocketmq-console-ng-1.0.0.jar  &amp;             需要开放的端口    8080、9876、10911        访问控制台    http://localhost:8099/rocketmq-console        物理部署      "
  },
  
  {
    "title": "RocketMQ如何在控制台查看死信队列",
    "url": "/posts/rocketmq-ruhe-zai-kongzhitai-chakan-sixinduilie/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "RocketMQ的ACK机制其中涉及到了消息消费重试，当重试次数达到默认的16次后（可以通过配置文件修改）如果对应的消息还没被成功消费的话，该消息就会投递到DLQ死信队列。不过，在使用控制台查询死信消息队列的时候会报错org.apache.rocketmq.client.exception.MQClientException: Can not find Message Queue for t...",
    "content": "RocketMQ的ACK机制其中涉及到了消息消费重试，当重试次数达到默认的16次后（可以通过配置文件修改）如果对应的消息还没被成功消费的话，该消息就会投递到DLQ死信队列。不过，在使用控制台查询死信消息队列的时候会报错org.apache.rocketmq.client.exception.MQClientException: Can not find Message Queue for this topic, %DLQ%consumer1 See http://rocketmq.apache.org/docs/faq/ for further details.，具体如下图：对应服务器进入相关的目录下/usr/local/rocketmq/store/consumequeue，发现确实是存在%DLQ%consumer1。我们通过RocketMQ的管理命令（先进入/usr/local/rocketmq/bin）sh mqadmin topicList -n 192.168.140.129:9876;192.168.140.128:9876查看所有的Topic，发现也确实能够找到。sh mqadmin topicRoute -n 192.168.140.129:9876 -t %DLQ%consumer1查看该Topic信息，发现perm为2。修改Topic的perm为6（两台机器都要执行），在128机器上执行如下命令：sh mqadmin updateTopic -b 192.168.159.129:10911 -n 192.168.159.129:9876 -t %DLQ%consumer1 -p 6129机器上执行如下命令：sh mqadmin updateTopic -b 192.168.159.128:10911 -n 192.168.159.128:9876 -t %DLQ%consumer1 -p 6查看控制台死信队列。"
  },
  
  {
    "title": "RocketMQ配置项",
    "url": "/posts/rocketmq-peizhixiang/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "客户端的公共配置类：ClientConfig            参数名      默认值      说明                  NamesrvAddr             NameServer地址列表，多个NameServer地址用分号隔开              clientIP      本机IP      客户端本机IP地址，某些机器会发生无法识别客户端IP地址情...",
    "content": "客户端的公共配置类：ClientConfig            参数名      默认值      说明                  NamesrvAddr             NameServer地址列表，多个NameServer地址用分号隔开              clientIP      本机IP      客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定              instanceName      DEFAULT      客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）              clientCallbackExecutorThreads      4      通信层异步回调线程数              pollNameServerInteval      30000      轮训NameServer间隔时间，单位毫秒              heartbeatBrokerInterval      30000      向Broker发送心跳间隔时间，单位毫秒              persistConsumerOffsetInterval      5000      持久化Consumer消费进度间隔时间，单位毫秒      Producer配置            参数名      默认值      说明                  producerGroup      DEFAULT_PRODUCER      Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。              createTopicKey      TBW102      在发送消息时，自动创建服务器不存在的Topic，需要指定Key              defaultTopicQueueNums      4      在发送消息时，自动创建服务器不存在的Topic，默认创建的队列数              sendMsgTimeout      10000      发送消息超时时间，单位毫秒              compressMsgBodyOverHowmuch      4096      消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节              retryAnotherBrokerWhenNotStoreOK      FALSE      如果发送消息返回sendResult，但是sendStatus!=SEND_OK，是否重试发送              maxMessageSize      131072      客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）              transactionCheckListener             事物消息回查监听器，如果发送事务消息，必须设置              checkThreadPoolMinSize      1      Broker回查Producer事务状态时，线程池大小              checkThreadPoolMaxSize      1      Broker回查Producer事务状态时，线程池大小              checkRequestHoldMax      2000      Broker回查Producer事务状态时，Producer本地缓冲请求队列大小      PushConsumer配置            参数名      默认值      说明                  consumerGroup      DEFAULT_CONSUMER      Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组              messageModel      CLUSTERING      消息模型，支持以下两种：1.集群消费；2.广播消费              consumeFromWhere      CONSUME_FROM_LAST_OFFSET      Consumer启动后，默认从什么位置开始消费              allocateMessageQueueStrategy      AllocateMessageQueueAveragely      Rebalance算法实现策略              Subscription      {}      订阅关系              messageListener             消息监听器              offsetStore             消费进度存储              consumeThreadMin      10      消费线程池数量              consumeThreadMax      20      消费线程池数量              consumeConcurrentlyMaxSpan      2000      单队列并行消费允许的最大跨度      PullConsumer配置            参数名      默认值      说明                  consumerGroup             Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组              brokerSuspendMaxTimeMillis      20000      长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒              consumerPullTimeoutMillis      10000      非长轮询，拉消息超时时间，单位毫秒              consumerTimeoutMillisWhenSuspend      30000      长轮询，Consumer拉消息请求Broker挂起超过指定时间，客户端认为超时，单位毫秒              messageModel      BROADCASTING      消息模型，支持以下两种：1.集群消费；2.广播模式              messageQueueListener             监听队列变化              offsetStore             消费进度存储              registerTopics             注册的Topic集合              allocateMessageQueueStrategy             Rebalance算法实现策略      Broker配置查看Broker默认配置sh mqbroker -m            参数名\t       默认值       说明                  consumerGroup             Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组              listenPort      10911      Broker对外服务的监听端口              namesrvAddr      Null      NameServer地址              brokerIP1      本机IP      本机IP地址，默认系统自动识别，但是某些多网卡机器会存在识别错误的情况，这种情况下可以人工配置              brokerName             本机主机名              brokerClusterName      DefaultCluster      Broker所属哪个集群              brokerId      0      BrokerId，必须是大等于0的整数，0表示Master，&gt;0表示Slave，一个Master可以挂多个Slave，Master和Slave通过BrokerName来配对              storePathCommitLog      $HOME/store/commitlog      commitLog存储路径              storePathConsumeQueue      $HOME/store/consumequeue      消费队列存储路径              storePathIndex      $HOME/store/index      消息索引存储队列              deleteWhen      4      删除时间时间点，默认凌晨4点              fileReservedTime      48      文件保留时间，默认48小时              maxTransferBytesOnMessageInMemory      262144      单次pull消息（内存）传输的最大字节数              maxTransferCountOnMessageInMemory      32      单次pull消息（内存）传输的最大条数              maxTransferBytesOnMessageInMemory      65535      单次pull消息（磁盘）传输的最大字节数              maxTransferCountOnMessageInDisk      8      单次pull消息（磁盘）传输的最大条数              messageIndexEnable      TRUE      是否开启消息索引功能              messageIndexSafe      FALSE      是否提供安全的消息索引机制，索引保证不丢              brokerRole      ASYNC_MASTER      Broker的角色-ASYNC_MASTER异步复制Master-SYNC_MASTER同步双写Master-SLAVE              flushDiskType      ASYNC_FLUSH      刷盘方式-ASYNC_FLUSH异步刷盘-SYNC_FLUSH同步刷盘              cleanFileForciblyEnable      TRUE      磁盘满，且无过期文件情况下TRUE表示强制删除文件，优先保证服务可用FALSE标记服务不可用，文件不删除      "
  },
  
  {
    "title": "关于RocketMQ",
    "url": "/posts/guanyu-rocketmq/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "RocketMQ队列的长度RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会...",
    "content": "RocketMQ队列的长度RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除。RocketMQ的消息优先级RocketMQ并不遵循任何规范，但参考了各种规范的设计思想。考虑到持久化的消息按照优先级排序开销大，RocketMQ没有特意支持消息优先级。在Message的API中的确没有提供和Priority(优先级)有关的方法。两种变通的处理思路供参考：  使用消息队列来表示不同的优先级：单独配置一个优先级高的队列，和一个普通优先级的队列，将不同优先级发送到不同队列即可；  使用t来表示不同的优先级：每个优先级可以用不同的Topic表示，发消息时，指定不同的Topic来表示优先级。RocketMQ提供2级消息分类，方便使用者灵活控制TopicTopic表示消息的第一级类型，比如一个电商系统的消息可以分为：交易消息、物流消息……一条消息必须有一个Topic。TagTag表示消息的第二级类型，比如交易消息又可以分为：交易创建消息，交易完成消息…..一条消息可以没有Tag。订阅指定Topic下Tags分别等于TagA或TagC或TagDconsumer.subscribe(\"TopicTest1\", \"TagA || TagC || TagD\");设置为广播消费模式consumer.setMessageModel(MessageModel.BROADCASTING);消费者的消费位置ConsumeFromWhere consumeFromWhere   CONSUME_FROM_LAST_OFFSET：第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费   CONSUME_FROM_FIRST_OFFSET：第一次启动从队列初始位置消费，后续再启动接着上次消费的进度开始消费   CONSUME_FROM_TIMESTAMP：第一次启动从指定时间点位置消费，后续再启动接着上次消费的进度开始消费 以上所说的第一次启动是指从来没有消费过的消费者，如果该消费者消费过，那么会在Broker端记录该消费者的消费位置，如果该消费者挂了再启动，那么自动从上次消费的进度开始。如何拿到消费者的处理结果绝大部分队列用于削峰和解耦，也有用于处理分布式事务。削峰是用于当应用处理不过来过大的并发请求时，将请求存于队列中，用单个或多个消费者来处理请求。这时候想要拿到请求怎么办呢？  每个消费者处理完成请求，再发送消息到消息队列中，生产者再实现消费者来消费这些处理结果信息；  将处理结果存于缓存等高性能组件中，通过轮询的方式获取任务处理结果，消息结果可以用推送的方式告知(移动端),也可以让请求方每个几秒轮询一次处理结果。队列重新消费的间隔每次重新消费间隔：10s,30s,1m,2m,3m默认消息重发次数为16次。"
  },
  
  {
    "title": "CentOS7安装RocketMQ",
    "url": "/posts/centos-anzhuang-rocketmq/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "      上传安装包    JDK1.8 (注意一定要使用1.8以上版本，1.7版本不能识别RocketMQ中的metaspace特性，该特性由1.8最新提出) 。  RocketMQ压缩包，下载选择binary版。        解压RocketMQ压缩包        修改配置文件    在conf文件中可以看到以下文件夹，对应rocketmq的不同部署模式：      2m-2s-a...",
    "content": "      上传安装包    JDK1.8 (注意一定要使用1.8以上版本，1.7版本不能识别RocketMQ中的metaspace特性，该特性由1.8最新提出) 。  RocketMQ压缩包，下载选择binary版。        解压RocketMQ压缩包        修改配置文件    在conf文件中可以看到以下文件夹，对应rocketmq的不同部署模式：      2m-2s-async  两主两从异步 异步数据的配置文件夹   2m-2s-sync   两主两从同步 同步数据的配置文件夹   2m-noslave   两主无从的配置文件           vi ../conf/broker.conf  brokerIP1 = 192.168.x.x         显示指定为本机外网IP，不要用localhost和127.0.0.1，因为远程主机会根据brokerIP1指定的地址去访问Broker        在安装目录下创建存储路径      mkdir -p data/store/{commitlog,consumequeue,index}            进入conf目录下修改日志配置文件      mkdir -p /home/apache-rocketmq/logs  sed -i 's#${user.home}#/home/apache-rocketmq#g' *.xml            修改JVM参数    vi修改runserver.sh和runbroker.sh的JVM参数如下（根据虚拟机内存大小设置，超出内存大小可能会报错）：      JAVA_OPT=\"${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn256m -XX:PermSize=128m -XX:MaxPermSize=320m\"            启动mqnamesrv      nohup sh mqnamesrv &amp;            启动broker      nohup sh mqbroker -c /home/apache-rocketmq/conf/broker.conf autoCreateTopicEnable=true &gt;/dev/null 2&gt;&amp;1 &amp;            使用jps命令检查是否启动成功      [root@localhost bin]# jps  1155 NamesrvStartup  1212 BrokerStartup  3197 Jps            安装RocketMQ-Console    GitHub下载链接：https://github.com/apache/rocketmq-externals，修改配置文件rocketmq-console/src/main/resources/application.properties       server.port = 8080  rocketmq.config.namesrvAddr = NameServer的IP:9876        编译RocketMQ-Console得到rocketmq-console-ng-1.0.0.jar      mvn clean package -Dmaven.test.skip=true            启动控制台    可以直接用jar包来启动，这个jar是用源码编译好的      nohup java -jar rocketmq-console-ng-1.0.0.jar &amp;             需要开放的端口    8080、9876、10911        访问控制台    http://localhost:8080/rocketmq-console  "
  },
  
  {
    "title": "删除下载未完整的依赖文件",
    "url": "/posts/shanchu-xiazai-weiwanzheng-de-yilai/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-07-14 03:47:00 +0800",
    





    
    "snippet": "set REPOSITORY_PATH=E:\\repositoryrem 正在搜索...for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do ( del /s /q %%i)rem 搜索完毕pause记得路径修改为你自己所在依赖包的位置，然后把.txt文件后缀改为.bat ，双击运行即可跳出窗口去...",
    "content": "set REPOSITORY_PATH=E:\\repositoryrem 正在搜索...for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do ( del /s /q %%i)rem 搜索完毕pause记得路径修改为你自己所在依赖包的位置，然后把.txt文件后缀改为.bat ，双击运行即可跳出窗口去自动删除。"
  },
  
  {
    "title": "IntelliJ IDEA Maven菜单模块为灰色",
    "url": "/posts/maven-candan-mokuai-wei-huise/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-07-14 03:23:00 +0800",
    





    
    "snippet": "Idea用maven搭建聚合项目时，出现了如下的问题：即Maven工具栏中的某一个模块是灰色的，同时导致了新的问题：在pom文件中引入jar包，但是在Java代码里，找不到这个类。然后我看了一下Dependencies目录，jar是下载好的。jar包是下载好的，但是引用类文件的地方还是有红色报错：提示要Add library to classpath。解决办法：Preferences -&g...",
    "content": "Idea用maven搭建聚合项目时，出现了如下的问题：即Maven工具栏中的某一个模块是灰色的，同时导致了新的问题：在pom文件中引入jar包，但是在Java代码里，找不到这个类。然后我看了一下Dependencies目录，jar是下载好的。jar包是下载好的，但是引用类文件的地方还是有红色报错：提示要Add library to classpath。解决办法：Preferences -&gt; build -&gt; maven -&gt; ignore files，找到对应的Maven模块，取消勾选。Maven中的灰色模块变为了黑色，同时引用的类文件也不再报错。可能出现这种问题的原因：新建模块（module）时，已经新建了一个模块，但是由于种种原因，你将该模块删除了，又新建了一个同名的模块，这时父项目的pom文件中不报错了，但是重新新建的模块已经被加入了Maven的ignoreFiles中，所以这时需要手动去取消勾选。  参考：idea maven菜单模块为灰色"
  },
  
  {
    "title": "IntelliJ IDEA离线使用Maven仓库的方法",
    "url": "/posts/lixian-shiyong-maven-cangku-de-fangfa/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-07-14 03:23:00 +0800",
    





    
    "snippet": "首先将相关的Maven依赖在外网的环境中下载好，然后将整个repository打包后拷贝到内网的机器上并解压。然后将外网的settings文件也拷贝到内网使用，或者也可以将内网 settings 文件中的镜像配置部分改成和外网一样。&lt;mirrors&gt; &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirror...",
    "content": "首先将相关的Maven依赖在外网的环境中下载好，然后将整个repository打包后拷贝到内网的机器上并解压。然后将外网的settings文件也拷贝到内网使用，或者也可以将内网 settings 文件中的镜像配置部分改成和外网一样。&lt;mirrors&gt; &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;这么做的原因是确保镜像id和repository里依赖的配置是一致的。我们随便打开一个本地仓库的依赖，会有个_remote.repositories 文件。打开后会发现.pom和.jar文件会后面会有对应镜像id，如果与settings文件里不匹配的话，那么编译时仍然会去远程仓库获取。最后打开IDEA的Maven设置，配置好本地仓库地址和settings文件地址，并勾选上Work offline（离线模式），这样就完成Maven的离线配置了。  参考：Intellij IDEA - 离线使用本地Maven仓库的方法（没有外网，且不搭建私服）"
  },
  
  {
    "title": "Spring MVC",
    "url": "/posts/spring-mvc/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "现在主流的Web MVC框架除了Struts这个主力外，其次就是Spring MVC了，因此这也是作为一名程序员需要掌握的主流框架，框架选择多了，应对多变的需求和业务时，可实行的方案自然就多了。不过要想灵活运用Spring MVC来应对大多数的Web开发，就必须要掌握它的配置及原理。web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;...",
    "content": "现在主流的Web MVC框架除了Struts这个主力外，其次就是Spring MVC了，因此这也是作为一名程序员需要掌握的主流框架，框架选择多了，应对多变的需求和业务时，可实行的方案自然就多了。不过要想灵活运用Spring MVC来应对大多数的Web开发，就必须要掌握它的配置及原理。web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xmlns=\"http://java.sun.com/xml/ns/javaee\"         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"         id=\"WebApp_ID\"         version=\"2.5\"&gt;  &lt;display-name&gt;TestSpring&lt;/display-name&gt;    &lt;!-- Spring servlet --&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;      &lt;/init-param&gt;      &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;!-- Spring Listener --&gt;  &lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;  &lt;/listener&gt;    &lt;!-- applicationContext.xml load --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;&lt;/web-app&gt; applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans    xsi:schemaLocation=\"http://www.springframework.org/schema/beans                 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd                 http://www.springframework.org/schema/context                 http://www.springframework.org/schema/context/spring-context-3.0.xsd                 http://www.springframework.org/schema/aop                 http://www.springframework.org/schema/aop/spring-aop-3.0.xsd                 http://www.springframework.org/schema/tx                 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd                 http://www.springframework.org/schema/mvc                 http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd \"    xmlns:tx=\"http://www.springframework.org/schema/tx\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"&gt;        &lt;!-- Spring bean --&gt;    &lt;bean id=\"user\" class=\"com.bbs.bean.User\"&gt;&lt;/bean&gt;    &lt;bean id=\"db1\" class=\"com.bbs.util.DBConnection\"&gt;&lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"com.bbs.dao.UserDao\"&gt;        &lt;property name=\"db\"&gt;&lt;ref bean=\"db1\"/&gt;&lt;/property&gt;    &lt;/bean&gt;        &lt;!-- Spring SimpleUrlHandlerMapping --&gt;    &lt;bean id=\"urlMap\"         class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;        &lt;property name=\"mappings\"&gt;            &lt;props&gt;                &lt;prop key=\"test.do\"&gt;test&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;bean id=\"test\" class=\"com.bbs.servlet.TestServletBean\"&gt;        &lt;property name=\"userDao\"&gt;            &lt;ref bean=\"userDao\"/&gt;        &lt;/property&gt;        &lt;property name=\"user\"&gt;            &lt;ref bean=\"user\"/&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;  TestServletBean.javapackage com.bbs.servlet;import java.io.PrintWriter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import com.bbs.bean.User;import com.bbs.dao.UserDao;public class TestServletBean implements Controller {    private User user;    private UserDao userDao;    public User getUser() {        return user;    }    public UserDao getUserDao() {        return userDao;    }    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    public void setUser(User user) {        this.user = user;    }        public TestServletBean() {            }        public ModelAndView handleRequest(HttpServletRequest request,             HttpServletResponse response) throws Exception {        try {            user = userDao.find(8);        } catch (Exception e) {            e.printStackTrace();        }        PrintWriter out = response.getWriter();        out.print(user.getUsername());        out.close();        return null;    }    }AOP配置头&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:aop=\"http://www.springframework.org/schema/aop\"\txmlns:tx=\"http://www.springframework.org/schema/tx\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context-3.0.xsd        http://www.springframework.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop-3.0.xsd        http://www.springframework.org/schema/tx         http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt; MVC配置头&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.s`pringframework.org/schema/beans/spring-beans-3.0.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context-3.0.xsd          http://www.springframework.org/schema/mvc         http://www.springfr`amework.org/schema/mvc/spring-mvc-3.0.xsd\"     xmlns:context=\"http://www.springframework.org/schema/context\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:mvc=\"http://www.springframework.org/schema/mvc\"&gt;Spring Bean配置头&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \t\"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;"
  },
  
  {
    "title": "Spring IOC",
    "url": "/posts/spring-ioc/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "IOC理论的背景我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到...",
    "content": "IOC理论的背景我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。齿轮组中齿轮之间的啮合关系，与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。什么是控制反转(IOC)IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦，如下图：大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。IOC的别名：依赖注入(DI)2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring就是通过反射来实现注入的。我们举一个生活中的例子，来帮助理解依赖注入的过程。大家对USB接口和USB设备应该都很熟悉吧，USB为我们使用电脑提供了很大的方便，现在有很多的外部设备都支持USB接口。现在，我们利用电脑主机和USB接口来实现一个任务：从外部USB设备读取一个文件。电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。通过这个例子，依赖注入的思路已经非常清楚：当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。我们把依赖注入应用到软件系统中，再来描述一下这个过程：对象A依赖于对象B，当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。IOC为我们带来了什么好处我们还是从USB的例子说起，使用USB外部设备比使用内置硬盘，到底带来什么好处？第一、USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。所以，无论两者中的任何一方出现什么的问题，都不会影响另一方的运行。这种特性体现在软件工程中，就是可维护性比较好，非常便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。第二、USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。这种特性体现在软件开发过程中，好处可是太大了。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。所以，在一个大中型项目中，团队成员分工明确、责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将得到大幅度的提高。第三、同一个USB外部设备可以插接到任何支持USB的设备，可以插接到电脑主机，也可以插接到DV机，USB外部设备可以被反复利用。在软件工程中，这种特性就是可复用性好，我们可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。显然，IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现，都可以插接到支持此标准的模块中。第四、同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。以上几点好处，难道还不足以打动我们，让我们在项目开发过程中使用IOC框架吗？IOC容器的技术剖析IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。IOC容器的一些产品Sun ONE技术体系下的IOC容器有：轻量级的有Spring、Guice、Pico Container、Avalon、HiveMind；重量级的有EJB；不轻不重的有JBoss，Jdon等等。Spring框架作为Java开发中SSH(Struts、Spring、Hibernate)三剑客之一，大中小项目中都有使用，非常成熟，应用广泛，EJB在关键性的工业级项目中也被使用，比如某些电信业务。.Net技术体系下的IOC容器有：Spring.Net、Castle等等。Spring.Net是从Java的Spring移植过来的IOC容器，Castle的IOC容器就是Windsor部分。它们均是轻量级的框架，比较成熟，其中Spring.Net已经被逐渐应用于各种项目中。使用IOC框架应该注意什么使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。第一、软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。第二、由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。第三、具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。第四、IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，象WEB2.0网站就是这种情况。"
  },
  
  {
    "title": "Spring AOP",
    "url": "/posts/spring-aop/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "AOP（Aspect Oriented Programming），面向切面编程（也叫面向方面），是Spring框架中的内容，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。主要的功能有：日志记录，性能统计，安全控制，事务处...",
    "content": "AOP（Aspect Oriented Programming），面向切面编程（也叫面向方面），是Spring框架中的内容，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。主要的功能有：日志记录，性能统计，安全控制，事务处理，异常处理等等。什么是AOPAOP可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系。使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。OOP和AOPOOP专注于对象，我们利用对象的属性，行为来解决现实中的问题，而AOP则用来在使用OOP解决问题的过程中增强解决问题的能力，实现更好的模块化。AOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。AOP能做什么AOP可以从增强模块化以及降低切面与业务逻辑的耦合度来增强OOP程序。使用AOP可以为需要某些特定功能的对象集合增加功能而不必修改这些对象的类代码。也就是我们将与实际业务逻辑无关但是需要关注的部分提取出来通过AOP来动态的添加到业务逻辑代码中。即使这些Aspect的实现机制以及代码进行了修改，只需改动一处而不会影响原有业务逻辑代码。Spring中的AOP与同样实现AOP的AspectJ不同，AspectJ将附加功能加入到目标对象中进行编译，Spring中附加功能与目标对象是分开的，在runtime时动态增加到目标对象中。这通常是通过Proxy实现的（可以看看设计模式中的代理模式，Spring的AOP就是基于Proxy实现的）。也因为Spring没有将附加功能与目标对象混合后编译所以Spring的在为对象增加附加功能只能实现在method（方法）的级别。相当于只能在执行某个method前或之后增加特定功能，而无法在方法体内部截断并增加功能。Spring通过配置文件来随时对一系列特定的对象增加、修改或取消特定功能而使程序不受其影响，也就是说这一系列对象即使没有通过Spring的AOP增加应用的功能时也是可以正常运行的。可以理解为这一系列对象根本不知道自己是否通过AOP被增加了某些功能。AOP相关概念切面(Aspect)切面可以理解为我们程序中许多并无关联的对象、子程序所共同拥有的需要关注的方面，通常遍布于整个程序中，比如我们需要在许多代码逻辑中增加安全性保障的代码（大部分这些代码都是相同的），比如在执行一个方法前后要进行日志记录，比如在执行方法时要实现事务，保证操作的原子性等等。这些一个共同点就是我们程序中需要关注的但是与实际业务逻辑无关。在利用AOP以前，它分散于整个程序中并混杂在业务逻辑代码中，假如对于安全性考虑需要变更安全性相关代码，则需要改动大量原先混杂在业务逻辑中的安全性处理代码。类似这种需要考虑的方面我们叫他切面，也就是Aspect。切入点(PointCut)指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解，MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上。连接点(JointPoint)程序执行过程中明确的点，如方法的调用或特定的异常被抛出。通知(Advice)在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice：BeforeAdvice，AfterAdvice，ThrowAdvice和DynamicIntroductionAdvice。目标对象(Target)要使用方面功能的组件对象或被切入点表达式指定的对象，包含连接点的对象，也被称作被通知或被代理对象，POJO。动态代理对象(AutoProxy)Spring使用了AOP机制后，采用的是动态代理技术实现的，当采用了AOP之后，Spring通过getBean返回的对象是一个动态代理类型对象，当使用该对象的业务方法时，该对象会负责调用方面组件和目标组件的功能，如果未采用AOP，Spring通过getBean返回的是原始类型对象，因此执行的是原有目标对象的处理Spring动态代理技术采用的是以下两种:  采用JDK Proxy API实现(目标对象有接口定义)  采用Cglib.jar工具包API实现(目标对象没有接口定义)引入（Introduction）添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现IsModified接口，来简化缓存。Spring中要使用Introduction，可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口。AOP代理（AOP Proxy）AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。织入（Weaving）组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯JavaAOP框架一样，在运行时完成织入。AOP通知类型通知主要负责指定方面功能和目标方法功能的作用关系。Spring框架提供了以下5种类型通知：  前置通知&lt;aop:before&gt;：方面功能在目标方法之前调用  后置通知&lt;aop:after-returning&gt;：方面功能在目标方法之后调用，目标方法无异常执行  最终通知&lt;aop:after&gt;：方面功能在目标方法之后调用，目标方法有无异常都执行  异常通知&lt;aop:after-throwing&gt;：方面功能在目标方法抛出异常之后执行  环绕通知&lt;aop:around&gt;：方面功能在目标方法执行前和后调用AOP切入点表达式的指定切入点表达式用于指定哪些对象和方法调用方面功能，方法限定表达式：execution(修饰符? 返回类型 方法名(参数) throws 异常类型?)  示例1–匹配所有Bean对象中以add开头的方法execution(* add*(..))  示例2–匹配UserService类中所有的方法execution(* tarena.service.UserService.*(..))  示例3–匹配UserService类中有返回值的所有方法execution(!void tarena.service.UserService.*(..))  示例4–匹配所有Bean对象中修饰符为public，方法名为add的方法execution(public * add(..))  示例5–匹配tarena.service包下所有类的所有方法execution(* tarena.service.*.*(..))  示例6–匹配tarena.service包及其子包中所有类所有方法execution(* tarena.service..*.*(..))如何使用AOP可以通过配置文件或者编程的方式来使用Spring AOP。配置可以通过xml文件来进行，大概有四种方式：  配置ProxyFactoryBean，显式地设置advisors，advice，target等。  配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象。  通过&lt;aop:config&gt;来配置。  通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点。也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象，advisor等相关配置，最终通过getProxy()方法来获取代理对象。AOP使用示例applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xmlns:context=\"http://www.springframework.org/schema/context\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xmlns:tx=\"http://www.springframework.org/schema/tx\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans              http://www.springframework.org/schema/beans/spring-beans-3.0.xsd             http://www.springframework.org/schema/context              http://www.springframework.org/schema/context/spring-context-3.0.xsd             http://www.springframework.org/schema/aop              http://www.springframework.org/schema/aop/spring-aop-3.0.xsd             http://www.springframework.org/schema/tx              http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt;     &lt;!-- AspectJ框架 方面编程 --&gt;    &lt;bean id=\"join\" class=\"com.book.aspect.BuyJoin\"&gt;&lt;/bean&gt;    &lt;bean id=\"appleBuy\" class=\"com.book.AppleBuy\"&gt;&lt;/bean&gt;    &lt;aop:config&gt;        &lt;!-- 执行：正则表达式，匹配切入点             1、execution(* com.book.AppleBuy.*(..))  AppleBuy类内所有的方法            2、execution(* com.book.*.*(..))  com.book包下所有的类的方法内所有的方法            3、execution(* com..*.*(..))  book包下及子包下的所有方法        --&gt;        &lt;!-- 定义切入点（什么位置执行通知） --&gt;        &lt;aop:pointcut id=\"testpoint\"                 expression=\"execution(* com.book.AppleBuy.*buy*(..))\"/&gt;        &lt;!-- 定义切面（对切入点统一操作） --&gt;        &lt;aop:aspect ref=\"join\"&gt;            &lt;aop:around pointcut-ref=\"testpoint\" method=\"buy\"/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt; BuyJoin.javapackage com.book.aspect;import org.aspectj.lang.ProceedingJoinPoint;public class BuyJoin {    public void buy(ProceedingJoinPoint join) throws Throwable {        System.out.println(\"支付\");        // 买苹果的业务方法，需要用到连接点        join.proceed();        System.out.println(\"完成\");    }}  Test.javapublic class Test {    public static void main(String[] args) {        BeanFactory bf = new ClassPathXmlApplicationContext(\"applicationContext1.xml\");        IBuy o = (IBuy) bf.getBean(\"appleBuy\");        o.buy();        System.out.println(\"=========================\");        o.steal();    }} "
  },
  
  {
    "title": "如何手动获取Spring容器中的bean",
    "url": "/posts/ruhe-shoudong-huoqu-spring-rongqi-zhongde-bean/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "1、定义一个工具类，实现ApplicationContextAware，实现setApplicationContext()方法public class SpringContextUtils implements ApplicationContextAware {     private static ApplicationContext context;    @Override    pu...",
    "content": "1、定义一个工具类，实现ApplicationContextAware，实现setApplicationContext()方法public class SpringContextUtils implements ApplicationContextAware {     private static ApplicationContext context;    @Override    public void setApplicationContext(ApplicationContext context)            throws BeansException {        SpringContextUtils.context = context;    }    public static ApplicationContext getContext() {        return context;    }}如此一来，我们就可以通过该工具类，来获得ApplicationContext，进而使用其getBean()方法来获取我们需要的bean。2、在Spring配置文件中注册该工具类之所以我们能如此方便地使用该工具类来获取，正是因为Spring能够为我们自动地执行setApplicationContext()方法，显然，这也是因为IOC的缘故，所以必然这个工具类也是需要在Spring的配置文件中进行配置的。&lt;bean id=\"springContextUtils\" class=\"com.zker.common.util.SpringContextUtils\" /&gt;3、编写方法进行使用一切就绪，我们就可以在需要使用的地方调用该方法来获取bean了。public String ajaxRegister() throws IOException {    UserDao userDao = (UserDao) SpringContextUtils.getContext().getBean(\"userDao\");    if (userDao.findAdminByLoginName(loginName) != null            || userDao.findUserByLoginName(loginName) != null) {        message.setMsg(\"用户名已存在\");        message.setStatus(false);    } else {        message.setMsg(\"用户名可以注册\");        message.setStatus(true);    }    return \"register\";}  参考如何手动获取Spring容器中的bean？"
  },
  
  {
    "title": "转发和重定向的区别",
    "url": "/posts/zhuanfa-he-chongdingxiang/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "调用方式不一样转发是  ServletContext.getRequestDispatcher(url).forward(req,rops);，url只能使用绝对路径，因为ServletRequest具有相对路径的概念；而ServletContext对象无此概念。当使用绝对路径时，/代表的是Web项目，代表http://localhost:8080/项目名/。  request.getReq...",
    "content": "调用方式不一样转发是  ServletContext.getRequestDispatcher(url).forward(req,rops);，url只能使用绝对路径，因为ServletRequest具有相对路径的概念；而ServletContext对象无此概念。当使用绝对路径时，/代表的是Web项目，代表http://localhost:8080/项目名/。  request.getRequestDispatcher(url).forward(req,rops);，url可以使用相对路径。  &lt;jsp:forward page=\"welcome.jsp\"&gt;&lt;/jsp:forward&gt;。重定向是response.sendRedirect(url);浏览器地址栏是否发生变化转发不发生变化，重定向会发生变化。参数的传递方式不一样重定向response.sendRedirect(url)跳转到指定的URL地址，产生一个新的Request，所以要传递参数只有在URL后加参数，如：url?id=1。转发request.getRequestDispatcher(url).forward(request, response)是直接将请求转发到指定URL，所以该请求能够直接获得上一个请求的数据，也就是说采用请求转发，Request对象始终存在，不会重新创建。行为对象不一样转发是服务器的行为，重定向是客户端浏览器的行为。"
  },
  
  {
    "title": "关于Servlet",
    "url": "/posts/shenmeshi-servlet/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "什么是ServletJava Servlet是运行在Web服务器或应用服务器上的程序，它是作为来Web浏览器或其他Http客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。使用Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Servlet是一个Java编写的程序，此程序是基于Http协议的，在服务器端运行的。是按照Servle...",
    "content": "什么是ServletJava Servlet是运行在Web服务器或应用服务器上的程序，它是作为来Web浏览器或其他Http客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。使用Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Servlet是一个Java编写的程序，此程序是基于Http协议的，在服务器端运行的。是按照Servlet规范编写的一个Java类。Java Servlet通常情况下与使用CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。Servlet怎么处理一个请求当用户发送一个请求到某个Servlet的时候，Servlet容器会创建一个ServletRequst和ServletResponse对象。在ServletRequst对象中封装了用户的请求信息，然后Servlet容器把ServletRequst和ServletResponse对象传给用户所请求的Servlet，Servlet把处理好的结果写在ServletResponse中，然后Servlet容器把响应结果传给用户。Servlet与JSP有什么区别JSP经编译后就是Servlet，也可以说JSP等于Servlet。JSP更擅长页面（表现）。Servlet更擅长逻辑编辑（最核心的区别）。在实际应用中采用Servlet来控制业务流程，而采用JSP来生成动态网页。在Struts框架中，JSP位于MVC设计模式的视图层，而Servlet位于控制层。"
  },
  
  {
    "title": "Servlet四大域中的值的获取方式",
    "url": "/posts/servlet-zhong-4dayu-zhongde-zhi-de-huoqu-fangshi/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "PageContextPageContent是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。常用方法：getAttribute(String name); // 取得page范围内的name属性 getAttribute(String name, int scope); // 取得指定范围内的name属性...",
    "content": "PageContextPageContent是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。常用方法：getAttribute(String name); // 取得page范围内的name属性 getAttribute(String name, int scope); // 取得指定范围内的name属性其中scope可以是如下4个值PageContext.PAGE_SCOPE // 对应于page范围PageContext.REQUEST_SCOPE // 对应于request范围PageContext.SESSION_SCOPE // 对应于session范围PageContext.APPLICATION_SCOPE // 对应于application范围RequestRequest是表示一个请求，只要发出一个请求就会创建一个Request，它的作用域仅在当前请求中有效。常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。常用方法：request.setAttribute();request.getAttribute();request.removeAttribute();request.getParameter();Session服务器会为每个会话创建一个Session对象，所以Session中的数据可供当前会话中所有Servlet共享会话，用户打开浏览器会话开始，直到关闭浏览器会话才会结束，一次会话期间只会创建一个Session对象。常用于Web开发中的登陆验证界面（当用户登录成功后浏览器分配其一个Session键值对）。常用方法：session.setAttribute();session.getAttribute();session.removeAttribute();获得Session对象方法：（1）在Servlet中：HttpSession session = request.getSession();（2）由于Session属于JSP九大内置对象之一，当然可以直接使用，例如：&lt;%session.serAttribute(\"name\", \"admin\")%&gt;备注：Session是服务器端对象，保存在服务器端，并且服务器可以将创建Session后产生的sessionid通过一个Cookie返回给客户端以便下次验证，Session底层依赖于Cookie。Application（ServletContext）Application属性范围值只要设置一次，则所有的网页窗口都可以取得数据，ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象。获取Application对象方法（Servlet中）：ServletContext app01 = this.getServletContext();app01.setAttribute(\"name\", \"kaixuan\"); // 设置一个值进去ServletContext app02 = this.getServletContext();app02.getAttribute(\"name\"); // 获取键值对ServletContext同属于JSP九大内置对象之一，故可以直接使用。备注：服务器只会创建一个ServletContext对象，所以app01就是app02，通过app01设置的值当然可以通过app02获取。"
  },
  
  {
    "title": "Servlet如何使用Cookie",
    "url": "/posts/servlet-ruhe-shihyong-cookie/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "/** 创建Cookie */// 键值形式创建CookieCookie cookie = new Cookie(\"temp\", tempData);// 设置Cookie的存活时间为秒cookie.setMaxAge(60 * 60 * 24);// 写入客户端硬盘response.addCookie(cookie);/** 调用Cookie */// 将目录下所有Cookie读入并存入C...",
    "content": "/** 创建Cookie */// 键值形式创建CookieCookie cookie = new Cookie(\"temp\", tempData);// 设置Cookie的存活时间为秒cookie.setMaxAge(60 * 60 * 24);// 写入客户端硬盘response.addCookie(cookie);/** 调用Cookie */// 将目录下所有Cookie读入并存入Cookies数组中Cookie cookies[] = request.getCookies();Cookie sCookie = null;if (cookies != null) {    // 循环列出所有可用的Cookie    for(int i = 0; i &lt; cookies.length; i++) {        sCookie = cookies[i];        String sname = sCookie.getName();        String name = sCookie.getValue();    }}"
  },
  
  {
    "title": "Spring核心组件",
    "url": "/posts/spring-de-hexin-zujian/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-12 13:47:00 +0800",
    





    
    "snippet": "核心容器（Spring Core）核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。应用上下文（Spring Context）Spring上下文是一个配置...",
    "content": "核心容器（Spring Core）核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。应用上下文（Spring Context）Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。面向切面编程（Spring AOP）通过配置管理特性，Spring AOP模块直接将面向方面的编程功能集成到了Spring框架中。所以，可以很容易地使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于 Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。JDBC和DAO模块（Spring DAO）JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。对象实体映射（Spring ORM）Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。Web模块（Spring Web）Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。MVC模块（Spring Web MVC）MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。"
  },
  
  {
    "title": "ContextLoaderListener的作用",
    "url": "/posts/ContextLoaderListener-de-zuoyong/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-12 13:47:00 +0800",
    





    
    "snippet": "ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。如何部署ApplicationContext的XML文件。如果在web.xml中不写任何参数配置信息，默认的路径是/WEB-I...",
    "content": "ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。如何部署ApplicationContext的XML文件。如果在web.xml中不写任何参数配置信息，默认的路径是/WEB-INF/applicationContext.xml，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml；如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数：&lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            /WEB-INF/classes/applicationContext-*.xml         &lt;/param-value&gt;  &lt;/context-param&gt;  在&lt;param-value&gt;&lt;/param-value&gt;里指定相应的XML文件名，如果有多个XML文件，可以写在一起并以,号分隔。上面的applicationContext-*.xml采用通配符，比如这目录下有applicationContext-ibatis-base.xml,applicationContext-action.xml,applicationContext-ibatis-dao.xml等文件，都会一同被载入。由此可见applicationContext.xml的文件位置就可以有两种默认实现：  第一种：直接将之放到/WEB-INF下，之后在web.xml中声明一个Listener；      第二种：将之放到classpath下，但是此时要在web.xml中加入&lt;context-param&gt;，用它来指明你的applicationContext.xml的位置以供web容器来加载。按照Struts2整合spring的官方给出的档案，写成：      &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;          /WEB-INF/applicationContext-*.xml,classpath*:applicationContext-*.xml      &lt;/param-value&gt;   &lt;/context-param&gt;      配置示例&lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;  &lt;!-- 注册Spring提供的Servlet --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;disptcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;disptcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/testDisServlet.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;注册Spring提供的Servlet时init-param从context-param指定的applicationContext.xml文件路径读取配置信息。 "
  },
  
  {
    "title": "Spring的字符编码过滤器",
    "url": "/posts/spring-de-zifubianma-guolvqi/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-09 13:47:00 +0800",
    





    
    "snippet": "&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;     ...",
    "content": "&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;"
  },
  
  {
    "title": "WebLogic新建JNDI数据源",
    "url": "/posts/weblogic-xinjian-jndi-shujuyuan/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "新建Oracle数据源进入Weblogic管理控制台，点击左侧【域结构】→【base domain】→【服务】→【数据源】，然后点击右侧【新建】→【一般数据源】，如下图所示：填写JDBC数据源的【名称】、【JNDI名称】，选择数据库类型，如选择【Oracle】,下一步：选择Oracle数据库的驱动程序，如下图所示：这里选择【Oracle’ s Driver （Thin）for Instanc...",
    "content": "新建Oracle数据源进入Weblogic管理控制台，点击左侧【域结构】→【base domain】→【服务】→【数据源】，然后点击右侧【新建】→【一般数据源】，如下图所示：填写JDBC数据源的【名称】、【JNDI名称】，选择数据库类型，如选择【Oracle】,下一步：选择Oracle数据库的驱动程序，如下图所示：这里选择【Oracle’ s Driver （Thin）for Instance connections;Version:Any】，点击【下一步】按钮，进入下一个配置步骤：这里使用默认配置即可 ，点击【下一步】按钮，进入下一个配置步骤，如下图所示，填写数据库的连接信息：要连接的数据库，数据库的IP地址，连接数据库时使用的端口号，登录数据库时使用的用户名和密码点击【下一步】按钮，进入下一个配置步骤：如下图所示：点击【完成】，这样WebLogic就会创建一个新的JDBC数据源，如下图所示：到此，在WebLogic新建针对Oracle数据库的JNDI数据源就算是全部完成了。数据源创建之后，我们就可以在应用程序中使用数据源了。新建MySQL数据源配置步骤和针对Oracle数据库创建的JDBC数据源大部分是一样的，针对不一样的地方给出如下的截图说明：到此，在WebLogic新建针对MySQL数据库的JNDI数据源就算是全部完成了。"
  },
  
  {
    "title": "WebLogic生产模式免用户名密码启动",
    "url": "/posts/weblogic-shengchanmoshi-mianyonghuming-mima-qidong/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "在user_projects\\domains\\base_domain\\servers\\AdminServer\\security路径下创建boot.properties文件。#Tue Jun 25 16:03:48 CST 2019password=weblogicusername= weblogic123启动之后Weblogic会将该文件中的用户名和密码加密。#Tue Jun 25 16:0...",
    "content": "在user_projects\\domains\\base_domain\\servers\\AdminServer\\security路径下创建boot.properties文件。#Tue Jun 25 16:03:48 CST 2019password=weblogicusername= weblogic123启动之后Weblogic会将该文件中的用户名和密码加密。#Tue Jun 25 16:03:48 CST 2019password={AES}nJ5pDEJUQFWxKHzz4kwiVW2DFqFCnDhW/wHzsPgYt7o\\=username={AES}yjpymx0snt+AZhAxDv7PtBVkS8p4ms03YHbvsJRNjdQ\\=如果需要修改启动Weblogic的密码，只需修改该文件的内容即可。"
  },
  
  {
    "title": "WebLogic启动命令",
    "url": "/posts/weblogic-qidong-mingling/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "WebLogic启动server命令[root@lbogon roy]# nohup ./startWebLogic.sh &gt;out.log 2&gt;&amp;1 &amp; ",
    "content": "WebLogic启动server命令[root@lbogon roy]# nohup ./startWebLogic.sh &gt;out.log 2&gt;&amp;1 &amp; "
  },
  
  {
    "title": "WebLogic静默创建域",
    "url": "/posts/weblogic-jingmo-chuangjian-yu/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "进入路径cd /weblogic/oracle/middleware/wlserver/common/bin静默创建域./config.sh -mode=silent -silent_script=/home/app_admin/weblogic_ins/create_domain.rsp -logfile=/home/app_admin/weblogic/create_domain.log...",
    "content": "进入路径cd /weblogic/oracle/middleware/wlserver/common/bin静默创建域./config.sh -mode=silent -silent_script=/home/app_admin/weblogic_ins/create_domain.rsp -logfile=/home/app_admin/weblogic/create_domain.logcreate_domain.rsp文件内容read template from \"/home/app_admin/weblogic/Oracle/Middleware/wlserver/common/templates/wls/wls.jar\"; set JavaHome \"/home/app_admin/jdk1.8.0_144\"; set ServerStartMode \"prod\"; find Server \"AdminServer\" as AdminServer;set AdminServer.ListenAddress \"\";set AdminServer.ListenPort \"7001\";//set AdminServer.SSL.Enabled \"true\";//set AdminServer.SSL.ListenPort \"7002\"; //We can directly create a new managed server.create Server \"VM-YDYWJYSL01\" as BASE;//set BASE.ListenAddress \"\";//set BASE.ListenPort \"8003\";//set BASE.SSL.Enabled \"true\";//set BASE.SSL.ListenPort \"8004″; //Create Machine//create Machine \"base\" as Machinename; //use templates default weblogic userfind User \"weblogic\" as u1;set u1.password \"weblogic123\"; //create a new user//create User \"weblogic\" as u1;//set u1.password \"weblogic123\"; write domain to \"/home/app_admin/weblogic/Oracle/Middleware/user_project/domains/base_domain/\";  // The domain name will be \"demo-domain\" close template;注意  ServerStartMode，dev为开发模式，prod为生产模式  AdminServer.ListenAddress为空默认是本机IP  SSL端口7002根据实际选择打开还是关闭  Machinename是主机名"
  },
  
  {
    "title": "WebLogic静默安装",
    "url": "/posts/weblogic-jingmo-anzhuang/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "前期准备新建用户组web[root@edwcube3 ~]# groupadd web新建用户weblogic并修改用户密码# 添加用户，并用-g参数来制定 web用户组[root@edwcube3 ~]# useradd -g web weblogic # passwd命令修改密码[root@edwcube3 ~]# passwd weblogic Changing password fo...",
    "content": "前期准备新建用户组web[root@edwcube3 ~]# groupadd web新建用户weblogic并修改用户密码# 添加用户，并用-g参数来制定 web用户组[root@edwcube3 ~]# useradd -g web weblogic # passwd命令修改密码[root@edwcube3 ~]# passwd weblogic Changing password for user weblogic.New UNIX password:Retype new UNIX password:passwd: all authentication tokens updated successfully.安装JDK。可以不安装JDK，直接在响应文件中指定JDK位置。开始安装首先看命令的格式java -jar wls_121200.jar -silent -responseFile file -invPtrLoc file# -response file：响应文件# -invPtrLoc file：初始化环境文件创建响应文件wls.rsp，响应文件中的项一定要写全，否则会报参数不足等错误[ENGINE]#DO NOT CHANGE THIS.Response File Version=1.0.0.0.0[GENERIC]#The oracle home location. This can be an existing Oracle Home or a new Oracle HomeORACLE_HOME=/home/weblogic#Set this variable value to the Installation Type selected. e.g. WebLogic Server, Coherence, Complete with Examples.INSTALL_TYPE=WebLogic Server#Provide the My Oracle Support Username. If you wish to ignore Oracle Configuration Manager configuration provide empty string for user name.MYORACLESUPPORT_USERNAME=#Provide the My Oracle Support PasswordMYORACLESUPPORT_PASSWORD=&lt;SECURE VALUE&gt;#Set this to true if you wish to decline the security updates. Setting this to true and providing empty string for My Oracle Support username will ignore the Oracle Configuration Manager configurationDECLINE_SECURITY_UPDATES=true#Set this to true if My Oracle Support Password is specifiedSECURITY_UPDATES_VIA_MYORACLESUPPORT=false#Provide the Proxy HostPROXY_HOST=#Provide the Proxy PortPROXY_PORT=#Provide the Proxy UsernamePROXY_USER=#Provide the Proxy PasswordPROXY_PWD=&lt;SECURE VALUE&gt;#Type String (URL format) Indicates the OCM Repeater URL which should be of the format [scheme[Http/Https]]://[repeater host]:[repeater port]COLLECTOR_SUPPORTHUB_URL=创建初始化环境文件文件oraInst.locinventory_loc=/home/weblogic/oraInventoryinst_group=weblogic保证所需要的目录weblogic用户要用读写权限，/ghca/bea文件用户weblogic必须要有读写权限，oraInst.loc，wls.rsp，fmw_12.1.3.0.0_wls.jar文件用户weblogic必须要有读写权限。安装 wls.rsp，oraInst.loc必须指定绝对路径java -jar fmw_12.1.3.0.0_wls.jar -silent -responseFile /home/weblogic/wls.rsp -invPtrLoc /home/weblogic/oraInst.loc启动程序日志文件为/tmp/OraInstall2016-12-07_11-28-48AM/launcher2016-12-07_11-28-48AM.log。正在提取文件........Java HotSpot(TM) Server VM warning: You have loaded library /tmp/orcl3700411247043593693.tmp/Disk1/install/linux/libjni.so which might have disabled stack guard. The VM will try to fix the stack guard now.It's highly recommended that you fix the library with 'execstack -c &lt;libfile&gt;', or link it with '-z noexecstack'.启动 Oracle Universal Installer检查 CPU 速度是否大于 300 MHz。 实际为 2128.009 MHz 通过检查交换空间: 必须大于 512 MB。 实际为 8388604 MB 通过检查此平台是否需要 64 位 JVM。 实际为32 通过 (不需要 64 位)检查临时空间: 必须大于 300 MB。 实际为 3559 MB 通过准备从/tmp/OraInstall2016-12-07_11-28-48AM启动 Oracle Universal InstallerJava HotSpot(TM) Server VM warning: ignoring option MaxPermSize=512m; support was removed in 8.0 ---可忽略日志:/tmp/OraInstall2016-12-07_11-28-48AM/install2016-12-07_11-28-48AM.log版权所有 (c) 1996, 2014, Oracle 和/或其附属公司。保留所有权利。正在读取响应文件...开始检查: CertifiedVersions预期的结果: enterprise-4,enterprise-5,enterprise-6,redhat-6,redhat-4,redhat-5,SuSE-11之一实际结果: (未知操作系统版本)检查完成。此次检查的总体结果为: 未通过 &lt;&lt;&lt;&lt; 可忽略问题: 此 Oracle 软件未经当前操作系统认证。建议案: 确保在正确的平台上安装软件。警告: 检查:CertifiedVersions 失败。开始检查: CheckJDKVersion预期的结果: 1.7.0_15实际结果: 1.8.0_111检查完成。此次检查的总体结果为: 通过  CheckJDKVersion 检查: 成功。已启用此会话的验证。正在验证数据...正在复制文件...可以在以下位置找到本次安装会话的日志:/tmp/OraInstall2016-12-07_11-28-48AM/install2016-12-07_11-28-48AM.log-----------20%----------40%----------60%----------80%--------100%Oracle Fusion Middleware 12c WebLogic Server 和 Coherence 12.1.3.0.0 的 安装 已成功完成。日志已成功复制到/home/weblogic/oraInventory/logs。打印此信息，说明weblogic安装成功了。"
  },
  
  {
    "title": "WebLogic集成到Eclipse",
    "url": "/posts/weblogic-jichengdao-eclipse/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "集成Weblogic其实和集成Tomcat操作基本是一样的（不过由于可能适配包不支持最新的weblogic12所以我新装了jdk1.7和weblogic10.3.6来演示。选择接受协议后开始安装适配包，由于网络问题安装比较慢，没有东西弹出来但在Eclipse右下角会有安装进度。选择重启Eclipse，重启后再次按前边步骤进到下图界面。可以看到Weblogic已成功添加，直接点击“Apply ...",
    "content": "集成Weblogic其实和集成Tomcat操作基本是一样的（不过由于可能适配包不支持最新的weblogic12所以我新装了jdk1.7和weblogic10.3.6来演示。选择接受协议后开始安装适配包，由于网络问题安装比较慢，没有东西弹出来但在Eclipse右下角会有安装进度。选择重启Eclipse，重启后再次按前边步骤进到下图界面。可以看到Weblogic已成功添加，直接点击“Apply and Close”。但现在我们并没有指定domain目录所以下边还得指定domain。在图中标签中展出“Known Domains”，然后在其中选择我们前边创建的base_domain。可以看到检测报错The server is invalid. Error occurred reading server credential. Required file or directory 'servers/AdminServer/security/boot.properties' cannot be found.，意思是在domain目录中找不到servers/AdminServer/security/boot.properties，这是Weblogic启动需要的用户密码文件，默认没有这个文件，也没有servers/AdminServer/security目录，所以我们进入domain主目录（我这里是D:\\Oracle\\Middleware\\user_projects\\domains\\base_domain），然后创建servers/AdminServer/security目录并在该目录下创建boot.properties文件，最后用记事本打开boot.properties，在其中写入前边创建domain时指定的用户名密码并保存，比如我这里是：先点Back返回上一步再点Next返回来，就不会有报错。我们这里由于什么都没配，所以没有资源，直接点“Finish”即可。这意思是boot.properties中还是明文密码这样不安全，不管他直接选“No”即可，使用一个项目测试可以看到Weblogic可正常服务。"
  },
  
  {
    "title": "WebLogic安装和部署",
    "url": "/posts/weblogic-anzhuang-he-bushu/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "安装Weblogic双击安装文件启动安装程序，在安装首页面点击下一步按钮。创建中间件主目录，建议路径为：D:\\OracleMiddleware，点击下一步按钮。设置安全更新账户，此处跳过，点击下一步按钮。选择安装类型，此处我们选择典型，点击下一步按钮。选择产品安装目录，点击下一步按钮。设置快捷方式位置，此处我们选择“所有用户”，点击下一步按钮。安装概要确认，点击下一步按钮。进行正式安装，等待...",
    "content": "安装Weblogic双击安装文件启动安装程序，在安装首页面点击下一步按钮。创建中间件主目录，建议路径为：D:\\OracleMiddleware，点击下一步按钮。设置安全更新账户，此处跳过，点击下一步按钮。选择安装类型，此处我们选择典型，点击下一步按钮。选择产品安装目录，点击下一步按钮。设置快捷方式位置，此处我们选择“所有用户”，点击下一步按钮。安装概要确认，点击下一步按钮。进行正式安装，等待完成，此过程切勿退出。配置域安装成功后，提示弹出配置向导，此处我们选择“创建新的Weblogic域”，点击下一步按钮。设置域类型，此处我们选择“Basic…”，点击下一步按钮。指定域名和位置，此处我们以base_domain举例，域位置默认为D:\\OracleMiddleware\\user_projects\\domains目录，点击下一步按钮。配置管理员用户名和口令，此处建议管理员名称/密码为weblogic/admin，点击下一步按钮。设置开发模式，此处建议选择可用JDK内的JRocket SDK，以防止Console发布崩溃的问题出现，点击下一步按钮。进行可选配置，此处勾选“管理服务器”，点击下一步按钮。配置管理服务器，此处ListenPort可以根据自己偏好进行设置，建议初次建立时不要调整，点击下一步按钮。配置概要预览，进行二次确认后，如无问题点击创建按钮。安装完成，此处会提示域位置以及管理服务器访问地址，点击完成按钮。运行OracleMiddleware\\user_projects\\domains\\picc_domain\\bin\\startWebLogic.cmd，在浏览器输入：http://localhost:7001/console访问控制台。"
  },
  
  {
    "title": "JWT",
    "url": "/posts/jwt/",
    "categories": "Knowledge, JWT",
    "tags": "JWT",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "什么是JWTJson web token (JWT)， 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。该Token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该Token也可直接...",
    "content": "什么是JWTJson web token (JWT)， 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。该Token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该Token也可直接被用于认证，也可被加密。JWT的组成第一部分称为头部（header)，第二部分称为载荷（payload)，第三部分是签证（signature)。      header    JWT的头部承载两部分信息：声明类型，这里是JWT；声明加密的算法，通常直接使用HMAC SHA256，完整的头部就像下面这样的JSON：      {      \"typ\": \"JWT\",      \"alg\": \"HS256\"  }        然后将头部进行BASE64加密（该加密是可以对称解密的），构成了第一部分。      eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9            playload    载荷就是存放有效信息的地方：标准中注册的声明、公共的声明、私有的声明。                  标准中注册的声明（建议但不强制使用）          iss: JWT签发者  sub: JWT所面向的用户  aud: 接收JWT的一方  exp: JWT的过期时间，这个过期时间必须要大于签发时间  nbf: 定义在什么时间之前，该JWT都是不可用的.  iat: JWT的签发时间  jti: JWT的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。                            公共的声明        公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的信息，但不建议添加敏感信息，因为该部分在客户端可解密。                    私有的声明        私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为BASE64是对称解密的，意味着该部分信息可以归类为明文信息。这个指的就是自定义的声明。这些声明跟JWT标准规定的声明区别在于：JWT规定的声明，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的声明进行验证；而私有的声明不会验证，除非明确告诉接收方要对这些声明进行验证以及规则才行。              定义一个payload      {      \"sub\": \"1234567890\",      \"name\": \"John Doe\",      \"admin\": true  }        然后将其进行BASE64加密，得到Jwt的第二部分。      eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9            signature    JWT的第三部分是一个签证信息，这个签证信息由三部分组成：      header (BASE64后的)  payload (BASE64后的)  secret        这个部分需要BASE64加密后的header和BASE64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行组合加密，然后就构成了JWT的第三部分。      // javascript  var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);  var signature = HMACSHA256(encodedString, 'secret');   // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ      将这三部分用.连接成一个完整的字符串，构成了最终的JWT:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ注意：secret是保存在服务器端的，JWT的签发生成也是在服务器端的，secret就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发JWT了。JWT有什么好处  支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。  无状态(也称：服务端可扩展行): Token机制在服务端不需要存储Session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的Cookie或本地介质存储状态信息。  更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：JavaScript，HTML，图片等），而你的服务端只要提供API即可。  去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可。  更适用于移动应用: 当你的客户端是一个原生平台（iOS，Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。  CSRF: 因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。一般建议使用：1、在HTTP请求中以参数的形式加入一个服务器端产生的token，或者，2、放入http请求头中也就是一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。  性能: 一次网络往返时间（通过数据库查询Session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。  不需要为登录页面做特殊处理: 如果你使用Protractor做功能测试的时候，不再需要为登录页面做特殊处理。  基于标准化:你的API可以采用标准化的JSON Web Token (JWT)。这个标准已经存在多个后端库（.NET，Ruby，Java，Python，PHP）和多家公司的支持（如：FireBASE，Google，Microsoft）。Java中的实现在Java的实现中可以有两种方式，一种是不借助第三方jar，自己生成token，另一种的借助第三方jar，传入自己需要的负荷信息，生成token。      自己生成Token    header和poyload的组成都是JSON字符串，所以先创建头部的JSON，然后用BASE64编码org.apache.axis.encoding.Base64。然后再创建负荷的JSON，然后也同样用BASE64编码，这样就生成了两个字符串，然后用.拼接到一起就形成了现在的形式eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0。接下来对上边拼接成的字符串进行HS256的算法加密生成sign签名，这里需要自己手动去写一个类，然后提供一个静态方法供外界的调用，类的实现代码如下：     import javax.crypto.Mac;   import javax.crypto.spec.SecretKeySpec;   import org.apache.commons.codec.binary.Base64;   public class HS256 {       public static String returnSign(String message) {           String hash = \"\";           // 别人篡改数据，但是签名的密匙是在服务器存储，         // 密匙不同，生成的sign也不同。           // 所以根据sign的不同就可以知道是否篡改了数据。           String secret = \"mystar\"; // 密匙           try {               Mac sha256_HMAC = Mac.getInstance(\"HmacSHA256\");               SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes(),                                       \"HmacSHA256\");               sha256_HMAC.init(secret_key);               hash = Base64.encodeBase64String(sha256_HMAC                                         .doFinal(message.getBytes()));               System.out.println(message + \"#####\" + hash);           } catch (Exception e) {               System.out.println(\"Error\");           }           return hash;       }   }          这样Token的三部分就生成了，然后当做参数传到前台，用Cookie存储就可以在同一客户端调用了。当从客户端带过来Token参数的时候，直接对头部和负荷再次调用加密算法，看生成的新的签名和之前的签名是否一致，判断数据是否被篡改。        借用第三方的jar(jjwt-0.7.0.jar)生成token      public static String createJWT(String py) {      System.out.println(\"负荷的值：\" + py);      SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;      // 此处就是服务器定义的自己的秘钥      String authJJm = PropertiesUtil.getValue(\"authJm\");      byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(authJm);      Key signingKey = new SecretKeySpec(apiKeySecretBytes,                                   signatureAlgorithm.getJcaName());      JwtBuilder builder = Jwts.builder()          .setHeaderParam(\"typ\", \"JWT\")          .setHeaderParam(\"alg\", \"HS256\")          .setPayload(py) // 负荷          .signWith(signatureAlgorithm, signingKey); // 部分签名，用HS256加密      return builder.compact();  }        调用这个方法会自动对header和poyload进行BASE64的编码，用的是jar包自带的io.jsonwebtoken.impl.Base64Codec，跟自己生成Token时，用的BASE64的jar不一样，自己在此列出来：      public static void main(String[] args) {          JSONObject json_header = new JSONObject();        json_header.put(\"typ\", \"JWT\"); // 类型        json_header.put(\"alg\", \"HS256\"); // 加密算法        String header = Base64Codec.BASE64URL.encode(json_header.toString()        .getBytes());        String aa = Base64Codec.BASE64URL.decodeToString(header);        System.out.println(header + \"--\" + aa);    }          接着上边createJWT()方法说，只要把自己定义的负荷JSON串当做参数传入就行，并且签名也会对应的生成，返回一个完整的Token。在测试的过程中，发现即使自己不定义Token的头部，也会自动生成header，只是里边没有typ这样的参数定义，只有HS256，这里源码里边，默认了alg的value。这样执行完，把生成的Token就当做参数传到前台，存储在Cookie里边。然后再说一下，前台带过来Token参数时候，怎么处理，看代码：      public static Claims parseJWT(String jwt) {      // 秘钥，跟生成Token时对应一致      String authJm = PropertiesUtil.getValue(\"authJm\");       if (jwt.split(\"\\\\.\").length == 3) {          String head = jwt.split(\"\\\\.\")[0]; // 头部          String payload = jwt.split(\"\\\\.\")[1]; // 负荷          // System.out.println(Base64Codec.BASE64URL.decodeToString(payload));          String sign = jwt.split(\"\\\\.\")[2]; // 签名          JwsHeader claims1 = Jwts.parser().setSigningKey(DatatypeConverter                          .parseBase64Binary(authJm))                          .parseClaimsJws(jwt).getHeader(); // 头部信息          System.out.println(\"头部：\" + claims1.toString());          Claims claims = Jwts.parser().setSigningKey(DatatypeConverter                          .parseBase64Binary(authJm))                          .parseClaimsJws(jwt).getBody(); // 负荷信息          // 传入负荷，再次调用返回签名，看是否一致          String sign_new = createJWT(JSONObject.toJSONString(claims))                                          .split(\"\\\\.\")[2];           if (sign_new.equals(sign)) {              System.out.println(\"匹配一致，数据没有篡改\");          }          return claims;      } else {          return null;      }  }        这个过程的原理跟自己生成Token判断原理一样，都是重新生成sign，只是一个是调用自己的方法，另外一个是调用第三方的方法。  Token过期时间这个相对来说不是太复杂，可以在负荷里边多带一个参数，把过期时间放进去，其实里边有一个exp标签名就是存储过期时间字段的，存储的是时间戳。// 存储long nowMillis = System.currentTimeMillis();long expMillis = nowMillis + 1000*2; // 设置Token 2秒过期// 获取Date aa = new Date(Long.parseLong(claims.get(\"aa\").toString()));可以存储一个生成Token时间和Token过期时间，然后服务器接收到的时候，可以根据当前的时间去判断。当前时间大于Token生成时间并且小于Token过期时间的情况下，继续走接下来的业务操作。  参考基于Token的WEB后台认证机制【JWT】JWT+HA256加密 Token验证JSON Web Token - 在Web应用间安全地传递信息"
  },
  
  {
    "title": "Git命令及其影响",
    "url": "/posts/git-mingling-huizong/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-07-06 13:47:00 +0800",
    





    
    "snippet": "本地仓库            行为      命令      备注                  初始化      git init      在本地的当前目录里初始化git仓库              拉取远程仓库      git clone 地址      从网络上某个地址拷贝仓库(repository)到本地              查看当前状态      git stat...",
    "content": "本地仓库            行为      命令      备注                  初始化      git init      在本地的当前目录里初始化git仓库              拉取远程仓库      git clone 地址      从网络上某个地址拷贝仓库(repository)到本地              查看当前状态      git status      查看当前仓库的状态              查看不同      git diff      查看当前状态和最新的commit之间不同的地方                     git diff 版本号1 版本号2      查看两个指定的版本之间不同的地方。这里的版本号指的是commit的hash值              添加文件      git add -A      在commit之前要先add              撤回stage的东西      git checkout – .      这里用英文句号表示撤回所有修改              提交      git commit -m “提交信息”      提交信息最好能体现更改了什么              删除未tracked      git clean -xf      删除当前目录下所有没有track过的文件。不管它是否是.gitignore文件里面指定的文件夹和文件              查看提交记录      git log      查看当前版本及之前的commit记录                     git reflog      查看HEAD的变更记录              版本回退      git reset –hard 版本号      回退到指定版本号的版本，该版本之后的修改都被删除。同时也是通过这个命令回到最新版本。需要reflog配合      远程仓库            行为      命令      备注                  设置用户名      git config –global user.name “你的用户名”                     设置邮箱      git config –global user.email “你的邮箱”                     生成ssh key      ssh-keygen -t rsa -C “你的邮箱”                     添加远程仓库      git remote add origin 你复制的地址      设置origin              上传并指定默认      git push -u origin master      指定origin为默认主机，以后push默认上传到origin上              提交到远程仓库      git push      将当前分支增加的commit提交到远程仓库              从远程仓库同步      git pull      在本地版本低于远程仓库版本的时候，获取远程仓库的commit      可以用一张图直观地看出以上主要的命令对仓库的影响。对照查看两张图：  Workspace：即工作区，逻辑上是本地计算机，还没添加到repository的状态；  Staging：即版本库中的stage，是暂存区。修改已经添加进repository，但还没有作为commit提交，类似于缓存；  Local repository：即版本库中master那个地方。到这一步才算是成功生成一个新版本；  Remote repository：则是远程仓库。用来将本地仓库上传到网络，可以用于备份、共享、合作。"
  },
  
  {
    "title": "Git本地仓库的使用",
    "url": "/posts/git-bendi-cangku-de-shiyong/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-07-06 13:47:00 +0800",
    





    
    "snippet": "新仓库初始化运行git init来初始化仓库它会创建一个隐藏的文件夹.git文件的添加和提交在这个文件夹里面创建一个today.txt的文件。这时使用git status来查看有什么变化。它告诉我有一个还未追踪的文件，并提示我可以使用git add &lt;file&gt;...把它加进去，执行git add -A，再次使用git status。状态变了，说明add成功。再看看它的提示Cha...",
    "content": "新仓库初始化运行git init来初始化仓库它会创建一个隐藏的文件夹.git文件的添加和提交在这个文件夹里面创建一个today.txt的文件。这时使用git status来查看有什么变化。它告诉我有一个还未追踪的文件，并提示我可以使用git add &lt;file&gt;...把它加进去，执行git add -A，再次使用git status。状态变了，说明add成功。再看看它的提示Changes to be committed，也就是说现在可以执行commit了。注意，只有被add到暂存区的更新才会被提交进入repo。提交前，如果对WorkSpace的文件进行修改，而没有被添加到暂存区，那么提交进repo中的只是暂存区的更新，WorkSpace修改的部分不会提交进repo中的。执行git commit -m \"提交信息\"将文件提交到repository里。提交信息用英文的双引号括起来。这时运行git log就可以看到提交的记录了，git log显示内容依次是：  此次提交对应的版本号  提交人：姓名 邮箱  提交的时间  提交版本修改的内容：就是我们commit -m \"xxx\"里的xxx文件的修改接着修改文件内容。我们用git status看看有什么变化。这和之前的提示不一样了。之前是这个。比较一下就会看到，之前的是添加新文件，当时文件还没被追踪（untracked），而这次是更改已经追踪（tracked）的文件。现在我们通过git看看文件做了哪些变化，执行git diff它默认跟最新的一个commit进行比较。红色（前面有减号-）表示删除，绿色（前面有加号+）表示添加。因此，在git看来，我们是删除了原来那一行，并添加了新的两行。这在文件内容特别多的时候效果比较明显。当然，我们也可以把WorkSpace中的状态和repo中的状态进行diff，命令如下：git diff HEAD~n，这个命令在以下情况可以使用：  你忘记改了什么，又想知道。  别人发给你新版本，你想知道更改了什么。假如我现在想撤销这些更改，执行git checkout -- .（git add之前）就行了。执行git status看看，上一个status的提示已经不见了。再来看看文件，已经复原了，那么再次进行修改。git add -Agit commit -m \"将[自己]改为[米娜桑]\"用git log看看提交（commit）记录。现在有两个提交了。版本回退现在试着将文件回退到第一个commit时的状态。从刚才的git log我们看到两行黄色部分是以commit开头的，后面接着一串字符。这一串字符是16进制的数，是一串哈希值。我们叫它版本号就行了。开始回退，执行git reset --hard 1df0573（取版本号前7位就可以了）。这里提示HEAD已经更改指向至1df0573了。此时文件内容已经回到第一个版本的状态。这里文件的修改日期被更改为现在的时间 2016\\6\\2 19:29，这是由于文件的修改日期是由Windows修改的，因为它检测到这个文件被修改了。而我们刚才从最新版本回退到现在这个版本，就像是我们手动修改了文件内容一样，事实上是由git来完成的。现在再执行git log。新版本的commit记录不见了，这就是reset --hard的力量，那怎么回到最新版呢？先执行git reflog。可以看到HEAD的变化情况。第一行表示当前HEAD所在的版本号是1df0573，而之所以在这个版本号，是由于我们执行了reset命令。看第二行，它告诉我们，这个HEAD所在的版本号是ad93b89，这个版本号是在执行commit之后形成的。此时我再用一次reset，git reset --hard ad93b89，将HEAD指向ad93b89， 同时查看log。回到第一次reset前的状态了。清除未追踪的文件现在看看如何用命令删除新加的文件。首先手动创建个文件，用来演示。用checkout是没办法删除掉它的，使用git clean -xf。这个命令的杀伤力比较大，它删除当前目录下所有没有track过的文件。不管它是否是.gitignore文件里面指定的文件夹和文件。"
  },
  
  {
    "title": "Git版本回退",
    "url": "/posts/git-banben-huitui/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-07-06 13:47:00 +0800",
    





    
    "snippet": "撤销WorkSpace中的更新使用git checkout --&lt;file&gt;...命令。注意：使用这种方法撤销更新的时候一定要慎重，因为通过这种方式撤销后，更新将没有办法再找回。当然，如果我们已经add了的话，那么checkout是没任何作用的，我们要先取消添加才可以撤回提交，使用下述指令：git reset HEAD Test.javagit checkout Test.jav...",
    "content": "撤销WorkSpace中的更新使用git checkout --&lt;file&gt;...命令。注意：使用这种方法撤销更新的时候一定要慎重，因为通过这种方式撤销后，更新将没有办法再找回。当然，如果我们已经add了的话，那么checkout是没任何作用的，我们要先取消添加才可以撤回提交，使用下述指令：git reset HEAD Test.javagit checkout Test.java撤销Stage中的更新使用git reset HEAD &lt;file&gt;...命令把暂存区的更新移出到WorkSpace中。撤销Repo中的更新撤销提交有两种方式：使用HEAD指针和使用commit id，在Git中，有一个HEAD指针指向当前分支中最新的提交。用HEAD代表当前版本，上一个版本就是HEAD^，再上一个版本就是HEAD^^依次类推，如果想回退到更早的提交，可以使用HEAD~n（也就是，HEAD^=HEAD~1，HEAD^^=HEAD~2）。git reset --hard HEAD^git reset --hard HEAD~1git reset --c2760c5512bc67a8b990c1da508d40cca623f23恢复被撤销的提交回退后，你突然后悔了，想回退回新的那个版本，可是遗憾的是，你键入git log却发现没有了最新的那个版本号，这怎么办呢，没事，Git中给你提供了这颗”后悔药”，Git记录着你输入的每一条指令，键入git reflog，你会发现，版本号就在这里，然后键入git reset --hard ad2080c。–hard和–soft前面在使用reset来撤销更新的时候，我们都是使用的--head选项，其实与之对应的还有一个--soft选项，区别如下：  –head：撤销并删除相应的更新。  –soft：撤销相应的更新，把这些更新的内容放到Stage中。删除文件在Git中，如果我们要删除一个文件，可以使用下面的命令，git rm &lt;file&gt;相比rm只是多了一步，把这次删除的更新发到Stage中。"
  },
  
  {
    "title": "Oracle DBLINK",
    "url": "/posts/oracle-dblink/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-07-06 01:47:00 +0800",
    





    
    "snippet": "Oracle在进行跨库访问时，可以通过创建DBLINK实现，首先了解下环境：在tnsnames.ora中配置两个数据库别名：orcl(用户名：wangyong 密码：1988)、orcl2(用户名：wangyong 密码：123456)，在orcl中创建DBLINK来访问orcl2赋予权限在创建DBLINK之前，我们需要判断，登陆的用户是否具备创建DBLINK的权限，所以我们执行以下的语句(...",
    "content": "Oracle在进行跨库访问时，可以通过创建DBLINK实现，首先了解下环境：在tnsnames.ora中配置两个数据库别名：orcl(用户名：wangyong 密码：1988)、orcl2(用户名：wangyong 密码：123456)，在orcl中创建DBLINK来访问orcl2赋予权限在创建DBLINK之前，我们需要判断，登陆的用户是否具备创建DBLINK的权限，所以我们执行以下的语句(用wangyong用户登陆orcl)-- 查看wangyong用户是否具备创建DBLINK权限select * from user_sys_privs where privilege like upper('%DBLINK%') AND USERNAME='WANGYONG';如果查询有返回行，则表示具备创建DBLINK权限，否则，则需要使用sys登陆orcl为WANGYONG用户赋予创建权限-- 给wangyong用户授予创建dblink的权限grant create public DBLINK to wangyong;此时，再执行上面查看是否具备权限的SQL语句，会发现有返回行，表示WANGYONG这个用户已经具备创建DBLINK的权限创建DBLINK      通过PLSQL图形化创建     填写完成后点击Apply按钮即可创建成功。        通过sqlplus中的SQL语句创建     -- 注意一点，如果密码是数字开头，用“”括起来 create public DBLINK TESTLINK2 connect to WANGYONG  identified by \"123456\" USING 'ORCL21'         -- 没有在tnsnames.ora中配置连接时使用下面的语句创建DBLINK CREATE DBLINK 'DBLINK名字' CONNECT TO '用户名' IDENTIFIED BY '密码' USING  '(DESCRIPTION =      (ADDRESS_LIST =         (ADDRESS =(PROTOCOL = TCP)(HOST = 数据库IP地址)(PORT = 1521))     )     (CONNECT_DATA =         (SERVICE_NAME = 服务名))     )';        这样，就完成了简单database简单的创建  创建同义词对于链接字符串，还可以创建同义词代替，使用起来会稍微省点事-- 创建同义词create synonym TESTSYNONYM FOR company@TESTLINK1;那么查询、插入、修改、删除中可直接用WYSYNONYM代替company@TESTLINK1即可，例如查询语句可改成如下方式-- 查询ORCL2中WANGYONG用户的表COMPANYSELECT * FROM TESTSYNONYM order by id"
  },
  
  {
    "title": "CentOS离线安装Oracle依赖",
    "url": "/posts/centos-lixian-anzhuang-oracle-yilai/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2021-07-06 01:47:00 +0800",
    





    
    "snippet": "安装离线下载插件[root@localhost honcur]# sudo yum install yum-plugin-downloadonly 这个插件可以把依赖包下载到本地。下载rpm包，保存在本地[root@localhost ~]# cd /usr/local[root@localhost local]# mkdir oralib[root@localhost local]# cd...",
    "content": "安装离线下载插件[root@localhost honcur]# sudo yum install yum-plugin-downloadonly 这个插件可以把依赖包下载到本地。下载rpm包，保存在本地[root@localhost ~]# cd /usr/local[root@localhost local]# mkdir oralib[root@localhost local]# cd oralib[root@localhost local]# yum install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers kernel-headers ksh libaio libaio-devel libgcc libgomp libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel glibc-static --downloadonly --downloaddir=. 执行命令后，进入/usr/local/oralib可以看到依赖包已经全部下载在文件夹内。安装Oracle需要的依赖包把依赖包oralib.tar放入/usr/local文件夹下，然后打开terminal# 切换到root[honcur@localhost ~]$ su root # 切换到目录[root@localhost honcur]# cd /usr/local # 解压依赖包[root@localhost local]# tar zxvf oralib.tar # 切换到oralib目录[root@localhost local]# cd oralib/ # 安装所有依赖,然后根据提示输入‘Y’，敲回车[root@localhost oralib]# yum localinstall *.rpm –nogpgcheck "
  },
  
  {
    "title": "Spring集成Quartz",
    "url": "/posts/spring-jicheng-quertz/",
    "categories": "Knowledge, Quartz",
    "tags": "Quartz",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "依赖&lt;!-- 定时任务 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;配置文件&l...",
    "content": "依赖&lt;!-- 定时任务 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans                      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 需要执行的类 --&gt; &lt;bean id=\"testJob\" class=\"com.sky.test.TestImpl\" /&gt; &lt;!-- 配置job --&gt; &lt;bean id=\"testJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt;  &lt;property name=\"targetObject\" ref=\"testJob\" /&gt;  &lt;!-- 定时的方法名 --&gt;  &lt;property name=\"targetMethod\" value=\"test\" /&gt;  &lt;!-- 是否允许任务并发执行。当值为false时，表示必须等到前一个线程处理完毕后才再启一个新的线程 --&gt;  &lt;property name=\"concurrent\" value=\"false\" /&gt; &lt;/bean&gt;     &lt;!-- CronTrigger表达式触发器 --&gt; &lt;bean id=\"testJobTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt;  &lt;property name=\"jobDetail\" ref=\"testJobDetail\" /&gt;  &lt;!-- 1000ms --&gt;  &lt;property name=\"startDelay\" value=\"1000\" /&gt;  &lt;!-- 设置定时的时间 --&gt;  &lt;property name=\"cronExpression\" value=\"0 0 4 * * ?\" /&gt; &lt;/bean&gt;     &lt;!--配置调度工厂 --&gt; &lt;bean id=\"schedulerFactoryNews\" autowire=\"no\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt;  &lt;property name=\"triggers\"&gt;   &lt;list&gt;    &lt;ref bean=\"testJobTrigger\" /&gt;   &lt;/list&gt;  &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;"
  },
  
  {
    "title": "Corn表达式",
    "url": "/posts/corn-biaodashi/",
    "categories": "Knowledge, Quartz",
    "tags": "Quartz",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "一个Cron表达式有至少6个（也可能7个）有空格分隔的时间元素，按顺序依次为秒       （0~59）分       （0~59）时       （0~23）天（月） （0~31，但是你需要考虑你月的天数）月       （0~11）天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）年       （1970－2099）其中每个元素可以是一个值(如...",
    "content": "一个Cron表达式有至少6个（也可能7个）有空格分隔的时间元素，按顺序依次为秒       （0~59）分       （0~59）时       （0~23）天（月） （0~31，但是你需要考虑你月的天数）月       （0~11）天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）年       （1970－2099）其中每个元素可以是一个值(如6)一个连续区间(9-12)一个间隔时间(8-18/4)(/表示每隔4小时)一个列表(1,3,5)通配符由于“月份中的日期”和“星期中的日期”这两个元素互斥的，必须要对其中一个设置0 0 10,14,16 * * ?          每天上午10点，下午2点，4点0 0/30 9-17 * * ?           朝九晚五工作时间内每半小时0 0 12 ? * WED              表示每个星期三中午12点 0 0 12 * * ?                每天中午12点触发 0 15 10 ? * *               每天上午10:15触发 0 15 10 * * ?               每天上午10:15触发 0 15 10 * * ? *             每天上午10:15触发 0 15 10 * * ? 2005          2005年的每天上午10:15触发 0 * 14 * * ?                在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ?              在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ?           在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ?              在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED          每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI         周一至周五的上午10:15触发 0 15 10 15 * ?              每月15日上午10:15触发 0 15 10 L * ?               每月最后一日的上午10:15触发 0 15 10 ? * 6L              每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2002-2005    2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3             每月的第三个星期五上午10:15触发   有些子表达式能包含一些范围或列表。例如：子表达式（天（星期））可以为MON-FRI，MON,WED,FRI，MON-WED,SAT。  *字符代表所有可能的值，因此，*在子表达式（月）里表示每个月的含义，*在子表达式（天（星期））表示星期的每一天。  /字符用来指定数值的增量。  例如：在子表达式（分钟）里的0/15表示从第0分钟开始，每15分钟，在子表达式（分钟）里的3/20表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样。  ?字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值，当两个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为?。  L字符仅被用于天（月）和天（星期）两个子表达式，它是单词last的缩写，但是它在两个子表达式里的含义是不同的，在天（月）子表达式中，“L”表示一个月的最后一天，在天（星期）自表达式中，L表示一个星期的最后一天，也就是SAT，如果在L前有具体的内容，它就具有其他的含义了。例如：6L表示这个月的倒数第6天，FRIL表示这个月的最一个星期五。  注意：在使用L参数时，不要指定列表或范围，因为这会导致问题。"
  },
  
  {
    "title": "Oracle 创建用户并分配权限",
    "url": "/posts/oracle-chuangjian-yonghu-bing-fenpei-quanxian/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "进入CMD命令行，输入sqlplus /nolog进入Oralce控制台；输入conn / as sysdba以管理员权限登录；登录成功输入create user 用户名 identified by 密码创建用户名密码；创建成功，开始授予权限，输入：-- 连接数据库权限grant create session to 用户名-- 操作表空间权限grant unlimited tablespac...",
    "content": "进入CMD命令行，输入sqlplus /nolog进入Oralce控制台；输入conn / as sysdba以管理员权限登录；登录成功输入create user 用户名 identified by 密码创建用户名密码；创建成功，开始授予权限，输入：-- 连接数据库权限grant create session to 用户名-- 操作表空间权限grant unlimited tablespace to 用户名;-- 创建表权限grant create table to 用户名;-- 删除表权限grante drop table to 用户名;-- 插入表权限grant insert table to 用户名;-- 更新表权限grant update table to 用户名;创建完成，退出控制台，输入用户名，密码登录查询用户是否创建成功。"
  },
  
  {
    "title": "Oracle 安装",
    "url": "/posts/oracle-anzhuang/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "  下载安装包http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html以下网址来源于官方下载页网win32位操作系统http://download.oracle.com/otn/nt/oracle11g/112010/win32_11gR2_database_1of2.ziphttp:...",
    "content": "  下载安装包http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html以下网址来源于官方下载页网win32位操作系统http://download.oracle.com/otn/nt/oracle11g/112010/win32_11gR2_database_1of2.ziphttp://download.oracle.com/otn/nt/oracle11g/112010/win32_11gR2_database_2of2.zip  win64位操作系统http://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_database_1of2.ziphttp://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_database_2of2.zip  双击安装文件，进行安装    配置更新信息，此处我们直接下一步    配置更新信息跳过的提醒，直接点击是按钮    设置安装选项，此处我们选择“创建和配置数据库”，点击下一步按钮    系统类别设置，此处我们选择“桌面类”，点击下一步按钮    设置安装信息，建议将Oracle主目录位置设置为非中文目录D:\\Oracle11g；全局数据库名默认为orcl，可根据自己需要进行修改；数据库口令为非必录项，如果录入则会设置为管理员账户的初始密码，设置完成后点击下一步按钮    如果密码过于简单，则会提示不符合规范，规范为不小于8位，且至少包含数字、小写字母、大写字母，此处我们忽略，点击是按钮    提进行先决条件检查    安装概要确认，查看无误后，点击完成按钮    进行安装，此过程时间较长    如果初始安装时，选择了创建数据库，则会创建数据库实例    设置数据库口令，如果不更改则直接点确认即可，此处建议点击口令管理进行调整    如果点击口令管理，则可设置账户锁定状态以及初始密码，填写完成后点击确定按钮    安装结束，此时会显示安装的配置信息，点击关闭按钮安装结束  "
  },
  
  {
    "title": "JDBC、数据源、JNDI、数据库连接池",
    "url": "/posts/shujuyuan-lianjiechi/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "JDBCjava database connectivity standard 是一套规范的面向应用程序的接口，通过它可以访问各类关系数据库。各个数据库会实现该接口作为驱动如jtds.jar，当然可以自己写实现。JDBC是低级API，提供访问数据库的接口，是构建高级API的基础，利用纯Java编写可以在任何操作系统任何Java环境下工作。JDBC API中定义了一些Java类分别用来表示与数...",
    "content": "JDBCjava database connectivity standard 是一套规范的面向应用程序的接口，通过它可以访问各类关系数据库。各个数据库会实现该接口作为驱动如jtds.jar，当然可以自己写实现。JDBC是低级API，提供访问数据库的接口，是构建高级API的基础，利用纯Java编写可以在任何操作系统任何Java环境下工作。JDBC API中定义了一些Java类分别用来表示与数据库的连接（connections），SQL语句（SQL statements），结果集（result sets）以及其它的数据库对象，使得Java程序能方便地与数据库交互并处理所得的结果。使用JDBC，所有Java程序（包括Java applications ，applets和servlet）都能通过SQL语句或存储在数据库中的过程（stored procedures）来存取数据库。要通过JDBC来存取某一特定的数据库，必须有相应的JDBC Driver，它往往是由生产数据库的厂家提供，是连接JDBC API与具体数据库之间的桥梁。JDBC Driver是用于特定数据库的一套实施了JDBC接口的类集。简单的说，JDBC可以做三件事：与数据库建立连接，发送SQL语句，处理结果。JDBC可以理解为ODBC的纯Java语言和面向对象的实现。JDBC传统模式开发存在的主要问题      时间和内存资源消耗巨大。    普通的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再根据JDBC代码（或配置文件）中的用户名和密码进行验证其正确性。这一过程一般会花费0.05~1s，一旦需要数据库连接的时候就必须向数据库请求一个，执行完后再断开连接。显然，如果同一个数据库在同一时间有数十人甚至上百人请求连接势必会占用大量的系统资源，严重的会导致服务器崩溃。        有内存泄漏的风险。    因为每一次数据库连接使用完后都需要断开连接，但如果程序出现异常致使连接未能及时关闭，这样就可能导致内存泄漏，最终只能以重启数据库的方法来解决；另外使用传统JDBC模式开发不能控制需要创建的连接数，系统一般会将资源大量分出给连接以防止资源不够用，如果连接数超出一定数量也会有极大的可能导致内存泄漏。  数据源数据源定义的是连接到实际数据库的一条路径而已，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接的，如ODBC数据源。也就是说数据源仅仅是数据库的连接名称，一个数据库可以有多个数据源连接。在Java语言中，DataSource对象就是一个代表数据源实体的对象。JNDIJNDI全称是java naming and directory interface（Java命名和目录接口）。简单点就是你按命名规则给一个东西命名然后你就可以通过该名字在特定环境下直接查找到该东西了。JNDI中的命名（Naming），就是将Java对象以某个名称的形式绑定（binding）到一个容器环境（Context）中，以后调用容器环境到JNDI容器环境（Context）的查找（lookup）方法又可以查找出某个名称所绑定的Java对象。这样做的好处在于在真实的项目应用中，通常是由系统程序或框架程序先将资源对象绑定到JNDI环境中，以后在该系统或框架中运行的模块程序就可以从JNDI环境中查找这些资源对象了。比如，Tomcat服务器在启动时可以创建一个连接到某种数据库系统的数据源（DataSource）对象，并将该数据源（DataSource）对象绑定到JNDI环境中，以后在这个Tomcat服务器中运行的Servlet和JSP程序就可以从JNDI环境中查询出这个数据源（DataSource）对象进行使用，而不用关心数据源（DataSource）对象是如何创建出来的，这种方式极大的增强了系统的可维护性，这样，当数据库系统的连接参数发生变更时，就只是Tomcat系统管理员一个人要关心的事情，而与所有的应用程序开发人员无关。数据库连接池为了解决由使用传统开发模式创建连接导致的一系列问题，我们可以采用数据库连接池技术。数据库连接池是负责分配、管理和释放数据库连接。使用数据库连接池是因为数据库连接是一种关键的有限的昂贵的资源。如Weblogic、Tomcat、WebSphere容器都实现了数据库连接池，但是数据库连接池是可以独立出来自己编码实现的。常见的数据库连接池有：c3p0、DBCP、BoneCP、Proxool等。数据库连接池在系统启动时初始化了一定量maxIdle=idlenum的数据库连接，即没有使用中的连接被释放的情况下，连接池中保存的最大空闲连接数。数据库连接请求如果没有超过idle的值则直接去连接池中获取；如果超过了maxIdle的值则新建一个数据库连接；但如果数据库连接池中的连接总数超过了maxActive=activenum则做如下处理：  直接抛错。  让想要借出连接的线程等待一段时间，如果等不到，再抛错。  每隔一段时间检查一次pool，直到有可用连接，否则一直等下去。  永远可以拿到（视情况需要maxActive不设置或0或负）。但当没有可以使用的数据库连接的时候，连接池将要等待一个连接被返回的最长时间（毫秒）maxWait=waitnum，超过这个时间就要抛出异常。数据源与数据库连接池关系  数据源是一种数据库对编程提供的一个接口，每个数据源对应一个数据库。  连接池只是存放数据库连接对象的一个缓冲池，需要数据连接的时候从缓冲池中取就行了。  连接池可以管理数据源。数据源与JNDI关系数据源是在JDBC 2.0中引入的一个概念。在JDBC 2.0扩展包中定义了javax.sql.DataSource接口来描述这个概念。如果用户希望建立一个数据库连接，通过查询在JNDI服务中的数据源，可以从数据源中获取相应的数据库连接。这样用户就只需要提供一个逻辑名称，而不是数据库登录的具体细节。即DataSource采用Java的JNDI技术，来获得DataSource对象的引用。"
  },
  
  {
    "title": "JNDI方式创建数据源连接",
    "url": "/posts/jndi-fangshi-chuangjian-shujuyuan/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "以JNDI方式创建数据源首先要配置数据源的相关连接信息，该配置在Tomcat安装目录下的conf/context.xml文件中&lt;Context&gt;   &lt;Resource  name=\"jdbc/NutzDemo\"               auth=\"Container\"              type=\"javax.sql.DataSource\"          ...",
    "content": "以JNDI方式创建数据源首先要配置数据源的相关连接信息，该配置在Tomcat安装目录下的conf/context.xml文件中&lt;Context&gt;   &lt;Resource  name=\"jdbc/NutzDemo\"               auth=\"Container\"              type=\"javax.sql.DataSource\"              maxActive=\"100\"               maxIdle=\"30\"              maxWait=\"10000\"              username=\"root\"               password=\"root\"              driverClassName=\"com.mysql.jdbc.Driver\"              url=\"jdbc:mysql://localhost:3306/cheng\" /&gt;&lt;/Context&gt;在项目的web.xml中引入数据源&lt;resource-ref&gt;  &lt;res-ref-name&gt;jdbc/NutzDemo&lt;/res-ref-name&gt;  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;  &lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt;获取数据库连接以进行相应的操作// 初始化JNDI上下文，创建DataSource对象Context initContext = new InitialContext();Context context = (Context) initContext.lookup(\"java:comp/env\");DataSource dataSource = (DataSource) context.lookup(\"jdbc/NutzDemo\");Connection conn = dataSource.getConnection();PreparedStatement ps = conn.prepareStatement(\"select * from t_role\");ResultSet rs = ps.executeQuery();System.out.println(rs.next());rs.close();conn.close();或者整合到Spring，在Spring的配置文件中添加如下代码&lt;bean id=\"datasource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;  &lt;property name=\"jndiName\" value=\"java:comp/env/jdbc/NutzDemor\" /&gt; &lt;/bean&gt;"
  },
  
  {
    "title": "Linux查看文件内容的命令",
    "url": "/posts/linux-chakan-wenjian-neirong-de-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-07-05 01:47:00 +0800",
    





    
    "snippet": "catmorehead /etc/passwd    # 查看文件的前十行head -2 /etc/passwd # 查看文件的前两行tail /etc/passwd    # 查看文件的后十行tail -f /etc/passwd # 实时跟踪文件的后十行tail -2 /etc/passwd # 查看文件的后两行wc -l /etc/passwd   # 显示文件的行数nl /etc/p...",
    "content": "catmorehead /etc/passwd    # 查看文件的前十行head -2 /etc/passwd # 查看文件的前两行tail /etc/passwd    # 查看文件的后十行tail -f /etc/passwd # 实时跟踪文件的后十行tail -2 /etc/passwd # 查看文件的后两行wc -l /etc/passwd   # 显示文件的行数nl /etc/passwd      # 直接打印文件内容并且显示行号"
  },
  
  {
    "title": "Context上下文",
    "url": "/posts/shangxiawen/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-02 13:47:00 +0800",
    





    
    "snippet": "程序执行部分到达子程序，子程序要获得结果，就要用到程序之前的一些结果（包括但不限于外部变量值，外部对象等等）；APP点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。这些都是上下文的典型例子，理解成环境就可以，而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。进程中断在操作系统中是有...",
    "content": "程序执行部分到达子程序，子程序要获得结果，就要用到程序之前的一些结果（包括但不限于外部变量值，外部对象等等）；APP点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。这些都是上下文的典型例子，理解成环境就可以，而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。进程中断在操作系统中是有上有下的。ServletContext是Servlet中最大的一个接口，呈现了Web应用的Servlet视图。它代表当前的web应用，所有的Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为Context域对象。这里的Context可以理解成是一种容器，而且容器里的东西是共享的。PageContext是JSP中的内置对象之一，它是javax.servlet.jsp.PageContext类的实例对象。提供了对JSP页面所有的对象及命名空间的访问，这里Context看作是一个实现访问JSP页面之间的数据共享的容器。"
  },
  
  {
    "title": "JSP九大内置对象及四大作用域",
    "url": "/posts/jsp-9daneizhiduixiang-4dazuoyongyu/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2021-07-02 13:47:00 +0800",
    





    
    "snippet": "JSP九大内置对象request     请求对象       类型javax.servlet.ServletRequest   作用域 Requestresponse    响应对象       类型javax.servlet.ServletResponse  作用域 PagepageContext 页面上下文对象  类型javax.servlet.jsp.PageContext  作用域...",
    "content": "JSP九大内置对象request     请求对象       类型javax.servlet.ServletRequest   作用域 Requestresponse    响应对象       类型javax.servlet.ServletResponse  作用域 PagepageContext 页面上下文对象  类型javax.servlet.jsp.PageContext  作用域 Pagesession     会话对象       类型javax.servlet.http.HttpSession 作用域 Sessionapplication 应用程序对象   类型javax.servlet.ServletContext    作用域 Applicationout         输出对象       类型javax.servlet.jsp.JspWriter    作用域 Pageconfig      配置对象       类型javax.servlet.ServletConfig    作用域 Pagepage        页面对象       类型javax.servlet.Object           作用域 Pageexception   例外对象       类型javax.servlet.Throwable        作用域 Pageexception对象则代表了JSP文件运行时所产生的例外对象，此对象不能在一般JSP文件中直接使用，而只能在使用了&lt;%@ page isErrorPage=\"true\"%&gt;的JSP文件中使用。JSP四大域对象JSP九大内置对象中有四大域对象，范围小到大page(PageContext,JSP有效)              指pageContext(javax.servlet.jsp.PageContext)request(一次请求)                指HttpServletRequest(javax.servlet.ServletRequest)session(一次会话)                       指HttpSession(javax.servlet.http.HttpSession)application(ServletContext,当前web应用) 指application(javax.servlet.ServletContext)Servlet三大域对象  request  session  application实验大概流程是这样的，我们访问index.jsp的时候，分别对pageContext，request，session，application四个作用域中的变量进行累加。（当然先判断这个变量是不是存在，如果变量不存在，则要把变量初始化成1）。计算完成后就从index.jsp执行forward跳转到test.jsp。在test.jsp里再进行一次累加，然后显示出这四个整数来。从显示的结果来看，我们可以直观的得出结论：  page里的变量没法从index.jsp传递到test.jsp。只要页面跳转了，它们就不见了。  request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。  session和application里的变量一直在累加，开始还看不出区别，只要关闭浏览器，再次重启浏览器访问这页，session里的变量就重新计算了。  application里的变量一直在累加，除非你重启Tomcat，否则它会一直变大。作用域规定的是变量的有效期限：  如果把变量放到pageContext里，就说明它的作用域是page，它的有效范围只在当前JSP页面里。从把变量放到PageContext开始，到JSP页面结束，你都可以使用这个变量。  如果把变量放到request里，就说明它的作用域是request，它的有效范围是当前请求周期。所谓请求周期，就是指从HTTP请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个JSP页面，在这些页面里你都可以使用这个变量。  如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。  如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他作用域中都是不会发生的，page，request，session都是完全隔离的，无论如何修改都不会影响其他人的数据。作用域的生命周期和作用范围  application(ServletContext)          生命周期：当Web应用被加载进容器时创建代表整个web应用的ServletContext对象，当服务器关闭或Web应用被移除时，ServletContext对象跟着销毁。      作用范围：整个Web应用。        request          生命周期：在service 方法调用前由服务器创建，传入service方法。整个请求结束，request生命结束。      作用范围：整个请求链（请求转发也存在）。        session          生命周期：在第一次调用 request.getSession() 方法时，服务器会检查是否已经有对应的session,如果没有就在内存中创建一个session并返回。当一段时间内session没有被使用（默认为30分钟），则服务器会销毁该session。如果服务器非正常关闭（强行关闭），没有到期的session也会跟着销毁。如果调用session提供的invalidate()，可以立即销毁session。      作用范围：一次会话。        page(PageContext)          生命周期：当对JSP请求时开始，当响应结束时销毁。      作用范围：整个JSP页面，是四大作用域中最小的一个。      "
  },
  
  {
    "title": "context-param和init-param",
    "url": "/posts/context-param-he-init-param/",
    "categories": "Knowledge, JavaWeb",
    "tags": "JavaWeb",
    "date": "2021-07-02 01:47:00 +0800",
    





    
    "snippet": "初始化参数web.xml里面可以定义两种参数  Application范围内的参数，存放在ServletContext中，在web.xml中配置如下     &lt;context-param&gt;     &lt;param-name&gt;context/param&lt;/param-name&gt;     &lt;param-value&gt;avalible during ap...",
    "content": "初始化参数web.xml里面可以定义两种参数  Application范围内的参数，存放在ServletContext中，在web.xml中配置如下     &lt;context-param&gt;     &lt;param-name&gt;context/param&lt;/param-name&gt;     &lt;param-value&gt;avalible during application&lt;/param-value&gt; &lt;/context-param&gt;        Servlet范围内的参数，只能在Servlet的init()方法中取得，在web.xml中配置如下     &lt;servlet&gt;     &lt;servlet-name&gt;MainServlet&lt;/servlet-name&gt;     &lt;servlet-class&gt;com.wes.controller.MainServlet&lt;/servlet-class&gt;     &lt;init-param&gt;        &lt;param-name&gt;param1&lt;/param-name&gt;        &lt;param-value&gt;avalible in servlet init()&lt;/param-value&gt;     &lt;/init-param&gt;     &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt;      初始化参数获取在Servlet中可以通过代码分别取用package com.wes.controller;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;public class MainServlet extends HttpServlet {    public MainServlet() {        super();    }    public void init() throws ServletException {        System.out.println(\"下面的参数是存放在ServletContext中的\");        System.out.println(getServletContext().getInitParameter(\"context/param\"));        System.out.println(\"下面的参数param1是在Servlet中存放的\");        System.out.println(this.getInitParameter(\"param1\"));    }}第一种参数在Servlet里面可以通过getServletContext().getInitParameter(\"context/param\")得到第二种参数只能在Servlet的init()方法中通过this.getInitParameter(\"param1\")得到示例&lt;servlet&gt;    &lt;description&gt;&lt;/description&gt;    &lt;display-name&gt;IOCServlet&lt;/display-name&gt;    &lt;servlet-name&gt;IOCServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.hp.servlet.IOCServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;test&lt;/param-name&gt;        &lt;param-value&gt;123&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt; &lt;context-param&gt;    &lt;param-name&gt;test1&lt;/param-name&gt;    &lt;param-value&gt;456&lt;/param-value&gt;&lt;/context-param&gt; PrintWriter out = response.getWriter();out.println(\"context test：\" + getServletContext().getInitParameter(\"test\"));out.println(\"context test1：\" + getServletContext().getInitParameter(\"test1\"));out.println(\"init test：\" + this.getInitParameter(\"test\"));out.println(\"init test1：\" + this.getInitParameter(\"test1\"));out.close();# 结果context test nullcontext test1 456init test 123init test1 null"
  },
  
  {
    "title": "Spring项目启动报错",
    "url": "/posts/spring-xiangmu-qidong-baocuo/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-01 13:47:00 +0800",
    





    
    "snippet": "报错信息通配符的匹配很全面, 但无法找到元素 'mvc:annotation-driven' 的声明报错原因虽然在XML文件上方声明了mvc，但没有配置此声明对应的文件信息。解决方法正确配置如下&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/200...",
    "content": "报错信息通配符的匹配很全面, 但无法找到元素 'mvc:annotation-driven' 的声明报错原因虽然在XML文件上方声明了mvc，但没有配置此声明对应的文件信息。解决方法正确配置如下&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc         http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;意思就是，mvc声明用http://www.springframework.org/schema/mvc/spring-mvc.xsd这个文件来解析。"
  },
  
  {
    "title": "ResponseBody返回4种数据格式的数据",
    "url": "/posts/ResponseBody-fanhui-sizhong-geshi-de-shuju/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-01 13:47:00 +0800",
    





    
    "snippet": "返回键值对或者集合前端JS请求// 返回值为Map的形式$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()}...",
    "content": "返回键值对或者集合前端JS请求// 返回值为Map的形式$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()}, // 请求参数        dataType : \"json\", // Ajax接口（请求URL）返回的数据类型        success : function(data) { // data：返回数据（JSON对象）            if(data.name == \"empty\") {                $(\".errorFont\").text(\"用户名为不能为空！\");                $(\".errorFont\").css(\"color\",\"red\");            } else if (data.name == \"exist\") {                $(\".errorFont\").text(\"用户名已注册\");                $(\".errorFont\").css(\"color\",\"green\");            } else if (data.name == \"noexist\") {                $(\".errorFont\").text(\"用户名未注册\");                $(\".errorFont\").css(\"color\",\"red\");            }        },        error : function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 验证用户是否存在，返回一个键值对的数据@RequestMapping(\"/nameProving\") @ResponseBodypublic Object nameProving(String name) {    HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;();    if (StringUtils.isEmpty(name)) {        resultMap.put(\"name\", \"empty\");    } else {        Userss user = userService.getUserByName(name);        if(user!=null)            resultMap.put(\"name\", \"exist\");        else            resultMap.put(\"name\", \"noexist\");    }    return JSONArray.toJSONString(resultMap);}返回JSON格式的字符串前端JS请求// 返回值为String的形式，dataType:\"json\"$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving2?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()},        dataType : \"json\",        success : function(data) { // data：返回数据（JSON对象）            if(data == \"empty\") {                $(\".errorFont\").text(\"用户名为不能为空2！\");                $(\".errorFont\").css(\"color\",\"red\");            } else if(data == \"exist\") {                $(\".errorFont\").text(\"用户名已注册2\");                $(\".errorFont\").css(\"color\",\"green\");            } else if(data == \"noexist\") {                $(\".errorFont\").text(\"用户名未注册2\");                $(\".errorFont\").css(\"color\",\"red\");            }        },        error : function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员2！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 验证用户是否存在，返回一个转成JSON字符串的数据@RequestMapping(\"/nameProving2\") @ResponseBodypublic String nameProving2(String name) {    String result = \"\";    if(StringUtils.isEmpty(name)) {        result = \"empty\";    } else {        Userss user = userService.getUserByName(name);        if(user != null)            result = \"exist\";        else            result = \"noexist\";    }    return JSONArray.toJSONString(result);}返回字符串前端JS请求// 返回值为String的形式，dataType:\"text\"$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving3?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()},        dataType : \"text\"        success:function(data) {            if(data == \"\\\"empty\\\"\") {                $(\".errorFont\").text(\"用户名为不能为空3！\");                $(\".errorFont\").css(\"color\",\"red\");            } else if(data == \"\\\"exist\\\"\") {                $(\".errorFont\").text(\"用户名已注册3\");                $(\".errorFont\").css(\"color\",\"green\");            } else if(data == \"\\\"noexist\\\"\") {                $(\".errorFont\").text(\"用户名未注册3\");                $(\".errorFont\").css(\"color\",\"red\");            }        },        error:function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员3！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 验证用户是否存在，返回一个字符串的数据/*** 此方法中有多个注解 * method：指定请求方式* required：表示参数是否必须，默认为必须，fslse为不是必须* @param name* @return*/@RequestMapping(value=\"/nameProving3\", method=RequestMethod.POST, params=\"name\") @ResponseBodypublic String nameProving3(@RequestParam(value=\"name\", required=false) String name) {    String result = \"\";    if(StringUtils.isEmpty(name)) {        result= \"empty\";    } else {        Userss user=userService.getUserByName(name);        if(user!=null)            result= \"exist\";        else            result= \"noexist\";    }    return result;}返回类对象的数据前端JS请求// 返回值为类对象的形式，dataType:\"json\"$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving4?t=\"+new Date().getTime(),        data : {name:$(\".name\").val()},        dataType : \"json\",        success : function(data) {            if (data == null) {                $(\".errorFont\").text(\"用户名为空或者用户名不存在4！\");                $(\".errorFont\").css(\"color\",\"red\");            } else {                $(\".errorFont\").text(\"用户名\"+data.name+\"已注册4\");                $(\".errorFont\").css(\"color\",\"green\");            }        },        error : function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员2！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 返回一个类对象@RequestMapping(\"/nameProving4\") @ResponseBodypublic User nameProving4(String name) {    User user = userService.getUserByName(name);    if(user==null){        return null;    }    return user;}"
  },
  
  {
    "title": "web.xml的加载顺序",
    "url": "/posts/webxml-de-jiazai-shunxu/",
    "categories": "Knowledge, JavaWeb",
    "tags": "JavaWeb",
    "date": "2021-07-01 13:47:00 +0800",
    





    
    "snippet": "web.xml加载顺序首先可以肯定的是，加载顺序与它们在web.xml文件中的先后顺序无关。即不会因为filter写在listener的前面而会先加载filter。最终得出的结论是：listener -&gt; filter -&gt; servlet同时还存在着这样一种配置节：context-param，它用于向ServletContext提供键值对，即应用程序上下文信息。我们的liste...",
    "content": "web.xml加载顺序首先可以肯定的是，加载顺序与它们在web.xml文件中的先后顺序无关。即不会因为filter写在listener的前面而会先加载filter。最终得出的结论是：listener -&gt; filter -&gt; servlet同时还存在着这样一种配置节：context-param，它用于向ServletContext提供键值对，即应用程序上下文信息。我们的listener，filter等在初始化时会用到这些上下文中的信息，那么context-param配置节是不是应该写在listener配置节前呢？实际上 context-param配置节可写在任意位置，因此真正的加载顺序为：context-param -&gt; listener -&gt; filter -&gt; servlet对于某类配置节而言，与它们出现的顺序是有关的。以filter为例，web.xml中可以定义多个filter，与filter相关的一个配置节是filter-mapping，这里一定要注意，对于拥有相同filter-name的filter和filter-mapping配置节而言，filter-mapping必须出现在filter之后，否则当解析到filter-mapping时，它所对应的filter-name还未定义。web容器启动时初始化每个filter时，是按照filter配置节出现的顺序来初始化的，当请求资源匹配多个filter-mapping时，filter拦截资源是按照filter-mapping配置节出现的顺序来依次调用doFilter()方法的。servlet同filter类似，此处不再赘述。由此，可以看出，web.xml的加载顺序是：context-param -&gt; listener -&gt; filter -&gt; servlet ，而同个类型之间的实际程序调用的顺序是根据对应的mapping的顺序进行调用的。Load-on-startup元素Load-on-startup元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候，加载这个servlet。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。在servlet的配置当中，5的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。web.xml加载过程  启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取&lt;listener&gt;和&lt;context-param&gt;两个结点。  紧急着，容器创建一个ServletContext（servlet上下文），这个web项目的所有部分都将共享这个上下文。  容器将&lt;context-param&gt;转换为键值对，并交给servletContext。  容器创建&lt;listener&gt;中的类实例，创建监听器。"
  },
  
  {
    "title": "WebLogic默认用户名和密码",
    "url": "/posts/welogic-moren-yonghuminghemima/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "Weblogic的默认用户名和密码：weblogic/weblogic",
    "content": "Weblogic的默认用户名和密码：weblogic/weblogic"
  },
  
  {
    "title": "Oracle 常用语句",
    "url": "/posts/oracle-changyong-yuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "临时表select to_date('2004-05-07','yyyy-mm-dd') from dual修改字段长度alter table &lt;TABLENAME&gt; modify &lt;COL&gt; &lt;COLTYPE&gt;;-- 示例alter table TEST modify param1 VARCHAR2(4000);修改字段名称alter table &lt...",
    "content": "临时表select to_date('2004-05-07','yyyy-mm-dd') from dual修改字段长度alter table &lt;TABLENAME&gt; modify &lt;COL&gt; &lt;COLTYPE&gt;;-- 示例alter table TEST modify param1 VARCHAR2(4000);修改字段名称alter table &lt;TABLENAME&gt; RENAME COLUMN &lt;COL1&gt; TO &lt;COL2&gt;;查询数据库中包含USERCODE字段的表select * from user_tab_cols where column_name='USERCODE';查询所有表select table_name from user_tables;查询指定表名下的所有字段select * from user_tab_columns where Table_Name='表名';查询所有表的字段和注释select * from user_col_comments;"
  },
  
  {
    "title": "Git配置用户名和邮箱",
    "url": "/posts/git-peizhi-yonghuming-he-youxiang/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "# 设置全局用户名和邮箱git config --global user.name '张三'git config --global user.email 'zhangsan@email.com'# 查看当前配置git config --global user.namegit config --global user.email# 针对某个项目单独设置用户名和邮箱# 进入到该项目的.git目录...",
    "content": "# 设置全局用户名和邮箱git config --global user.name '张三'git config --global user.email 'zhangsan@email.com'# 查看当前配置git config --global user.namegit config --global user.email# 针对某个项目单独设置用户名和邮箱# 进入到该项目的.git目录，执行如下命令git config --local user.name '张三'git config --local user.email 'zhangsan@email.com'# 删除全局的用户和邮箱git config --global --unset user.namegit config --global --unset user.email# 删除某个项目中的用户名和邮箱# 进入到该项目的.git目录，执行如下命令git config --local --unset user.namegit config --local --unset user.email"
  },
  
  {
    "title": "Git常用命令",
    "url": "/posts/git-changyong-mingling/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "git init     # 初始化仓库git status   # 查看工作区状态git add -A   # 添加文件git commit -m \"提交信息\"  # 将文件提交到repository里git log      # 查看提交的记录git diff     # 查询更改信息git checkout -- .        # 撤销更改git reset --hard 1df0...",
    "content": "git init     # 初始化仓库git status   # 查看工作区状态git add -A   # 添加文件git commit -m \"提交信息\"  # 将文件提交到repository里git log      # 查看提交的记录git diff     # 查询更改信息git checkout -- .        # 撤销更改git reset --hard 1df0573 # 回退，取版本号前7位就可以了git clean -xf            # 删除新加的文件git checkout develop     # 切换到开发分支git checkout -b xxx        # 创建本地分支git remote update origin --prune    # 刷新远程分支列表"
  },
  
  {
    "title": "Dubbo发布和引用服务",
    "url": "/posts/dubbo-fabuheyinyong-fuwu/",
    "categories": "Knowledge, Dubbo",
    "tags": "Dubbo",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "使用Dubbo发布服务在spring/applicationContext-dubbo.xml文件里添加如下信息&lt;!-- Dubbo服务的名称，用于计算依赖关系，名称可自定义，但不可重复--&gt; &lt;dubbo:application name=\"test\" /&gt;&lt;!-- 配置注册中心ZooKeeper地址 --&gt; &lt;dubbo:registry pro...",
    "content": "使用Dubbo发布服务在spring/applicationContext-dubbo.xml文件里添加如下信息&lt;!-- Dubbo服务的名称，用于计算依赖关系，名称可自定义，但不可重复--&gt; &lt;dubbo:application name=\"test\" /&gt;&lt;!-- 配置注册中心ZooKeeper地址 --&gt; &lt;dubbo:registry protocol=\"zookeeper\" address=\"127.0.0.1:2181\" /&gt;&lt;!-- 用Dubbo协议在20882端口暴露服务 --&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20882\" /&gt;&lt;!-- 发布接口服务 interface:发布的接口全限定名称 ref:接口的实现类                     version:版本号 timeout:设置超时时间--&gt;&lt;dubbo:service interface=\"com.test.reveal.testReveal.TestInterReveal\"             ref=\"testInterReveal\" version=\"2.0.0\" timeout=\"300000\"/&gt;使用Dubbo引用服务在spring/springmvc.xml文件里添加如下信息&lt;!-- Dubbo服务的名称，用于计算依赖关系，名称可自定义，但不可重复--&gt;&lt;dubbo:application name=\"test-item\"/&gt;&lt;!-- 配置注册中心ZooKeeper地址，该注册地址必须和服务接口注册地址相同 --&gt; &lt;dubbo:registry protocol=\"zookeeper\" address=\"127.0.0.1:2181\" /&gt;&lt;!-- 引用接口服务 --&gt;&lt;dubbo:reference interface=\"com.test.reveal.testReveal.TestInterReveal\"             id=\"testInterReveal\" check=\"false\" version=\"2.0.0\"/&gt;"
  },
  
  {
    "title": "CentOS安装JDK",
    "url": "/posts/centos-anzhuang-jdk/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2021-06-30 01:47:00 +0800",
    





    
    "snippet": "当前JDK最新版本下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html历史JDK版本下载地址：http://www.oracle.com/technetwork/java/javase/archive-139210.htmlLinux上一般会安装Open JDK，关于OpenJDK和JDK的区别：htt...",
    "content": "当前JDK最新版本下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html历史JDK版本下载地址：http://www.oracle.com/technetwork/java/javase/archive-139210.htmlLinux上一般会安装Open JDK，关于OpenJDK和JDK的区别：http://www.cnblogs.com/sxdcgaq8080/p/7487369.html卸载系统自带OpenJDK查看系统自带的OpenJDK版本信息java -version查看系统自带Java相关文件rpm -qa | grep java以上文件中，下面这几个可以删除java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64删除系统自带Java文件rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64检查是否已经删除成功java -version显示未找到命令...，代表已经删除成功了，如果还没删除，使用yum -y remove xxx命令删除解压JDKtar -zxvf jdk-8u144-linux-x64.tar.gz配置环境变量vi /etc/profile在文本的最后一行插入#java environmentexport JAVA_HOME=/usr/soft/jdk1.8.0_65export JRE_HOME=$JAVA_HOME/jreexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib退出viESCshift+qqw!刷新环境变量source /etc/profile检查是否安装成功java -version"
  },
  
  {
    "title": "ORA-00911 invalid character",
    "url": "/posts/tongshi-zhixing-duotiao-insert-yuju-baocuo/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-25 13:47:00 +0800",
    





    
    "snippet": "错误信息在PLSQL Developer中的SQL窗口执行多条insert语句时会提示错误：ORA-00911 : invalid character，检查sql提示所在的分号是英文的，没有问题。更加奇怪的是如果一条一条执行，是不会出现这个错误的，都是可以成功的，但是批量执行就会提示ORA-00911了。解决方法在SQL的开始和最后添加如下：begin  insert sql1;  inse...",
    "content": "错误信息在PLSQL Developer中的SQL窗口执行多条insert语句时会提示错误：ORA-00911 : invalid character，检查sql提示所在的分号是英文的，没有问题。更加奇怪的是如果一条一条执行，是不会出现这个错误的，都是可以成功的，但是批量执行就会提示ORA-00911了。解决方法在SQL的开始和最后添加如下：begin  insert sql1;  insert sql2;  ...end;这样就可以了。"
  },
  
  {
    "title": "Oracle 的精确函数",
    "url": "/posts/oracle-de-jinggque-hanshu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-25 13:47:00 +0800",
    





    
    "snippet": "ROUND按照指定的精度进行四舍五入select round(3.1415926, 4) from dual;------------------3.1416TRUNC按照指定的精度进行截取一个数select trunc(3.1415926, 4) from dual;------------------3.1415FLOOR对给定的数字取整数位select floor(2345.67) f...",
    "content": "ROUND按照指定的精度进行四舍五入select round(3.1415926, 4) from dual;------------------3.1416TRUNC按照指定的精度进行截取一个数select trunc(3.1415926, 4) from dual;------------------3.1415FLOOR对给定的数字取整数位select floor(2345.67) from dual;------------------2345CEIL返回大于或等于给出数字的最小整数select ceil(3.1415927) from dual;------------------4"
  },
  
  {
    "title": "Git忽略提交文件",
    "url": "/posts/git-hulue-tijiao-wenjian/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-25 13:47:00 +0800",
    





    
    "snippet": "Git可以add多个文件后再一次性提交，不过如果我们改动的文件很多的话，我们可以git add .一次添加全部，但有一些是几百年都不变一次的又或者自动生成的，比如lib，gen，bin文件夹等等，我们可以在代码仓库的根目录下创建一个名为.gitignore的文件，然后编辑里面的内容，把不需提交的文件忽略掉。/gen//bin//project.properties那么我们git add .的...",
    "content": "Git可以add多个文件后再一次性提交，不过如果我们改动的文件很多的话，我们可以git add .一次添加全部，但有一些是几百年都不变一次的又或者自动生成的，比如lib，gen，bin文件夹等等，我们可以在代码仓库的根目录下创建一个名为.gitignore的文件，然后编辑里面的内容，把不需提交的文件忽略掉。/gen//bin//project.properties那么我们git add .的时候，这里的文件就不会add。"
  },
  
  {
    "title": "CentOS安装Maven",
    "url": "/posts/centos-anzhuang-maven/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2021-06-25 01:47:00 +0800",
    





    
    "snippet": "解压Maven安装包tar -zxvf apache-maven-3.5.2-bin.tar.gz 配置maven环境变量vi /etc/profile添加环境变量# maven environmentexport MAVEN_HOME=/var/local/apache-maven-3.5.2export MAVEN_HOMEexport PATH=$PATH:$MAVEN_HOME/bi...",
    "content": "解压Maven安装包tar -zxvf apache-maven-3.5.2-bin.tar.gz 配置maven环境变量vi /etc/profile添加环境变量# maven environmentexport MAVEN_HOME=/var/local/apache-maven-3.5.2export MAVEN_HOMEexport PATH=$PATH:$MAVEN_HOME/bin刷新环境变量source /etc/profile验证结果mvn -version"
  },
  
  {
    "title": "ResponseBody响应乱码",
    "url": "/posts/ResponseBody-luanma/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "第一种解决方案是使用@RequestMapping注解的produces方法，写法如下：@RequestMapping(value = \"testPersonalValidtor.do\",produces = \"application/json;charset=utf-8\")  第二种方法是在Spring的配置文件中修改：&lt;!-- 处理@ResponseBody响应乱码 --&gt;&...",
    "content": "第一种解决方案是使用@RequestMapping注解的produces方法，写法如下：@RequestMapping(value = \"testPersonalValidtor.do\",produces = \"application/json;charset=utf-8\")  第二种方法是在Spring的配置文件中修改：&lt;!-- 处理@ResponseBody响应乱码 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;       &lt;property name=\"messageConverters\"&gt;            &lt;list&gt;                &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt;                    &lt;property name=\"supportedMediaTypes\"&gt;                        &lt;list&gt;                            &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;                        &lt;/list&gt;                    &lt;/property&gt;                &lt;/bean&gt;            &lt;/list&gt;       &lt;/property&gt;  &lt;/bean&gt; "
  },
  
  {
    "title": "Oracle 计算时间差",
    "url": "/posts/oracle-jisuan-shijiancha/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "SELECT    param1,    param2,    param3FROM    TEST TWHERE    TO_NUMBER (        TO_DATE (            TO_CHAR (T.modifydate, 'yyyy-mm-dd hh24:mi:ss'),            'yyyy-mm-dd hh24:mi:ss'        ) -  ...",
    "content": "SELECT    param1,    param2,    param3FROM    TEST TWHERE    TO_NUMBER (        TO_DATE (            TO_CHAR (T.modifydate, 'yyyy-mm-dd hh24:mi:ss'),            'yyyy-mm-dd hh24:mi:ss'        ) -         TO_DATE (            TO_CHAR (T.createdate, 'yyyy-mm-dd hh24:mi:ss'),            'yyyy-mm-dd hh24:mi:ss'        )    ) * 86400 &gt; 2 * 24 * 60 * 60SELECT    param1,    param2,    param3FROM    TEST TWHERE    T.createdate &lt;![CDATA[&lt;]]&gt; (SYSDATE - 1/12)-- SYSDATE为Date类型，可以直接减，不用转换格式。"
  },
  
  {
    "title": "Oracle 误删数据的恢复方法",
    "url": "/posts/oracle-huifu-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "DELETE误删数据利用Oracle提供的闪回方法，如果在删除数据后还没做大量的操作（只要保证被删除数据的块没被覆写），就可以利用闪回方式直接找回删除的数据  确定删除数据的时间（在删除数据之前的时间就行，不过最好是删除数据的时间点）      用以下语句找出删除的数据     select * from TEST as of timestamp to_timestamp('删除时间', '...",
    "content": "DELETE误删数据利用Oracle提供的闪回方法，如果在删除数据后还没做大量的操作（只要保证被删除数据的块没被覆写），就可以利用闪回方式直接找回删除的数据  确定删除数据的时间（在删除数据之前的时间就行，不过最好是删除数据的时间点）      用以下语句找出删除的数据     select * from TEST as of timestamp to_timestamp('删除时间', 'yyyy-mm-dd hh24:mi:ss');            把删除的数据重新插入原表     insert into TEST (     select     *     from     TEST as of timestamp to_timestamp('删除时间', 'yyyy-mm-dd hh24:mi:ss') ); -- 注意要保证主键不重复      如果表结构没有发生改变，还可以直接使用闪回整个表的方式来恢复数据。表闪回要求用户必须要有flash any table权限-- 开启行移动功能 alter table 表名 enable row movement;-- 恢复表数据flashback table 表名 to timestamp to_timestamp('删除时间', 'yyyy-mm-dd hh24:mi:ss');-- 关闭行移动功能(千万别忘记)alter table 表名 disable row movement;DROP误删表由于Oracle在删除表时，没有直接清空表所占的块，Oracle把这些已删除的表的信息放到了一个虚拟容器“回收站”中，而只是对该表的数据块做了可以被覆写的标志，所以在块未被重新使用前还可以恢复。      查询这个“回收站”或者查询user_table视图来查找已被删除的表     select table_name,dropped from user_tables; select object_name,original_name,type,droptime from user_recyclebin;        在以上信息中，表名都是被重命名过的，字段table_name或者object_name就是删除后在回收站中的存放表名        如果还能记住表名，则可以用下面语句直接恢复     flashback table 原表名 to before drop;            如果记不住了，也可以直接使用回收站的表名进行恢复，然后再重命名，参照以下语句     flashback table \"回收站中的表名(如：Bin$DSbdfd4rdfdfdfegdfsf==$0)\" to  before drop rename to 新表名;      误删数据库Oracle的闪回功能除了以上基本功能外，还可以闪回整个数据库，使用数据库闪回功能，可以使数据库回到过去某一状态, 语法如下alter database flashback onflashback database to scn SCNNO;flashback database to timestamp to_timestamp('2007-2-12 12:00:00','yyyy-mm-dd hh24:mi:ss');总结Oracle提供以上机制保证了安全操作，但同时也代来了另外一个问题，就是空间占用，由于以上机制的运行，使用DROP一个表或者DELETE数据后，空间不会自动回收，对于一些确定不使用的表，删除时要同时回收空间，可以有以下2种方式：  采用truncate方式进行截断。（但不能进行数据恢复了）      在drop时加上purge选项drop table 表名 purge    该选项也可以通过删除recyclebin区域来永久性删除表     -- 删除表 drop table emp cascade constraints; purge table emp; -- 删除当前用户的回收站: purge recyclebin; -- 删除全体用户在回收站的数据: purge dba_recyclebin;      "
  },
  
  {
    "title": "JS声明全局变量",
    "url": "/posts/js-shengming-quanjubianliang/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "  使用var + 变量名的方式在function外部声明，即为全局变量，否则在function内部声明的是局部变量。  没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。  使用window全局对象window.test;来声明，全局对象的属性对应也是全局变量。",
    "content": "  使用var + 变量名的方式在function外部声明，即为全局变量，否则在function内部声明的是局部变量。  没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。  使用window全局对象window.test;来声明，全局对象的属性对应也是全局变量。"
  },
  
  {
    "title": "JS解析JSON",
    "url": "/posts/js-jiexi-json/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "JS是无法直接接收和使用JSON的数据，会出现undefined，所以要解析才能使用。方式一var str = '{\"rows\":[{\"ID\":0,\"登录账号\":\"admin\",\"登录时间\":\"2018-04-05\"}]}';var obj = eval(\"(\" + str + \")\");console.log(obj);var rows = obj[\"rows\"];for(var i = ...",
    "content": "JS是无法直接接收和使用JSON的数据，会出现undefined，所以要解析才能使用。方式一var str = '{\"rows\":[{\"ID\":0,\"登录账号\":\"admin\",\"登录时间\":\"2018-04-05\"}]}';var obj = eval(\"(\" + str + \")\");console.log(obj);var rows = obj[\"rows\"];for(var i = 0; i &lt; rows.length; i++){  var ri = rows[i];  for(var k in ri){    console.log(k + \": \" + ri[k]);  }}方式二var data = '{\"rows\":[{\"ID\":0,\"登录账号\":\"admin\",\"登录时间\":\"2018-04-05\"}]}';var obj = JSON.parse(data);console.log(obj);JSON.parse()和eval()的区别JSON.parse()解析JSON格式的数据会对要解析的字符串进行格式检查，如果格式不正确则不进行解析，而eval()则可以解析任何字符串，eval()是不安全的。比如下面的字符串：var str = 'alert(1000.toString())';eval(str);JSON.parse(str);用eval()可以解析，并且会弹出对话框，而用JSON.parse()则解析不了。如果恶意用户在JSON字符串中注入了向页面插入木马链接的脚本，用eval()是可以操作的，而用JSON.parse()则不必担心这个问题。注意：某些旧版浏览器不支持JSON.parse()，可以可以使用第三方库来支持https://github.com/douglascrockford/JSON-js/blob/master/json2.js。"
  },
  
  {
    "title": "JS将字符串转为日期",
    "url": "/posts/js-jiang-zifuchuan-zhuanhuanwei-riqi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "var str = \"2010-08-01\";// 转换日期格式，\"2010/08/01\"str = str.replace(/-/g, '/');// 创建日期对象var date = new Date(str);// 加一天date.setDate(date.getDate() + 1);",
    "content": "var str = \"2010-08-01\";// 转换日期格式，\"2010/08/01\"str = str.replace(/-/g, '/');// 创建日期对象var date = new Date(str);// 加一天date.setDate(date.getDate() + 1);"
  },
  
  {
    "title": "JS获取字符串在数组的位置",
    "url": "/posts/js-huoqu-zifuchuan-zai-shuzu-zhongde-weizhi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "function indexOf(arr, str){    // 如果可以的话，调用原生方法    if(arr &amp;&amp; arr.indexOf){        return arr.indexOf(str);    }         var len = arr.length;    for(var i = 0; i &lt; len; i++){        // 定...",
    "content": "function indexOf(arr, str){    // 如果可以的话，调用原生方法    if(arr &amp;&amp; arr.indexOf){        return arr.indexOf(str);    }         var len = arr.length;    for(var i = 0; i &lt; len; i++){        // 定位该元素位置        if(arr[i] == str){            return i;        }    }         // 数组中不存在该元素    return -1;}var a = '1';var arry = ['1', '2', '3', '4']var index = indexOf(arry, a);alert(index); // 弹出0"
  },
  
  {
    "title": "JS对URL转码与解码",
    "url": "/posts/js-dui-url-jinxing-bianma/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "escape和unescapeescape()函数用于JS对字符串进行编码，不常用。escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。采用unicode字符集对指定的字符串除0-255以外进行编码。所有的空格符、标点符号、特殊字符以及非ASCII字符都将被转化成%xx格式的字符编码（xx等于该字符在字符集表里面的编码的16进制数字）。比如，空格符对应的...",
    "content": "escape和unescapeescape()函数用于JS对字符串进行编码，不常用。escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。采用unicode字符集对指定的字符串除0-255以外进行编码。所有的空格符、标点符号、特殊字符以及非ASCII字符都将被转化成%xx格式的字符编码（xx等于该字符在字符集表里面的编码的16进制数字）。比如，空格符对应的编码是%20。escape不编码字符有69个* + - . / @ _ 0-9 a-z A-Z。var url = \"http://localhost:8080/pro?a=1&amp;b=张三&amp;c=aaa\";escape(url) // http%3A//localhost%3A8080/pro%3Fa%3D1%26b%3D%u5F20%u4E09%26c%3Daaa  encodeURI和decodeURIencodeURI()用于整个url编码。把URL字符串采用UTF-8编码格式转化成escape格式的字符串。encodeURI不编码字符有82个! # $ &amp; ' ( ) * + , - . / : ; = ? @ _ ~ 0-9 a-z A-Zvar url = \"http://localhost:8080/pro?a=1&amp;b=张三&amp;c=aaa\";encodeURI(url) // http://localhost:8080/pro?a=1&amp;b=%E5%BC%A0%E4%B8%89&amp;c=aaa encodeURIComponent和decodeURIComponentencodeURIComponent()用于参数的传递，参数包含特殊字符可能会造成间断。与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。因此，; / ? : @ &amp; = + $ , #这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。把URI字符串采用UTF-8编码格式转化成escape格式的字符串。var url = \"http://localhost:8080/pro?a=1&amp;b=张三&amp;c=aaa\";encodeURIComponent(url) // http%3A%2F%2Flocalhost%3A8080%2Fpro%3Fa%3D1%26b%3D%E5%BC%A0%E4%B8%89%26c%3Daaavar url = \"http://localhost:8080/pp?a=1&amp;b=\"+ paramUrl,var paramUrl = \"http://localhost:8080/aa?a=1&amp;b=2&amp;c=3\";// 应该使用encodeURIComponent()进行转码　　encodeURIComponent(paramUrl) // http://localhost:8080/pp?a=1&amp;b=http%3A%2F%2Flocalhost%3A8080%2Faa%3Fa%3D1%2..."
  },
  
  {
    "title": "JS遍历Map",
    "url": "/posts/js-bianli-map/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "console.log(map);for(var key in map){  console.log(\"属性：\" + key + \",值：\" + map[key]);}",
    "content": "console.log(map);for(var key in map){  console.log(\"属性：\" + key + \",值：\" + map[key]);}"
  },
  
  {
    "title": "Git乱码问题",
    "url": "/posts/git-luanma-wenti/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "git diff比较文件差异时，中文显示为乱码git diff接受的编码格式utf-8，而filename是以gb2312格式编写的，所以git diff命令就显示乱码。解决办法：在vim中将filename另存为utf-8格式。git status查看修改历史时，中文显示乱码解决方法：git config core.quotepath false",
    "content": "git diff比较文件差异时，中文显示为乱码git diff接受的编码格式utf-8，而filename是以gb2312格式编写的，所以git diff命令就显示乱码。解决办法：在vim中将filename另存为utf-8格式。git status查看修改历史时，中文显示乱码解决方法：git config core.quotepath false"
  },
  
  {
    "title": "Linux如何配置网络",
    "url": "/posts/linux-ruhe-peizhi-wangluo/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "查看CentOS的网络配置信息ifconfig -a或ip addr如果无法使用ifconfig命令，则需要安装软件yum install net-tools安装完成后即可使用ifconfig命令配置网络打开网络配置文件vi /etc/sysconfig/network-scripts/ifcfg-eth0把倒数第三行ONBOOT=no改为ONBOOT=yes，重启网络服务service n...",
    "content": "查看CentOS的网络配置信息ifconfig -a或ip addr如果无法使用ifconfig命令，则需要安装软件yum install net-tools安装完成后即可使用ifconfig命令配置网络打开网络配置文件vi /etc/sysconfig/network-scripts/ifcfg-eth0把倒数第三行ONBOOT=no改为ONBOOT=yes，重启网络服务service network restart检查网络连接ifconfig此时可以看到已经连接网络，不过，使用的是路由器分配的ip，如果需要静态ip，需要再设置一下vi /etc/sysconfig/network-scripts/ifcfg-eth0在最后面加入IPADDR=192.168.33.199(这里设置你的静态IP，注意冲突)GETAWAY=192.168.33.1(网关)、NETMASK=255.255.255.0(子网掩码)service network restartifconfig可以看到，ip已经从103变成了199"
  },
  
  {
    "title": "Linux如何开放端口",
    "url": "/posts/linux-ruhe-kaifang-duankou/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，如果要添加范围例外端口，如1000-2000语法命令如下：启用区域端口和协议组合firewall-cmd [--zone=&lt;zone&gt;] --add-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; [--timeout=&lt;s&gt;]参数解释...",
    "content": "在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，如果要添加范围例外端口，如1000-2000语法命令如下：启用区域端口和协议组合firewall-cmd [--zone=&lt;zone&gt;] --add-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; [--timeout=&lt;s&gt;]参数解释--zone  # 作用域--add-port=80/tcp  # 添加端口，格式为：端口/通讯协议--remove-port=80/tcp  # 移除端口，格式为：端口/通讯协议--permanent  # 永久生效，没有此参数重启后失效此举将启用端口和协议的组合。作用域&lt;zone&gt;可以通过命令firewall-cmd --get-active-zones查看，端口可以是一个单独的端口&lt;port&gt;或者是一个端口范围&lt;port&gt;-&lt;port&gt;。协议可以是tcp或udp，实际命令如下：      添加    firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=1000-2000/tcp --permanent（--permanent永久生效，没有此参数重启后失效）             重新载入    firewall-cmd --reload            查看    firewall-cmd --zone=public --query-port=80/tcp            删除    firewall-cmd --zone=public --remove-port=80/tcp --permanent            其他命令    firewall-cmd --list-ports # 查看已经开放的端口firewall-cmd --state # 查看默认防火墙状态（关闭后显示notrunning，开启后显示running）      当然你可以还原传统的管理方式      关闭firewalld防火墙    systemctl stop firewalldsystemctl mask firewalld            检查是否安装了iptables    service iptables status             安装iptables及iptables-services    yum install -y iptables yum install iptables-services            设置防火墙开机启动    systemctl enable iptablessystemctl enable iptables.service             开启防火墙服务    systemctl start iptables.service            修改/etc/sysconfig/iptables，增加如下一行    -A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT            重启防火墙使配置生效    systemctl restart iptables.service       其他命令# iptablesystemctl stop iptablessystemctl start iptablessystemctl restart iptablessystemctl reload iptables# firewalldsystemctl status firewalld  # 查看防火墙状态systemctl start firewalld  # 开启防火墙systemctl stop firewalld  # 关闭防火墙firewall-cmd --permanent --zone=public --add-port=27017/tcp --permanent  # 开启指定端口firewall-cmd --zone=public --remove-port=27017/tcp --permanent  # 关闭指定端口firewall-cmd --permanent --zone=public --add-port=27017-30000/tcp --permanent  # 开启指定范围端口firewall-cmd --permanent --zone=public --add-port=1-65535/tcp --permanent  # 开启所有端口firewall-cmd --zone=public --remove-port=27017-30000/tcp --permanent  # 关闭指定范围端口firewall-cmd --permanent --query-port=27017/tcp  # 查看端口是否开放firewall-cmd --reload  # 重启防火墙firewall-cmd --list-ports  # 查看已经开放的端口iptables -L -n  # 查看规则，这个命令是和iptables的相同的man firewall-cmd  # 查看帮助"
  },
  
  {
    "title": "Linux chmod命令",
    "url": "/posts/linux-chmod-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "在Linux中要修改一个文件夹或文件的权限要用到chmod命令，语法如下：chmod [who] [+ | - | =] [mode] 文件名各选项含义  who          u 表示“用户（user）”，即文件或目录的所有者      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户      o 表示“其他（others）用户”      a 表示“所有（al...",
    "content": "在Linux中要修改一个文件夹或文件的权限要用到chmod命令，语法如下：chmod [who] [+ | - | =] [mode] 文件名各选项含义  who          u 表示“用户（user）”，即文件或目录的所有者      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户      o 表示“其他（others）用户”      a 表示“所有（all）用户”。它是系统默认值        操作符号          + 添加某个权限      - 取消某个权限      = 赋予给定权限并取消其他所有权限（如果有的话）        mode          r 可读      w 可写      x 可执行x只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x属性。      实例把index.html文件修改为可写可读可执行chmod 777 index.html要修改目录下所有文件属性可写可读可执行chmod 777 *.*修改所有htm文件的属性:chmod 777 *.htm修改文件夹属性的方法，把目录 /images/xiao 修改为可写可读可执行chmod 777 /images/xiao修改目录下所有的文件夹属性chmod 777 *要修改文件夹内所有的文件和文件夹及子文件夹属性为可写可读可执行chmod -R 777 /upload查看权限ls -l xxx.xxx那么就会出现相类似的信息，主要都是这些：-rw-rw-r--一共有10位数，其中： 最前面那个–代表的是类型  rw- 代表的是所有者（user）的权限  rw- 代表的是组群（group）的权限  r–- 代表的是其他人（other）的权限修改文件权限chmod o w xxx.xxx表示给其他人授予写xxx.xxx这个文件的权限chmod go - rw xxx.xxx表示删除xxx.xxx中组群和其他人的读和写的权限其他rwx也可以用数字来代替r ———— 4w ———— 2x ———— 1- ———— 0  -rw---     (600) 只有所有者才有读和写的权限  -rw-r–r–   (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限  -rwx--     (700) 只有所有者才有读，写，执行的权限  -rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限  -rwx–x–x   (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限  -rw-rw-rw- (666) 每个人都有读写的权限  -rwxrwxrwx (777) 每个人都有读写和执行的权限"
  },
  
  {
    "title": "Eclipse更换工作空间的步骤",
    "url": "/posts/eclipse-genghuan-kongjian/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "一、指定新工作空间位置二、设置编码1. 设置工作空间编码UTF-82. 设置JSP编码三、指定JDK位置四、配置Tomcat1. Tomcat发布位置设置五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件1. 指定Maven插件2. 指定Maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入：.abcde...",
    "content": "一、指定新工作空间位置二、设置编码1. 设置工作空间编码UTF-82. 设置JSP编码三、指定JDK位置四、配置Tomcat1. Tomcat发布位置设置五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件1. 指定Maven插件2. 指定Maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入：.abcdefghijklmnopqrstuvwxyz十二、校验删除十三、Debug十四、配置注释要在Types和Methods和Overriding methods中配置十五、properties文件乱码"
  },
  
  {
    "title": "Eclipse配置反编译工具JadClipse",
    "url": "/posts/eclipse-anzhuang-jadclipse/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-23 13:47:00 +0800",
    





    
    "snippet": "当运行引用了第三方jar包项目时，突然报出了jar包中的某个类的某一行出现异常。我们想看一下这个class文件的代码时，经常出现了如下图所示的场景：去找源码很浪费时间（除非是Maven项目，在pom.xml中引入依赖jar包会连同源文件下载下来）。在Eclipse中配置反编译工具，就可以随时查看class文件的内容了。下面就以JadClipse为例，讲述一下配置过程。      下载net....",
    "content": "当运行引用了第三方jar包项目时，突然报出了jar包中的某个类的某一行出现异常。我们想看一下这个class文件的代码时，经常出现了如下图所示的场景：去找源码很浪费时间（除非是Maven项目，在pom.xml中引入依赖jar包会连同源文件下载下来）。在Eclipse中配置反编译工具，就可以随时查看class文件的内容了。下面就以JadClipse为例，讲述一下配置过程。      下载net.sf.jadclipse_3.3.0.jar:  http://jadclipse.sourceforge.net/            将net.sf.jadclipse_3.3.0.jar(作用：如果不安装，第6步则搜不到JadClipse) 复制到Eclipse安装目录下的plugins下，如下图所示            Jad.exe下载地址为：http://www.javadecompilers.com/jad            将压缩包解压到Eclipse安装目录新建文件夹Jad（也可以自定义目录），如下图所示            进入Jad目录，在该目录下新建Jadtemp文件，用于存放jad.exe执行程序的缓存文件夹，如下图所示            在Eclipse中指定Jad.exe路径和缓存文件夹Jadtemp的路径。Eclipse中点击上方菜单Windows-&gt;Preferences，在搜索框中输入jad，如下图所示            指定class文件的默认打开方式            指定没有源代码的class文件的默认打开方式                    测试是否好使      "
  },
  
  {
    "title": "在Java中使用Lombok",
    "url": "/posts/java-zhong-shiyong-lombok/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-23 01:47:00 +0800",
    





    
    "snippet": "Lombok是一个帮助简化代码的工具，通过注解的形式例如：@Setter @Getter，可以替代代码中的getter和setter方法，虽然Eclipse自带的setter、getter代码生成也不需要我们手动的去敲写，但是使用@Setter @Getter这样的注解，能够使我们的代码看上去更加的简洁、优雅。在写之前，我遇到一个问题，在照着网上一些博文的做法，我直接将依赖加入pom文件，使...",
    "content": "Lombok是一个帮助简化代码的工具，通过注解的形式例如：@Setter @Getter，可以替代代码中的getter和setter方法，虽然Eclipse自带的setter、getter代码生成也不需要我们手动的去敲写，但是使用@Setter @Getter这样的注解，能够使我们的代码看上去更加的简洁、优雅。在写之前，我遇到一个问题，在照着网上一些博文的做法，我直接将依赖加入pom文件，使我的@Setter @Getter注解生效了，但是在我查看对象对应方法时我却找不到他的get、set方法，最后发现Lombok需要安装的，需要在eclipse.ini配置，单独的引入依赖不行。依赖：&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;将下载的lombok.jar放在与eclipse.ini同级目录下，在eclipse.ini文件中加入：-Xbootclasspath/a:lombok-1.16.8.jar -javaagent:lombok-1.16.8.jar重启项目，就发现能够正常使用了。"
  },
  
  {
    "title": "encodeURIComponent编码和后台解码",
    "url": "/posts/encodeURIComponent-bianma-he-jiema/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-23 01:47:00 +0800",
    





    
    "snippet": "方法一JavaScriptwindow.self.location = \"searchbytext.action?searchtext=\"         + encodeURIComponent(encodeURIComponent(seartext));Javasearchtext = java.net.URLDecoder.decode(searchtext, \"UTF-8\");两次编...",
    "content": "方法一JavaScriptwindow.self.location = \"searchbytext.action?searchtext=\"         + encodeURIComponent(encodeURIComponent(seartext));Javasearchtext = java.net.URLDecoder.decode(searchtext, \"UTF-8\");两次编码的原因：后台Java代码给searchtext赋值的时候，本身已经使用了一次解码，不过解码的结果依然不对。所以我们可以在页面上进行两次编码操作，这样后台自动的那次就可以抵消掉，然后使用searchtext = java.net.URLDecoder.decode(searchtext, \"UTF-8\");进行一次解码就好了。方法二另外还有一种方法是JavaScript进行一次编码，后台Java处理时换种写法就好了：JavaScriptwindow.self.location = \"searchbytext.action?searchtext=\"         + encodeURIComponent(seartext);JavaString s = new String(request.getParameter(\"searchtext\")        .getBytes(\"ISO8859-1\"), \"UTF-8\");"
  },
  
  {
    "title": "NoClassDefFoundError和ClassNotFoundException",
    "url": "/posts/NoClassDefFoundError-he-ClassNotFoundException/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-23 01:47:00 +0800",
    





    
    "snippet": "在日常Java开发中，我们经常碰到java.lang.NoClassDefFoundError这样的错误，需要花费很多时间去找错误的原因，而且我们很容易把java.lang.NoClassDefFoundError和java.lang.ClassNotfoundException这两个错误搞混，事实上这两个错误是完全不同的。NoClassDefFoundError的原因NoClassDefF...",
    "content": "在日常Java开发中，我们经常碰到java.lang.NoClassDefFoundError这样的错误，需要花费很多时间去找错误的原因，而且我们很容易把java.lang.NoClassDefFoundError和java.lang.ClassNotfoundException这两个错误搞混，事实上这两个错误是完全不同的。NoClassDefFoundError的原因NoClassDefFoundError错误的发生，是因为Java虚拟机在编译时能找到合适的类，而在运行时不能找到合适的类导致的错误。例如在运行时我们想调用某个类的方法或者访问这个类的静态成员的时候，发现这个类不可用，此时Java虚拟机就会抛出NoClassDefFoundError错误。与ClassNotFoundException的不同在于，这个错误发生只在运行时需要加载对应的类不成功，而不是编译时发生。ClassNotFoundException的原因ClassNotFoundException是在编译的时候在classpath中找不到对应的类而发生的错误。可能发生在使用反射的地方，spring容器加载类实例时也可能发生这种情况。ClassNotFoundException比NoClassDefFoundError容易解决，是因为在编译时我们就知道错误发生，并且完全是由于环境的问题导致。怎么解决NoClassDefFoundError错误根据前文，很明显NoClassDefFoundError的错误是因为在运行时类加载器在classpath下找不到需要加载的类，所以我们需要把对应的类加载到classpath中，或者检查为什么类在classpath中是不可用的，这个发生可能的原因如下：  对应的Class在Java的classpath中不可用  你可能用jar命令运行你的程序，但类并没有在jar文件的manifest文件中的classpath属性中定义  可能程序的启动脚本覆盖了原来的classpath环境变量  因为NoClassDefFoundError是java.lang.LinkageError的一个子类，所以可能由于程序依赖的原生的类库不可用而导致  检查日志文件中是否有java.lang.ExceptionInInitializerError这样的错误，NoClassDefFoundError有可能是由于静态初始化失败导致的  如果你工作在J2EE的环境，有多个不同的类加载器，也可能导致NoClassDefFoundError"
  },
  
  {
    "title": "Java中判断Map是否为空",
    "url": "/posts/java-zhong-pandaun-map-shifou-weikong/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "isEmpty()方法判断Map是否有内容（即new分配空间后是否有put键值对），若没有内容则true，否则false== null是判断Map是否为null（即是否new分配空间，和其中的键值对没关系），若没有内容则true，否则falseMap map = new HashMap&lt;String, String&gt;();System.out.println(\"判断Map是否有内...",
    "content": "isEmpty()方法判断Map是否有内容（即new分配空间后是否有put键值对），若没有内容则true，否则false== null是判断Map是否为null（即是否new分配空间，和其中的键值对没关系），若没有内容则true，否则falseMap map = new HashMap&lt;String, String&gt;();System.out.println(\"判断Map是否有内容:\" + map.isEmpty()); // trueSystem.out.println(\"判断Map是否为null:\" + map==null); // falseMap map = new HashMap&lt;String, String&gt;();map = null;System.out.println(\"判断Map是否有内容:\" + map.isEmpty()); // 报空指针异常System.out.println(\"判断Map是否为null:\" + (map == null)); // trueMap map = new HashMap&lt;String, String&gt;();map.put(null, null);System.out.println(\"判断Map是否为null:\" + (map == null)); // falseSystem.out.println(\"判断Map是否有内容:\" + map.isEmpty()); // false"
  },
  
  {
    "title": "在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义",
    "url": "/posts/baocuo-rfc-7230-rfc-3986/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "报错信息java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义  org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:504)  org.apache.coyote.http11.Htt...",
    "content": "报错信息java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义  org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:504)  org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:503)  org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)  org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:818)  org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1626)  org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)  java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)  java.lang.Thread.run(Thread.java:748)~报错原因这个错误的原因是JSP传递参数时传递了中文，而项目使用的是高版本的Tomcat，高版本的Tomcat传递参数不兼容。解决方法对传入的中文参数进行encodeURI()处理。function chenge() {    var frm = document.userFrom;    var userId = frm.userId.value;    var userName = frm.userName.value;      userName = encodeURI(userName);    var url = \"userAction.do?action=User&amp;userId=\" + userId + \"&amp;userName=\" + userName;    window.location.href = url;}"
  },
  
  {
    "title": "如何把Excel文本格式里的数字批量转成文本",
    "url": "/posts/ba-excel-wenbengeshi-lide-shuzi-piliang-zhuanhuancheng-wenben/",
    "categories": "Knowledge, Excel",
    "tags": "Excel",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "Excel中长数字会自动变成“科学计数法”，如果只需要显示成“文本”，可以用以下步骤：      首先在EXCEL表格中把要更改成为文本的数据全部选中。            然后在导航栏的“数据”栏内点击“分列”选项。            进入文本分列向导的分隔类型页面后，直接点击右下角的“下一步”。            设置分隔符号页面同上一步一样，点击右下角“下一步”。      ...",
    "content": "Excel中长数字会自动变成“科学计数法”，如果只需要显示成“文本”，可以用以下步骤：      首先在EXCEL表格中把要更改成为文本的数据全部选中。            然后在导航栏的“数据”栏内点击“分列”选项。            进入文本分列向导的分隔类型页面后，直接点击右下角的“下一步”。            设置分隔符号页面同上一步一样，点击右下角“下一步”。            在最后一个页面左侧把“文本”勾选，然后点击“完成”。            这时回到EXCEL表格内就能够查看到，所有的数字数据都已经显示为文本模式了。      "
  },
  
  {
    "title": "Eclipse中为jar包配置API",
    "url": "/posts/eclipse-zhong-wei-jarbao-peizhi-api/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "步骤  打开Perferences首选项；  定位到Installed JREs，选中你已有的要添加Java API的JRE或JDK；  单击右方的Edit，出现Edit JRE对话框，如果你是新建，出现New JRE对话框也一样。这时下方会出现一列jar包，例如X:/Program Files/Java/(jre/jdk版本)/jre/lib/rt.jar。单击rt.jar包选中，然后单击...",
    "content": "步骤  打开Perferences首选项；  定位到Installed JREs，选中你已有的要添加Java API的JRE或JDK；  单击右方的Edit，出现Edit JRE对话框，如果你是新建，出现New JRE对话框也一样。这时下方会出现一列jar包，例如X:/Program Files/Java/(jre/jdk版本)/jre/lib/rt.jar。单击rt.jar包选中，然后单击右方的Javadoc Location；  填写Java API位置，Javadoc URL方式是Java API的网络地址或本地Javadoc解压后的地址。Javadoc in archive是下载到本地的Javadoc压缩包地址，然后在Path within archive中填写API在压缩包内部的结构，一般为docs/API，也可以通过Browse更方便地导入；  试试在Eclipse中写几句代码，然后单击你要查API的类或方法名，F1一下，是不是能很快地定位到help，第一项应该就是javadoc for你选择的类或方法了。你可以在Eclipse中查看，也能快速定位到浏览器了，不用你自己查找；说明一般定位rt.jar包就可以了。不放心的话你也可以把别的包都配置下。示例Window  –&gt;  Preferences  –&gt;  Java  –&gt;  Installed JRES  –&gt;  选择右边的JDK  –&gt;  点击Edit  –&gt;   选择rt.jar栏  –&gt;  点击右边Javadoc Location  –&gt;  选择Javadoc in archive  –&gt;  Externel file  –&gt;   Archive path栏选择自己下载的API压缩包文件地址  –&gt;  Path within archive栏选择压缩包中html/zh_CN/api。"
  },
  
  {
    "title": "Eclipse报PermGen space异常",
    "url": "/posts/eclipse-bao-permgen-space-yichang/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "修改catalina.bat在Tomcat/bin目录下的catalina.batrem ----- Execute The Requested Command ----------------------下面加入JAVA_OPTS=\"-server -Xms800m -Xmx800m -XXNewSize=256M -XX:PermSize=256M -XX:MaxNewSize=512m...",
    "content": "修改catalina.bat在Tomcat/bin目录下的catalina.batrem ----- Execute The Requested Command ----------------------下面加入JAVA_OPTS=\"-server -Xms800m -Xmx800m -XXNewSize=256M -XX:PermSize=256M -XX:MaxNewSize=512m -XX:MaxPermSize=512m\" 这种方法在只使用Tomcat时管用，但使用Eclipse时不管用。修改eclipse.ini加入-vmd:/jdk6/bin/javaw.exe-vmargs-Dosgi.requiredJavaVersion=1.5 -Xms512m -Xmx1024m-XX:PermSize=256M -XX:MaxPermSize=512m修改Eclipse的Run Configurations点击Run - Run Configurations，在打开的窗口中点击Arguments选项卡，在VM arguments中内容最下边输入-Xms256m -Xmx512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m保存后再次重启"
  },
  
  {
    "title": "如何让图片按比例响应式缩放、并自动裁剪",
    "url": "/posts/ruhe-rangtupian-anbili-xiangyingshi-suofang/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "响应式网站、移动端页面在DIV CSS布局中对于图片列表或图片排版时，如果想要图片按比例缩放，最简单的就是把img宽度设为100%，不设置高度，高度就会自动跟着宽度缩放，但是如果要达到的效果是，要让图片的宽高要按一定的比例显示，如1：1 、4：3 等，然而图片尺寸不是这个比例，又不想让图片拉伸变形，自动裁剪掉两边多余部分、这该如何解决呢？代码HTML部分&lt;div class=\"zoom...",
    "content": "响应式网站、移动端页面在DIV CSS布局中对于图片列表或图片排版时，如果想要图片按比例缩放，最简单的就是把img宽度设为100%，不设置高度，高度就会自动跟着宽度缩放，但是如果要达到的效果是，要让图片的宽高要按一定的比例显示，如1：1 、4：3 等，然而图片尺寸不是这个比例，又不想让图片拉伸变形，自动裁剪掉两边多余部分、这该如何解决呢？代码HTML部分&lt;div class=\"zoomImage\" style=\"background-image:url(images/test1.jpg)\"&gt;&lt;/div&gt;CSS部分.zoomImage{    width:100%;    height:0;    padding-bottom: 100%;    overflow:hidden;    background-position: center center;    background-repeat: no-repeat;    -webkit-background-size:cover;    -moz-background-size:cover;    background-size:cover;}原理剖析width:100%;height:0;padding-bottom: 100%;overflow:hidden;样式中的上面4句主要目的是为了让这个div以1：1的大小呈现，虽然高度为0，但是它的padding值为100%，这是因为在padding为百分比的时候，是根据他父层的宽度来进行计算的。在一点MDN关于padding的文档也有说到。background-position: center center;background-repeat: no-repeat;-webkit-background-size:cover;-moz-background-size:cover;background-size:cover;后面5句利用了CSS3中的background-size:cover的特性，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。对于padding为百分比的时候，我画了一张图，希望有助于大家理解：总结你所需要的比例就是width与padding-bottom的比例，用的时候，直接把.zoomImage当成img标签来用就可以了。"
  },
  
  {
    "title": "MySQL修改root密码的3种方法",
    "url": "/posts/mysql-xiugai-root-mima-de-fangfa/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-06-01 13:47:00 +0800",
    





    
    "snippet": "用set password命令 mysql&gt; set password for u&lt;sername&gt;@localhost = password('&lt;newpassword&gt;'); 用mysqladmin mysqladmin -u&lt;sername&gt; -p&lt;oldpassword&gt; password &lt;newpassword&gt; ...",
    "content": "用set password命令 mysql&gt; set password for u&lt;sername&gt;@localhost = password('&lt;newpassword&gt;'); 用mysqladmin mysqladmin -u&lt;sername&gt; -p&lt;oldpassword&gt; password &lt;newpassword&gt; 例子：mysqladmin -uroot -p123456 password 12用update直接编辑user表 mysql&gt; use mysql; mysql&gt; update user set password=password('12') where user='root' and host='localhost'; mysql&gt; flush privileges; "
  },
  
  {
    "title": "MySQL赋予用户权限",
    "url": "/posts/mysql-fuyu-yonghu-quanxian/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-06-01 13:47:00 +0800",
    





    
    "snippet": "本文实例，运行于MySQL5.0及以上版本。MySQL赋予用户权限的格式可概括为grant 权限 on 数据库对象 to 用户一、grant普通数据用户grant select on testdb.* to common_user@'%' -- 查询grant insert on testdb.* to common_user@'%' -- 插入grant update on testdb....",
    "content": "本文实例，运行于MySQL5.0及以上版本。MySQL赋予用户权限的格式可概括为grant 权限 on 数据库对象 to 用户一、grant普通数据用户grant select on testdb.* to common_user@'%' -- 查询grant insert on testdb.* to common_user@'%' -- 插入grant update on testdb.* to common_user@'%' -- 更新grant delete on testdb.* to common_user@'%' -- 删除或者，用一条MySQL命令来替代grant select, insert, update, delete on testdb.* to common_user@'%'二、grant数据库开发人员      grant创建、修改、删除MySQL数据表结构权限      grant create on testdb.* to developer@'192.168.0.%';  grant alter  on testdb.* to developer@'192.168.ssss0.%';  grant drop   on testdb.* to developer@'192.168.0.%';            grant操作MySQL外键权限      grant references on testdb.* to developer@'192.168.0.%';            grant操作MySQL临时表权限      grant create temporary tables on testdb.* to developer@'192.168.0.%';            grant操作MySQL索引权限      grant index on testdb.* to developer@'192.168.0.%';            grant操作MySQL视图、查看视图源代码权限      grant create view on testdb.* to developer@'192.168.0.%';  grant show   view on testdb.* to developer@'192.168.0.%';            grant操作MySQL存储过程、函数权限      grant create routine on testdb.* to developer@'192.168.0.%';    -- now, can show procedure status  grant alter  routine on testdb.* to developer@'192.168.0.%';    grant execute on testdb.* to developer@'192.168.0.%';      三、grant普通DBA管理某个MySQL数据库的权限grant all privileges on testdb to dba@'localhost'其中，关键字 “privileges” 可以省略。四、grant高级DBA管理MySQL中所有数据库的权限grant all on *.* to dba@'localhost'五、MySQL grant权限，分别可以作用在多个层次上      grant作用在整个MySQL服务器上     grant select on *.* to dba@localhost; -- dba可以查询MySQL中所有数据库中的表。 grant all    on *.* to dba@localhost; -- dba可以管理MySQL中的所有数据库            grant作用在单个数据库上     grant select on testdb.* to dba@localhost; -- dba可以查询testdb中的表。            grant作用在单个数据表上     grant select, insert, update, delete on testdb.orders to dba@localhost;            grant作用在表中的列上     grant select(id, se, rank) on testdb.apache_log to dba@localhost;            grant作用在存储过程、函数上     grant execute on procedure testdb.pr_add to 'dba'@'localhost' grant execute on function  testdb.fn_add to 'dba'@'localhost'      六、查看MySQL用户权限      查看当前用户（自己）权限      show grants;            查看其他 MySQL 用户权限      show grants for dba@localhost;      七、撤销已经赋予给MySQL用户的权限revoke跟grant的语法差不多，只需要把关键字“to”换成“from”即可grant  all on *.* to   dba@localhost;revoke all on *.* from dba@localhost;"
  },
  
  {
    "title": "Linux系统下MySQL表名区分大小写的问题",
    "url": "/posts/linux-xitongxia-mysql-biaoming-qufen-daxiaoxie-de-wenti/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-06-01 13:47:00 +0800",
    





    
    "snippet": "报错信息报错原因因为Linux环境下的MySQL数据库的表名默认是区分大小写的，可以查看Linux上的MySQL的配置文件/etc/my.cnf[root@centos tomcat7]# cat /etc/my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling sy...",
    "content": "报错信息报错原因因为Linux环境下的MySQL数据库的表名默认是区分大小写的，可以查看Linux上的MySQL的配置文件/etc/my.cnf[root@centos tomcat7]# cat /etc/my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid解决方法如果要使用数据库表名不区分大小写的话，就需要在[mysqld]下面添加一行配置，即lower_case_table_names=1[root@centos tomcat7]# vi /etc/my.cnf [mysqld]lower_case_table_names=1datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid补充lower_case_table_names参数  0：区分大小写  1：不区分大小写MySQL的大小写规则MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：  数据库名与表名是严格区分大小写的；  表的别名是严格区分大小写的；  列名与列的别名在所有的情况下均是忽略大小写的；  变量名也是严格区分大小写的；MySQL在Windows下都不区分大小写。如果想在查询时区分字段值的大小写，则：字段值需要设置BINARY属性，设置的方法有多种：  创建时设置CREATE TABLE T( A VARCHAR(10) BINARY );  使用alter修改ALTER TABLE`tablename` MODIFY COLUMN `cloname` VARCHAR(45) BINARY;  mysql tableeditor中直接勾选BINARY项。修改完配置之后，一定要重启数据库：[root@centos tomcat7]# service mysqld restartStopping mysqld:  [  OK  ]Starting mysqld:  [  OK  ]修改配置后的问题使用Navicat工具重新连接MySQL数据库，再次查询person表，这时发现不管查询SQL语句中的表名是大写还是小写都提示找不到person表了。原因是修改配置之后，会导致原来的大写的表名TEST无法识别，所以这一点要特别注意，解决办法是:  在修改配置之前一定先将所有表的表结构和表数据导出做备份；  删除原来的表；  修改配置；  将表结构和表数据导入。按照上面的步骤操作之后，再次查询person表，表名就不区分大小写了。"
  },
  
  {
    "title": "利用BeanUtils在对象间复制属性",
    "url": "/posts/java-duixiang-shuxing-de-fuzhi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "如果你有两个具有很多相同属性的JavaBean，一个很常见的情况就是Struts里的PO对象（持久对象）和对应的ActionForm，例如Teacher和TeacherForm。我们一般会在Action里从ActionForm构造一个PO对象，传统的方式是使用类似下面的语句对属性逐个赋值：// 得到TeacherFormTeacherForm teacherForm = (TeacherFo...",
    "content": "如果你有两个具有很多相同属性的JavaBean，一个很常见的情况就是Struts里的PO对象（持久对象）和对应的ActionForm，例如Teacher和TeacherForm。我们一般会在Action里从ActionForm构造一个PO对象，传统的方式是使用类似下面的语句对属性逐个赋值：// 得到TeacherFormTeacherForm teacherForm = (TeacherForm) form;// 构造Teacher对象Teacher teacher = new Teacher();// 赋值teacher.setName(teacherForm.getName());teacher.setAge(teacherForm.getAge());teacher.setGender(teacherForm.getGender());teacher.setMajor(teacherForm.getMajor());teacher.setDepartment(teacherForm.getDepartment());// 持久化Teacher对象到数据库HibernateDAO.save(teacher);而使用BeanUtils后，代码就大大改观了，如下所示：// 得到TeacherFormTeacherForm teacherForm = (TeacherForm) form;// 构造Teacher对象Teacher teacher = new Teacher();// 赋值BeanUtils.copyProperties(teacher, teacherForm);// 持久化Teacher对象到数据库HibernateDAO.save(teacher);如果Teacher和TeacherForm间存在名称不相同的属性，则BeanUtils不对这些属性进行处理，需要程序员手动处理。例如Teacher包含modifyDate属性而TeacherForm无此属性，那么在上面代码的copyProperties()后还要加上一句：teacher.setModifyDate(new Date());除BeanUtils外还有一个名为PropertyUtils的工具类，它也提供copyProperties()方法，作用与BeanUtils的同名方法十分相似，主要的区别在于后者提供类型转换功能，即发现两个JavaBean的同名属性为不同类型时，在支持的数据类型范围内进行转换，而前者不支持这个功能，但是速度会更快一些。PropertyUtils支持的转换类型如下：java.lang.BigDecimaljava.lang.BigIntegerboolean and java.lang.Booleanbyte and java.lang.Bytechar and java.lang.Characterjava.lang.Classdouble and java.lang.Doublefloat and java.lang.Floatint and java.lang.Integerlong and java.lang.Longshort and java.lang.Shortjava.lang.Stringjava.sql.Datejava.sql.Timejava.sql.Timestamp这里要注意一点，java.util.Date是不被支持的，而它的子类java.sql.Date是被支持的。因此如果对象包含时间类型的属性，且希望被转换的时候，一定要使用java.sql.Date类型。否则在转换时会提示argument mistype异常。"
  },
  
  {
    "title": "将项目导入Eclipse后JSP页面报错",
    "url": "/posts/xiangmu-daoru-eclipse-hou-jsp-yemian-baocuo/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "如何修改动态web模块版本",
    "url": "/posts/ruhe-xiugai-xiangmu-de-webdongtai-banben/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "报错信息Project facet Dynamic Web Module version 3.0 is not supported.解决方法找到工程项目的硬盘目录，打开项目下的.setting文件夹，找到.setting文件夹内的org.eclipse.wst.common.project.facet.core.xml文件，文件格式大致如下：&lt;?xml version=\"1.0\" en...",
    "content": "报错信息Project facet Dynamic Web Module version 3.0 is not supported.解决方法找到工程项目的硬盘目录，打开项目下的.setting文件夹，找到.setting文件夹内的org.eclipse.wst.common.project.facet.core.xml文件，文件格式大致如下：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  &lt;faceted-project&gt;      &lt;runtime name=\"Apache Tomcat v7.0\"/&gt;      &lt;fixed facet=\"java\"/&gt;      &lt;fixed facet=\"jst.web\"/&gt;      &lt;fixed facet=\"wst.jsdt.web\"/&gt;      &lt;installed facet=\"java\" version=\"1.7\"/&gt;      &lt;installed facet=\"jst.web\" version=\"3.0\"/&gt;      &lt;installed facet=\"wst.jsdt.web\" version=\"1.0\"/&gt;  &lt;/faceted-project&gt;  直接手动修改jst.web对应的version即可，最后重启Tomcat就可以正常使用了，然后刷新项目即可，若是在Eclispe中更改属性，则是无法更改的。"
  },
  
  {
    "title": "使用animation属性实现背景颜色动态渐变的效果",
    "url": "/posts/beijing-yanse-dongtai-jianbian/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "基础知识关键帧（传递点）是在动画中定义更改的帧。@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。@keyframes规则的名称声明为@keyframes + 任意名称。0％表示开始动画，100％表示结束时间。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。@...",
    "content": "基础知识关键帧（传递点）是在动画中定义更改的帧。@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。@keyframes规则的名称声明为@keyframes + 任意名称。0％表示开始动画，100％表示结束时间。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。@keyframes name {  0% { background: red; }  50% { background: orange; }  100% { background: pink; }}@-webkit-keyframes name {  0% { background: red; }  50% { background: orange; }  100% { background: pink; }}说明：对于Chrome和Safari等WebKit浏览器，需要供应商前缀（-webkit-）。以这种方式编写-webkit-keyframes。相关属性      animation-name（动画名）    @keyframes定义的名称。如果未指定此项，则不会执行动画。此外，如果指定的动画名称与任何关键帧都不匹配，则不会执行该关键帧。        animation-duration（动画持续时间）    通过秒 + s指定执行一个动画的时间长度。例如，5s持续5秒。如果为0，则不会执行。即使指定了负值，也会将其视为0。        animation-timing-function（动画定时功能）    指定动画的时间以及如何继续。可以通过调整动画进度速度的比例来表达平滑运动。        animation-delay（动画延迟）    读取元素时，从元素编号 + s指定“动画开始”的时间。例如，5s持续5秒。初始值0将立即执行。        animation-iteration-count（动画迭代计数）    使用数字指定重复动画的次数。infinite指定无限循环。        animation-direction（动画方向）    指定重复动画的方向。          normal：正常方向播放（初始值）。      alternate：在正常和偶数时间以相反方向重新生成奇数次。      reverse：向后播放。      alternate-reverse：反向播放。            animation-play-state（动画播放状态）          paused：暂停。      running：播放。            animation-fill-mode（动画填充模式）    指定播放动画之前和之后的状态。          none：默认值。      forwards：播放后保持最后一个关键帧的状态。      backwards：在播放前应用第一个关键帧的状态。      both … forwards：向前和向后都应用。      属性总结animation允许您分别指定每个属性的值，用空格分隔。项目可以省略，但动画名称必须在执行前写入。建议按以下顺序列出。animation-name（动画名称）animation-duration（动画持续时间）animation-timing-function（动画定时功能）animation-delay（动画延迟）animation-iteration-count（动画迭代计数）animation-direction（动画方向）animation-fill-mode（动画填充模式）animation-play-state（动画播放状态）具体实现在了解了基础的知识之后，我们来详细看看具体的实现方法。首先，将关键帧的名称设置为“bg-color”，并将背景颜色设置为从0到100％的过渡。@-webkit-keyframes bg-color {  0% { background-color: #e74c3c; }  20% { background-color: #f1c40f; }  40% { background-color: #1abc9c; }  60% { background-color: #3498db; }  80% { background-color: #9b59b6; }  100% { background-color: #e74c3c; }}@keyframes bg-color {  0% { background-color: #e74c3c; }  20% { background-color: #f1c40f; }  40% { background-color: #1abc9c; }  60% { background-color: #3498db; }  80% { background-color: #9b59b6; }  100% { background-color: #e74c3c; }}由于此时指定整个网页的背景颜色，body以animation指定属性。值分别为关键帧名称，bg-color更改在10秒内添加，无限循环infinite。不要忘记webkit的版本。body {  background-color: #e74c3c;  animation: bg-color 10s infinite;  -webkit-animation: bg-color 10s infinite;}完整代码&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style type=\"text/css\"&gt;      body {        background-color: #e74c3c;        animation: bg-color 10s infinite;        -webkit-animation: bg-color 10s infinite;      }      @-webkit-keyframes bg-color {        0% { background-color: #e74c3c; }        20% { background-color: #f1c40f; }        40% { background-color: #1abc9c; }        60% { background-color: #3498db; }        80% { background-color: #9b59b6; }        100% { background-color: #e74c3c; }      }      @keyframes bg-color {        0% { background-color: #e74c3c; }        20% { background-color: #f1c40f; }        40% { background-color: #1abc9c; }        60% { background-color: #3498db; }        80% { background-color: #9b59b6; }        100% { background-color: #e74c3c; }      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "项目中无法识别JDBC连接串的SID",
    "url": "/posts/xiangmuzhong-wufa-shibie-jdbc-zhongde-sid/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "将连接串：url: jdbc:oracle:thin@10.112.129.9:1521:jira修改为：url: jdbc:oracle:thin:@//10.112.129.9:1521/jira",
    "content": "将连接串：url: jdbc:oracle:thin@10.112.129.9:1521:jira修改为：url: jdbc:oracle:thin:@//10.112.129.9:1521/jira"
  },
  
  {
    "title": "Oracle 替换字符串",
    "url": "/posts/oracle-tihuan-zifuchuan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "replace(strSource, str1, str2)将strSource中的str1替换成str2  strSource：源字符串  str1: 要替换的字符串  str2: 替换后的字符串select '替换字符串' as oldStr, replace('替换字符串', '替换', '修改') as newStr from dual",
    "content": "replace(strSource, str1, str2)将strSource中的str1替换成str2  strSource：源字符串  str1: 要替换的字符串  str2: 替换后的字符串select '替换字符串' as oldStr, replace('替换字符串', '替换', '修改') as newStr from dual"
  },
  
  {
    "title": "Oracle substr函数和instr函数",
    "url": "/posts/oracle-substr-hanshu-he-instr-hanshu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "substr函数：截取字符串语法：SUBSTR(string, start, [length])  string：表示源字符串，即要截取的字符串。  start：开始位置，从1开始查找。如果start是负数，则从string字符串末尾开始算起。  length：可选项，表示截取字符串长度。示例：SELECT SUBSTR('Hello SQL!', 1) FROM dual --截取所有字符...",
    "content": "substr函数：截取字符串语法：SUBSTR(string, start, [length])  string：表示源字符串，即要截取的字符串。  start：开始位置，从1开始查找。如果start是负数，则从string字符串末尾开始算起。  length：可选项，表示截取字符串长度。示例：SELECT SUBSTR('Hello SQL!', 1) FROM dual --截取所有字符串，返回'Hello SQL!'SELECT SUBSTR('Hello SQL!', 2) FROM dual --从第2个字符开始，截取到末尾。返回'ello SQL!'SELECT SUBSTR('Hello SQL!', -4) FROM dual --从倒数第4个字符开始，截取到末尾。返回'SQL!'SELECT SUBSTR('Hello SQL!', 3, 6) FROM dual --从第3个字符开始，截取6个字符。返回'llo SQ'SELECT SUBSTR('Hello SQL!', -4, 3) FROM dual --从倒数第4个字符开始，截取3个字符。返回'SQL'instr函数：返回子字符串在源字符串中的位置语法：INSTR(string, child_string, [start], [show_time])  string：表示源字符串。  child_string：子字符串，即要查找的字符串。  start：可选项，开始位置，默认从1开始。如果为负数，则从右向左检索。  show_time：可选项，表示子字符串第几次出现在源字符串当中，默认第1次，负数则报错。示例：--表示从源字符串'city_company_staff'中第1个字符开始查找子字符串'_'第1次出现的位置SELECT INSTR('city_company_staff', '_') FROM dual --返回5--表示从源字符串'city_company_staff'中第5个字符开始查找子字符串'_'第1次出现的位置SELECT INSTR('city_company_staff', '_', 5) FROM dual --返回5--表示从源字符串'city_company_staff'中第5个字符开始查找子字符串'_'第1次出现的位置SELECT INSTR('city_company_staff', '_', 5, 1) FROM dual --返回5--表示从源字符串'city_company_staff'中第3个字符开始查找子字符串'_'第2次出现的位置SELECT INSTR('city_company_staff', '_', 3, 2) FROM dual --返回13--start参数为-1，从右向左检索，查找'_'字符串在源字符串中第1次出现的位置SELECT INSTR('city_company_staff', '_', -1, 1) FROM dual --返回13--start参数为-6，从右向左检索，查找'_'字符串在源字符串中第2次出现的位置SELECT INSTR('city_company_staff', '_', -6, 2) FROM dual --返回5substr函数结合instr函数截取字符串现有需求：数据查询处理需要对code进行”拆分”，code命名规则类似：城市_所属公司_员工职位_员工姓名，其中，城市、公司、职位、姓民字符串长度不固定，由于字符串长度不固定，只使用substr函数无法实现需求，需配合instr函数定位到字符'_'的位置，然后使用substr函数进行截取。详细见下面例子。表数据如下：SOURCE_CODEBJ_BAIDU_CEO_LYSH_BOKE_MANAGER_LWXHRB_WM_CASHIER_OYZY获取城市：SELECT  SUBSTR (SOURCE_CODE, 1, INSTR (SOURCE_CODE, '_', 1, 1) - 1) AS CITYFROM  TABLE_CODE_TEST结果：解释：此处截取源字符串SOURCE_CODE，从第1个字符开始，由于代表城市的code长度不固定，我们无法确定截取几个字符，所以使用instr函数判断第一个’_‘字符的位置，进而确定每个SOURCE_CODE截取几个字符串。那为什么减1呢？是因为INSTR (SOURCE_CODE, '_', 1, 1)获取的是源字符串中'_'字符第一次出现的位置，再减1就得出了CITY字符个数。获取公司：SELECT  SUBSTR (   SOURCE_CODE,     INSTR (SOURCE_CODE, '_', 1, 1) + 1,     INSTR (SOURCE_CODE, '_', 1, 2) - INSTR (SOURCE_CODE, '_', 1, 1)-1  ) AS COMPANYFROM  TABLE_CODE_TEST结果：解释：截取源字符串，从（第一个'_'出现位置+1）开始，截取个数为：第2个'_'出现位置减去第1个'_'出现位置，此时还多了一个下划线'_'，再减去1即可得到代表公司字符串。获取姓名：SELECT  SUBSTR (SOURCE_CODE, INSTR (SOURCE_CODE, '_', 1, 3) + 1) AS STF_NAMEFROM  TABLE_CODE_TEST结果：解释：截取源字符串，从（'_'第3次出现位置+1）开始截取，截取到末尾。"
  },
  
  {
    "title": "Oracle 拼接字符串",
    "url": "/posts/oracle-pinjie-zifuchuan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "1、使用||来拼接字符串：select '拼接'||'字符串' as Str from student;2、使用concat(param1, param2)函数实现：select concat('拼接', '字符串') as Str from student;注：oracle的concat()方法只支持两个参数，如果拼接多个参数，可以嵌套concat()：select concat(conc...",
    "content": "1、使用||来拼接字符串：select '拼接'||'字符串' as Str from student;2、使用concat(param1, param2)函数实现：select concat('拼接', '字符串') as Str from student;注：oracle的concat()方法只支持两个参数，如果拼接多个参数，可以嵌套concat()：select concat(concat('拼接', '字符串'), 'ab') as Str from student;"
  },
  
  {
    "title": "Oracle 分页的实现",
    "url": "/posts/oracle-fenye-de-shixian/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "通用分页格式，page是页码，size是每页显示条数。SELECT  *FROM  (    SELECT      T.*,      ROWNUM rn    FROM      (        SELECT          *        FROM          T_BASE_PROVINCE        ORDER BY          ID ASC      ) T ...",
    "content": "通用分页格式，page是页码，size是每页显示条数。SELECT  *FROM  (    SELECT      T.*,      ROWNUM rn    FROM      (        SELECT          *        FROM          T_BASE_PROVINCE        ORDER BY          ID ASC      ) T    WHERE      ROWNUM &lt;= page * size  )WHERE  rn &gt; (page - 1) * size;"
  },
  
  {
    "title": "Oracle 创建本地数据库",
    "url": "/posts/oracle-chuangjian-bendi-shujuku/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "  按住键盘上Windows键，打开开始菜单，找到Database Configuration Assitant并打开；  打开数据库配置助手Database Configuration Assitant，单击“下一步”，选择“创建数据库”，单击“下一步”；  选择“一般用途或事务处理”，单击“下一步”；  设置数据库的名称和实例名，两者可设置相同，也可以不同，单击“下一步”；  管理选项配...",
    "content": "  按住键盘上Windows键，打开开始菜单，找到Database Configuration Assitant并打开；  打开数据库配置助手Database Configuration Assitant，单击“下一步”，选择“创建数据库”，单击“下一步”；  选择“一般用途或事务处理”，单击“下一步”；  设置数据库的名称和实例名，两者可设置相同，也可以不同，单击“下一步”；  管理选项配置，不勾选配置Enterprise Manager，单击“下一步”；  数据库身份证明，可以为不同的账户分别设置不同的管理口令，也可以为所有账户设置同一口令，单击“下一步”；  数据库文件所在位置，默认存储类型：文件系统，存储位置：使用模版中的数据库文件位置，也可以自己指定存储路径，单击“下一步”；  恢复配置，指定快速恢复区；  数据库内容，根据需要，选择是否添加示例方案，单击“下一步”；  初始化参数，设置内存、字符集等，单击“下一步”；  数据库存储，控制文件、数据文件、重做日志文件位置设置，单击“下一步”；  创建选项，创建数据库，生成脚本，单击“完成”，开始创建数据库。"
  },
  
  {
    "title": "Oracle 查看汉字所占字节",
    "url": "/posts/oracle-chakan-hanzi-suozhan-zijie/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "使用以下语句查询select userenv('language') from dual;如果显示如下，一个汉字占用两个字节SIMPLIFIED CHINESE_CHINA.ZHS16GBK如果显示如下，一个汉字占用三个字节SIMPLIFIED CHINESE_CHINA.AL32UTF8也可以用以下语句查询一个汉字占用的字节长度select lengthb('你') from dual;",
    "content": "使用以下语句查询select userenv('language') from dual;如果显示如下，一个汉字占用两个字节SIMPLIFIED CHINESE_CHINA.ZHS16GBK如果显示如下，一个汉字占用三个字节SIMPLIFIED CHINESE_CHINA.AL32UTF8也可以用以下语句查询一个汉字占用的字节长度select lengthb('你') from dual;"
  },
  
  {
    "title": "Oracle add_month函数",
    "url": "/posts/oracle-add-month-hanshu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "SELECT  ADD_MONTHS (    TO_DATE (      TO_CHAR (SYSDATE, 'yyyy-MM-dd'),      'yyyy-MM-dd HH24:mi:ss'    ),    - 1  )FROM  dual执行结果为上一个月的今天。",
    "content": "SELECT  ADD_MONTHS (    TO_DATE (      TO_CHAR (SYSDATE, 'yyyy-MM-dd'),      'yyyy-MM-dd HH24:mi:ss'    ),    - 1  )FROM  dual执行结果为上一个月的今天。"
  },
  
  {
    "title": "Oracle 判断字符串是否相等，包含NULL的情况",
    "url": "/posts/oracle-panduan-zifuchuan-shifou-xiangdeng/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "在Oracle中，将空字符串视为null，任何值与null比较结果都为null。如此一来，在比较两个字符串的时候就会出现意外，例如：select * from test where str &lt;&gt; 'test';此时，值为null的记录不会显示出。应当将null转为其他字符串：select * from test where nvl(to_char(str),'xx') &lt;&...",
    "content": "在Oracle中，将空字符串视为null，任何值与null比较结果都为null。如此一来，在比较两个字符串的时候就会出现意外，例如：select * from test where str &lt;&gt; 'test';此时，值为null的记录不会显示出。应当将null转为其他字符串：select * from test where nvl(to_char(str),'xx') &lt;&gt; 'test';"
  },
  
  {
    "title": "Oracle 将查询出来的表数据修改一个或几个字段后，再插入到表中",
    "url": "/posts/oracle-jiang-chaxunchu-de-shuju-xiugaihou-charu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "INSERT INTO  tableNameSELECT  seq_master.nextval, --自定义值（序列号）  TO_DATE('2012/01/01', 'YYYY/MM/DD'), --自定义值  CURR_SOURCE, --原始字段信息  CURR_DEST, --原始字段信息  EXCHANGE_RATE, --原始字段信息  SYSDATE, --自定义值 （系统时...",
    "content": "INSERT INTO  tableNameSELECT  seq_master.nextval, --自定义值（序列号）  TO_DATE('2012/01/01', 'YYYY/MM/DD'), --自定义值  CURR_SOURCE, --原始字段信息  CURR_DEST, --原始字段信息  EXCHANGE_RATE, --原始字段信息  SYSDATE, --自定义值 （系统时间）  COMPANY_CODEFROM  tableNameWHERE  TO_CHAR(EXPIRE_DATE, 'YYYY/MM/DD') = '2011/12/01'"
  },
  
  {
    "title": "Oracle 11g各种服务的作用以及哪些需要开启",
    "url": "/posts/oracle-ge-fuwu-de-zuoyong/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "Windwos server 2012 R2上成功安装Oracle 11g后共有7个服务，如果全局数据库名为orcl，则Oracle服务分别为：Oracle ORCL VSSWriter ServiceOracleDBConsoleorclOracleJobSchedulerORCLOracleMTSRecoveryServiceOracleOraDb11g_home1ClrAgentOra...",
    "content": "Windwos server 2012 R2上成功安装Oracle 11g后共有7个服务，如果全局数据库名为orcl，则Oracle服务分别为：Oracle ORCL VSSWriter ServiceOracleDBConsoleorclOracleJobSchedulerORCLOracleMTSRecoveryServiceOracleOraDb11g_home1ClrAgentOracleOraDb11g_home1TNSListenerOracleServiceORCL其中OracleOraDb11g_home1ClrAgent是默认为手动操作，其余的默认自动启动。这七个服务的含义分别为：  Oracle ORCL VSS Writer Service：Oracle卷映射拷贝写入服务，VSS(Volume Shadow Copy Service)能够让存储基础设备(比如磁盘，阵列等)创建高保真的时间点映像，即映射拷贝(shadow copy)。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。(非必须启动)  OracleDBConsoleorcl：Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager(企业管理器OEM)的时候，需要启动这个服务。(非必须启动)  OracleJobSchedulerORCL：Oracle作业调度(定时器)服务，ORCL是Oracle实例标识。(非必须启动)  OracleMTSRecoveryService：服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。(非必须启动)  OracleOraDb11g_home1ClrAgent：Oracle数据库.NET扩展服务的一部分。 (非必须启动)  OracleOraDb11g_home1TNSListener：监听器服务，服务只有在数据库需要远程访问的时候才需要。(非必须启动)  OracleServiceORCL：数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础，只有该服务启动，Oracle数据库才能正常启动。(必须启动)那么在开发的时候到底需要启动哪些服务：  只用Oracle自带的sqlplus的话，只要启动OracleServiceORCL即可；  使用PL/SQL Developer等第三方工具的话，OracleOraDb11g_home1TNSListener服务也要开启；  OracleDBConsoleorcl是进入基于web的EM必须开启的，其余服务很少用。"
  },
  
  {
    "title": "Oracle 查询表中重复数据",
    "url": "/posts/oracle-chaxun-biaozhong-chongfu-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "1、查找表中的重复记录，重复记录是根据单个字段（peopleId）来判断SELECT  *FROM  peopleWHERE  peopleId IN (    SELECT      peopleId    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )2、删除表中多余的...",
    "content": "1、查找表中的重复记录，重复记录是根据单个字段（peopleId）来判断SELECT  *FROM  peopleWHERE  peopleId IN (    SELECT      peopleId    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录DELETE FROM  peopleWHERE  peopleId IN (    SELECT      peopleId    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )  AND rowid NOT IN (    SELECT      min(rowid)    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )3、查找表中多余的重复记录（多个字段） SELECT  *FROM  vitae aWHERE  (a.peopleId, a.seq) IN (    SELECT      peopleId,      seq    FROM      vitae    GROUP BY      peopleId,      seq    HAVING      count(*) &gt; 1  )4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录DELETE FROM  vitae aWHERE  (a.peopleId, a.seq) IN (    SELECT      peopleId,      seq    FROM      vitae    GROUP BY      peopleId,      seq    HAVING      count(*) &gt; 1  )  AND rowid NOT IN (    SELECT      min(rowid)    FROM      vitae    GROUP BY      peopleId,      seq    HAVING      count(*) &gt; 1  )比方说，在A表中存在一个字段“name”，而且不同记录之间的“name”值有可能会相同，现在就需要查询出在该表中的各记录之间，“name”值存在重复的项SELECT  NAME,  Count(*)FROM  AGROUP BY  NAMEHAVING  Count(*) &gt; 1如果还查性别也相同大则如下SELECT  NAME,  sex,  Count(*)FROM  AGROUP BY  NAME,  sexHAVING  Count(*) &gt; 1"
  },
  
  {
    "title": "Oracle 查询包含大小写的数据",
    "url": "/posts/oracle-chaxun-baohan-daxiaoxie-de-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-10 13:47:00 +0800",
    





    
    "snippet": "查询包含小写的所有数据select oper_no from info_oper where regexp_like(oper_no,'[[:lower:]]');select oper_no from info_oper where regexp_like(oper_no,'[a-z]');查询包含大写的所有数据select oper_no from info_oper where reg...",
    "content": "查询包含小写的所有数据select oper_no from info_oper where regexp_like(oper_no,'[[:lower:]]');select oper_no from info_oper where regexp_like(oper_no,'[a-z]');查询包含大写的所有数据select oper_no from info_oper where regexp_like(oper_no,'[[:upper:]]');select oper_no from info_oper where regexp_like(oper_no,'[A-Z]'); "
  },
  
  {
    "title": "Spring Boot如何快速切换配置",
    "url": "/posts/springboot-ruhe-kuaisu-qiehuan-peizhi/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2021-03-26 13:47:00 +0800",
    





    
    "snippet": "如果，我们有生产环境和开发环境，怎样更简单的切换配置呢？创建一个开发环境用的yml：application-dev.yml创建一个生产环境用的yml：application-prod.yml假如再有个都要使用的yml：application-common.yml写一个总的配置来集成他们：application.yml在不同的要求下，切换相应的配置文件即可。  参考：【springboot】【...",
    "content": "如果，我们有生产环境和开发环境，怎样更简单的切换配置呢？创建一个开发环境用的yml：application-dev.yml创建一个生产环境用的yml：application-prod.yml假如再有个都要使用的yml：application-common.yml写一个总的配置来集成他们：application.yml在不同的要求下，切换相应的配置文件即可。  参考：【springboot】【三】yml 配置文件（怎样更加简便的获取到配置文件中的属性，以便每个class都能快速获取到）"
  },
  
  {
    "title": "IntelliJ IDEA运行报Command line is too long的问题",
    "url": "/posts/intelliJ-idea-yunxing-xiangmu-bao-command-line-is-too-long/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "打开程序的运行配置，把Shorten command line改为JAR manifest或classpath file，如图所示：   参考：解决Intellij IDEA运行报Command line is too long的问题",
    "content": "打开程序的运行配置，把Shorten command line改为JAR manifest或classpath file，如图所示：   参考：解决Intellij IDEA运行报Command line is too long的问题"
  },
  
  {
    "title": "IntelliJ IDEA一键清除所有断点",
    "url": "/posts/intelliJ-idea-yijian-qingchu-suoyou-duandian/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "1.在IDEA左下方找到”View Breakpoints”按钮，点击打开2.点击”Java Line Breakpoints”前方的全选框，取消全选3.点击上方”-“即”Remove”按钮，即可取消所有Breakpoints4.清除断点后，点击”Done”  参考：intellij idea 如何一键清除所有断点",
    "content": "1.在IDEA左下方找到”View Breakpoints”按钮，点击打开2.点击”Java Line Breakpoints”前方的全选框，取消全选3.点击上方”-“即”Remove”按钮，即可取消所有Breakpoints4.清除断点后，点击”Done”  参考：intellij idea 如何一键清除所有断点"
  },
  
  {
    "title": "IntelliJ IDEA取消参数名称（形参名）提示",
    "url": "/posts/intelliJ-idea-quxiao-xingcanming-tishi/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "File -&gt; Setting -&gt; Editor -&gt; General -&gt; Appearance 把“Show parameter name hints”选项前面的勾去掉，点击“OK”，完成。  参考：IDEA取消参数名称（形参名）提示",
    "content": "File -&gt; Setting -&gt; Editor -&gt; General -&gt; Appearance 把“Show parameter name hints”选项前面的勾去掉，点击“OK”，完成。  参考：IDEA取消参数名称（形参名）提示"
  },
  
  {
    "title": "IntelliJ IDEA的Run Dashboard如何显示出来",
    "url": "/posts/intelliJ-idea-de-rundashboard-ruhe-xianshi-chulai/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "点击如图所示位置的下来三角按钮，然后选择Edit Configurations，或者点击菜单栏Run -&gt; Edit Configurations在运行配置窗口，选择一条Spring Boot的运行配置，然后点击上方的复制按钮进行复制副本复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run conf...",
    "content": "点击如图所示位置的下来三角按钮，然后选择Edit Configurations，或者点击菜单栏Run -&gt; Edit Configurations在运行配置窗口，选择一条Spring Boot的运行配置，然后点击上方的复制按钮进行复制副本复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run configurations in Run Dashboard如图所示，则立即可以看到Run Dashboard窗口已经成功显示出来了，在Run Dashboard中可以看到当前所有的启动配置，直接点击可以方便的启动和停止如图以上方法还没有显示出来的话，则可以通过修改IDEA的workspace.xml的方式来快速打开Run Dashboard窗口打开workspace.xml文件之后，找到component为RunDashboard的节点处，然后在component标签里添加&lt;option name=\"configurationTypes\"&gt;    &lt;set&gt;        &lt;option value=\"SpringBootApplicationConfigurationType\" /&gt;    &lt;/set&gt;&lt;/option&gt;最后保存即可，保存完成之后立即自动弹出Run Dashboard窗口了  参考：springboot在idea的RunDashboard如何显示出来"
  },
  
  {
    "title": "IntelliJ IDEA项目目录的文件名显示为红色的解决办法",
    "url": "/posts/intelliJ-idea-wenjianming-xianshi-hongse/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-18 13:23:00 +0800",
    





    
    "snippet": "报错信息导入IDEA的项目文件显示为红色。报错原因项目目录中存在版本控制文件所导致的，解决办法就是——解除版本控制。解决方法File –&gt; settings –&gt; version control或者使用快捷键CTRL + ALT + S进入设置界面，在右侧的目录列表中选择项目后面的Subversion改成&lt;none&gt;即可。  参考：IDEA项目目录的文件名显示为红色的...",
    "content": "报错信息导入IDEA的项目文件显示为红色。报错原因项目目录中存在版本控制文件所导致的，解决办法就是——解除版本控制。解决方法File –&gt; settings –&gt; version control或者使用快捷键CTRL + ALT + S进入设置界面，在右侧的目录列表中选择项目后面的Subversion改成&lt;none&gt;即可。  参考：IDEA项目目录的文件名显示为红色的解决办法"
  },
  
  {
    "title": "IntelliJ IDEA项目目录的Java类文件名的左下角出现红圈",
    "url": "/posts/intelliJ-idea-wenjian-zuoxiajiao-chuxian-hongquan/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-18 13:23:00 +0800",
    





    
    "snippet": "报错信息src目录下的Java类的名字的左下角出现红圈并且中间有一个字母J。按住CTRL点左键的时候出现“cannot find declaration to go to”。报错原因模块路径错误。解决方法File –&gt; Project Structure –&gt; Modules进入模块设置界面，重新添加工程路径即可。   参考：idea的src目录下的java类文件名的左下角出现红...",
    "content": "报错信息src目录下的Java类的名字的左下角出现红圈并且中间有一个字母J。按住CTRL点左键的时候出现“cannot find declaration to go to”。报错原因模块路径错误。解决方法File –&gt; Project Structure –&gt; Modules进入模块设置界面，重新添加工程路径即可。   参考：idea的src目录下的java类文件名的左下角出现红圈中间有一个小j字母的解决方法（完美解决）"
  },
  
  {
    "title": "IntelliJ IDEA中非Maven项目如何引用jar包",
    "url": "/posts/intelliJ-idea-feimaven-xiangmu-ruhe-yinru-jarbao/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-18 13:23:00 +0800",
    





    
    "snippet": "在引用jar包方面IDEA和Eclipse是不一样的，直接复制到lib是没用的，无法自动导包。IDEA引入jar包流程：打开File -&gt; Project Structure -&gt; Modules -&gt; Dependencies -&gt; 加号 -&gt; 1. Jars or directories…  参考：IDEA中非Maven项目如何引用jar包？为什么直接放到l...",
    "content": "在引用jar包方面IDEA和Eclipse是不一样的，直接复制到lib是没用的，无法自动导包。IDEA引入jar包流程：打开File -&gt; Project Structure -&gt; Modules -&gt; Dependencies -&gt; 加号 -&gt; 1. Jars or directories…  参考：IDEA中非Maven项目如何引用jar包？为什么直接放到lib中无效？"
  },
  
  {
    "title": "Python的一些常用操作",
    "url": "/posts/python-yixie-changyong-de-caozuo/",
    "categories": "Knowledge, Python",
    "tags": "Python",
    "date": "2021-03-09 13:47:00 +0800",
    





    
    "snippet": "Python删除文件使用python删除一个文件或文件夹，需要使用os模块。import ospath = 'F:/新建文本文档.txt'  # 文件路径if os.path.exists(path):  # 如果文件存在    # 删除文件，可使用以下两种方法。    os.remove(path)      #os.unlink(path)else:    print('no such ...",
    "content": "Python删除文件使用python删除一个文件或文件夹，需要使用os模块。import ospath = 'F:/新建文本文档.txt'  # 文件路径if os.path.exists(path):  # 如果文件存在    # 删除文件，可使用以下两种方法。    os.remove(path)      #os.unlink(path)else:    print('no such file:%s'%my_file)  # 则返回文件不存在Python创建文件并写入new_page = FILE_PATH + \"\\test.txt\"    with open(new_page, 'w+') as file:        file.write(\"test\\n\")Python获取文件修改时间mtime = os.stat(file).st_mtimefile_modify_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(mtime))"
  },
  
  {
    "title": "使用Javamail通过SMTP协议发信",
    "url": "/posts/shiyong-javamail-tongguo-smtp-xieyi-faxin/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-03-04 13:47:00 +0800",
    





    
    "snippet": "package mail.util;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.io.UnsupportedEncodingException;import java.util.Properties;publi...",
    "content": "package mail.util;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.io.UnsupportedEncodingException;import java.util.Properties;public class SampleMail {    private static final String ALIDM_SMTP_HOST = \"smtpdm.aliyun.com\";    private static final String ALIDM_SMTP_PORT = \"25\"; // 或\"80\"    public static void main(String[] args) throws UnsupportedEncodingException {        // 配置发送邮件的环境属性        final Properties props = new Properties();        // 表示SMTP发送邮件，需要进行身份验证        props.put(\"mail.smtp.auth\", \"true\");        props.put(\"mail.smtp.host\", ALIDM_SMTP_HOST);        props.put(\"mail.smtp.port\", ALIDM_SMTP_PORT);        // 如果使用SSL，则去掉使用25端口的配置，进行如下配置,        // props.put(\"mail.smtp.socketFactory.class\",         //       \"javax.net.ssl.SSLSocketFactory\");        // props.put(\"mail.smtp.socketFactory.port\", \"465\");        // props.put(\"mail.smtp.port\", \"465\");        // 发件人的账号，填写控制台配置的发信地址,比如xxx@xxx.com        props.put(\"mail.user\", \"发信地址\");        // 访问SMTP服务时需要提供的密码(在控制台选择发信地址进行设置)        props.put(\"mail.password\", \"***\");        // 构建授权信息，用于进行SMTP进行身份验证        Authenticator authenticator = new Authenticator() {            @Override            protected PasswordAuthentication getPasswordAuthentication() {                // 用户名、密码                String userName = props.getProperty(\"mail.user\");                String password = props.getProperty(\"mail.password\");                return new PasswordAuthentication(userName, password);            }        };                // 使用环境属性和授权信息，创建邮件会话        Session mailSession = Session.getInstance(props, authenticator);        // mailSession.setDebug(true);        // UUID uuid = UUID.randomUUID();        // final String messageIDValue = \"&lt;\" + uuid.toString() + \"&gt;\";        // 创建邮件消息        MimeMessage message = new MimeMessage(mailSession) {            // @Override            // protected void updateMessageID() throws MessagingException {            // 设置自定义Message-ID值            // setHeader(\"Message-ID\", messageIDValue);            // }        };        try {            // 设置发件人邮件地址和名称。填写控制台配置的发信地址，            // 比如xxx@xxx.com。和上面的mail.user保持一致，            // 发件人名称用户可以自定义填写。            InternetAddress from = new InternetAddress(\"发信地址\", \"发件人名称\");            message.setFrom(from);            // 可选，设置回信地址            Address[] a = new Address[1];            a[0] = new InternetAddress(\"***\");            message.setReplyTo(a);            // 设置收件人邮件地址，比如yyy@yyy.com            InternetAddress to = new InternetAddress(\"收件人邮件地址\");            message.setRecipient(MimeMessage.RecipientType.TO, to);            // 如果同时发给多人，才将上面两行替换为如下（因为部分收信系统的一些限制，            // 尽量每次投递给一个人；同时我们限制单次允许发送的人数是30人）：            // InternetAddress[] adds = new InternetAddress[2];            // adds[0] = new InternetAddress(\"xxxxx@qq.com\");            // adds[1] = new InternetAddress(\"xxxxx@qq.com\");            // message.setRecipients(Message.RecipientType.TO, adds);            String ccUser = \"抄送邮箱\";            // 设置多个抄送地址            if (null != ccUser &amp;&amp; !ccUser.isEmpty()) {                @SuppressWarnings(\"static-access\")                InternetAddress[] internetAddressCC = new InternetAddress()                    .parse(ccUser);                message.setRecipients(Message.RecipientType.CC, internetAddressCC);            }            String bccUser = \"密送邮箱\";            // 设置多个密送地址            if (null != bccUser &amp;&amp; !bccUser.isEmpty()) {                @SuppressWarnings(\"static-access\")                InternetAddress[] internetAddressBCC = new InternetAddress()                    .parse(bccUser);                message.setRecipients(Message.RecipientType.BCC, internetAddressBCC);            }            // 设置邮件标题            message.setSubject(\"测试邮件\");            // 设置邮件的内容体            message.setContent(\"测试的HTML邮件\", \"text/html;charset=UTF-8\");                        // 若需要开启邮件跟踪服务，请使用以下代码设置跟踪链接头。首先域名需要备案，            // 设置且已正确解析了CNAME配置；其次发信需要打Tag，此Tag在控制台已创建并存在，            // Tag创建10分钟后方可使用；            // String tagName = \"Test\";            // HashMap&lt;String, String&gt; trace = new HashMap&lt;&gt;();            // trace.put(\"OpenTrace\", \"1\");            // trace.put(\"TagName\", tagName);            // String jsonTrace = JSON.toJSONString(trace);            // String base64Trace = new String(Base64            //    .encodeBase64(jsonTrace.getBytes()));            // 设置跟踪链接头            // message.addHeader(\"X-AliDM-Trace\", base64Trace);            // 发送附件，总的邮件大小不超过15M，创建消息部分            // BodyPart messageBodyPart = new MimeBodyPart();            // 消息            // messageBodyPart.setText(\"消息Text\");            // 创建多重消息            // Multipart multipart = new MimeMultipart();            // 设置文本消息部分            // multipart.addBodyPart(messageBodyPart);            // 附件部分            // messageBodyPart = new MimeBodyPart();            // 设置要发送附件的文件路径            // String filename = \"D:\\\\goProjects\\\\src\\\\测试pdf.pdf\";            // FileDataSource source = new FileDataSource(filename);            // messageBodyPart.setDataHandler(new DataHandler(source));            // 处理附件名称中文（附带文件路径）乱码问题            // messageBodyPart.setFileName(MimeUtility.encodeText(filename));            // messageBodyPart.addHeader(\"Content-Transfer-Encoding\", \"base64\");            // multipart.addBodyPart(messageBodyPart);            // 发送含有附件的完整消息            // message.setContent(multipart);            // 发送附件代码，结束            // 发送邮件            Transport.send(message);        } catch (MessagingException e) {            String err = e.getMessage();            // 在这里处理message内容， 格式是固定的            System.out.println(err);        }    }    }  参考：SMTP 之 Java 调用示例"
  },
  
  {
    "title": "MySQL中对字符串类型字段进行数字值排序",
    "url": "/posts/dui-zifuchuan-leixing-ziduan-jinxing-shuzizhi-paixu/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-01-31 13:47:00 +0800",
    





    
    "snippet": "-- 方式一SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMBER + 0 DESC                -- 方式二        SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMB...",
    "content": "-- 方式一SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMBER + 0 DESC                -- 方式二        SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMBER * 1 DESC"
  },
  
  {
    "title": "Unable to load annotation processor factory",
    "url": "/posts/unable-to-load-annotation-processor-factory/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-01-31 13:47:00 +0800",
    





    
    "snippet": "报错信息Description Resource Path Location TypeUnable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar’ for project XXXXXXXXX Annotation processor factory path A...",
    "content": "报错信息Description Resource Path Location TypeUnable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar’ for project XXXXXXXXX Annotation processor factory path APT Build Problem.Description Resource Path Location TypeUnable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\tools.jar’ for project XXXXXXXXX Annotation processor factory path APT Build Problem说明  重点在annotation processor factory找不到C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar。  annotation processor注解的处理器是项目properties中java compiler里的。  C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\tools.jar和jconsole.jar都是JDK里的。解决方法  参考：Unable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar’"
  },
  
  {
    "title": "Maven全局配置文件settings.xml详解",
    "url": "/posts/maven-quanju-peizhi-wenjian-xiangjie/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "一、概要1.1 settings.xml的作用它是用来设置Maven参数的配置文件。并且，settings.xml是Maven的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。1.2 settings.xml文件位置settings.xml文件一般存在于Maven的安装目录的conf子目录下面，或者是用户目录的.m2子目录下面。1.3 配置的优先...",
    "content": "一、概要1.1 settings.xml的作用它是用来设置Maven参数的配置文件。并且，settings.xml是Maven的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。1.2 settings.xml文件位置settings.xml文件一般存在于Maven的安装目录的conf子目录下面，或者是用户目录的.m2子目录下面。1.3 配置的优先级其实相对于多用户的PC机而言，在Maven安装目录的conf子目录下面的settings.xml才是真正的全局的配置。而用户目录的.m2子目录下面的settings.xml的配置只是针对当前用户的。当这两个文件同时存在的时候，那么对于相同的配置信息用户目录下面的settings.xml中定义的会覆盖Maven安装目录下面的settings.xml中的定义。用户目录下的settings.xml文件一般是不存在的，但是Maven允许我们在这里定义我们自己的settings.xml，如果需要在这里定义我们自己的settings.xml的时候就可以把Maven安装目录下面的settings.xml文件拷贝到用户目录的.m2目录下，然后改成自己想要的样子。二、settings.xml元素详解顶级元素概览&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0                          https://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  &lt;localRepository/&gt;  &lt;interactiveMode/&gt;  &lt;usePluginRegistry/&gt;  &lt;offline/&gt;  &lt;pluginGroups/&gt;  &lt;servers/&gt;  &lt;mirrors/&gt;  &lt;proxies/&gt;  &lt;profiles/&gt;  &lt;activeProfiles/&gt;&lt;/settings&gt;2.1 LocalRepository作用：该值表示构建系统本地仓库的路径。其默认值：~/.m2/repository。&lt;localRepository&gt;${user.home}/.m2/repository&lt;/localRepository&gt;2.2 InteractiveMode作用：表示Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。&lt;interactiveMode&gt;true&lt;/interactiveMode&gt;2.3 UsePluginRegistry作用：Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。&lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt;2.4 Offline作用：这个属性表示在Maven进行项目编译和部署等操作时是否允许Maven进行联网来下载所需要的信息。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。&lt;offline&gt;false&lt;/offline&gt;2.5 PluginGroups作用：在pluginGroups元素下面可以定义一系列的pluginGroup元素。表示当通过plugin的前缀来解析plugin的时候到哪里寻找。pluginGroup元素指定的是plugin的groupId。默认情况下，Maven会自动把org.apache.maven.plugins和org.codehaus.mojo添加到pluginGroups下。&lt;pluginGroups&gt;  &lt;!--plugin的组织Id（groupId） --&gt;  &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt;&lt;/pluginGroups&gt;2.6 Servers作用：一般，仓库的下载和部署是在pom.xml文件中的repositories和distributionManagement元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，这些信息可以配置在settings.xml中。&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;&lt;servers&gt;  &lt;!--服务器元素包含配置服务器时需要的信息 --&gt;  &lt;server&gt;    &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;    &lt;id&gt;server001&lt;/id&gt;    &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;    &lt;username&gt;my_login&lt;/username&gt;    &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt;    &lt;password&gt;my_password&lt;/password&gt;    &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;    &lt;privateKey&gt;${usr.home}/.ssh/id_dsa&lt;/privateKey&gt;    &lt;!--鉴权时使用的私钥密码。 --&gt;    &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt;    &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;    &lt;filePermissions&gt;664&lt;/filePermissions&gt;    &lt;!--目录被创建时的权限。 --&gt;    &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt;  &lt;/server&gt;&lt;/servers&gt;2.7 Mirrors作用：用于定义一系列的远程仓库的镜像。我们可以在pom中定义一个下载工件的时候所使用的远程仓库。但是有时候这个远程仓库会比较忙，所以这个时候人们就想着给它创建镜像以缓解远程仓库的压力，也就是说会把对远程仓库的请求转换到对其镜像地址的请求。每个远程仓库都会有一个id，这样我们就可以创建自己的mirror来关联到该仓库，那么以后需要从远程仓库下载工件的时候Maven就可以从我们定义好的mirror站点来下载，这可以很好的缓解我们远程仓库的压力。在我们定义的mirror中每个远程仓库都只能有一个mirror与它关联，也就是说你不能同时配置多个mirror的mirrorOf指向同一个repositoryId。&lt;mirrors&gt;  &lt;!-- 给定仓库的下载镜像。 --&gt;  &lt;mirror&gt;    &lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;    &lt;id&gt;mirrorId&lt;/id&gt;    &lt;!-- 镜像名称 --&gt;    &lt;name&gt;PlanetMirror Australia&lt;/name&gt;    &lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;    &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt;    &lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;2.8 Proxies作用：用来配置不同的代理。&lt;proxies&gt;  &lt;!--代理元素包含配置代理时需要的信息 --&gt;  &lt;proxy&gt;    &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;    &lt;id&gt;myproxy&lt;/id&gt;    &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;    &lt;active&gt;true&lt;/active&gt;    &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;    &lt;protocol&gt;http&lt;/protocol&gt;    &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;    &lt;host&gt;proxy.somewhere.com&lt;/host&gt;    &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;    &lt;port&gt;8080&lt;/port&gt;    &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;    &lt;username&gt;proxyuser&lt;/username&gt;    &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;    &lt;password&gt;somepassword&lt;/password&gt;    &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;    &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt;  &lt;/proxy&gt;&lt;/proxies&gt;2.9 Profiles作用：根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id、activation、repositories、pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings.xml中的profile被激活，它的值会覆盖任何其它定义在pom.xml中带有相同id的profile。当所有的约束条件都满足的时候就会激活这个profile。&lt;profiles&gt;    &lt;profile&gt;　　&lt;!-- profile的唯一标识 --&gt;        &lt;id&gt;test&lt;/id&gt;             &lt;!-- 自动触发profile的条件逻辑 --&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;            &lt;jdk&gt;1.6&lt;/jdk&gt;            &lt;os&gt;                &lt;name&gt;Windows 7&lt;/name&gt;                &lt;family&gt;Windows&lt;/family&gt;                &lt;arch&gt;x86&lt;/arch&gt;                &lt;version&gt;5.1.2600&lt;/version&gt;            &lt;/os&gt;            &lt;property&gt;                &lt;name&gt;mavenVersion&lt;/name&gt;                &lt;value&gt;2.0.3&lt;/value&gt;            &lt;/property&gt;            &lt;file&gt;                &lt;exists&gt;${basedir}/file2.properties&lt;/exists&gt;                &lt;missing&gt;${basedir}/file1.properties&lt;/missing&gt;            &lt;/file&gt;        &lt;/activation&gt;        &lt;!-- 扩展属性列表 --&gt;        &lt;properties /&gt;        &lt;!-- 远程仓库列表 --&gt;        &lt;repositories /&gt;        &lt;!-- 插件仓库列表 --&gt;        &lt;pluginRepositories /&gt;      ...    &lt;/profile&gt;&lt;/profiles&gt;2.9.1 Activation作用：自动触发profile的条件逻辑。这是profile中最重要的元素。跟pom.xml中的profile一样，settings.xml中的profile也可以在特定环境下改变一些值，而这些环境是通过activation元素来指定的。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。  jdk：表示当jdk的版本满足条件的时候激活，在这里是1.6。这里的版本还可以用一个范围表示，如  &lt;jdk&gt;[1.4,1.7)&lt;/jdk&gt;表示1.4、1.5和1.6满足；  &lt;jdk&gt;[1.4,1.7]&lt;/jdk&gt;表示1.4、1.5、1.6和1.7满足；  os：表示当操作系统满足条件的时候激活。  property：property是键值对的形式，表示当Maven检测到了这样一个键值对的时候就激活该profile。          下面的示例表示当存在属性hello的时候激活该profile。        &lt;property&gt;    &lt;name&gt;hello&lt;/name&gt;&lt;/property&gt;                    下面的示例表示当属性hello的值为world的时候激活该profile。        &lt;property&gt;    &lt;name&gt;hello&lt;/name&gt;    &lt;value&gt;world&lt;/value&gt;&lt;/property&gt;                这个时候如果要激活该profile的话，可以在调用Maven指令的时候加上参数hello并指定其值为world，如：mvn compile –Dhello=world              file：表示当文件存在或不存在的时候激活，exists表示存在，missing表示不存在。如下面例子表示当文件hello/world不存在的时候激活该profile。      &lt;profile&gt;      &lt;activation&gt;          &lt;file&gt;              &lt;missing&gt;hello/world&lt;/missing&gt;          &lt;/file&gt;      &lt;/activation&gt;  &lt;/profile&gt;        activeByDefault：当其值为true的时候表示如果没有其他的profile处于激活状态的时候，该profile将自动被激活。  properties：用于定义属性键值对的。当该profile是激活状态的时候，properties下面指定的属性都可以在pom.xml中使用。对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在pom.xml中的任何地方使用标记${X}来使用，这里X是指属性的名称。属性有五种不同的形式，并且都能在settings.xml文件中访问。      &lt;!--  1、env.X: 在一个变量前加上\"env.\"的前缀，会返回一个shell环境变量。例如,\"env.PATH\"指代了$path环境变量（在Windows上是%PATH%）。  2、project.x：指代了POM中对应的元素值。例如: &lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;通过${project.version}获得version的值。  3、settings.x: 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;通过 ${settings.offline}获得offline的值。  4、Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 ${java.home}。  5、x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以${someVar}的形式使用。  --&gt;  &lt;properties&gt;      &lt;user.install&gt;${user.home}/our-project&lt;/user.install&gt;  &lt;/properties&gt;        注：如果该profile被激活，则可以在pom.xml中使用${user.install}。    repositories：用于定义远程仓库的，当该profile是激活状态的时候，这里面定义的远程仓库将作为当前pom的远程仓库。它是Maven用来填充构建系统本地仓库所使用的一组远程仓库。      &lt;repositories&gt;  &lt;!--包含需要连接到远程仓库的信息 --&gt;  &lt;repository&gt;      &lt;!--远程仓库唯一标识 --&gt;      &lt;id&gt;codehausSnapshots&lt;/id&gt;      &lt;!--远程仓库名称 --&gt;      &lt;name&gt;Codehaus Snapshots&lt;/name&gt;      &lt;!--如何处理远程仓库里发布版本的下载 --&gt;      &lt;releases&gt;      &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;      &lt;enabled&gt;false&lt;/enabled&gt;      &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;      &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;      &lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;      &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;      &lt;/releases&gt;      &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;      &lt;snapshots&gt;      &lt;enabled /&gt;      &lt;updatePolicy /&gt;      &lt;checksumPolicy /&gt;      &lt;/snapshots&gt;      &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;      &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt;      &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;      &lt;layout&gt;default&lt;/layout&gt;  &lt;/repository&gt;  &lt;/repositories&gt;              releases、snapshots：这是对于工件的类型的限制。      enabled：表示这个仓库是否允许这种类型的工件      updatePolicy：表示多久尝试更新一次。可选值有always、daily、interval:minutes（表示每多久更新一次）和never。      checksumPolicy：当Maven在部署项目到仓库的时候会连同校验文件一起提交，checksumPolicy表示当这个校验文件缺失或不正确的时候该如何处理，可选项有ignore、fail和warn。      pluginRepositories：在Maven中有两种类型的仓库，一种是存储工件的仓库，另一种就是存储plugin插件的仓库。pluginRepositories的定义和repositories的定义类似，它表示Maven在哪些地方可以找到所需要的插件。和repository类似，只是repository是管理jar包依赖的仓库，pluginRepositories则是管理插件的仓库。maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。        &lt;pluginRepositories&gt;&lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;&lt;pluginRepository&gt;    &lt;releases&gt;    &lt;enabled /&gt;    &lt;updatePolicy /&gt;    &lt;checksumPolicy /&gt;    &lt;/releases&gt;    &lt;snapshots&gt;    &lt;enabled /&gt;    &lt;updatePolicy /&gt;    &lt;checksumPolicy /&gt;    &lt;/snapshots&gt;    &lt;id /&gt;    &lt;name /&gt;    &lt;url /&gt;    &lt;layout /&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;                示例：        &lt;activation&gt;&lt;!--profile默认是否激活的标识 --&gt;&lt;activeByDefault&gt;false&lt;/activeByDefault&gt;&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;&lt;jdk&gt;1.5&lt;/jdk&gt;&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;&lt;os&gt;    &lt;!--激活profile的操作系统的名字 --&gt;    &lt;name&gt;Windows XP&lt;/name&gt;    &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;    &lt;family&gt;Windows&lt;/family&gt;    &lt;!--激活profile的操作系统体系结构 --&gt;    &lt;arch&gt;x86&lt;/arch&gt;    &lt;!--激活profile的操作系统版本 --&gt;    &lt;version&gt;5.1.2600&lt;/version&gt;&lt;/os&gt;&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;&lt;property&gt;    &lt;!--激活profile的属性的名称 --&gt;    &lt;name&gt;mavenVersion&lt;/name&gt;    &lt;!--激活profile的属性的值 --&gt;    &lt;value&gt;2.0.3&lt;/value&gt;&lt;/property&gt;&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;&lt;file&gt;    &lt;!--如果指定的文件存在，则激活profile。 --&gt;    &lt;exists&gt;${basedir}/file2.properties&lt;/exists&gt;    &lt;!--如果指定的文件不存在，则激活profile。 --&gt;    &lt;missing&gt;${basedir}/file1.properties&lt;/missing&gt;&lt;/file&gt;&lt;/activation&gt;                    2.10 ActiveProfiles作用：手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0                      https://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  ...  &lt;activeProfiles&gt;    &lt;!-- 要激活的profile id --&gt;    &lt;activeProfile&gt;env-test&lt;/activeProfile&gt;  &lt;/activeProfiles&gt;  ...&lt;/settings&gt;"
  },
  
  {
    "title": "Linux 用户操作",
    "url": "/posts/linux-yonghu-caozuo/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "查看用户列表 cat /etc/passwd 或者 cat /etc/shadow增加/修改/删除用户 useradd/usermod/userdel增加/修改/删除用户组 groupadd/groupmod/groupdel修改密码 passwd &lt;accountName&gt;",
    "content": "查看用户列表 cat /etc/passwd 或者 cat /etc/shadow增加/修改/删除用户 useradd/usermod/userdel增加/修改/删除用户组 groupadd/groupmod/groupdel修改密码 passwd &lt;accountName&gt;"
  },
  
  {
    "title": "next()和nextLine()的区别",
    "url": "/posts/next-he-nextline-de-qubie/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "  next()这个函数会扫描从有效字符起到空格，Tab，回车等结束字符之间的内容并作为String返回。  nextLine()这个函数在输入完一些东西之后按下回车则视为输入结束，输入的内容将被作为String返回。  next()这个函数与之不同在于，next()什么都不输入直接敲回车不会返回，而nextLine()即使不输入东西直接敲回车也会返回。再举个例子，输入abc def gh\\...",
    "content": "  next()这个函数会扫描从有效字符起到空格，Tab，回车等结束字符之间的内容并作为String返回。  nextLine()这个函数在输入完一些东西之后按下回车则视为输入结束，输入的内容将被作为String返回。  next()这个函数与之不同在于，next()什么都不输入直接敲回车不会返回，而nextLine()即使不输入东西直接敲回车也会返回。再举个例子，输入abc def gh\\n，next()会返回abc，而nextLine()会返回abc def gh\\n。"
  },
  
  {
    "title": "Java删除数组中元素的方法",
    "url": "/posts/java-shanchu-shuzu-zhong-yuansu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "public static void main(String[] args) {    String[] data = new String[] { \"a\", \"b\", \"c\" };    String del = \"c\";    for (int i = 0; i &lt; data.length; i++) {        if (del.equals(data[i])) {     ...",
    "content": "public static void main(String[] args) {    String[] data = new String[] { \"a\", \"b\", \"c\" };    String del = \"c\";    for (int i = 0; i &lt; data.length; i++) {        if (del.equals(data[i])) {            for (int k = i; k &lt; data.length - 1; k++) {                data[k] = data[k + 1];            }            data = Arrays.copyOf(data, data.length - 1);        }    }    for (int i = 0; i &lt; data.length; i++) {        System.out.println(data[i]);    }}"
  },
  
  {
    "title": "如何判断Bigdecimal类型变量是否等于0",
    "url": "/posts/java-ruhe-panduan-bigdecimal-shifou-wei0/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "使用以下方法比较存在问题：b.equals(BigDecimal.ZERO);查看源代码发现Bigdecimal的equals方法不仅仅比较值的大小是否相等，首先比较的是scale（scale是bigdecimal的保留小数点位数，比如new Bigdecimal(\"1.001\")scale为3），也就是说，不但值的大小要相等，保留位数也要相等，equals才能返回true。Bigdecim...",
    "content": "使用以下方法比较存在问题：b.equals(BigDecimal.ZERO);查看源代码发现Bigdecimal的equals方法不仅仅比较值的大小是否相等，首先比较的是scale（scale是bigdecimal的保留小数点位数，比如new Bigdecimal(\"1.001\")scale为3），也就是说，不但值的大小要相等，保留位数也要相等，equals才能返回true。Bigdecimal b = new Bigdecimal(\"0\")和Bigdecimal c = new Bigdecimal(\"0.0\"),用equals比较，返回就是false。可以用以下方法比较：// 返回true，则等于0，返回false，则不等于0b.compareTo(BigDecimal.ZERO) == 0还可以用compareTo方法比较两个Bigdecimal数值的大小a.compareTo(b)// a&lt;b, 返回-1// a=b，返回0// a&gt;b, 返回1"
  },
  
  {
    "title": "Oracle 保留三位小数，不足补0",
    "url": "/posts/oracle-baoliu-sanwei-xiaoshu-buzu-bu0/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-01-21 13:47:00 +0800",
    





    
    "snippet": "格式化为小数select   to_char(round(0.2, 3),'fm99999999990.000')from   dual;格式化为百分比select  to_char(round(0.2*100,2),'fm99999999990.00')||'%'from   dual;",
    "content": "格式化为小数select   to_char(round(0.2, 3),'fm99999999990.000')from   dual;格式化为百分比select  to_char(round(0.2*100,2),'fm99999999990.00')||'%'from   dual;"
  },
  
  {
    "title": "MySQL中使用SQL语句从文本文件导入数据",
    "url": "/posts/mysql-shiyong-sql-yuju-daoru-waibu-shuju/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "load data infile 'C:\\\\Users\\\\admin\\\\Desktop\\\\test.txt' into table t_admin fields terminated by ','lines terminated by '\\r\\n';",
    "content": "load data infile 'C:\\\\Users\\\\admin\\\\Desktop\\\\test.txt' into table t_admin fields terminated by ','lines terminated by '\\r\\n';"
  },
  
  {
    "title": "MySQL查询如何把指定数据行排在前面",
    "url": "/posts/mysql-chaxun-ruhe-jiang-zhiding-shuju-paizai-qianmian/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "如果只是一条数据行，可以这样：SELECT * FROM user ORDER BY user_id &lt;&gt; 7, score DESC;主要是user_id &lt;&gt; 7 ，会把用户id为7的排在前面。如果是多条数据行：SELECT * FROM user ORDER BY user_id NOT IN (7, 8, 9), score DESC;",
    "content": "如果只是一条数据行，可以这样：SELECT * FROM user ORDER BY user_id &lt;&gt; 7, score DESC;主要是user_id &lt;&gt; 7 ，会把用户id为7的排在前面。如果是多条数据行：SELECT * FROM user ORDER BY user_id NOT IN (7, 8, 9), score DESC;"
  },
  
  {
    "title": "pom文件报错：The POM for com.oracle:ojdbc14:jar:10.2.0.1.0 is missing",
    "url": "/posts/pom-wenjian-baocuo-zhaobudao-oracle-de-qudongbao/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "报错信息The POM for com.oracle:ojdbc14:jar:10.2.0.1.0 is missing, no dependency information available; 解决方法cmd中输入mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 ...",
    "content": "报错信息The POM for com.oracle:ojdbc14:jar:10.2.0.1.0 is missing, no dependency information available; 解决方法cmd中输入mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 -Dpackaging=jar -Dfile=C:\\Users\\Administrator\\Desktop\\ojdbc14-10.2.0.2.0.jar 将Oracle驱动包导入到Maven本地库中，重新运行maven update即可。"
  },
  
  {
    "title": "关于Maven",
    "url": "/posts/guanyu-maven/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "什么是MavenMaven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期。即项目的jar包依赖，开发，测试，发布打包。Maven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期，即项目的jar包依赖，开发，测试，发布打包。项目坐标Maven通过特定的标识来定义项目名称，这样既可以唯一的匹配其他的jar包，也可以通过发布，使别人能使用自己的发布产品。这个标识就被叫做坐标。&l...",
    "content": "什么是MavenMaven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期。即项目的jar包依赖，开发，测试，发布打包。Maven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期，即项目的jar包依赖，开发，测试，发布打包。项目坐标Maven通过特定的标识来定义项目名称，这样既可以唯一的匹配其他的jar包，也可以通过发布，使别人能使用自己的发布产品。这个标识就被叫做坐标。&lt;groupId&gt;com.test&lt;/groupId&gt;&lt;artifactId&gt;maventest&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;maventest&lt;/name&gt;&lt;url&gt;http://maven.apache.org&lt;/url&gt;  groupId：所述的项目名称，由于有的项目并不是一个jar包构成的，而是由很多的jar包组成的。因此这个groupId就是整个项目的名称。  artifactId：包的名称。  version：版本号。  packaging：包的类型，一般都是jar，也可以是war之类的。如果不填，默认就是jar。  name和url：一个是名称，一个是maven的地址。主要就是上面的几个参数。当想要依赖什么jar的时候就可以通过下面的方式依赖：&lt;dependencies&gt; &lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;3.8.1&lt;/version&gt;   &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;jar包的命名规则artifactId-version[-classifier].packaging比如上面的pom.xml生成的jar包名字就是：maventest-0.0.1-SNAPSHOT.jar。这里的classifier是可选的，但是有的项目可能还需要导出附属的一些文件，如javadoc，source等等，那么这个地方就需要配置一个字符串。一般都是JDKXXX之类的。"
  },
  
  {
    "title": "国内Maven库镜像（阿里云）",
    "url": "/posts/aliyun-jingxiangku/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "原来Maven地址应该是：http://repo1.maven.org/maven2/还有一个：http://central.maven.org/maven2/但是太慢了，可以改成阿里云的镜像库，配置如下：&lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&l...",
    "content": "原来Maven地址应该是：http://repo1.maven.org/maven2/还有一个：http://central.maven.org/maven2/但是太慢了，可以改成阿里云的镜像库，配置如下：&lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;          &lt;/mirror&gt;&lt;/mirrors&gt;或者直接加在repositories里面：&lt;repositories&gt;  &lt;repository&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;  &lt;/repository&gt;&lt;/repositories&gt;"
  },
  
  {
    "title": "项目启动报时区错误",
    "url": "/posts/xiangmu-qidong-bao-shiqu-cuowu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "报错信息The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must...报错原因原因是使用了Mysql Connector/J 6.x以上的版本，然后就报了时区的错误。解决方法在配置url的时候不能简单写成：jdbc:mysql://localho...",
    "content": "报错信息The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must...报错原因原因是使用了Mysql Connector/J 6.x以上的版本，然后就报了时区的错误。解决方法在配置url的时候不能简单写成：jdbc:mysql://localhost:3306/yzu而是要写成：jdbc:mysql://localhost:3306/yzu?serverTimezone=UTC"
  },
  
  {
    "title": "Java中Oracle WHERE IN查询的项超过1000条的解决方案",
    "url": "/posts/java-chuli-oracle-in-chaoguo-1000-tiao-de-qingkuang/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-19 11:47:00 +0800",
    





    
    "snippet": "/** * 处理Oracle SQL语句IN子句中WHERE id IN (1, 2, ..., 1000, 1001)， * 如果子句中超过1000项就会报错。 * 这主要是Oracle考虑性能问题做的限制。 * 如果要解决此问题，可以用 WHERE id IN (1, 2, ..., 1000) OR id IN (1001, ...) * @author hoojo * @create...",
    "content": "/** * 处理Oracle SQL语句IN子句中WHERE id IN (1, 2, ..., 1000, 1001)， * 如果子句中超过1000项就会报错。 * 这主要是Oracle考虑性能问题做的限制。 * 如果要解决此问题，可以用 WHERE id IN (1, 2, ..., 1000) OR id IN (1001, ...) * @author hoojo * @createDate 2012-8-31 下午02:36:03 * @param ids IN语句中的集合对象 * @param count IN语句中出现的条件个数 * @param field IN语句对应的数据库查询字段 * @return field IN (...) OR field IN (...)字符串 */private String getOracleSQLIn(List&lt;?&gt; ids, int count, String field) {    count = Math.min(count, 1000);    int len = ids.size();    int size = len % count;    if (size == 0) {        size = len / count;    } else {        size = (len / count) + 1;    }    StringBuilder builder = new StringBuilder();    for (int i = 0; i &lt; size; i++) {        int fromIndex = i * count;        int toIndex = Math.min(fromIndex + count, len);        String productId = StringUtils.defaultIfEmpty(StringUtils.join(ids.subList(fromIndex, toIndex), \"','\"), \"\");        if (i != 0) {            builder.append(\" or \");        }        builder.append(field).append(\" in ('\").append(productId).append(\"')\");    }    return StringUtils.defaultIfEmpty(builder.toString(), field + \" in ('')\");}  参考：处理 Oracle SQL in 超过1000 的解决方案"
  },
  
  {
    "title": "PLSQL轻客户端的配置",
    "url": "/posts/plsql-qingkehuduan-de-peizhi/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "安装instantclient的原因在64位系统上安装64位的Oracle数据库，但是没有对应的64位PLSQL Developer，此时就不能使用PLSQL Developer来进行直接连接的，所以要想实现连接还得需要安装轻客户端：instantclient_11_2。instantclient_11_2的安装其实就是从官网下载一个压缩文件，解压到任意目录下然后配置即可。配置instant...",
    "content": "安装instantclient的原因在64位系统上安装64位的Oracle数据库，但是没有对应的64位PLSQL Developer，此时就不能使用PLSQL Developer来进行直接连接的，所以要想实现连接还得需要安装轻客户端：instantclient_11_2。instantclient_11_2的安装其实就是从官网下载一个压缩文件，解压到任意目录下然后配置即可。配置instantclient的步骤  将下载的instantclient_11_2压缩包解压到任意目录，如：D:\\app\\instantclient_11_2。  然后进入PLSQL的主界面（登陆时直接点取消按钮也是可以进入主界面的），点击工具–首选项，在如下界面做如下配置：    Oracle主目录名，即为你的instantclient的解压路径。  然后配置连接文件，在D:\\app\\instantclient_11_2目录下新建文件夹NETWORK，然后把Oracle安装目录下的D:\\app\\Administrator\\product\\11.2.0\\dbhome_2\\NETWORK目录下的整个ADMIN文件夹拷贝到D:\\app\\instantclient_11_2\\NETWORK目录下，或者新建目录NETWORK\\ADMIN和tnsnames.ora文件也可以，NETWORK\\ADMIN目录下的tnsnames.ora文件就是配置连接的文件。  经过如此配置后，PLSQL就能正常使用了。"
  },
  
  {
    "title": "PLSQL通过修改配置文件实现数据库连接",
    "url": "/posts/plsql-peizhi-lianjie/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "在Oracle的安装目录下查找tnsnames.ora文件，一般路径为：%ORACLE_HOME%\\network\\admin。打开tnsnames.ora，可以看到所有的数据库连接配置，介绍下配置格式：  只需要根据上一步介绍的格式修改IP或者端口号或者SID即可，总体不变，例如：test_database =  (DESCRIPTION =    (ADDRESS = (PROTOCOL...",
    "content": "在Oracle的安装目录下查找tnsnames.ora文件，一般路径为：%ORACLE_HOME%\\network\\admin。打开tnsnames.ora，可以看到所有的数据库连接配置，介绍下配置格式：  只需要根据上一步介绍的格式修改IP或者端口号或者SID即可，总体不变，例如：test_database =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = testdb)    )  )重新登陆PL/SQl，即会在database中有刚刚配置的数据库连接选项：  输入用户名密码，单击登录即可。"
  },
  
  {
    "title": "PLSQL连接数据库时报ORA-12560:TNS:协议适配器错误",
    "url": "/posts/ora-12560/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "造成ORA-12560:TNS:协议适配器错误的问题的原因有三个：  监听服务没有启起来。Windows平台可以如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleOraDb11g_home1TNSlistener服务。  database instance没有起起来。Windows平台如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleServiceBOOK...",
    "content": "造成ORA-12560:TNS:协议适配器错误的问题的原因有三个：  监听服务没有启起来。Windows平台可以如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleOraDb11g_home1TNSlistener服务。  database instance没有起起来。Windows平台如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleServiceBOOKSALES服务， BOOKSALES就是你的SID。　　　　  注册表问题。打开注册表，然后进入HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE\\HOME将该环境变量ORACLE_SID设置为XXXX，XXXX就是你的SID。或者右击我的电脑，属性–高级–环境变量—系统变量–新建，变量名=oracle_sid，变量值=XXXX，XXXX就是你的SID。或者进入sqlplus前，在命令行下输set oracle_sid=XXXX，XXXX就是你的SID。经过以上步骤，一般就可以解决问题。"
  },
  
  {
    "title": "MyBatis查询结果为NULL时报异常的解决方法",
    "url": "/posts/mybatis-chaxun-jieguo-weinull-shi-baoyichang/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "异常信息org.apache.ibatis.binding.BindingException: Mapper method 'com.XXXXX' attempted toreturn null from a method with a primitive return type (int).源代码&lt;select id=\"selectPageviews\" resultType=\"jav...",
    "content": "异常信息org.apache.ibatis.binding.BindingException: Mapper method 'com.XXXXX' attempted toreturn null from a method with a primitive return type (int).源代码&lt;select id=\"selectPageviews\" resultType=\"java.lang.Integer\" &gt;  select     sum(yc_hobby_pageviews)  from     SCOTT.yc_hobby_course  where    yc_hobby_course_user_id = #{yc_hobby_course_user_id}&lt;/select&gt;Oracle的解决方式select NVL(sum(yc_hobby_pageviews), 0) from ....MySQL的解决方式select IFFULL(sum(yc_hobby_pageviews), 0) from ....SQL Server的解决方式 select ISNULL(sum(yc_hobby_pageviews), 0) ...所有数据库适用select COALESCE(sum(yc_hobby_pageviews), 0) ..."
  },
  
  {
    "title": "Mybatis插入数据时返回主键",
    "url": "/posts/mybatis-charu-shuju-shi-fanhui-zhujian/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "方式一&lt;insert id=\"insertAndGetId\" useGeneratedKeys=\"true\" keyProperty=\"userId\"         parameterType=\"com.chenzhou.mybatis.User\"&gt;    insert into user(userName, password, comment)    values(#{use...",
    "content": "方式一&lt;insert id=\"insertAndGetId\" useGeneratedKeys=\"true\" keyProperty=\"userId\"         parameterType=\"com.chenzhou.mybatis.User\"&gt;    insert into user(userName, password, comment)    values(#{userName}, #{password}, #{comment})&lt;/insert&gt;User user = new User();  user.setUserName(\"ceshi\");  user.setPassword(\"123456\"); userDao.insertUser(user);System.out.println(\"插入后主键为：\" + user.getUserId());    useGeneratedKeys=\"true\"表示给主键设置自增长  keyProperty=\"userId\"表示将自增长后的id赋值给实体类中的userId字段  parameterType=\"com.chenzhou.mybatis.User\"这个属性指向传递的参数实体类  实体类中uerId要有getter()和setter()方法方式二&lt;insert id=\"insertProduct\" parameterType=\"domain.model.ProductBean\" &gt;    &lt;selectKey resultType=\"java.lang.Long\" order=\"AFTER\" keyProperty=\"productId\"&gt;      SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;      INSERT INTO t_product(productName, productDesrcible, merchantId)      values(#{productName}, #{productDesrcible}, #{merchantId})&lt;/insert&gt;  &lt;insert&gt;&lt;/insert&gt;中没有resultType属性，但是&lt;selectKey&gt;&lt;/selectKey&gt;标签是有的  order=\"AFTER\"表示先执行插入语句，之后再执行查询语句，可被设置为BEFORE或AFTER，如果设置为BEFORE，那么它会首先选择主键，设置keyProperty然后执行插入语句，如果设置为AFTER，那么先执行插入语句，然后是selectKey元素，这和如Oracle数据库相似，可以在插入语句中嵌入序列调用keyProperty=\"userId\"表示将自增长后的id赋值给实体类中的userId字段  SELECT LAST_INSERT_ID()表示MySQL语法中查询出刚刚插入的记录自增长id  实体类中uerId要有getter()和setter()方法"
  },
  
  {
    "title": "Jira 的一些查询",
    "url": "/posts/jira-de-yixie-chaxun/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "1. 查询Jira问题的固定或级联字段SELECT  jiraissue.*FROM  jiraissue,  OS_HISTORYSTEP,  customfieldvalue,  customfieldoptionWHERE  OS_HISTORYSTEP.ENTRY_ID = jiraissue.id  AND OS_HISTORYSTEP.ACTION_ID = &lt;action...",
    "content": "1. 查询Jira问题的固定或级联字段SELECT  jiraissue.*FROM  jiraissue,  OS_HISTORYSTEP,  customfieldvalue,  customfieldoptionWHERE  OS_HISTORYSTEP.ENTRY_ID = jiraissue.id  AND OS_HISTORYSTEP.ACTION_ID = &lt;action_id&gt;  AND OS_HISTORYSTEP.CALLER = &lt;user_name&gt;  AND customfieldvalue.issue = jiraissue.id  AND customfieldvalue.PARENTKEY = &lt;parent_key&gt;  AND customfieldvalue.stringvalue = customfieldoption.id  AND customfieldoption.customvalue like '&lt;cf_value&gt;';Where  &lt;user_name&gt; - the username of the desired user   &lt;action_id&gt; - the id of your transition into the fixed state (may need multiple)   &lt;parent_key&gt; - the id of the Level 1 option in customfieldoption - E.g.10040   &lt;cf_value&gt; - the Level 2 value of the cascading field.E.g 'realease%'2. 查一个问题的修复版本SELECT  projectversion.id,  vnameFROM  projectversion,  nodeassociation,  jiraissueWHERE  ASSOCIATION_TYPE = 'IssueFixVersion'  AND SINK_NODE_ID = projectversion.id  AND SOURCE_NODE_ID = jiraissue.id  AND pkey = '&lt;issue_key&gt;';WHERE  &lt;issue_key&gt; - the key of an issue.E.g.TEST -103. 查某个时间段更新过的所有问题SELECT  DISTINCT(j.id)FROM  jiraissue j,  changegroup gWHERE  j.id = g.issueid  AND g.author = '&lt;user name&gt;'  AND g.created &gt; '&lt;date&gt;';Where  &lt;date&gt; - the earliest desired date (The date should be in the          - format 'yyyy-mm-dd hh:mm:s'.E.g '2005-10-06 14:40:28')   &lt;username&gt; - the name of the desired user4. 查找一个项目的某个时间的所有问题的状态SELECT  JI.pkey,  STEP.STEP_IDFROM  (    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_CURRENTSTEP    WHERE      OS_CURRENTSTEP.START_DATE &lt; '&lt;your date&gt;'    UNION    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_HISTORYSTEP    WHERE      OS_HISTORYSTEP.START_DATE &lt; '&lt;your date&gt;'      AND OS_HISTORYSTEP.FINISH_DATE &gt; '&lt;your date&gt;'  ) As STEP,  (    SELECT      changeitem.OLDVALUE AS VAL,      changegroup.ISSUEID AS ISSID    FROM      changegroup,      changeitem    WHERE      changeitem.FIELD = 'Workflow'      AND changeitem.GROUPID = changegroup.ID    UNION    SELECT      jiraissue.WORKFLOW_ID AS VAL,      jiraissue.id as ISSID    FROM      jiraissue  ) As VALID,  jiraissue as JIWHERE  STEP.ENTRY_ID = VALID.VAL  AND VALID.ISSID = JI.id  AND JI.project = &lt;proj_id&gt;;Where  &lt;your date&gt; - is the date you want to check   &lt;proj_id&gt; - is the project you want to check5. 查某个项目所有状态的数量SELECT  count(*),  STEP.STEP_IDFROM  (    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_CURRENTSTEP    WHERE      OS_CURRENTSTEP.START_DATE &lt; '&lt;your date&gt;'    UNION    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_HISTORYSTEP    WHERE      OS_HISTORYSTEP.START_DATE &lt; '&lt;your date&gt;'      AND OS_HISTORYSTEP.FINISH_DATE &gt; '&lt;your date&gt;'  ) As STEP,  (    SELECT      changeitem.OLDVALUE AS VAL,      changegroup.ISSUEID AS ISSID    FROM      changegroup,      changeitem    WHERE      changeitem.FIELD = 'Workflow'      AND changeitem.GROUPID = changegroup.ID    UNION    SELECT      jiraissue.WORKFLOW_ID AS VAL,      jiraissue.id as ISSID    FROM      jiraissue  ) As VALID,  jiraissue as JIWHERE  STEP.ENTRY_ID = VALID.VAL  AND VALID.ISSID = JI.id  AND JI.project = &lt;proj_id&gt;Group By  STEP.STEP_ID;Where  &lt;your date&gt; - is the date you want to check   &lt;proj_id&gt; - is the project you want to check6. 查询有多少问题被改变了状态SELECT  NEWSTRING AS Status,  count(*) AS NumberFROM  changeitem,  changegroup,  jiraissueWHERE  changeitem.field = 'Status'  AND changeitem.groupid = changegroup.id  AND changegroup.issueid = jiraissue.id  AND jiraissue.project = &lt;project_id&gt;  AND changegroup.CREATED &gt;= '&lt;date_from&gt;'  AND changegroup.CREATED &lt; '&lt;date_to&gt;'Group By  NEWSTRINGUNIONSELECT  'Created' As Status,  count(*) AS NumberFROM  jiraissueWHERE  jiraissue.CREATED &gt;= '&lt;date_from&gt;'  AND jiraissue.CREATED &lt; '&lt;date_to&gt;'  AND jiraissue.project = &lt;project_id&gt;;Where  &lt;date_from&gt; - is the date you want to checkfrom  &lt;date_to&gt; - is the date you want to check to   &lt;project_id&gt; - is the project you want to check7. 获得一个问题的所有组件 SELECT  jiraissue.pkey,  component.cnameFROM  nodeassociation,  component,  jiraissueWHERE  component.ID = nodeassociation.SINK_NODE_ID  AND jiraissue.id = nodeassociation.SOURCE_NODE_ID  AND nodeassociation.ASSOCIATION_TYPE = 'IssueComponent'  AND pkey = '&lt;issue_key&gt;';8. 查找已经关闭的问题SELECT  pKey,  OS_CURRENTSTEP.STATUS,  OS_CURRENTSTEP.START_DATEFROM  jiraissue,  OS_CURRENTSTEPWHERE  issuestatus = 6  AND OS_CURRENTSTEP.ENTRY_ID = jiraissue.WORKFLOW_ID;9. 简单的连接SELECT * FROM jiraissue LEFT JOIN jiraaction ON jiraissue.id = jiraaction.issueid;SELECT * FROM jiraissue LEFT JOIN changegroup ON jiraissue.id = changegroup.issueid;SELECT * FROM changegroup LEFT JOIN changeitem ON changegroup.id = changeitem.groupid;SELECT * FROM jiraissue LEFT JOIN OS_CURRENTSTEP ON jiraissue.WORKFLOW_ID = OS_CURRENTSTEP.ENTRY_ID;SELECT * FROM jiraissue LEFT JOIN OS_HISTORYSTEP ON jiraissue.WORKFLOW_ID = OS_HISTORYSTEP.ENTRY_ID; 10. 返回所有项目问题SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  ji.pkey AS issue_id,  ji.reporter AS issue_reporter,  pri.pname AS issue_priority,  ist.pname AS issue_status,  ji.summary AS issue_summaryFROM  project p  LEFT OUTER JOIN jiraissue ji ON ji.project = p.id  LEFT OUTER JOIN priority pri ON ji.priority = pri.id  LEFT OUTER JOIN issuestatus ist ON ji.issuestatus = ist.idWHERE  p.pname = '&lt;project_name&gt;'ORDER BY  ji.pkey;11. 查询项目的所有版本SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  pv.vname AS version_name,  pv.description AS version_desc,  pv.sequence AS version_seq,  pv.released AS version_released,  pv.archived AS version_archived,  pv.url AS version_url,  pv.releasedate AS version_release_dateFROM  project p  LEFT OUTER JOIN projectversion pv ON pv.project = p.idWHERE  p.pname = '&lt;project_name&gt;'ORDER BY  pv.sequence;12. 返回项目的所有用户SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  prc.roletypeparameter AS project_rolesFROM  project p  LEFT OUTER JOIN projectroleactor prc ON prc.pid = p.idWHERE  p.pname = '&lt;project_name&gt;';13. 返回项目工作流SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  ws.name AS project_associated_workflow_scheme,  wse.workflow AS workflow_scheme_associated_workflow,  jw.descriptor AS workflow_descriptorFROM  project p  LEFT OUTER JOIN nodeassociation na ON na.source_node_id = p.id  AND na.sink_node_entity = 'WorkflowScheme'  LEFT OUTER JOIN workflowscheme ws ON ws.id = na.sink_node_id  LEFT OUTER JOIN workflowschemeentity wse ON wse.scheme = ws.id  LEFT OUTER JOIN jiraworkflows jw ON jw.workflowname = wse.workflowWHERE  p.pname = '&lt;project_name&gt;';14. 查询问题各个字段的显示模式SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  itss.name AS project_issue_type_screen_scheme,  fss.name AS screen_scheme_of_the_issue_type_screen_scheme,  fs.name AS screen_name_of_the_screen_scheme,  fst.name AS screen_tab_name,  fsli.fieldidentifier AS tab_field,  fsli.sequence AS tab_field_seqFROM  project p  LEFT OUTER JOIN nodeassociation na ON na.source_node_id = p.id  AND na.sink_node_entity = 'IssueTypeScreenScheme'  LEFT OUTER JOIN issuetypescreenscheme itss ON itss.id = na.sink_node_id  LEFT OUTER JOIN issuetypescreenschemeentity itsse ON itsse.scheme = itss.id  LEFT OUTER JOIN fieldscreenscheme fss ON itsse.fieldscreenscheme = fss.id  LEFT OUTER JOIN fieldscreenschemeitem fssi ON fss.id = fssi.fieldscreenscheme  LEFT OUTER JOIN fieldscreen fs ON fssi.fieldscreen = fs.id  LEFT OUTER JOIN fieldscreentab fst ON fs.id = fst.fieldscreen  LEFT OUTER JOIN fieldscreenlayoutitem fsli ON fst.id = fsli.fieldscreentabWHERE  p.pname = 'fengdi'ORDER BY  fsli.sequence;15. 查看一个问题的fix—for versionsselect  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueFixVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );16. 查看一个问提的影响版本select  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );17. 查看一个问题的所属模块select  *from  componentwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueComponent'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );18. 查看两个项目之间的超链接select  *from  issuelinkwhere  SOURCE =(    select      id    from      jiraissue    where      pkey = 'TP-1'  )  and DESTINATION =(    select      id    from      jiraissue    where      pkey = 'TP-2'  );19. 查看两个项目间的链接类型select  j1.pkey,  issuelinktype.INWARD,  j2.pkeyfrom  jiraissue j1,  issuelink,  issuelinktype,  jiraissue j2where  j1.id = issuelink.SOURCE  and j2.id = issuelink.DESTINATION  and issuelinktype.id = issuelink.linktype;20. 查看某个项目下的所有自定义字段select  *from  customfieldvaluewhere  issue =(    select      id    from      jiraissue    where      pkey = 'JRA-5448'  );21. 查看某个自定义字段的详细信息select * from customfield where id = 10190; 22. 查看自定义字段在某个项目的值select  stringvaluefrom  customfieldvaluewhere  customfield =(    select      id    from      customfield    where      cfname = 'Urgency'  )  and issue =(    select      id    from      jiraissue    where      pkey = 'FOR-845'  );23. 查看有多个值的自定义字段值select  stringvaluefrom  customfieldvaluewhere  customfield =(    select      id    from      customfield    where      cfname = 'Urgency'  )  and issue =(    select      id    from      jiraissue    where      pkey = 'FOR-845'  );24. 查看自定义字段的可选值select * from customfieldoption where customfieldconfig = 10031;25. 查看自定义字段的默认值select * from genericconfiguration where ID = 10031;26. 查看改动记录changegroup 和 changeItem27. 查看表的最大使用id-- 每次申请100，对应的名字配置在entitymodel.xmlselect * from SEQUENCE_VALUE_ITEM;28. 工作日志表worklog29. 用户和用户组表cwd_user, cwd_group, cwd_membership30. 用户权限表cwd_directory_operation31. 用户详细和自定义信息cwd_directory_attribute32. 关注和投票相关表userassociation33. 状态和工作流，查看问题的状态select issuestatus from jiraissue where pkey = 'TP-1';34. 状态定义表issuestatusselect pname from issuestatus, jiraissue where issuestatus.id = jiraissue.issuestatus and pkey = 'TP-1';35. 工作流名字和id对应表OS_WFENTRY 36. 查看所有问题的工作流跳转select  issuestatus.pname status,  issuestatus,  OS_CURRENTSTEP.STEP_ID,  OS_CURRENTSTEP.STATUSfrom  issuestatus,  jiraissue,  OS_CURRENTSTEPwhere  issuestatus.id = jiraissue.issuestatus  and jiraissue.workflow_id = OS_CURRENTSTEP.ENTRY_ID;37. 查询某个issue影响到的项目版本select  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );38. 查询某个issue解决的项目版本select  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueFixVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );39. 查询某个issue所在的项目模块select  *from  componentwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueComponent'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );40. 查询issue状态转换的详情select  cu.display_name,  cu.user_name,  cg.created,  dbms_lob.substr(ci.oldstring, 4000),  dbms_lob.substr(ci.newstring, 4000),  ji.issuetype,  p.pkey || '-' || ji.issuenum,  ji.summary,  p.pnamefrom  changeitem ci  left join changegroup cg on ci.groupid = cg.id  left join jiraissue ji on ji.id = cg.issueid  left join project p on p.id = ji.project  left join app_user au on au.user_key = cg.author  left join cwd_user cu on cu.lower_user_name = au.lower_user_namewhere  p.pname = '&lt;projectName&gt;'  and ji.id = '&lt;issueId&gt;'  and ci.field = 'status'"
  },
  
  {
    "title": "Jira 7.8的安装和配置",
    "url": "/posts/jira-de-anzhuang-he-peizhi/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "一、安装前准备Jira的运行是依赖Java环境的，也就是说需要安装JDK并且要是1.8以上版本，除此之外，我们还需要安装MySQL，为Jira创建对应的数据库，注意建库字符集为UTF-8，以上环境准备完毕后，我们现在开始下载并安装Jira。二、下载Jira到Jira官方下载网站下载和系统匹配的版本，或者使用Linux命令下载：wget  https://downloads.atlassian...",
    "content": "一、安装前准备Jira的运行是依赖Java环境的，也就是说需要安装JDK并且要是1.8以上版本，除此之外，我们还需要安装MySQL，为Jira创建对应的数据库，注意建库字符集为UTF-8，以上环境准备完毕后，我们现在开始下载并安装Jira。二、下载Jira到Jira官方下载网站下载和系统匹配的版本，或者使用Linux命令下载：wget  https://downloads.atlassian.com/software/jira/downloads/atlassian-jira-software-7.8.1-x64.bin。三、破解Jira使用./atlassian-jira-software-7.8.1-x64.bin命令开始Jira的安装流程，通过终端输出的信息，我们可以很明显的看出Jira安装到了/opt/atlassian/jira和/var/atlassian/application-data/jira目录下，并且Jira监听的端口是8080。Jira的主要配置文件，存放在/opt/atlassian/jira/conf/server.xml文件中。把破解包里面的atlassian-extras-3.2.jar和mysql-connector-java-5.1.39-bin.jar两个文件复制到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下。其中atlassian-extras-3.2.jar是用来替换原来的atlassian-extras-3.2.jar文件，用作破解Jira系统的。而mysql-connector-java-5.1.39-bin.jar是用来连接MySQL数据库的驱动软件包。然后使用./start-jira.sh命令启动Jira。四、配置Jira在浏览器中输入http://localhost:8080，打开Jira的安装界面。配置数据库连接。填写好后测试连接一下看看是否成功，在下一步。连接数据库的配置文件是/var/atlassian/application-data/jira/dbconfig.xml下面的配置就比较简单了，自定义也可以，默认也可以。注意：上图中的模式中，我们在此使用的是Private（私有）模式，在这个模式下，用户的创建需要由管理员创建。而在Public（共用）模式下，用户是可以自己进行注册。下面这个页面是需要我们输入Jira的License，如下： 注意：上图中的Server ID：BSG9-24QF-8M40-O1CT，因为我们没有正式的License，所以需要我们在Jira官网注册一个账号，然后利用这个账号申请一个可以试用30天的License，点击生成Jira许可证。如下： 将生成的License复制过来。设置管理员账号。设置邮件通知。设置语言。安装完成。到此Jira 7.8的安装就好了，现在看看Jira的破解，其实我们在前面复制atlassian-extras-3.1.2.jar到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下时，再次启动Jira时就已经破解了，我们现在登陆到Jira中查看授权信息，如下：如何修改内存vim /opt/atlassian/jira/bin/setenv.sh日志查看tail -f /opt/atlassian/jira/logs/catalina.out修改Jira Home的位置vim /usr/local/jira/atlassian-jira/WEB-INF/classes/jira-application.properties"
  },
  
  {
    "title": "局域网SVN服务器的搭建",
    "url": "/posts/juyuwang-svn-fuwuqi-de-dajian/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2021-01-12 13:47:00 +0800",
    





    
    "snippet": "安装VisualSVN Server在standard edition设置”安装目录”和”存放目录”还有”端口”，端口一下要记住打开VisualSVN Server添加用户在VisualSVN Server添加项目”t”现在用TortoiseSVN试试能不能连接SVN服务器。建个文件夹”t2015”，右击选择”SVN Checkout”，输入用户名和密码",
    "content": "安装VisualSVN Server在standard edition设置”安装目录”和”存放目录”还有”端口”，端口一下要记住打开VisualSVN Server添加用户在VisualSVN Server添加项目”t”现在用TortoiseSVN试试能不能连接SVN服务器。建个文件夹”t2015”，右击选择”SVN Checkout”，输入用户名和密码"
  },
  
  {
    "title": "Linux nohup命令",
    "url": "/posts/linux-nohup-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-01-12 13:47:00 +0800",
    





    
    "snippet": "Linux下有时候我们希望某个程序可以一直在后台执行，很多都是使用&amp;在程序命令结尾来让程序自动运行。[root@lbogon roy]# ./test.sh &amp; 但是这样在终端关闭的时候，程序也会随之停止，此时我们可以使用nohup命令。[root@lbogon roy]# nohup ./test.sh &amp; 这样的话终端关闭后程序不会停止，但是如果程序执行过程中报错...",
    "content": "Linux下有时候我们希望某个程序可以一直在后台执行，很多都是使用&amp;在程序命令结尾来让程序自动运行。[root@lbogon roy]# ./test.sh &amp; 但是这样在终端关闭的时候，程序也会随之停止，此时我们可以使用nohup命令。[root@lbogon roy]# nohup ./test.sh &amp; 这样的话终端关闭后程序不会停止，但是如果程序执行过程中报错，出现了logout，程序也会随之终止。所以如果我们希望程序可以一直在后台运行，无论是否报错，可以使用下面这个命令。[root@lbogon roy]# nohup ./test.sh &gt;output.log 2&gt;&amp;1 &amp;上条命令中&gt;output.log是将输出写入到output.log文件中，2&gt;&amp;1意思是把标准错误（2）重定向到标准输出中（1），即标准输出以及错误输出都在output.log文件中，程序执行出现错误也不会终止。"
  },
  
  {
    "title": "Linux mv命令",
    "url": "/posts/linux-mv-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-01-12 13:47:00 +0800",
    





    
    "snippet": "作用重命名、覆盖或移动文件。参数mv [options] existing-file new-filenamemv [options] existing-file-list directorymv [options] existing-directory new-directory  第一种形式：  existing-file是需要重命名的文件路径；  new-filename是文件的新路径...",
    "content": "作用重命名、覆盖或移动文件。参数mv [options] existing-file new-filenamemv [options] existing-file-list directorymv [options] existing-directory new-directory  第一种形式：  existing-file是需要重命名的文件路径；  new-filename是文件的新路径名，用于重命名或覆盖。  第二种形式：  existing-file是需要移动的文件路径列表；  directory是文件需要移动到的新目录，用于移动。  第三种形式：  existing-file是需要重命名的目录路径；  new-directory是目录的新路径名，用于重命名或覆盖。选项-b  如果已存在相同文件名，则覆盖前进行备份-f  如果已存在相同文件名，而用户不具有写的权限，则强制覆盖-i  如果已存在相同文件名，覆盖前提示用户进行确认-u  比较原文件与目标文件修改时间，如果目标文件较新则不覆盖-v  列出所有被移动或重命名的文件示例      重命名      $ mv demo1.txt demo2.txt    # 重命名文件            对已存在的文件覆盖前进行确认，y或Y开头的字符串表示确定，其余任意字符表示否定      $ mv demo2.txt -i demo.txt    # 是否覆盖\"demo.txt\"？ y            移动目录，此处将cde目录移动到abc目录中      $ mv cde abc            重命名目录，此处将abc目录重命名为dir目录      $ mv abc dir            mv -u，确认修改时间再判断是否覆盖，此处time2.txt的修改时间比time1.txt的修改时间新，所以覆盖失败      $ mv time1.txt -u time2.txt            mv -v，列出移动或覆盖时的信息      $ mv time1.txt -v time2.txt             mv -b，覆盖时进行备份，所备份的文件尾部有个～      $ mv -b aa.txt bb.txt      Tips  在Linux中，覆盖和重命名的概念几乎是一样的，没有Windows中所谓的rename这一说法。  选项可以写在任意位置，可以mv aa -v bb，也可以mv -v aa bb，还可以mv aa bb -v。"
  },
  
  {
    "title": "Spring Boot读取properties配置文件中的数据",
    "url": "/posts/springboot-duqu-peizhi-wnejian-de-shuju/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2021-01-11 13:47:00 +0800",
    





    
    "snippet": "一、使用@Value注解读取读取properties配置文件时，默认读取的是application.properties。application.properties：demo.name = Namedemo.age = 18Java：import org.springframework.beans.factory.annotation.Value;import org.springfram...",
    "content": "一、使用@Value注解读取读取properties配置文件时，默认读取的是application.properties。application.properties：demo.name = Namedemo.age = 18Java：import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Value(\"${demo.name}\")    private String name;    @Value(\"${demo.age}\")    private String age;    @RequestMapping(value = \"/gateway\")    public String gateway() {        //1、使用@Value注解读取        return \"get properties value by ''@Value'' :\" +            \" name=\" + name +            \" , age=\" + age;    }}这里，如果要把@Value(\"${demo.name}\")private String name;@Value(\"${demo.age}\")private String age;部分放到一个单独的类A中进行读取，然后在类B中调用，则要把类A增加@Component注解，并在类B中使用@Autowired自动装配类A，代码如下：类A：import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class ConfigBeanValue {    @Value(\"${demo.name}\")    public String name;    @Value(\"${demo.age}\")    public String age;}类B：import cn.wbnull.springbootdemo.config.ConfigBeanValue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Autowired    private ConfigBeanValue configBeanValue;    @RequestMapping(value = \"/gateway\")    public String gateway() {        //1、使用@Value注解读取        return \"get properties value by ''@Value'' :\" +            \" name=\" + configBeanValue.name +            \" , age=\" + configBeanValue.age;    }}二、使用Environment读取application.properties：demo.sex = 男demo.address = 山东Java：import cn.wbnull.springbootdemo.config.ConfigBeanValue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Autowired    private ConfigBeanValue configBeanValue;    @Autowired    private Environment environment;    @RequestMapping(value = \"/gateway\")    public String gateway() {        return \"get properties value by ''@Value'' :\" +            //1、使用@Value注解读取            \" name=\" + configBeanValue.name +            \" , age=\" + configBeanValue.age +            \"&lt;p&gt;get properties value by ''Environment'' :\" +            //2、使用Environment读取            \" , sex=\" + environment.getProperty(\"demo.sex\") +            \" , address=\" + environment.getProperty(\"demo.address\");    }}运行时如果发现中文乱码，我们在application.properties做如下配置：server.tomcat.uri-encoding = UTF-8spring.http.encoding.charset = UTF-8spring.http.encoding.enabled = truespring.http.encoding.force = truespring.messages.encoding = UTF-8三、使用@ConfigurationProperties注解读取在实际项目中，当项目需要注入的变量值很多时，上述所述的两种方法工作量会变得比较大，这时候我们通常使用基于类型安全的配置方式，将properties属性和一个Bean关联在一起，即使用注解@ConfigurationProperties读取配置文件数据。在src\\main\\resources下新建config.properties配置文件：demo.phone = 10086demo.wife = self创建ConfigBeanProp并注入config.properties中的值：import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = \"demo\")@PropertySource(value = \"config.properties\")public class ConfigBeanProp {    private String phone;    private String wife;    public String getPhone() {        return phone;    }    public void setPhone(String phone) {        this.phone = phone;    }    public String getWife() {        return wife;    }    public void setWife(String wife) {        this.wife = wife;    }}@Component表示将该类标识为Bean。@ConfigurationProperties(prefix = \"demo\")用于绑定属性，其中prefix表示所绑定的属性的前缀。@PropertySource(value = \"config.properties\")表示配置文件路径。使用时，先使用@Autowired自动装载ConfigBeanProp，然后再进行取值，示例如下：import cn.wbnull.springbootdemo.config.ConfigBeanProp;import cn.wbnull.springbootdemo.config.ConfigBeanValue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Autowired    private ConfigBeanValue configBeanValue;    @Autowired    private Environment environment;    @Autowired    private ConfigBeanProp configBeanProp;    @RequestMapping(value = \"/gateway\")    public String gateway() {        return \"get properties value by ''@Value'' :\" +            //1、使用@Value注解读取            \" name=\" + configBeanValue.name +            \" , age=\" + configBeanValue.age +            \"&lt;p&gt;get properties value by ''Environment'' :\" +            //2、使用Environment读取            \" sex=\" + environment.getProperty(\"demo.sex\") +            \" , address=\" + environment.getProperty(\"demo.address\") +            \"&lt;p&gt;get properties value by ''@ConfigurationProperties'' :\" +            //3、使用@ConfigurationProperties注解读取            \" phone=\" + configBeanProp.getPhone() +            \" , wife=\" + configBeanProp.getWife();    }}"
  },
  
  {
    "title": "JSTL标签的用法",
    "url": "/posts/jstl-biaoqian-de-yongfa/",
    "categories": "Knowledge, JSTL",
    "tags": "JSTL",
    "date": "2021-01-11 13:47:00 +0800",
    





    
    "snippet": "JSP标准标记库（Standard Tag Library，JSTL）是一组以标准化格式实现许多通用的Web站点功能的定制标记。除了核心JSP标记，如jsp:include之外，定制标记库工具使您能够创建唯一的标记来描述以站点或应用程序为导向的操作。一旦您创建了定制标记库（简称taglib），当您扩展项目或转向另一个项目时您可以重复使用这些标记。您还可以将 taglib传递给其它开发人员，从...",
    "content": "JSP标准标记库（Standard Tag Library，JSTL）是一组以标准化格式实现许多通用的Web站点功能的定制标记。除了核心JSP标记，如jsp:include之外，定制标记库工具使您能够创建唯一的标记来描述以站点或应用程序为导向的操作。一旦您创建了定制标记库（简称taglib），当您扩展项目或转向另一个项目时您可以重复使用这些标记。您还可以将 taglib传递给其它开发人员，从而他们可以在自己的网站上使用，或者在您Web应用程序的其它部分使用。JSTL的目标是为了简化JSP页面的设计。对于页面设计人员来说，使用脚本语言（默认值是Java语言）操作动态数据是比较困难的，而采用标签和表达式语言相对容易一些，JSTL的使用为页面设计人员和程序开发人员的分工协作提供了便利。一、配置JSTL包括两个jar文件， jstl.jar和standard.jar。原文引入：&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;       二、core标签库core标签库主要包括了一般用途的标签、条件标签、迭代标签和URL相关的标签。在JSP页面使用core标签要使用taglig指令，指定引用的标签库，如下：&lt;%@ taglib rui=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;一般用途的标签有：&lt;c:out&gt;、&lt;c:set&gt;、&lt;c:remove&gt;、&lt;c:cath&gt;条件标签包括：&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c:when&gt;、&lt;c:otherwise&gt;迭代标签有：&lt;c:forEach&gt;2.1 &lt; c:out&gt;用于计算一个表达式并将结果输出。类似于JSP中&lt;%=%&gt;表达式，或者是EL中${el-expression}。2.2 &lt; c:set&gt;用于设置范围变量的值或者javabean对象的属性。看个实际例子：&lt;c:set var=\"username\" value=\"lisi\" scope=\"session\"/&gt;这样就相当于设置了session 。2.3 &lt; c:remove&gt;相对&lt;c:set&gt;其作用是移除范围变量。比如： &lt;c:remove var=\"nusername\" scope=\"session\"/&gt;2.4 &lt; c:catch&gt;用于捕获在其中嵌套的操作所抛出的异常对象，并将异常信息保存到变量中。我们将有可能抛出异常的代码放置到开始标签&lt;c:catch&gt;和结束标签&lt;/c:catch&gt;之间。如果其中代码出现异常，异常对象将被捕获，保存在var声明的变量中，该变量有page范围。如果没有发生异常，而var所标识的范围变量将被移除。如果没有指定var属性，异常只是简单的被捕获，异常信息并不会被保存。如下：&lt;c:catch var=\"exception\"&gt;&lt;%    int i = 5;    int j = 0;    int k=i/j;%&gt;&lt;/c:catch&gt;&lt;c:out value=\"${exception}\"/&gt;&lt;br&gt;&lt;c:out value=\"${exception.massage}\"/&gt;后一句相当于exception.getMessage()。2.5 &lt; c:if&gt;用于实现Java中的if语句功能。语法：&lt;c:if test=\"逻辑表达式\"         var=\"代表逻辑表达式的值的命名变量的名字\"         scope=\"{page|request|session|application}\" / &gt; 标签会把逻辑表达式的值存放在var属性指定的命名变量中，scope属性则指定命名变量的范围，scope属性的默认值是page（页面范围）。例如以下标签先判断username请求参数的值是否为Tom，然后把判断结果作为result命名变量存放在请求范围内：&lt;c:if test=\"${param.username=='Tom'}\"  var=\"result\" scope=\"request\" /&gt; ${result} 以上标签等价于以下Java程序片段：&lt;%      String username = request.getParameter(\"username\");      if(username!=null &amp;&amp; username.equals(\"Tom\")) {        request.setAttribute(\"result\", true);      } else {        request.setAttribute(\"result\", false);      }%&gt; 2.6 &lt; c:choose&gt;&lt;c:choose&gt;和&lt;c:when&gt;、&lt;c:otherwise&gt;一起实现互斥条件执行，类似于Java中的if else。&lt;c:choose&gt;一般作为&lt;c:when&gt;、&lt;c:otherwise&gt;的父标签。比如：&lt;c:choose&gt;    &lt;c:when test=\"${row.v_money&lt;10000}\"&gt;        初学下海    &lt;/c:when&gt;    &lt;c:when test=\"${row.v_money&gt;=10000&amp;&amp;row.v_money&lt;20000}\"&gt;        身手小试    &lt;/c:when&gt;    &lt;c:otherwise&gt;        商业能手    &lt;/c:otherwise&gt;&lt;/c:choose&gt;2.7 &lt; c:forEach&gt;遍历记录集&lt;c:forEach items=\"${finalResult.rows}\" var=\"row\"&gt;           &lt;tr class=\"&lt;%=tdClass[(rank+1)%2]%&gt;\"&gt;        &lt;td align=\"center\"&gt;&lt;span&gt;&lt;%=rank%&gt;&lt;/span&gt;&lt;/td&gt;        &lt;td align=\"center\"&gt;&lt;span&gt;&lt;c:out value=\"${row.player_name}\"/&gt;&lt;/span&gt;&lt;/td&gt;        &lt;td align=\"center\"&gt;&lt;span&gt;￥&lt;c:out value=\"${row.money}\"/&gt;&lt;/span&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;%rank++;%&gt;     &lt;/c:forEach&gt;也可以设定固定次数&lt;c:forEach var =\"i\" begin=\"100\" end=\"110\"&gt;    ${i}&lt;/c:forEach&gt;如果再加个step=\"2\"那么每次增长为2。三、fmt标签库&lt;fmt:formatNumber value=\"12.3\" pattern=\".000\" /&gt;将输出12.300，应用样式”.000”将使格式化后的小数部分有3位。不足3位将以0补齐。&lt;fmt:formatDate value=\"&lt;%=new java.util.Date() %&gt;\" type=\"date\" /&gt;格式化的结果是：2007-5-27。&lt;fmt:formatDate value=\"&lt;%=new java.util.Date() %&gt;\" type=\"time\" /&gt;格式化的结果是：9:25:11。&lt;fmt:formatDate value=\"&lt;%=new java.util.Date() %&gt;\" type=\"both\" /&gt;格式化的结果是：2007-5-27 9:25:11。"
  },
  
  {
    "title": "给GitHub主页添加统计图",
    "url": "/posts/gei-github-zhuye-tianjia-tongjimianban/",
    "categories": "Knowledge, GitHub",
    "tags": "GitHub",
    "date": "2021-01-11 13:47:00 +0800",
    





    
    "snippet": "本文添加的统计图来源于这个仓库https://github.com/anuraghazra/github-readme-stats创建仓库登录你的Github帐号，然后创建一个与你的用户名同名的仓库。注意事项：  仓库名与用户名必须一样；  仓库必须公开；  仓库里需要有一个README文件；修改README的内容以下是我的配置：&lt;img align=\"right\" src=\"http...",
    "content": "本文添加的统计图来源于这个仓库https://github.com/anuraghazra/github-readme-stats创建仓库登录你的Github帐号，然后创建一个与你的用户名同名的仓库。注意事项：  仓库名与用户名必须一样；  仓库必须公开；  仓库里需要有一个README文件；修改README的内容以下是我的配置：&lt;img align=\"right\" src=\"https://github-readme-stats.vercel.app/api?username=soupk&amp;show_icons=true&amp;icon_color=27c968&amp;text_color=d4f4e1&amp;bg_color=333333&amp;hide_title=false&amp;hide_border=true&amp;title_color=ffffff&amp;include_all_commits=true\" /&gt;### Hello World 👋- :octocat:  New to GitHub- :dart:   Stick to the goal- :bird:  A green hand- :ledger:   My notebook效果如下："
  },
  
  {
    "title": "为Jekyll添加功能",
    "url": "/posts/wei-jekyll-tianjia-gongneng/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2021-01-11 00:34:00 +0800",
    





    
    "snippet": "Jekyll本身插件的安装一共3种方式:  在根目录下新建_plugins文件夹, 然后把对应的*.rb插件文件放进去即可;  在_config.yml文件中增加一个gems关键字, 然后把要引用的插件用数组形式存储其中即可;  在Gemfile中添加相关的插件;使用kramdown自动生成目录树启用kramdown，即在_config.yml中添加markdown: kramdown这一行...",
    "content": "Jekyll本身插件的安装一共3种方式:  在根目录下新建_plugins文件夹, 然后把对应的*.rb插件文件放进去即可;  在_config.yml文件中增加一个gems关键字, 然后把要引用的插件用数组形式存储其中即可;  在Gemfile中添加相关的插件;使用kramdown自动生成目录树启用kramdown，即在_config.yml中添加markdown: kramdown这一行，然后在md文章中需要插入目录的地方添加：* 目录{:toc}添加中英文字数统计      英文字数统计    jekyll中有内置的英文字数统计方法number_of_words，直接在需要显示的文章中添加代码    // 注意：以下代码显示出来的只是字数，需要加一些文字说明\\{\\{ page.content | number_of_words \\}\\}// 使用时去掉\\            中文字数统计    添加代码    // 操作同上\\{\\{ content | strip_html | strip_newlines | split: \"\" | size \\}\\}// 使用时去掉\\      "
  },
  
  {
    "title": "给Jekyll博客添加访问量统计",
    "url": "/posts/wei-jekyll-boke-tianjia-fangwenliang-tongji/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2021-01-11 00:34:00 +0800",
    





    
    "snippet": "给Jekyll博客添加访问量统计需要使用不蒜子插件，在需要统计浏览量的页面引入busuanzi.js：&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;添加站点的访问量：      pv的方式      &lt;!-- 单个用户连续点击n篇文章，...",
    "content": "给Jekyll博客添加访问量统计需要使用不蒜子插件，在需要统计浏览量的页面引入busuanzi.js：&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;添加站点的访问量：      pv的方式      &lt;!-- 单个用户连续点击n篇文章，记录n次访问量 --&gt;  &lt;span id=\"busuanzi_container_site_pv\"&gt;      本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次  &lt;/span&gt;            uv的方式      &lt;!-- 单个用户连续点击n篇文章，只记录1次访客数 --&gt;  &lt;span id=\"busuanzi_container_site_uv\"&gt;      本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次  &lt;/span&gt;      添加单页访问量：      pv的方式      &lt;!-- 单个用户点击1篇文章，本篇文章记录1次阅读量 --&gt;  &lt;span id=\"busuanzi_container_page_pv\"&gt;  本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次  &lt;/span&gt;      "
  },
  
  {
    "title": "Git获取文件commit的日期",
    "url": "/posts/git-huoqu-wenjian-de-commit-riqi/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-01-09 13:47:00 +0800",
    





    
    "snippet": "git log -1 --pretty=%ad --date=iso test.html",
    "content": "git log -1 --pretty=%ad --date=iso test.html"
  },
  
  {
    "title": "一些好看的头像",
    "url": "/posts/yixie-haokan-de-touxiang/",
    "categories": "Design, Picture",
    "tags": "Picture",
    "date": "2021-01-06 13:47:00 +0800",
    





    
    "snippet": "这些好看的头像是我在这个网址发现的：https://mobile.zcool.com.cn/work/ZMTQwNzQ4MjQ=.html，是叫土星浮游的一位插画师的作品，收藏了   ",
    "content": "这些好看的头像是我在这个网址发现的：https://mobile.zcool.com.cn/work/ZMTQwNzQ4MjQ=.html，是叫土星浮游的一位插画师的作品，收藏了   "
  },
  
  {
    "title": "String、Date、Timestamp之间的转换",
    "url": "/posts/string-date-timestamp-zhijian-de-huzhuan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-05 11:47:00 +0800",
    





    
    "snippet": "一、String与Date互转1.1 String转Datepublic static void main(String[] args) {    // 注意format的格式要与日期String的格式相匹配     DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");    String dateStr = \"2010/...",
    "content": "一、String与Date互转1.1 String转Datepublic static void main(String[] args) {    // 注意format的格式要与日期String的格式相匹配     DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");    String dateStr = \"2010/05/04 12:34:23\";    Date date = new Date();    try {        date = sdf.parse(dateStr);        System.out.println(date.toString());    } catch (Exception e) {        e.printStackTrace();    }}1.2 Date转Stringpublic static void main(String[] args) {    //format的格式可以任意      DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");      DateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH/mm/ss\");      Date date = new Date();      try {          System.out.println(sdf.format(date));          System.out.println(sdf2.format(date));      } catch (Exception e) {          e.printStackTrace();      }  }二、String与Timestamp互转2.1 String转Timestamppublic static void main(String[] args) {    Timestamp ts = new Timestamp(System.currentTimeMillis());      // String的类型必须形如： yyyy-mm-dd hh:mm:ss[.f...]    // 这样的格式，中括号表示可选，否则报错    String tsStr = \"2011-05-09 11:49:45\";      try {          ts = Timestamp.valueOf(tsStr);          System.out.println(ts);      } catch (Exception e) {          e.printStackTrace();      }  }2.2 Timestamp转Stringpublic static void main(String[] args) {    DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");    Timestamp ts = new Timestamp(System.currentTimeMillis());    try {        // 方法一，优势在于可以灵活的设置字符串的形式        System.out.println(sdf.format(ts));        // 方法二        System.out.println(ts.toString());    } catch (Exception e) {        e.printStackTrace();    }}三、Date与Timestamp互转3.1 Timestamp转Datepublic static void main(String[] args) {    Timestamp ts = new Timestamp(System.currentTimeMillis());    Date date = new Date();    try {        date = ts;        System.out.println(date.toString());    } catch (Exception e) {        e.printStackTrace();    }}Date和Timesta是父子类关系。3.2 Date转Timestamppublic static void main(String[] args) {    Timestamp ts = new Timestamp(System.currentTimeMillis());    Date date = new Date();    try {        ts = new Timestamp(date.getTime());        System.out.println(ts.toString());    } catch (Exception e) {        e.printStackTrace();    }}"
  },
  
  {
    "title": "Enable Google Page Views",
    "url": "/posts/enable-google-pv/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2021-01-04 07:32:00 +0800",
    





    
    "snippet": "  The content of this post applies only to Universal Analytics property (UA), not Google Analytics 4 (GA 4). In addition, since UA is about to be deprecated on Jul 1, 2023, the Page Views feature o...",
    "content": "  The content of this post applies only to Universal Analytics property (UA), not Google Analytics 4 (GA 4). In addition, since UA is about to be deprecated on Jul 1, 2023, the Page Views feature of Chirpy will also be deprecated at that time.This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well.  Head to https://analytics.google.com/ and click on Start Measuring  Enter your desired Account Name and choose the desired checkboxes  Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard  Enter the required information About your business  Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps:  Go to Admin on the left column  Select the desired property from the drop-down on the second column  Click on Data Streams  Add a stream and click on Web  Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml file:google_analytics:  id: 'G-V6XXXXXXX'   # fill in your Google Analytics ID  # Google Analytics pageviews report settings  pv:    proxy_endpoint:   # fill in the Google Analytics superProxy endpoint of Google App Engine    cache_path:       # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine      Visit https://console.cloud.google.com/appengine        Click on Create Application        Click on Create Project        Enter the name and choose the data center close to you        Select Python language and Standard environment        Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient.        Go to your App Engine dashboard on your browser and select API &amp; Services from the left navigation menu        Click on Enable APIs and Services button on the top        Enable the following APIs: Google Analytics API        On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status        Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&lt;project-id&gt;.&lt;region&gt;.r.appspot.com/admin/auth        Note down the Your Client ID and Your Client Secret. You’ll need this in the next section.        Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart        Run the following commands:    [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser:    https://accounts.google.com/o/oauth2/auth?response_type=code&amp;client_id=XYZ.apps.googleusercontent.com&amp;redirect_uri=ABCDEFGEnter verification code: &lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here      Setup Google Analytics superProxy      Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local.        Remove the first 2 lines in the src/app.yaml file:    - application: your-project-id- version: 1            In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard.        Enter any random key for XSRF_KEY, your config.py should look similar to this    #!/usr/bin/python2.7__author__ = 'pete.frisella@gmail.com (Pete Frisella)'# OAuth 2.0 Client SettingsAUTH_CONFIG = {  'OAUTH_CLIENT_ID': 'YOUR_CLIENT_ID',  'OAUTH_CLIENT_SECRET': 'YOUR_CLIENT_SECRET',  'OAUTH_REDIRECT_URI': '%s%s' % (    'https://chirpy-test-XXXXXX.ue.r.appspot.com',    '/admin/auth'  )}# XSRF SettingsXSRF_KEY = 'OnceUponATimeThereLivedALegend'              You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com.But, for the sake of keeping it simple, we will be using the Google provided default URL.            From inside the src/ directory, deploy the app    [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor:      [/tmp/google-analytics-super-proxy/src/app.yaml]source:          [/tmp/google-analytics-super-proxy/src]target project:  [chirpy-test-XXXX]target service:  [default]target version:  [VESRION_NUM]target url:      [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage                 ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse            Visit the deployed service. Add a /admin to the end of the URL.        Click on Authorize Users and make sure to add yourself as a managed user.        If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix.  If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows:  start-date: fill in the first day of blog posting  end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date)  metrics: select ga:pageviews  dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 1:      filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=.    Among them, ; means using logical AND to concatenate two rules.    If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl.  After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics:  id: 'G-V6XXXXXXX'   # fill in your Google Analytics ID  pv:    proxy_endpoint: 'https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&lt;ID FROM SUPER PROXY&gt;'    cache_path:       # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference            Google Analytics Core Reporting API: Filters &#8617;      "
  },
  
  {
    "title": "POI使用示例",
    "url": "/posts/poi-shiyong-shili/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import java.io.FileOutputStream;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFFont;import org.apache.poi....",
    "content": "import java.io.FileOutputStream;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFFont;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.hssf.usermodel.HSSFRichTextString;import org.apache.poi.hssf.usermodel.HSSFDataFormat;import org.apache.poi.hssf.usermodel.HSSFComment;import org.apache.poi.hssf.usermodel.HSSFPatriarch;import org.apache.poi.hssf.usermodel.HSSFClientAnchor;public class PoiCreateExcelDemo {    public static void main(String[] args) {           // 创建新的Excel工作簿        HSSFWorkbook workbook = new HSSFWorkbook();                // 在Excel工作簿中建一工作表，其名为缺省值, 也可以指定Sheet名称        HSSFSheet sheet = workbook.createSheet();        //HSSFSheet sheet = workbook.createSheet(\"SheetName\");                 // 用于格式化单元格的数据        HSSFDataFormat format = workbook.createDataFormat();                // 创建新行(row),并将单元格(cell)放入其中. 行号从0开始计算.        HSSFRow row = sheet.createRow((short) 1);        // 设置字体        HSSFFont font = workbook.createFont();        font.setFontHeightInPoints((short) 20); //字体高度        font.setColor(HSSFFont.COLOR_RED); //字体颜色        font.setFontName(\"黑体\"); //字体        font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); //宽度        font.setItalic(true); //是否使用斜体\t    // font.setStrikeout(true); //是否使用划线        // 设置单元格类型        HSSFCellStyle cellStyle = workbook.createCellStyle();        cellStyle.setFont(font);        cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER); //水平布局：居中        cellStyle.setWrapText(true);                // 添加单元格注释        // 创建HSSFPatriarch对象,HSSFPatriarch是所有注释的容器.        HSSFPatriarch patr = sheet.createDrawingPatriarch();        // 定义注释的大小和位置,详见文档        HSSFComment comment = patr.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short)4, 2, (short) 6, 5));        // 设置注释内容        comment.setString(new HSSFRichTextString(\"可以在POI中添加注释！\"));        // 设置注释作者. 当鼠标移动到单元格上是可以在状态栏中看到该内容.        comment.setAuthor(\"Xuys.\");                // 创建单元格        HSSFCell cell = row.createCell((short) 1);        HSSFRichTextString hssfString = new HSSFRichTextString(\"Hello World!\");        cell.setCellValue(hssfString);//设置单元格内容        cell.setCellStyle(cellStyle);//设置单元格样式        cell.setCellType(HSSFCell.CELL_TYPE_STRING);//指定单元格格式：数值、公式或字符串        cell.setCellComment(comment);//添加注释        //格式化数据        row = sheet.createRow((short) 2);        cell = row.createCell((short) 2);        cell.setCellValue(11111.25);        cellStyle = workbook.createCellStyle();        cellStyle.setDataFormat(format.getFormat(\"0.0\"));        cell.setCellStyle(cellStyle);        row = sheet.createRow((short) 3);        cell = row.createCell((short) 3);        cell.setCellValue(9736279.073);        cellStyle = workbook.createCellStyle();        cellStyle.setDataFormat(format.getFormat(\"#,##0.0000\"));        cell.setCellStyle(cellStyle);                sheet.autoSizeColumn((short)0); //调整第一列宽度        sheet.autoSizeColumn((short)1); //调整第二列宽度        sheet.autoSizeColumn((short)2); //调整第三列宽度        sheet.autoSizeColumn((short)3); //调整第四列宽度        try {            FileOutputStream fileOut = new FileOutputStream(\"E:/demo.xls\");            workbook.write(fileOut);            fileOut.close();        } catch (Exception e) {            System.out.println(e.toString());        }    }}"
  },
  
  {
    "title": "POI自定义单元格背景颜色",
    "url": "/posts/poi-shezhi-danyuange-yanse/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import org.apache.poi.hssf.usermodel.*;import org.apache.poi.hssf.util.HSSFColor;import java.io.FileOutputStream;public class PoiBackgroundColorDemo {\tpublic static void main(String[] args) throws ...",
    "content": "import org.apache.poi.hssf.usermodel.*;import org.apache.poi.hssf.util.HSSFColor;import java.io.FileOutputStream;public class PoiBackgroundColorDemo {\tpublic static void main(String[] args) throws Exception {        //创建Excel工作薄        HSSFWorkbook excel = new HSSFWorkbook();        //创建第一个sheet        HSSFSheet sheet = excel.createSheet(\"POI Demo\");        //创建第一行    \tHSSFRow row = sheet.createRow((short) 0);        //创建第一个单元格        HSSFCell cell = row.createCell((short) 0);        //设置单元格的值        cell.setCellValue(\"Ay\");        //生成单元格样式        HSSFCellStyle style = excel.createCellStyle();        //设置背景颜色        style.setFillForegroundColor(HSSFColor.LIME.index);        //solid填充foreground前景色        style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);        cell.setCellStyle(style);        //通过流写到硬盘        FileOutputStream out = new FileOutputStream(\"D:/old_color.xls\");        excel.write(out);        out.close();        //自定义单元格的样式        cell.setCellValue(\"Al\");        //拿到palette颜色板        HSSFPalette palette = excel.getCustomPalette();        //把之前的颜色HSSFColor.LIME.index替换为RGB(51, 204, 204)宝石蓝这种颜色        palette.setColorAtIndex(HSSFColor.LIME.index, (byte) 0, (byte) 255, (byte) 127);                out = new FileOutputStream(\"D:/new_color.xls\");        excel.write(out);        out.close();    }}D:/old_color.xls结果  D:/new_color.xls结果"
  },
  
  {
    "title": "POI合并单元格",
    "url": "/posts/poi-hebing-danyuange/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "XSSFWorkbook wb = new XSSFWorkbook();XSSFSheet sheet = wb.createSheet();// 参数说明：1：开始行 2：结束行 3：开始列 4：结束列// 比如我要合并第二行到第四行，第六列到第八列 sheet.addMergedRegion(new CellRangeAddress(1, 3, 5, 7));比如我们要生成的单元格为：...",
    "content": "XSSFWorkbook wb = new XSSFWorkbook();XSSFSheet sheet = wb.createSheet();// 参数说明：1：开始行 2：结束行 3：开始列 4：结束列// 比如我要合并第二行到第四行，第六列到第八列 sheet.addMergedRegion(new CellRangeAddress(1, 3, 5, 7));比如我们要生成的单元格为：sheet.addMergedRegion(new CellRangeAddress(0, 3, 0, 0));sheet.addMergedRegion(new CellRangeAddress(0, 3, 3, 3));sheet.addMergedRegion(new CellRangeAddress(0, 3, 4, 4));// 第一行数据XSSFRow row = sheet.createRow(0);row.createCell(0).setCellValue(\"工作站\");row.createCell(1).setCellValue(\"位置\");row.createCell(2).setCellValue(\"序号\");row.createCell(3).setCellValue(\"订单号\");row.createCell(4).setCellValue(\"成品号/型号\");// 第二行数据XSSFRow row = sheet.createRow(number);// row.createCell(0).setCellValue(\"工作站\"); // 因为和上面的行合并了，所以不用再次赋值了row.createCell(1).setCellValue(\"位置\");row.createCell(2).setCellValue(\"序号\");// row.createCell(3).setCellValue(\"订单号\"); // 因为和上面的行合并了，所以不用再次赋值了// row.createCell(4).setCellValue(\"成品号/型号\"); // 因为和上面的行合并了，所以不用再次赋值了// 第三行数据和第二行是一样的// 第四五行数据和第一行是一样的 "
  },
  
  {
    "title": "POI冻结行或列",
    "url": "/posts/poi-dongjie-hang-huo-lie/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "HSSFWorkbook workbook = new HSSFWorkbook();  HSSFSheet sheet = workbook.createSheet();  sheet.createFreezePane(a, b, c, d);   四个参数的含义：  ａ表示要冻结的列数；  ｂ表示要冻结的行数；  ｃ表示右边区域[可见]的首列序号；  ｄ表示下边区域[可见]的首行序号；举...",
    "content": "HSSFWorkbook workbook = new HSSFWorkbook();  HSSFSheet sheet = workbook.createSheet();  sheet.createFreezePane(a, b, c, d);   四个参数的含义：  ａ表示要冻结的列数；  ｂ表示要冻结的行数；  ｃ表示右边区域[可见]的首列序号；  ｄ表示下边区域[可见]的首行序号；举例：// 冻结第一列，冻结列右侧的第一列为B列CreateFreezePane(1, 0, 1, 0);// 冻结左侧两列，冻结列右侧的第一列为F列CreateFreezePane(2, 0, 5, 0);// 冻结第一行，冻结行下侧第一行的左边框显示“2”CreateFreezePane(0, 1, 0, 1);"
  },
  
  {
    "title": "Java随机数的两种获取方式",
    "url": "/posts/java-suijishu-de-huoqu-fangshi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import java.util.Random;public class RandomDemo {    public static void main(String[] args) {        //实现方式一        int random = (int) (Math.random() * 60);        System.out.println(random);      ...",
    "content": "import java.util.Random;public class RandomDemo {    public static void main(String[] args) {        //实现方式一        int random = (int) (Math.random() * 60);        System.out.println(random);                //实现方式二        Random random1 = new Random(124585454);        Random random2 = new Random(124585454);        int r1 = random1.nextInt(61); // 0-60        int r2 = random2.nextInt(61);        //random1和random2得到的随机数是一样的        System.out.println(r1 + \" \" + r2);    }}一、java.lang.Math.Random调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。在使用Math.Random()的时候需要注意的地方是该函数是返回double类型的值，所以在赋值给其他类型变量的时候注意需要进行塑形转换。二、java.util.Random  在Java的API帮助文档中，总结了一下对这个Random()函数功能的描述：          java.util.Random类中实现的随机算法是伪随机，也就是有规则的随机，所谓有规则的就是在给定种(seed)的区间内随机生成数字；      相同种子数的Random对象，相同次数生成的随机数字是完全相同的；      Random类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率均等；        Random()的两种构造方法：          Random()：创建一个新的随机数生成器。      Random(long seed)：使用单个long种子创建一个新的随机数生成器。我们可以在构造Random对象的时候指定种子：Random r1 = new Random(20);，或者默认当前系统时间对应的相对时间有关的数字作为种子数: Random r1 = new Random();。你在创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。        下面是Java.util.Random()方法摘要：          protected int next(int bits)：生成下一个伪随机数。      boolean nextBoolean()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的boolean值。      void nextBytes(byte[] bytes)：生成随机字节并将其置于用户提供的byte数组中。      double nextDouble()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布的double值。      float nextFloat()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布float值。      double nextGaussian()：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。      int nextInt()：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的int值。      int nextInt(int n)：会随机生成一个整数，这个整数的范围就是int类型的范围-2^31 ~ 2^31-1      long nextLong()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的long值。      void setSeed(long seed)：使用单个long种子设置此随机数生成器的种子。        示例：          生成[0, 1.0)区间的小数：double d1 = r.nextDouble();      生成[0, 5.0)区间的小数：double d2 = r.nextDouble() * 5;      生成[1, 2.5)区间的小数：double d3 = r.nextDouble() * 1.5 + 1;      生成-2^31 ~ 2^31-1之间的整数：int n = r.nextInt();      生成[0, 10)区间的整数：int n = r.nextInt(10);或n = Math.abs(r.nextInt() % 10);      三、两种方法的对比最后再来简单对比一下这两个随机函数的特点：  java.Math.Random()实际是在内部调用java.util.Random()的，它有一个致命的弱点，它和系统时间有关，也就是说相隔时间很短的两个random比如：    double a = Math.random();double b = Math.random();        极有可能会得到两个一模一样的double。    java.util.Random()在调用的时候可以实现和java.Math.Random()一样的功能，而且他具有很多的调用方法，相对来说比较灵活。所以从总体来看，使用java.util.Random()会相对来说比较灵活一些。"
  },
  
  {
    "title": "FileOutputStream类的换行写入和追加写入",
    "url": "/posts/fileoutputstream-de-huanhang-xieru-he-zhuijia-xieru/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import java.io.FileOutputStream;    public class FileOutputStreamDemo {      public static void main(String[] args) throws Exception {          // 创建文件输出流对象          FileOutputStream fos1 = new Fil...",
    "content": "import java.io.FileOutputStream;    public class FileOutputStreamDemo {      public static void main(String[] args) throws Exception {          // 创建文件输出流对象          FileOutputStream fos1 = new FileOutputStream(\"fos1.txt\");          // 第二个参数为true表示程序每次运行都是追加字符串在原有的字符上        FileOutputStream fos2 = new FileOutputStream(\"fos2.txt\", true);             // 写数据          for (int x = 0; x &lt; 10; x++) {              fos1.write((\"hello\" + x).getBytes());              fos1.write(\"\\r\\n\".getBytes());// 写入一个换行          }          for (int x = 0; x &lt; 10; x++) {              fos2.write((\"hello\" + x).getBytes());              fos2.write(\"\\r\\n\".getBytes());// 写入一个换行          }        // 释放资源          fos1.close();          fos2.close();      }  }  "
  },
  
  {
    "title": "Maven的安装和使用",
    "url": "/posts/maven-de-anzhuang-he-shiyong/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-02 13:47:00 +0800",
    





    
    "snippet": "一、Maven的安装和配置1.1 下载进入Maven官网的下载页面：http://maven.apache.org/download.cgi，选择当前最新版本，例如apache-maven-3.0.4-bin.zip，下载到本地并解压。1.2 配置进入Maven安装目录下的conf子目录中，打开settings.xml进行配置修改。      修改默认的本地仓库位置    Maven默认的本...",
    "content": "一、Maven的安装和配置1.1 下载进入Maven官网的下载页面：http://maven.apache.org/download.cgi，选择当前最新版本，例如apache-maven-3.0.4-bin.zip，下载到本地并解压。1.2 配置进入Maven安装目录下的conf子目录中，打开settings.xml进行配置修改。      修改默认的本地仓库位置    Maven默认的本地仓库位置是当前用户工作目录下的.m2/repository，使用过程中这个目录里的文件会比较多，占用空间越来越大。一般建议更换到其它磁盘目录下。如下配置，就把默认的本地仓库更改到D:/.m2/repository这个目录（这个目录结构需要自己创建好）：    &lt;localRepository&gt;D:/.m2/repository&lt;/localRepository&gt;            修改默认的中央仓库镜像    Maven默认的中央仓库里的文件不全。所以，都需要自行添加其它的镜像地址。在settings.xml文件中的&lt;mirrors&gt;标签里添加如下内容：    &lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;      二、Maven的使用Maven一般作为插件在IDE中使用，下面以Eclipse为例。2.1 安装Maven插件Eclipse默认不支持Maven。需要给它添加m2eclipse插件。下面是具体的操作步骤：  依次选择Eclipse菜单栏的“Help”菜单“Instance NewSoftWare”菜单项，弹出如下对话窗口：  选择“Add..”按钮，弹出如下对话框：  这个对话框就是用于添加一个插件地址的。在“Name”对应的输入框里输入该操作的一个标识名。在“Location”对应的输入框里输入这个插件的安装地址。注：Maven的Eclipse插件地址为http://download.eclipse.org/technology/m2e/releases。输入后，如下图所示：  输入完成后，点击右下角的“OK”按钮，就会弹出如下对话框：  这里需要选择想要安装的插件的详细内容。选中“Maven Integration for Eclipse”前面的复选框。如下图所示：  选择完成后，点击右下方的“Next&gt;”按钮进行安装。安装成功后，会提示需要重启Eclipse来生效这次配置。重启之后，就可以使用m2eclipse插件功能了。2.2 配置Maven插件插件安装好之后，还需要进行一些配置才能够开始使用Maven的功能。  设置m2eclipse插件所关联的Maven程序          依次选择Eclipse菜单栏的“Window”菜单“Preferences”菜单项，弹出如下对话框：      在这个对话框左边的导航栏中展开“Maven”目录结点，并选择“Installations”子节点，如下图所示：      这里需要关联上对应的Maven安装程序。具体操作是，在右边面板中选择“Add…”按钮，会弹出如下选择Maven安装目录的选择对话框，通过这个对话框来选择Maven的具体安装目录。选择好之后就点击“确定”按钮。如下图所示：        设置自定义的本地仓库          选择如上图对话窗口左边菜单树 “Maven”节点下的“UserSettings”子节点，它默认的配置文件是C:\\Documents and Settings\\csdn\\.m2\\settings.xml，如下图所示：      这边需要修改为我们自定义的settings.xml文件。具体操作是，点击“Browse…”按钮来选择Maven安装目录下的settings.xml文件，点击“打开”按钮来确认刚才的选择，就会回到如下图的对话窗口中：      在上图中点击右下角的“OK”按钮来完成所有的配置修改。      "
  },
  
  {
    "title": "HashMap的四种遍历方法",
    "url": "/posts/hashmap-de-sizhong-bianli-fangfa/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;public class MapShowTest {    public static void ...",
    "content": "import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;public class MapShowTest {    public static void main(String[] args) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();        for (int i = 0; i &lt; 10; i++) {            map.put(i, i + 1);        }        // 通过Map.keySet遍历key和value        for (int temp : map.keySet()) {            System.out.print(temp + \"=\" + map.get(temp) + \", \");        }        // 通过Map.entrySet遍历key和value，推荐，尤其是容量大时        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entry = map.entrySet();        for (Map.Entry&lt;Integer, Integer&gt; temp : entry) {            System.out.print(temp.getKey() + \"=\" + temp.getValue() + \", \");        }        // 通过Map.entrySet使用iterator遍历key和value        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entry1 = map.entrySet();        Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = entry1.iterator();        while (iterator.hasNext()) {            Map.Entry&lt;Integer, Integer&gt; mapTemp = iterator.next();            System.out.print(mapTemp.getKey() + \"=\" + mapTemp.getValue() + \", \");        }        //通过Map.values()遍历所有的value，但不能遍历key        Collection&lt;Integer&gt; c = map.values();        for (int temp : c) {            System.out.print(\"value= \" + temp + \", \");        }    }}"
  },
  
  {
    "title": "final和static",
    "url": "/posts/final-he-static/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "一、final根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类的成员方法和变量（包括成员变量和局部变量）。它有以下特点：  final类不能被继承，没有子类，final类中的方法默认是final的。  final方法不能被子类的方法覆盖，但可以被继承。  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  fina...",
    "content": "一、final根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类的成员方法和变量（包括成员变量和局部变量）。它有以下特点：  final类不能被继承，没有子类，final类中的方法默认是final的。  final方法不能被子类的方法覆盖，但可以被继承。  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  final不能用于修饰构造方法。  父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。1.1 final类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。1.2 final方法final类不能被继承，因此final类的成员方法没有机会被覆盖。使用final方法的原因有二：第一、把方法锁定，防止任何继承类修改它的意义和实现。第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。1.3 final变量修饰变量是final用得最多的地方，对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。举个例子：class Man {    private final int i = 0;    public Man() {        // i = 1; // 报错        final Object obj = new Object();        // obj = new Object(); // 报错    }}另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。举个例子：package org.test;  public class Test3 {     private final String S = \"final实例变量S\";     private final int A = 100;     public final int B = 90;     public static final int C = 80;     private static final int D = 70;     public final int E; // final空白,必须在初始化对象的时候赋初值     public Test3(int x) {         E = x;     }     public static void main(String[] args) {         Test3 t = new Test3(2);         // t.A=11; // 出错,final变量的值一旦给定就无法改变         // t.B=91; // 出错,final变量的值一旦给定就无法改变         // t.C=81; // 出错,final变量的值一旦给定就无法改变         // t.D=71; // 出错,final变量的值一旦给定就无法改变         System.out.println(t.A);         System.out.println(t.B);         System.out.println(t.C); // 不推荐用对象方式访问静态字段         System.out.println(t.D); // 不推荐用对象方式访问静态字段         System.out.println(Test3.C); // 推荐使用类名直接调用        System.out.println(Test3.D); // 推荐使用类名直接调用        // System.out.println(Test3.E); // 出错,因为E为final空白,依据不同对象值有所不同.         System.out.println(t.E);         Test3 t1 = new Test3(3);         System.out.println(t1.E); // final空白变量E依据对象的不同而不同     }     private void test() {         System.out.println(new Test3(1).A);         System.out.println(Test3.C);         System.out.println(Test3.D);     }     public void test2() {             final int a; // final空白,在需要的时候才赋值             final int b = 4; // 局部常量，final用于局部变量的情形             a = 3;             // a=4; // 出错,已经给赋过值了            // b=2; // 出错,已经给赋过值了    } }二、staticstatic表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。它有以下特点：  被static修饰的成员变量和成员方法独立于该类的任何对象。  类的所有实例共享同一个static变量。  static是在内存中分配一块区域，供整个类通用，所有的类的对象都享有它的共同的值。2.1 static方法（静态方法）静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联。因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。即使没有创建对象，也需要一个能调用的方法，为满足这两方面的要求，可使用static（静态）关键字。 2.2 static变量（静态变量）static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进行初始化。2.3 static代码块（静态块）static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。利用静态代码块可以对一些static变量进行赋值。举个例子：public class Test5 {     private static int a;     private int b;     static {         Test5.a = 3;         System.out.println(a);         Test5 t = new Test5();         t.f();         t.b = 1000;         System.out.println(t.b);     }     static {         Test5.a = 4;         System.out.println(a);     }     public static void main(String[] args) {         new Test5();    }     static {         Test5.a = 5;         System.out.println(a);     }     public void f() {         System.out.println(\"hhahhahah\");     } }运行结果：3hhahhahah100045很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。"
  },
  
  {
    "title": "compareTo()在排序中的应用",
    "url": "/posts/compareto-fangfa-de-shiyong/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "public class Student implements Comparable&lt;Student&gt; {    private String name;    private int age;    private double score;    public Student(String name, int age, double score) {        this....",
    "content": "public class Student implements Comparable&lt;Student&gt; {    private String name;    private int age;    private double score;    public Student(String name, int age, double score) {        this.age = age;        this.name = name;        this.score = score;    }    public String toString() {        return \"name=\" + name + \", age=\" + age + \", score=\" + score;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public double getScore() {        return score;    }    public void setScore(double score) {        this.score = score;    }    // 重写compareTo    public int compareTo(Student o) {        return this.age - o.age;    }    public static void main(String[] args) {        Student s1 = new Student(\"Bob\", 13, 50);        Student s2 = new Student(\"Tom\", 15, 40);        Student s3 = new Student(\"Jhon\", 20, 80);        Student s4 = new Student(\"Ann\", 10, 60);        Student[] stu = new Student[4];        stu[0] = s1;        stu[1] = s2;        stu[2] = s3;        stu[3] = s4;        //利用Arrays.sort对数组进行排序的时候按照重写的compareTo方法进行        Arrays.sort(stu);        for (int i = 0; i &lt; stu.length; i++) {            System.out.println(stu[i]);        }     }}运行结果：name=Ann, age=10, score=60.0name=Bob, age=13, score=50.0name=Tom, age=15, score=40.0name=Jhon, age=20, score=80.0import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Student implements Comparable&lt;Student&gt; {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    // 重写compareTo方法    public int compareTo(Student o) {        // 先按age排序        if (this.age &gt; o.getAge()) {            return (this.age - o.getAge());        }        if (this.age &lt; o.getAge()) {            return (o.getAge() - this.age);        }        // 再按name排序        if (this.name.compareTo(o.getName()) &gt; 0) {            return 1;        }        if (this.name.compareTo(o.getName()) &lt; 0) {            return -1;        }        return 0;    }    public static void main(String[] args) {        Student f1 = new Student(\"c\", 15);        Student f2 = new Student(\"a\", 25);        Student f3 = new Student(\"b\", 15);        List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        list.add(f1);        list.add(f3);        list.add(f2);        Collections.sort(list);        for (Student o : list) {            System.out.println(o.getAge() + \"--&gt;\" + o.getName());        }    }}运行结果：15--&gt;b15--&gt;c25--&gt;a"
  },
  
  {
    "title": "Java中获取当前时间的方法",
    "url": "/posts/Java-zhong-huoqu-dangqian-shijian-de-fangfa/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "package test.date.demo;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.util.Date;public class GetTimeDemo {    public static void main(String[] args) {        // 使用Date类和Sim...",
    "content": "package test.date.demo;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.util.Date;public class GetTimeDemo {    public static void main(String[] args) {        // 使用Date类和SimpleDateFormat类        SimpleDateFormat sdf = new SimpleDateFormat(\"YYYY-MM-dd hh:mm:ss\");        System.out.println(sdf.format(new Date()));                // 使用Timestamp        long time = System.currentTimeMillis();        System.out.println(new Timestamp(time).toString());    }}"
  },
  
  {
    "title": "接口编程对于开发的意义",
    "url": "/posts/jiekou-biancheng-duiyu-kaifa-de-yiyi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-01 11:47:00 +0800",
    





    
    "snippet": "对于Java的意义Java本身也是一个不断完善的语言，他也在频繁的改动他的系统API，他的API是一个庞大的体系，互相关联，如果不采用接口，而都是用实现类的话，那么API的改动就会给整个体系带来不稳定。而且如果改动API，那么就会有大量采用旧API的项目因无法正常运行，会损失大量客户。换句话说，JDK已经发布的API是一种承诺，一经发布就不能更改，即使原来API存在各种各样的问题（例如jav...",
    "content": "对于Java的意义Java本身也是一个不断完善的语言，他也在频繁的改动他的系统API，他的API是一个庞大的体系，互相关联，如果不采用接口，而都是用实现类的话，那么API的改动就会给整个体系带来不稳定。而且如果改动API，那么就会有大量采用旧API的项目因无法正常运行，会损失大量客户。换句话说，JDK已经发布的API是一种承诺，一经发布就不能更改，即使原来API存在各种各样的问题（例如java.util.Properties类就是一个失败的例子）也必须保留，于是在Java里就出现了不建议使用的方法，但JDK依然提供该方法。而且Java语言本身是一个跨平台的语言，为了满足在各个平台下运行，就必须把各种操作做成接口，在编写各个平台下的实现类。对于开发的意义在一些大型项目或者大型公司里，都是由架构师编写出系统接口，具体的实现类交给了程序员编写，公司越大这种情况越明显，所以在这些公司里做开发，我们可能都不知道编写出的系统是个什么样子，每天做的工作可能就是做“填空题”了。在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。实际上，在日常工作中，你已经按照接口编程了，只不过如果你没有这方面的意识，那么你只是在被动的实现这一思想；表现在频繁的抱怨别人改的代码影响了你（接口没有设计好），表现在某个模块的改动引起其他模块的大规模调整（模块接口没有很好的设计）等等。"
  },
  
  {
    "title": "继承和多态",
    "url": "/posts/jicheng-he-duotai/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-01 11:47:00 +0800",
    





    
    "snippet": "继承子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。或子类从父类继承方法，使得子类具有父类相同的行为。特点：在继承关系中，父类更通用、子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。表示父类和子类的术语：父类和子类、超类和子类、基类和派生类。多态多态性就是发送消息给某个对象，让该对象自行决定响应何种行为。指允许不同类的对象对...",
    "content": "继承子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。或子类从父类继承方法，使得子类具有父类相同的行为。特点：在继承关系中，父类更通用、子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。表示父类和子类的术语：父类和子类、超类和子类、基类和派生类。多态多态性就是发送消息给某个对象，让该对象自行决定响应何种行为。指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态的特征是表现出多种形态，具有多种实现方式。或者多态是具有表现多种形态的能力的特征。或者同一个实现接口，使用不同的实例而执行不同的操作。多态存在的三个必要条件一、要有继承；二、要有重写；三、父类引用指向子类对象。总结1、为什么子类类型的对象实例可以赋给超类引用自动实现向上转型。通过该语句，编译器自动将子类实例向上移动，成为通用类型BaseClass。2、不能把父类对象引用赋给子类对象引用变量在Java里面，向上转型是自动进行的,但是向下转型却不是，需要我们自己定义强制进行。"
  },
  
  {
    "title": "重写和重载的区别",
    "url": "/posts/chongxie-chongzai-de-qubie/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-01 11:47:00 +0800",
    





    
    "snippet": "重写（overwrite）父类与子类之间的多态性，对父类的函数进行重新定义。重写继承到的那个方法的代码，原方法被放弃。子类继承了父类的同名有参函数。当子类继承了父类的一个同名方法，且方法参数不同，称为重写。通过方法的重写，子类可以重新实现父类的某些方法，使其具有自己的特征。重写方法只能存在于具有继承关系中，重写方法只能重写父类非私有的方法。子类函数的访问修饰权限不能低于父类的。重载（over...",
    "content": "重写（overwrite）父类与子类之间的多态性，对父类的函数进行重新定义。重写继承到的那个方法的代码，原方法被放弃。子类继承了父类的同名有参函数。当子类继承了父类的一个同名方法，且方法参数不同，称为重写。通过方法的重写，子类可以重新实现父类的某些方法，使其具有自己的特征。重写方法只能存在于具有继承关系中，重写方法只能重写父类非私有的方法。子类函数的访问修饰权限不能低于父类的。重载（overload）重载是一个类中多态性的一种表现。完全新的方法，参数和原方法不同。当前类的同名方法。通过方法的重载，一个类可以有多个具有相同名字的方法，返回值类型可以相同也可以不相同，由传递给它们不同的个数和类型的参数来决定使用哪种方法。无法以返回类型作为重载函数的区分标准。重写与重载的区别在于重写是子类覆盖父类的方法，要求方法名和参数都相同，子类方法的可访问性可以与父类方法的可访问性相同，或更公开。重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但含有不同的参数，即参数个数、类型或顺序不同。"
  },
  
  {
    "title": "Spring Boot和Spring Cloud的关系",
    "url": "/posts/springboot-he-springcloud-de-guanxi/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2020-12-31 13:47:00 +0800",
    





    
    "snippet": "Spring Boot先于Spring Cloud问世。Spring Boot相当于脚手架，借助他可以快速搭建房子，它本身不具备任何功能属性，只是普通房间，没有其他任何功能。什么是Spring BootSpring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、产品级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置，这样...",
    "content": "Spring Boot先于Spring Cloud问世。Spring Boot相当于脚手架，借助他可以快速搭建房子，它本身不具备任何功能属性，只是普通房间，没有其他任何功能。什么是Spring BootSpring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、产品级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用只需要很少的Spring配置。Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是Spring Boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像Maven整合了所有的jar包，Spring Boot整合了所有的框架（不知道这样比喻是否合适）。Spring Boot的核心思想就是约定大于配置，一切自动完成。采用Spring Boot可以大大的简化你的开发模式，所有你想集成的常用框架，它都有对应的组件支持。什么是Spring CloudSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，Spring Cloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，Spring Cloud做为大管家就需要提供各种方案来维护整个生态。Spring Cloud就是一套分布式服务治理的框架，既然它是一套服务治理的框架，那么它本身不会提供具体功能性的操作，更专注于服务之间的通讯、熔断、监控等。因此就需要很多的组件来支持一套功能。Spring Boot和Spring Cloud的关系  Spring Boot是Spring的一套快速配置脚手架，可以基于Spring Boot快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；  Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；  Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot吗？不可以。  Spring Boot可以离开Spring Cloud独立使用，但是Spring Cloud离不开Spring Boot，属于依赖的关系。总结Spring Boot在Spring Clound中起到了承上启下的作用，如果要学习Spring Cloud必须要学习Spring Boot。"
  },
  
  {
    "title": "1.金融理财",
    "url": "/posts/jinronglicai/",
    "categories": "MyNotes, 4_JinRongLiCai",
    "tags": "",
    "date": "2020-12-30 13:47:00 +0800",
    





    
    "snippet": "一、个税1.1 所得范围依据《中华人民共和国个人所得税法》，下列各项个人所得，应当缴纳个人所得税：  （1）工资、薪金所得；  （2）劳务报酬所得；  （3）稿酬所得；  （4）特许权使用费所得；  （5）经营所得；  （6）利息、股息、红利所得；  （7）财产租赁所得；  （8）财产转让所得；  （9）偶然所得。居民个人取得工资、薪金所得；劳务报酬所得；稿酬所得；特许权使用费所得（以下称综...",
    "content": "一、个税1.1 所得范围依据《中华人民共和国个人所得税法》，下列各项个人所得，应当缴纳个人所得税：  （1）工资、薪金所得；  （2）劳务报酬所得；  （3）稿酬所得；  （4）特许权使用费所得；  （5）经营所得；  （6）利息、股息、红利所得；  （7）财产租赁所得；  （8）财产转让所得；  （9）偶然所得。居民个人取得工资、薪金所得；劳务报酬所得；稿酬所得；特许权使用费所得（以下称综合所得），按纳税年度合并计算个人所得税；有扣缴义务人的，由扣缴义务人按月或者按次预扣预缴税款；需要办理汇算清缴的，应当在取得所得的次年3月1日至6月30日内办理汇算清缴。非居民个人取得工资、薪金所得；劳务报酬所得；稿酬所得和特许权使用费所得按月或者按次分项计算个人所得税，不办理汇算清缴。1.2 适用税率  （1）综合所得，适用3%至45%的超额累进税率（税率表附后）；  （2）经营所得，适用5%至35%的超额累进税率（税率表附后）；  （3）利息、股息、红利所得，财产租赁所得，财产转让所得和偶然所得，适用比例税率，税率为20%。1.3 年度汇算清缴年度综合所得收入不超过12万元且需要汇算清缴补税的，或者年度汇算清缴补税金额不超过400元的，居民个人可免于办理个人所得税综合所得汇算清缴。居民个人取得综合所得时存在扣缴义务人未依法预扣预缴税款的情形除外。1.4 个税计算  工资、薪金所得  本期应预扣预缴税额 = （累计预扣预缴应纳税所得额 × 预扣率 - 速算扣除数) - 累计减免税额 - 累计已预扣预缴税额  累计预扣预缴应纳税所得额 = 累计收入 - 累计免税收入 - 累计减除费用 - 累计专项扣除 - 累计专项附加扣除 - 累计依法确定的其他扣除  其中：累计减除费用，按照5000元/月乘以纳税人当年截至本月在本单位的任职受雇月份数计算。  全年一次性奖金居民个人取得全年一次性奖金，符合《国家税务总局关于调整个人取得全年一次性奖金等计算征收个人所得税方法问题的通知》（国税发〔2005〕9号）规定的，在2023年12月31日前，不并入当年综合所得，以全年一次性奖金收入除以12个月得到的数额，按照《财政部税务总局关于个人所得税法修改后有关优惠政策衔接问题的通知》（财税〔2018〕164号 ）（以下简称164号文）所附按月换算后的综合所得税率表（以下简称月度税率表），确定适用税率和速算扣除数，单独计算纳税。  应纳税额 = 全年一次性奖金收入 × 适用税率 - 速算扣除数居民个人取得全年一次性奖金，也可以选择并入当年综合所得计算纳税。自2024年1月1日起，居民个人取得全年一次性奖金，应并入当年综合所得计算缴纳个人所得税。1.5 税率表年终奖计算使用1.6 专项附加扣除从2023年度起，为进一步减轻家庭生育养育和赡养老人的支出负担，依据《中华人民共和国个人所得税法》有关规定，国务院决定，提高3岁以下婴幼儿照护、子女教育、赡养老人等三项个人所得税专项附加扣除标准。1、婴幼儿照护2、子女教育3、继续教育4、大病医疗5、住房贷款利息6、住房租金7、赡养老人二、国债三、不动产3.1 产登记证办理流程  开发商办理初始登记；  领取《房屋所有权登记申请表》，同时填写该表；  到开发商指定的房屋面积计量站申请并领取测绘表；  领取相关文件，包括购房合同等；  缴纳公共维修基金、契税；  提交申请材料；  领取不动产证。3.2 所需材料（宁夏样例）  不动产登记申请审批表（原件）  申请人身份证明（复印件）  授权委托书（原件）  已备案的商品房预售合同（原件）  抵押合同（原件）  购房收据或购房发票（原件）3.3 法律法规根据《不动产登记暂行条例》第二十条的规定，不动产登记机构应当自受理登记申请之日起30个工作日内办结不动产登记手续，法律另有规定的除外。第二十一条规定，登记事项自记载于不动产登记簿时完成登记。不动产登记机构完成登记，应当依法向申请人核发不动产权属证书或者登记证明。3.4 其他问题3.4.1 商业贷款买房需要压房产证吗商业贷款买房时，房产证本身并不需要抵押给银行。根据相关规定和流程，购房者在办理按揭贷款手续时，通常会与银行签订《抵押合同》及《贷款合同》，并在产权等相关证书办理完毕后，前往当地房地产交易部门办理房屋抵押登记手续。这一步骤的目的是确保银行能够将房屋作为抵押物，以保障贷款的安全。在这个过程中，房管部门会将房屋的他项权证交给银行，而不是房产证本身。具体来说，商业贷款买房时，银行会得到《房屋他项权证》，而不是房产证。购房者在办理房产证后，可以自己保存并使用房产证，但由于房子处于抵押状态，所以很多事项不能办理。此外，关于房产证是否放在银行，这方面国家没有统一规定，具体要以贷款银行的具体政策而定。商业贷款买房时，不需要将房产证本身抵押给银行，只需办理《房屋他项权证》即可。3.5 名词解释3.5.1 LPR贷款市场报价利率（Loan Prime Rate, LPR）是由具有代表性的报价行，根据本行对最优质客户的贷款利率，以公开市场操作利率（主要指中期借贷便利利率）加点形成的方式报价，由中国人民银行授权全国银行间同业拆借中心计算并公布的基础性的贷款参考利率，各金融机构应主要参考LPR进行贷款定价。 现行的LPR包括1年期和5年期以上两个品种。LPR市场化程度较高，能够充分反映信贷市场资金供求情况，使用LPR进行贷款定价可以促进形成市场化的贷款利率，提高市场利率向信贷利率的传导效率。2020年8月12日，工行、建行、农行、中行和邮储五家国有大行同时发布公告，于8月25日起对批量转换范围内的个人住房贷款，按照相关规则统一调整为LPR（贷款市场报价利率）定价方式。9月7日，工农中建四大国有行分别发布存量房贷利率调整细则。根据四大行细则，对于符合条件的存量首套房贷，银行将于9月25日集中批量调整，无需客户操作。“二套转首套”、不良贷款归还积欠本息、当前执行的是固定利率或基准利率定价的存量房贷，需客户主动申请调整。LPR的发布时间：每月20日上午9:15，查询方法：可以在各大银行网站首页，查询贷款市场报价利率（LPR），同时中国人民银行也会每期同步更新。最新贷款市场报价利率（LPR）：  2023-09-20，1年期LPR为3.45%，5年期以上LPR为4.2%。  2024-09-20，1年期LPR为3.35%，5年期以上LPR为3.85%。3.5.2 按揭按揭是一种贷款方式，主要用于购房或购物。具体来说，按揭具有以下几个核心含义：  房地产抵押：按揭通常指的是购房者以所购买的住房作为抵押物，以此向银行或其他金融机构申请贷款。这种抵押可以是实物资产，如房地产，也可以是有价证券、契约等。  分期还款：购房者通过分期付款的方式来偿还贷款本金和利息。在分期付款期间，房子的所有权仍然属于购房者，但在贷款完全偿还后，银行会归还抵押物。  法律定义：按揭在法律上被定义为一种担保方式，即通过设立权利负担来担保按揭人（贷款人）向出借人（银行）偿还贷款的义务。  广义与狭义：按揭的概念可以广义和狭义两种理解。广义的按揭包括任何形式的质押和抵押，而狭义的按揭特指将房地产转移到贷款人名下，直到贷款还清。  与普通贷款的区别：按揭贷款与普通抵押贷款的主要区别在于，按揭贷款需要将房子作为抵押物，而普通抵押贷款则是已经拥有房子，用已购房屋做抵押向银行借钱用于其他消费。3.5.3 回迁房回迁房就是指发展商征收土地时，赔给回迁民的房子。四、保险纯粹风险对社会而言是一种绝对损失；相反，一些投机风险在导致损失的同时却可能给其他团体带来利益。例如，价格的上涨会给买方带来损失，但同时给卖方带来收益。公司和个人可通过购买保险来降低纯粹风险，但投机风险一般不能通过购买保险来降低。保险公司就是专门从事纯粹风险的度量和分担工作的实体。保险就是以确定的费用代替不确定的损失4.1 风险4.1.1 风险管理的目标以最小的成本将风险降低到主体能够承受的水平。或者说：风险成本最小化。4.1.2 风险三要素  风险因素（风险因素是指增加损失发生的频率或严重程度的条件，是损失发生的潜在原因）  风险事故（又称风险事件，是损失的直接原因）  损失（指价值的消灭或减少）4.1.3 风险管理技术（方法）  风险回避  风险控制（防损与减损、审计与内部控制）  风险融资          风险自留：自己备钱承担风险      风险转移：                  公司组织：有限责任公司的股东将风险转移给了公司          合同安排：买卖合同中的保证条款。          委托保管：保管人承担存货风险          担保合同：付款担保、履约担保等          套期保值：管理价格风险，降低了风险，也放弃了收益          购买保险：管理纯粹风险，转移给保险人。                    4.2 保险4.2.1 保险分类  按保险标的：财险（财产保险是以财产及其有关利益作为保险标的的保险，主要有财产损失保险、责任保险、信用保证保险）、寿险  按政策：政策性保险、商业保险  是否以赢利为目标：社会保险、商业保险  按转嫁风险方式：原保险、再保险  按保障对象：个险、团险  按实施方式：自愿保险、法定保险4.2.2 保险基本概念  保险人：亦称承保人，是与投保人订立保险合同，并根据保险合同收取保险费，在保险事故中承担赔偿或者给付保险金责任的人  投保人：是指与保险公司订立保险合同，并按照保险合同负有交付保险费义务的人  被保人：是指根据保险合同，其财产利益或人身受保险合同保障，在保险事故发生后，享有保险金请求权的人。投保人往往同时就是被保险人      受益人：是指在人身保险合同中，由被保人或者投保人指定的享有保险金请求权的人，投保人或者被保险人可以同时作为受益人    投保单：投保单本身不是合同，但保险合同成立后，投保单是保险合同的重要组成部分。  保险单：是保险合同的正式书面文件，一般由保险公司签发:保险单上载明了双方当事人的具体权利义务。  保险凭证：保险公司签发给投保人的证明保险合同已经订立的书面文件，一般不记载保险条款，实质上是一种简化的保险单，具有与保险单同等的法律效力。  暂保单：在某些情况下，正式出具保险单或保险凭证之前，保险公司签发给投保人的临时保险凭证，一般都有一个有效期限，待保险单出具，自动失效。      批单：保险公司应投保人或被保险人的要求出具的修订或更改保险合同内容的书面文件，其实质是对保险合同内容的变更，一经签发，就成为保险合同的重要组成部分。    险种：保险产品  险类：同一种类险种的集合  基本险：也称“主险”。单独可以承保的条款。      附加险：不能单独投保和承保的条款。    联保：公司内其他部门联合承保。      共保：两个不同的公司联合承保。    保险金额：保险金额，简称”保额”，是保险利益的货币价值表现，是投保时给保险标的确定的金额，又是保险人计收保险费的依据和承担给付责任的最高限额。      免赔额：对于健康保险，特别是其中的医疗费用保险，为了避免保险人在处理赔款时费用过大，通常健康保险单通过规定一些条款，来达到被保险人与保险人费用共担的目的。免赔额条款是其中的一种，即规定保险人只负责超过免赔额的部分。    保险标的：作为保险对象的财产及其有关利益或者人的寿命和身体  保险价值：保险标的的价值  保险期限：生效到终止  保险费（保费）  保险金额（赔偿限额）：保险公司赔付的最大限额  保险费率：单位保额（寿险为每千元，财险为每百元）的保费。保险费率=保险费/保险金额4.3 非车险  非车险包含的险种范围          船货险：Y（货运险）、C（船舶险）      农险：H（种植险）、M（林木险）、I（养殖险）      意外健康险：E（意外险）、W（健康险）      责任信用保证保险：Z（责任险）、B（保证保险类）、X（信用保险类）      企业家财工程险：Q（企业保险）、J（家财险）、G（工程险）      特险：A（航空）、O（石油）、K（航天）、N（核能）      4.4 车险  车险名词          标的：车辆      险类：例如 车险、个险、健康险、意外险等等      险种：例如 对于车险划分，主要有交强险和商业险      险别：例如 对于车险中的商业险来划分主要有车损、三者、盗抢等等      保险区间：对于车险中，保险区间是指，投保人在投保的时候，对于车辆从什么时候起保开始，到什么时候时间截至。      倒签单：以当前日期为标准，如果保险区间中的保单起期在当前日期之前，就属于倒签。      新车购置价：是指在买车时候购买的价格是多少，这里通常包括含税和不含税部分      车辆实际价值：是指在车辆使用过程中出现折损，按照一定的年限用新车购置价减去折损之后的价格      车辆保险：车船税：按照规定的计税依据和年税额标准计算征收的一种财产税；交强险：保险公司对被保险机动车发生道路交通事故造成对方的人身伤亡、财产损失进行赔偿的强制性责任保险(强制性)；机动车商业险：是由经国家批准的商业保险公司推出的一项险种(可自由选择)。        交强险保险金额          （1）死亡伤残赔偿限额为110000元；      （2）医疗费用赔偿限额为10000元；      （3）财产损失赔偿限额为2000元；      （4）被保险人无责任时，无责任死亡伤残赔偿限额为11000元；无责任医疗费用赔偿限额为1000元；无责任财产损失赔偿限额为100元。        车险的单证          商业险单证：特别约定、投保单、浮动告知单、保单、发票      交强险单证：特别约定、投保单、浮动告知单、保单、发票、保险标志      4.5 人身保险人身保险的分类  按实施方式来划分          法定保险：强制保险      自愿保险：对双方平等自愿        按保险保障的范围划分          人寿保险：死亡保险、生存保险、生死保险      年金保险      意外伤害保险      健康保险        按承保方式划分          个人保险：只是为一个人提供保险保障      团体保险：为某一团体的所有成员或绝大多数成员提供保障        按保险期限划分          长期业务：保险期限超过1年的人身保险业务      一年期业务：主要是意外伤害保险      短期业务：一般是只保一次航程或一次旅程        按有无分红划分          分红保险：既获得保险保障，又获得保险公司的经营利润      不分红保险：只获得保险保障        按被保险人是否要体检          验体保险      免验体保险      五、股票5.1 股票指数5.1.1 上证50上证50是指上海证券交易所推出的一种重要股票指数，该指数选取了在上海证券交易所上市的A股中市值规模大、流动性好的前50只股票作为样本股。这50只成分股通常是各个行业的龙头企业，覆盖了金融、能源、制造、消费等多个关键经济领域，代表了中国证券市场上的蓝筹股群体，能够综合反映中国经济的核心企业的整体状况和上海证券市场最具市场影响力的一批公司的股票价格表现。上证50指数的设计旨在追踪这批大型企业的市场表现，为投资者提供一个衡量市场走势的重要参考指标，同时也是衍生金融产品，如股指期货、期权等的标的之一。该指数自2004年1月2日起正式发布，基日为2003年12月31日，指数代码为000016。由于成分股的筛选标准严格，上证50指数的成分股通常具有较高的盈利能力、稳定的经营状态和良好的市场流动性，因此，它不仅是市场关注的焦点，也被视为中国经济和股市整体趋势的一个风向标。5.1.2 沪深300上证50与沪深300指数的主要区别体现在以下几个方面：  成分股数量与范围：          上证50：由上海证券交易所中规模最大、流动性最好的50只股票构成，仅涵盖上海市场。      沪深300：从上海和深圳两个证券市场中选出300只规模最大、流动性强的股票作为样本，覆盖面更广，包含更多的市场成分。        行业分布：          上证50指数中金融行业的权重较高，尤其是银行业，占据了较大比例，使得该指数对金融板块的表现尤为敏感。      沪深300指数虽然也包含较多金融股，但行业分布更为均衡，除了金融外，还包括工业、信息技术、消费等多个行业，更能全面反映A股市场的整体情况。        代表性与市场影响力：          上证50主要反映的是上海证券市场中最具市场影响力的一批大型龙头企业的整体状况，可以说是蓝筹股中的蓝筹。      沪深300则综合反映中国A股市场上市股票价格的整体表现，常被视为中国股市的“晴雨表”，其代表性更为广泛。        投资策略与适用性：          上证50指数因其成分股的高集中度和稳定性，可能更适合寻求长期稳定收益的投资者或用于资产配置中的基石部分。      沪深300指数由于其更广泛的市场覆盖和较好的行业平衡性，适合于希望更全面参与中国股市、进行指数化投资或进行市场趋势跟踪的投资者。        市场定位与产品：          两者均有相应的交易型开放式指数基金（ETF）等投资产品，但沪深300由于其更广泛的市场代表性，可能拥有更多的投资产品和更高的市场活跃度。      总的来说，上证50更侧重于上海市场的大盘蓝筹股，而沪深300则是跨市场的宽基指数，更能全面代表中国A股市场的整体表现。投资者在选择时应考虑自己的投资目标、风险偏好及市场预期。5.1.3 其他指数当然，除了沪深300和上证50之外，中国股市还有多种其他重要股票指数，用以反映不同市场板块或不同规模企业的表现。以下是一些较为知名的指数：      上证综合指数（上证综指）：反映上海证券交易所所有A股和B股的总体走势，是最具代表性的大盘指数之一。        深证成指（深证成份指数）：选取在深圳证券交易所上市的具有一定代表性的40家上市公司的股票作为样本股，反映深市主板市场的运行情况。        中证500指数：从沪深市场中剔除沪深300指数成分股及总市值排名前300名的股票后，选取总市值排名靠前的500只股票组成，主要反映A股市场中小市值公司的股票价格表现。        创业板指数：聚焦于深圳证券交易所创业板上市的公司，反映创业板块的整体表现，包含100只样本股。        上证180指数：挑选上海证券市场规模大、流动性好、行业代表性强的180只股票作为样本股，是上证50指数的扩展版。        深证100指数：由深圳证券市场中总市值排名前100位的股票构成，侧重于深圳市场的优质蓝筹股。        中证800指数：结合沪深300和中证500指数，由这两个指数的所有成分股组成，更加全面地覆盖大、中、小盘股。        上证380指数：反映上海证券市场中小型潜力蓝筹公司的整体状况，与上证180指数形成互补。        中证1000指数：选取中证800指数样本股之外规模偏小且流动性好的1000只股票组成，进一步覆盖小盘股市场。  这些指数各有特点，为投资者提供了丰富的市场分析工具和投资标的，适用于不同的投资策略和风险偏好。5.2 名词解释5.2.1 涨停和跌停涨停和跌停是股票交易中用于控制股票价格日内波动幅度的机制，常见于某些证券市场，尤其是中国A股市场。其具体定义如下：      涨停：当一只股票的价格上涨至证券交易所规定的当天最大允许涨幅时，即达到了涨停板，之后在当天的剩余交易时间内，该股票的价格不再上涨。在中国A股市场，普通股票的涨停限制通常是前一交易日收盘价的10%。对于特别处理的股票（ST股）或其他特定情况，如部分板块的新股上市初期，涨跌幅限制可能有所不同。        跌停：与涨停相反，当一只股票的价格下跌至证券交易所规定的当天最大允许跌幅时，即达到了跌停板，之后该股票价格在当天剩余时间里不再下跌。同样，在中国A股市场，普通股票的跌停限制也是前一交易日收盘价的10%。ST股和其他特定情况下的跌停限制可能为前一交易日收盘价的5%。  实施涨停跌停制度的目的主要是为了：  稳定市场：防止市场价格因短期剧烈波动而导致的市场恐慌或过度投机行为。  保护投资者：为投资者提供一定的缓冲时间，以便他们对市场信息做出反应，减少极端价格变动带来的风险。  促进理性投资：鼓励投资者基于公司基本面进行投资决策，而非仅凭市场情绪进行交易。需要注意的是，尽管价格达到涨停或跌停后不再变动，但在此价位上仍可以继续进行交易，只是价格不会超出限制范围。此外，某些特殊类型的证券（如权证）或在特定市场条件下（如新上市股票的首个交易日）可能不受此限制。5.2.2 科创板科创板，全称“上海证券交易所科创板”或称为“科技创新板”、“STAR Market”，是上海证券交易所下设的一个独立板块，旨在为科技型和创新型中小企业提供一个直接融资的平台。科创板的设立是中国资本市场改革的重要举措，它在2018年11月5日由国家主席习近平在首届中国国际进口博览会开幕式上宣布，并于2019年6月13日正式开板，7月22日迎来了首批公司上市。科创板的特点和目标主要包括：      服务对象：主要服务于符合国家战略、掌握关键核心技术、市场认可度高的科技创新企业，特别是那些处于高新技术产业和战略性新兴产业中的企业，如新一代信息技术、高端装备、新材料、新能源、节能环保以及生物医药等领域。        注册制试点：科创板实行注册制，相较于传统的审核制，注册制更强调信息披露，简化上市流程，提高市场效率，同时强化事后监管。        投资门槛：对个人投资者设置了相对较高的准入门槛，要求开通前20个交易日证券账户及资金账户内的资产日均不低于人民币50万元，并且有两年以上的证券交易经验。        市场机制：科创板在交易规则、退市机制等方面进行了创新，比如放宽涨跌幅限制（新股上市后的前5个交易日不设涨跌幅限制，之后每日涨跌幅放宽至20%）、实施更加灵活的交易机制等，以增强市场的流动性和价格发现功能。        支持政策：科创板得到了一系列政策支持，包括但不限于融资便利、税收优惠、研发投入支持等，旨在培育和促进科技创新企业发展。  科创板的设立体现了中国对于科技创新和高质量发展的重视，旨在通过资本市场的力量加速科技成果转化，推动产业升级，同时也是中国资本市场国际化和市场化改革的重要探索。"
  },
  
  {
    "title": "1.五险一金",
    "url": "/posts/wuxianyijin/",
    "categories": "MyNotes, 2_WuXianYiJin",
    "tags": "",
    "date": "2020-12-30 13:47:00 +0800",
    





    
    "snippet": "〇、待办  个人养老金  职工社保缴费记录查询一、社保1.1 社保的概念社保的全称是社会保险，是一种为失去劳动能力、暂时失业或因健康原因造成损失的人口提供收入或补偿的一种社会和经济制度。特点：属于强制性保险，主要目的是为了维持劳动力的再生产。1.2 社保的内容养老保险、医疗保险、失业保险、工商保险、生育保险。1.3 社保的类型1.3.1 社保类型细分      城乡居民社保         ...",
    "content": "〇、待办  个人养老金  职工社保缴费记录查询一、社保1.1 社保的概念社保的全称是社会保险，是一种为失去劳动能力、暂时失业或因健康原因造成损失的人口提供收入或补偿的一种社会和经济制度。特点：属于强制性保险，主要目的是为了维持劳动力的再生产。1.2 社保的内容养老保险、医疗保险、失业保险、工商保险、生育保险。1.3 社保的类型1.3.1 社保类型细分      城乡居民社保              农村社保（农村养老、新农合）        城镇居民社保（城镇居民养老、居民医保）              城镇职工社保              职工社保（职工养老，职工医疗，生育保险，工伤保险，失业保险）        灵活就业人员职工社保（职工养老、职工医疗）            1.3.2 社保类型合并      1.3.2.1 新型农村社会养老保险和城镇居民社会养老保险的合并    中国国务院总理李克强2014年2月7日主持召开国务院常务会议，听取关于2013年全国人大代表建议和全国政协委员提案办理工作汇报，决定合并新型农村社会养老保险和城镇居民社会养老保险，建立全国统一的城乡居民基本养老保险制度      1.3.2.2 新型农村合作医疗和城镇居民基本医疗保险的合并    2016年1月《国务院关于整合城乡居民基本医疗保险制度的意见》发布。《意见》指出整合城镇居民基本医疗保险（以下简称城镇居民医保）和新型农村合作医疗（以下简称新农合）两项制度，建立统一的城乡居民基本医疗保险（以下简称城乡居民医保）制度。1.3.3 合并后社保类型      城乡居民社保（城乡居民基本养老保险、城乡居民基本医疗保险）    城镇职工社保              城镇职工社保（城镇职工基本养老保险、城镇职工基本医疗保险，生育保险，工伤保险，失业保险）        灵活就业人员社保（灵活就业人员养老保险、灵活就业人员医疗保险）            1.4 社保间的区别1.4.1 职工社保和居民社保的区别  两者从本质上看是没有区别的，但是需要注意的是，两者不能同时缴纳，也就是说，如果你交职工社保就不能交居民社保，交居民社保就不能叫职工社保。当然，如果资金充足的话，还是交职工社保好，因为60岁之后我们才能拿到更多的养老金。            内容不同      居民社保：有两项保险，城乡居民基本医疗保险，城乡居民基本养老保险。  职工社保：主要有五项保险，分别为养老保险，医疗保险，失业保险，生育保险，工伤保险。              组成不同      居民社保：费用全由自己负责，2018年缴费为220元，其中120归为社会统筹，100放入个人账户。  职工社保：总的缴纳费用由自己和单位承担，由自己缴纳8%存入个人账户，单位缴纳12%归为社会统筹，60随后，作为退休职工，可以拿到的养老金为：基础养老金+个人账户养老+过渡性养老金。      1.4.2 职工社保和灵活就业人员社保的区别      缴费的限制不同：公司会为职工缴纳五险一金，国家强制规定公司和员工需要参与社保。而灵活就业者是以个人为名义缴纳社保的，灵活就业者的下岗、工伤和生育保险不需要列入缴纳范畴，只需交养老保险和医疗保险就可以；    承担的费用不同：以灵活就业者身份缴纳个人社保的成本要比职工缴纳个人社保承担的费用要大一些。公司职工在缴纳养老保险时费用是由公司和个人一同承担，个人需要缴纳8%的比例，其他的20%由公司来承担，而灵活就业者就要个人承担20%的比例；    享有待遇不同：公司员工一般男性达到60岁，女性达到50岁，女性干部达到55岁就能提出退休申请，而灵活就业者要依据法律法规的要求，男性达到60岁，女性达到55岁才能提出退休申请；    险种的待遇不同：公司职工除了医疗保险和养老保险之外也有别的三种保险待遇。而灵活就业人员仅能享受养老保险和医疗保险的待遇。  1.5 社保的转移和接续1.5.1 办理转移的情况      1.5.1.1 涉及社保类型    我们常说的社保是指养老保险、医疗保险、生育保险、工伤保险、失业保险，其中，工伤及生育保险属于“当期交纳当期享受”的险种，并不存在转移的问题。失业保险的转移主要是指您在领取失业保险金期间进行的跨省转移。所以，涉及到异地转移的社保主要是指养老保险、医疗保险。            1.5.1.2 涉及统筹区        同省同市不同地不需要转移。    同省不同市得参考本省是否实现省级统筹，实现的可以不转。    异省需要转移。        1.5.1.3 涉及年龄限制    社保的异地转移通常对参保人有年龄限制，一般会要求男性在50周岁以下，女性在40周岁以下才能转入，如超过这个年龄，就很难再异地转入了。这一政策视不同地区政策而定，具体可以拨打当地12333详询当地社保局。1.5.2 社保关系转移            1.5.2.1 居民转居民        未领取养老金，户口迁移，但仍在同一区县的，社保无需转移    未领取养老金，户口迁移，不在原区县的，社保需要转移，只要带上社保卡和户口本到转入当地的乡镇（街道）事务所、县社保局提出转入申请就行    已领取养老金，户口迁移，不在原区县的，社保无需转移        1.5.2.2 居民转职工    从城乡居民养老保险转入城镇职工养老保险时，缴费年限不累计计算也不折算。      1.5.2.3 职工转居民    从城镇职工养老保险转入城乡居民养老保险时，职工养老保险缴费年限可以合并累加计算为城乡居民养老保险缴费年限。只转移个人账户存储额，不转移统筹基金。      1.5.2.4 职工转职工    职工养老保险可以分为“一般账户”和“临时账户”两种类型。一般账户就是我们通常缴纳的账户。临时账户是50周岁以上男性、40周岁以上女性，在非户籍地首次参保所建立的社保账户。临时账户只起到一个过渡作用，并不具备退休的条件。“临时账户”人员想要满足退休并领取养老金的资格，在达到法定退休年龄前，将户籍迁入新就业参保地，从户籍迁入的次月开始，就能申请将新就业参保地所建立的“临时账户”调整为“一般账户”，然后依据规定领取养老金。  所以男性一定要在50岁之前，女性定要在40岁之前去办理转移，因为一旦超过了这两个年龄，你在新的参保地就只能去交临时社保了，不能在新参保地退休。  可以累计年限，个人账户部分8%会全部转移，统筹基金部分会转移缴纳基数的12%，也就是缴纳部分的60%。  Q：如何决定社保关系是否转移？  A：社保到底要不要转移，做决定前，先问自己以下三个问题：      未来还会不会回工作地工作?    是否临近退休年龄，需要开始办理退休手续了?    新单位或就业地有没有要求必须转移社保?    如果新工作单位或新就业地社保经办机构无硬性规定必须转移社保；您也暂不能确定未来是否会回工作地工作；未临近退休年龄(不确定待遇领取地)的，建议您先不要转，把社会保险暂时留置在工作地。  如果您决定辞职回老家/其他城市，且不再考虑回工作地参加工作，不会在工作地办理退休，那么您可以进行社保关系转移。      1.5.2.5 灵活转职工    灵活就业养老保险可转为职工养老保险，并将积累以前具体缴费期限。灵活就业个人所参加的养老保险，是属于城镇职工养老保险的范畴。而我们企业单位所参加的基本养老保险，也是属于城镇职工养老保险的范畴。二者之间是没有任何的区别，所以说灵活就业人员那么找到新的工作单位以后，就可以将自己的社保关系，转移到企业单位来继续参保，这个时候你就可以有灵活就业的社保转移，成为了企业单位的社保。      1.5.2.6 职工转灵活        职工最先需要按照规定与公司消除或是停止劳务关系；    随后需要以灵活就业人员的身分去申请社保登记；    再由个人社保经办机构审批；    最终审批通过的，给予登记备案。    以前具体缴费期限可以累计。1.6 社保的断缴和补缴1.6.1 社保补缴的类型            单位申报月报补缴      用人单位因未按时缴纳当月社会保险费导致单位整体欠费，需对欠缴的社会保险费进行整体还欠。              单位申报个人补缴              漏月补缴：由于用人单位原因漏缴(未按时缴纳)职工社会保险费的，用人单位须及时为职工办理补缴手续。        基数差补缴：用人单位未为职工足额缴纳社会保险费的，用人单位须及时为职工办理基数差补缴手续。        社平差补缴：由于社平基数发布时间晚于社保年度基数调整月，导致用人单位只能按参保人员原社保缴费基数缴纳社保费。当参保人员原缴费基数低于新发布的社平最低下限时，系统会自动生成社平基数差补缴记录，参保单位须及时办理职工社平差补缴。            1.6.2 社保的补缴  在职期间，因用人单位漏缴、错缴等原因导致职工社保断缴的，可由用人单位出具相关资料向人社部门提出补缴申请，然后通过用人单位补缴。如果是因为离职、换工作等个人原因导致社保断缴的，个人是无法办理补缴的。1.6.3 社保断缴的影响      对公积金的影响：公积金贷款的前提条件是连续缴满6个月（或者12个月），一旦中断，也就意味着接下来半年（或者1年）肯定不能使用公积金贷款了；    对生育报销的影响：对女性来说，享受生育报销和津贴的前提条件是连续缴满6个月（或者12个月），一旦中断，生育保险的福利也没有了；    对买房落户、买车拍牌的影响：1、对在大城市生活的人来说，买房、车牌摇号竞价、落户、小孩上学、旅游签证、甚至包括公务员报考等等公共事务的资格均和社保挂钩，有些甚至要求连续5年以上，你社保一旦中断，也就意味着5年的时间成本白白流失；2、北京积分落户申请人在京连续缴纳社会保险满7年，是申报北京积分落户的必要条件之一，期间断缴可补缴但补缴记录超出5个月没有申报资格；3、非京籍人员申请北京小客车摇号，对社保的要求是：近5年(含)连续在本市缴纳社会保险，也即申请月的上一个月开始往前推算60个月连续，不能断月(如有断月，补缴后有效)。如果不补缴，就会影响摇号。    对医保报销的影响：按规定，医保需要连续缴费满6个月，才能享受报销政策，缴纳医保的次月起，就可以刷卡使用个人账户余额，断缴当月或次月，社保卡就无法报销医疗费用，但里面的余额还是可以使用的。    对养老金的影响：国家规定至少缴满15年，退休之后才能领取养老金。如果中间有断缴的，断缴时间不能计入缴费年限，只有员工足额补齐所欠保费和利息之后，才开始继续计算缴费年限。  1.7 一些问题1.7.1 离职没找到工作，社保怎么办  如果已经离职又没有找到合适的工作接续社保该怎么办，可以及时到户籍地以灵活就业人员身份参加社保，这样也能让自己的社保不间断。但是无法缴纳公积金，外地户口无法自己缴纳社保，但可以通过无忧保缴纳五险一金。1.7.2 换工作如何避免社保断缴  一般来说，一家公司一般都是在每月15号给员工缴纳社保。所以，如果要辞职，也要等到当月15号以后，等公司交完这个月的社保，然后在下个月的15号前找到工作。这样下家公司就会把下个月的社保也给你缴上，就不会出现断缴。二、养老保险2.1 养老保险类型  城乡居民基本养老保险  城镇职工基本养老保险  灵活就业人员养老保险2.2 城乡居民基本养老保险2.2.1 参保      2.2.1.1 参保登记    参保人携带相关材料到户籍所属乡（镇）、社区办理城乡居民基本养老保险参保登记和待遇领取手续。      2.2.1.2 参保条件    《国务院关于建立统一的城乡居民基本养老保险制度的意见》(国发〔2014〕8号)规定，年满16周岁(不含在校学生)，非国家机关和事业单位工作人员及不属于职工基本养老保险制度覆盖范围的城乡居民，可以在户籍地参加城乡居民养老保险。养老保险是可以在异地缴纳，但是在异地缴纳养老保险需要和单位建立劳动关系，由单位代缴，本人不能个人在异地缴纳养老保险。而个人缴纳养老保险是需要在户口所在地申请缴纳。2.2.2 缴费      2.2.2.1 缴费时间    每年的1月1日至当年11月25日前，当年缴纳保费人员享受政府补贴，补缴往年欠费的不享受。每月25日前可办理当年缴费和补缴往年保险费业务，年度截止收费期通常为本年度的11月25日。      2.2.2.2 缴费方式    参保人可以通过税务局营业厅进行保费缴纳，也可以通过银行、微信、支付宝、云闪付等方式进行缴费。      2.2.2.3 缴费档次    Z2019起 ：已经缴费的年度，是不能变更缴费档次的；应缴未缴年度可选择当年的任一缴费档次进行补缴；新参保年度可选择任一缴费档次缴纳，个人多缴纳政府多补助。2019年起，我市各县区城乡居民基本养老保险缴费设置200元、300元、500元、1000元、3000元、5000元、8000元7个档次，按年缴费。      2.2.2.4 补缴    凡45周岁以上男性和40周岁以上的女性，均可参与行养老保险补缴，缴费次月享受待遇。  城乡居民养老保险补缴时间截至到每年的12月31日。大多数地方要求城乡居民养老保险的缴费时间是每年的6月31日之前，如果参保人错过了缴费时间，可以及时进行补缴。城乡居民养老保险补缴时间截至日期是每年的12月31日，如果12月31日之前没有补缴，城乡居民养老保险就是断交了一年。            情况1：新农保或城居保制度实施时，已满60周岁，且未领取过国家规定的基本养老保险待遇的，可不用缴费，可以按月领取城乡居民养老保险基础养老金。      例如：2011年7月城镇居民社会养老保险制度实施时，城镇户籍的王大爷65周岁，可以不缴费，直接按月领取城乡居民养老保险基础养老金。              情况2：当地制度实施时，距规定领取年龄不足15年的，应逐年缴费，也允许补缴，累计缴费年限不超过15年，补缴不享受政府补贴。补缴的档次不得超过当年制度实施时设定的最高缴费档次标准。      例如：2009年12月新农保制度试点时，农业户籍的李大爷53周岁，应连续7年缴费至满60周岁时，下月起按月领取城乡居民养老保险待遇，也可以补缴城乡居民养老保险费，累计缴费不超过15年。      比如某参保人选择的缴费基数是每年200年，补贴35年，他在2020年及时交了可以按200元+35元计入个人账户，但是2021年断交了，如果2022年补交2021年度应交的200元，则只能按照200元计入个人账户，就没有35元补贴。              情况3：制度实施时，距规定领取年龄超过15年的，应按年缴费，累计缴费15年及以上才能领取养老金。      例如：2012年7月城乡居民社会养老保险制度启动时。张大姐42周岁，应按年缴费，累计缴费满15年及以上，到年满60周岁时，下月起可按月领取城乡居民养老保险待遇。      2.2.3 补贴      2.2.3.1 特殊人群补贴    对参加城乡居民养老保险的致贫返贫人员、低保对象、特困人员、重度残疾人等特殊群体，政府继续按100元/年为其代缴城乡居民养老保险费，并享受相应的政府补贴，对多重身份的，只按一种身份计算。从2022年1月1日起，建档立卡脱贫人口不再享受政府代缴100元的优惠政策，但仍保留100元的缴费档次。对达到领取城乡居民基本养老保险待遇年龄的建档立卡脱贫人口，未领取国家规定的基本养老保险待遇的，可以不再补缴养老保险费，由户籍所在地经办机构为其办理待遇领取手续，次月起按月计发待遇。      2.2.3.2 政府补贴    选择100元、200元缴费档次的，政府补贴30元，200元以上档次的，缴费每提高一个档次，政府补贴增加15元，其中：300元档次补贴45元、500元档次补贴60元、1000元档次补贴75元、3000元档次补贴90元、5000元档次补贴105元、8000元档次补贴120元。        2.2.3.3 基础养老金的倾斜指标    在待遇计发上，我市各县区向下列人员适当予以倾斜：① 参保缴费人员累计缴费年限超过15年，缴费年限每增加1年，月基础养老金增加1元，补缴年限不用于计算年限基础养老金。② 领取待遇人员年满65周岁后，就可以领取高龄基础养老金，其中65-74周岁待遇领取人员的高龄基础养老金是每人每月1元，75-81周岁的高龄基础养老金是2元，85周岁及以上的高龄基础养老金是3元，上述两项政策可叠加享受。      2.2.3.4 丧葬补助金制度    城乡居民养老保险参保人员因病非因工死亡的，享有一次性丧葬补助金，补助金标准为：已按月领取城乡居民养老金人员，按照死者生前应发12个月的基础养老金发放；未达到按月领取基础养老金的人员，按其缴费年限计算，每缴费一年计发1个月的基础养老金，最多不超过12个月。另，个人账户有余额的，余额和丧葬补助金一并结清。2.2.5 资格认证  社保经办机构对领取城乡居民基本养老保险待遇的人员每年必须认证两次，上半年1至4月一次，下半年7到10月一次。如未按规定时间认证，则进行待遇暂停发放，待下次认证后再予以补发。可以通过“人社手机APP”软件进行认证。确实无法通过“人社手机APP”软件认证的，到县区社保经办机构指定认证场所进行认证。2.2.6 养老待遇      2.2.6.1 基础养老金    Z2019起2020-07-01起：113元**Z2019起2022-07-01起**：118元      2.2.6.2 计算办法    月领取养老金 =（个人缴费总额 + 政府补贴总额 + 利息）÷ 139 + 基础养老金 + 年限基础养老金 + 高龄基础养老金。2.2.7 领取政策  参加养老保险的城乡居民个人，年满60周岁、累计缴费满15年，且未领取国家规定的基本养老保险待遇的，可按月领取城乡居民养老保险待遇。  新农保、城乡居民养老保险实施（各旗县区试点启动之日）时，已年满60周岁人员，不用缴费，可按月领取基础养老金。因个人原因造成未领取待遇的，自按规定申请的次月领取养老金。2.2.8 缴费记录查询  2019年之后的可以在公众号菜单“社保服务→缴纳社保费→城乡居民社保费”的【缴费记录查询】中查询，之前年份的可能需要到社保部门进行查询。2.3 城镇职工基本养老保险2.3.1 参保  按照现行城镇职工养老保险的参保政策来说，不管是企业职工，还是城镇居民，亦或是城乡居民都是可以参加的，职工养老保险并没有设置参保门槛。也就是说，只要个人或者家庭经济承受能力足够，即使你不参加工作，也同样可以参加城镇职工养老保险。现目前想要参加城镇职工养老保险，可以通过两个方式参加：  第一，通过参加工作的方式，由企业为职工购买城镇职工养老保险，一般来说企业职工参加城镇职工养老保险，单位承担缴费比例的20%，而个人只需要承担缴费比例的8%。  第二，不论是城镇居民，还是城乡居民，亦或是农民，甚至是无业游民，只要个人经济承受能力足够，都是可以通过以灵活就业的方式参加城镇职工养老保险，其中缴费比例一般是20%。2.3.2 缴费      2.3.2.1 缴费时间    每月1-10日      2.3.2.2 缴费基数    缴纳社会养老保险的缴费基数是根据当地上一年度职工月平均工资来定的，上限为300%，下限为60%。如果大家的工资收入低于上一年度职工月平均工资的60%，就按60%为缴费基数来进行缴纳；如果高于300%的，就按照300%来进行缴纳；如果在60%-300%之间的，就按照实际数值来进行缴纳。      2.3.2.3 缴存比例    一般城镇职工社会养老保险都是以职工上年度个人工资收入来作为缴费基数，总缴费比例为28%，其中企业需要承担20%，个人只需承担8%；单位缴纳的20%全部划入统筹账户，个人缴纳的8%全部划入个人账户。      2.3.2.4 补缴    如果是因为单位的原因导致职工养老保险断交的话，那么员工是可以要求工作单位为我们将所欠缴的费用进行补缴。若用人单位不予补交，那么员工可以向当地劳动局或社保局进行投诉，由相关部门责令用人单位予以改正，补交职工养老保险。如果我们已经没有工作的话，那么我们可以自由就业的方式进行补缴，前往当地的社保局办理补缴手续就可以了。  Q：补缴算连续记录吗？  A：看城市政策具体要求，北京摇号补缴算连续记录，积分落户补缴不超过5个月且没有断缴记录，就算连续。  Q：养老保险交满15年后可以不交吗？  A：社保交满15年后可以不再交费。如果有单位，即使缴满15年，但职工还未退休的，企业还得继续缴费，直至退休；个人缴纳社保的话，可停缴，也可继续缴纳，根据当地政策，肯定也是继续缴纳好，养老保险是遵循“多缴多得”的原则，缴费基数越高、年限越长，退休时领取养老金也越多。      2.3.2.5 断缴    养老保险断交两个月对于用户的影响不大。养老保险规定只要累计缴费满15年就可以在达到法定退休年龄之后享受养老保险待遇，短短两个月的影响并不大。但是对于一些要求社保连续缴费来进行落户的城市来说，断交2个月，可能就会导致个人的落户时间被推迟。2.3.3 养老待遇      2.3.3.1 计发月数    在不同年龄办理退休，计发月数也是不同的，比如咱们常见的50岁办理退休，计发月数就是195个月；55岁办理退休，计发月数就是170个月；60岁办理退休，计发月数就是139个月。如果缴费年限不满15年需要延迟退休，或者是提前办理退休的情况下，比如45岁办理退休，计发月数就为216个月；62岁办理退休，计发月数就为125个月了。  在计算个人账户养老金时，计发月数越高，个人账户养老金也就越低，反之，个人账户养老金就会越高，那两者是成反比关系的，而退休年龄也和计发月数成反比关系，退休年龄越小，计发月数也就越高，退休年龄越大，计发月数就会越低。  Q：按计发月数领完后养老金会减少吗？  A：虽然个人账户余额没有了，但是个人账户养老金还是会照常发放的，只不过这部分金额转为统筹账户支付了，而养老金也并不会减少。      2.3.3.2 计算办法    北京养老金计算公式：退休时月基本养老金 = 月基础养老金 + 月个人账户养老金 + 月过渡性养老金 + 月调节金（1）月基础养老金 = (本市上年度所有职工的月平均工资 + 本人指数化月平均缴费工资) ÷ 2 × 缴费年限 × 1% （2）个人账户养老金 = 个人账户的余额 ÷ 计发月数(50岁为195、55岁为170、60岁为139) （3）月过渡性养老金 = 职工本人指数化月平均缴费工资 × 建立个人账户前的本人视同缴费年限 × 1.2%（4）月调节金计发标准：职工建立个人账户前的本人视同缴费年限满15年及以上者，每月每人发给15元（5）职工本人指数化月平均缴费工资 = 职工本人平均缴费工资指数 × 本人退休时上年度全省城镇非私营单位在岗职工月平均工资（6）职工本人平均缴费工资指数 = 建立个人账户当年至退休上年度本人历年缴费工资指数的平均值      视同缴费年限是指参加工作时间到建立个人账户前符合政策规定计算的连续工龄（不含折算工龄）。    实际缴费年限是指从建立个人账户起至退休时的缴费年限。    全部缴费年限 = 视同缴费年限 + 实际缴费年限（实际计算中要将缴费年限换算成年，保留两位小数）。    1996年1月之后参加工作的“新人”，工资构成没有过渡性养老金及调节金，月基本养老金合计 = 基础养老金 + 个人账户；1996年1月之前参加工作的“老人”，工资构成才有过渡性养老金及调节金，月基本养老金合计 = 基础养老金 + 过渡性养老金 + 个人账户 + 调节金（建账前缴费年限满15年及以上者有15元）  例如：李某07到11年，每年养老保险的个人实际缴费基数和当年的社会平均工资分别假设为，07年3000和3500，08年3200和4000，09年3500和4200，10年3600和4200，11年3800和4500，12年年初开始，李某开始领取养老保险金。而11年当地社会平均工资为4500元，他退休年龄为60岁，当时个人账户总储值为50000元，缴纳年度一共为15年。      计算个人平均缴费指数那么李某07到11年这5年时间的个人平均缴费指数，应该这么计算个人平均缴费指数 = (07年个人实际缴费基数/07年社会平均工资 + 08年个人实际缴费基数/08年社会平均工资 + 09年··· + 11年个人实际缴费基数/11年社会平均工资) ÷ 5 = (3000/3500 + 3200/4000 + 3500/4200 + 3600/4200 + 3800/4500) ÷ 5 = 0.838    计算指数化月平均缴费工资指数化月平均缴费工资 = 上年度社会平均工资 × 本人平均缴费指数 = 4500 × 0.838 = 3771    计算基础养老金基础养老金 = (上年度社会月平均工资 + 本人指数化月平均缴费工资) ÷ 2 × 缴费年限 × 1% = (4500 + 3771) ÷ 2 × 15 × 1% = 620元  2.3.4 领取政策            2.3.4.1 退休政策        正常退休              男年满60周岁，女管理和专业技术岗位年满55周岁、女非管理岗位年满50周岁；        缴费年限（含视同缴费年限）累计满15年；              因病提前退休（职）              依照劳动鉴定程序经市或区（县）劳动鉴定委员会鉴定达到完全丧失劳动能力；        缴费年限（含视同缴费年限）累计满15年。              特殊工种提前退休              男年满55周岁，女年满45周岁；        缴费年限（含视同缴费年限）累计满15年；        工种须经北京市人力和社会保障局职工养老保险处备案确认（原为北京市劳动和社会保障局养老保险处），其中从事高空、特别繁重体力劳动工种工作累计满10年，从事井下、高温工种工作累计满9年，从事其他有害身体健康工种工作累计满8年。        按照《关于进一步加强基础管理，规范退休核准工作有关问题的通知》第四条规定进行了公示，并在公示期内不存在异议的。              目前政策，养老最低需交够15年。如果到了国家规定的法定退休年龄，社保累计缴费年限不足15年的，按照规定退休后是不能按月领取养老金的。有三种方法解决：      办理延迟退休，但是退休延迟时间不能超过5年，继续缴纳社保至缴费满15年，而后就可以按月领取养老金。    将社保转为新农合。    一次性补缴社保满15年。        2.3.4.2 退休地政策    在多地参加社保，哪个地区交够10年，在哪领退休金。各个地方都不满10年，在户籍所在地领取，如果多地分别满10年，在最后缴纳满10年的工作地领取。      如果参保的地方和户籍所在地一样的话就可以在当地领取。    举个例子：退休之前虽然换过不同单位，但你一直在北京工作，又是北京户籍，就可以在北京领取。    如果参保的地方和户籍所在地不一样的话，那么就在缴纳满十年的地方领取养老金。   举个例子：你是上海户籍，在上海缴纳了5年，又在北京缴纳了11年，那么就在北京领取养老金。    如果有多个地方都缴纳满十年了，那么就在最后缴纳满十年的工作地领取。    举个例子：你是山东户籍，北京交了1年，上海交了4年，杭州交了10年，武汉交了10年。最后十年是在武汉缴费，那就可以在武汉领取养老金。    如果多地工作都不满十年的话，参保人的养老关系和相关的资金就要转到你的户籍地，在户籍地领取。   举个例子：你是北京户籍，北京交了5年，上海交了8年，杭州交了9年，那么最后是在北京领取养老金。        2.3.4.3 在北京退休的条件    外地城镇户籍人员在北京办理退休手续，申请按月享受养老保险待遇需满足4个条件：      第一，达到法定退休年龄。    第二，累计养老保险缴费年限十五年。    第三，累计在北京缴纳养老保险年限十年。    第四，4050前在京参保（女40周岁，男50岁简称“4050”）。    第五，退休当月必须在京正常缴费。  2.3.5 缴费记录查询2.3.6 转移和接续      2.3.6.1 转移步骤        登录“国家社会保险公共服务平台”，首次登录用户需先按操作提示完成【注册】，再点击【养老保险】进入【养老保险关系转移申请】；    点击【养老保险关系转移申请】后系统会弹出“身份验证”页面，请根据提示【点击进入】；    请按照提示选择任一问题进行验证，确认填写无误后点击【提交】；    认证成功后，点击【确定】；    进入“养老保险关系转移转移申请”页面，依次选填“本人基本信息”及“转移信息”；    点击【添加转出地】后正确选填转出地信息，保存后提交转移申请；    申请信息的确定和提交；    接收短信提示及反馈意见。        2.3.6.2 基金的转移    (1)单位缴费部分(统筹基金)      账户类别为“一般账户”的转移人员其统筹基金按本人1998年1月1日后各年度实际缴费基数的12%的总和计算转移。    账户类别为“临时账户”的转移人员，实际缴费比例高于12%的，按实际缴费比例计算转移金额；低于12%的，按12%计算。    (2)个人缴费部分  按个人账户储存额转移。其中：      1998年1月1日之前的，按个人缴费部分累计本息转移；    1998年1月1日至2005年12月31日期间的，按个人缴费基数的11%(含本息，下同)转移；    2006年1月1日之后的，按个人缴费基数的8%转移。  2.4 灵活就业人员养老保险2.4.1 灵活就业人员养老保险模式分为统账结合和只有统筹账户两种模式。统账结合的模式，即既有统筹基金账户，也建立了个人账户，缴费比例一般为8%左右。其中计入统筹基金账户的比例为6%，计入个人账户的比例为2%，这个比例和在岗职工是一样的，其中根据本人的年龄结构，计入统筹账户的部分还要返还一定的比例到个人账户。返还到个人账户的钱，就是每月返还到社保卡的钱，可以凭本人的社保卡到药店去买药，去医院的门诊看病或是用于支付住院费用中个人需要自费部分的医疗费用。如果只有统筹账户的模式，缴费基数还是按照上年度职工月平均工资，但是缴费比例只有4或是5%左右，只建立了统筹基金账户，没有个人账户，也就是个人应当返还的部分就不返还了，只有在住院时才能报销医疗费用，没有门诊费用。很多地方把建立个人账户分为两档缴费，即高档缴费就是建立了个人账户的，低档缴费就是没有建立个人账户的。凡是缴纳职工医疗保险的人员，缴费年限都会累计计算，今后随着本人的流动，医疗保险关系也会随之进行转移。2.4.2 参保在平时办理的医疗保险种类中并没有灵活就业医保的概念，很多灵活就业人员缴纳的医保，其实就是职工医疗保险，只不过灵活就业人员由于没有用人单位，需要全额来缴纳的医疗保险费用。灵活就业人员缴纳的职工医疗保险，一般只能在户籍所在地办理，是以上年度在岗职工月平均工资来作为缴费基数，缴费比例为8%。  Q：参加灵活就业养老还可以参加城乡居民医保吗？  A：我们按照灵活就业的方式，是可以选择缴纳职工养老保险和职工医疗保险。这两种保险是可以同步参保，当然也是可以单独参保，有一部分群体在选择参加灵活就业社保的过程中是同步参保的，也就是说职工养老保险和职工医疗保险都进行了参保，那么最终自己能够享受到的待遇，当然是可以享受职工医保的报销，同时也可以享受职工养老金的待遇。  但如果说你没有参加职工医疗保险，仅仅只是单独参加的职工养老保险，这种情况下你肯定是无法享受职工医保的报销，但是有些人又想让自己拥有一份医疗保险，那么是可以去参加城乡居民医疗保险的，也就是说，你没有参加职工医疗保险的前提下，参加城乡居民医疗保险没有问题，单独去享受居民医保的报销，是没有任何的问题。  Q：灵活就业人员社保缴费必须在户口所在地吗？  A：灵活就业人员可以在户籍所在地或者工作地参加社保。需要注意的是，目前只有部分地区适当的放宽了限制，如果在该地长期居住并拥有居住证，可以前往居住地所在的人社局政务服务大厅，以灵活就业人员的身份申请参加职工社保。  也就是说，灵活就业人员在工作地参保的，要按照规定在当地办理就业登记证和居住证，凭本人的身份证和就业证，在所就业地的街道社保服务机构办理缴费登记，选择缴费档次和缴费方式，也就可以正常缴纳社保了。2.4.3 缴费      2.4.3.1 缴费时间    灵活就业人员社保缴费时间2022年灵活就业人员缴费时间每月10-17日、19-25日的工作日按照《关于明确企业和灵活就业人员社会保险费征缴时间安排的通告》的规定：      自2021年4月起，灵活就业人员社会保险费由税务部门于每月8日、18日（以下简称扣款日）组织各合作银行批量扣款，请确保用于缴费的银行账户余额充足；每月10-17日、19-25日的工作日（以下简称查缴日），个人银行查询缴费业务请在当日15:00前办理。    每月扣款日如遇法定节假日顺延至下一个工作日，因扣款日顺延而占用查缴日时，当天不能进行银行查询缴费。    2022年灵活就业人员缴费除1月略有调整外，其他月份仍遵循以上原则进行缴费。  2.4.4 补贴      2.4.4.1 4050社保补贴    4050社保补贴，一般指的就是就业困难人员灵活就业社保补贴，目前很多地区都有。“4050人员”是国家对大龄就业困难人员的一种称呼，在部分地区，女性年满40岁，男性年满50岁，如果是实现灵活就业的就业困难人员的话，那么自己以灵活就业人员身份缴职工社保通常是可以申请社保缴费补贴的。有些地区可能是4045、4555、4757、4959人员，各地规定不一样。一般各地是要求持有缴费凭证申请补贴，也就是先缴费后补贴的形式。除了大龄失业人员以外，其他符合当地就业困难人员条件的，通常也可以申领这项补贴。总的来说，想要申领灵活就业社保补贴，通常需要满足以下条件：      通过当地就业困难人员认证（各地标准不一样），一般可以咨询所在街道；    实现灵活就业并按规定进行登记；    按规定以灵活就业人员身份自己缴纳职工养老保险、医疗保险。如果是参加的城乡居民养老保险和医疗保险，是无法领取4050补贴的。    一般来说，4050补贴可以申请三年，如果距离退休年龄不足五年，也有地方可以发放五年至退休。补贴标准原则上不超过实际缴费的2/3。比如每月费用为1000元，补贴666元;有的地方则是定额补贴，比如给予每个月600元的社保补贴。可以在2月-4月，到户口所在地进行申请咨询。  另外，在很多地区，除了就业困难人员灵活就业社保补贴以外，还有高校毕业生灵活就业社保补贴，符合条件的离校2年内未就业高校毕业生也可领取补贴。  Q：农村户口可以领4050社保补贴吗？  A：据了解，目前很多地区已经取消了灵活就业社保补贴的户口限制，也就是说，以灵活就业身份参与职工社保缴纳的农村朋友们，如果符合当地规定条件，那么也是可以申请灵活就业社保补贴的。比如，有些地区规定符合条件的失地农民可以申领灵活就业社保补贴，具体以当地规定为准。各地灵活就业社保补贴的申领条件、补贴标准、时间、流程可能都不太一样，可以详细咨询当地社保部门。2.4.5 领取政策      2.4.5.1 领取条件    对于医疗保险缴费年限的规定，由于我国的医疗保险采用的是地市级城市统筹，所以即使在同一个省的范围之内，各个地市的规定也是不统一的。对于缴费年限的计算，有的地方是累计缴费男性达到30年，女性累计达到25年，但有的地方还规定有附加条件，必须要在当地实际缴费达到10年，退休后才能不再缴纳医疗保险，终身享受医保待遇，具体你在哪个城市办理退休，需要按照当地城市的规定来执行。2.4.6 转移接续  开始是以灵活就业人员缴纳的医疗保险，后来又到企业去上班，由用人单位缴纳了职工医疗保险，如果是在一个医疗保险的统筹区内（即同一个城市的范围之内），那医疗保险关系这是不用转移的，可以直接由用人单位通过你原来的缴费账户直接缴费，只要中间的缴费时间是连续的，这可以计算为连续缴费年限；如果中间有断交的情况，属于累计计算缴费年限；如果属于异地缴纳的，比如你原来是在四川按照灵活就业人员缴纳的医疗保险，后来到广东去工作并由单位缴纳职工医疗保险，这就需要将在四川缴纳的医疗保险转入广东，才能累计计算缴费年限。2.5 个人养老金2.5.1 个人养老金定义  个人养老金为我国养老保障体系的第三支柱。第一支柱为基本养老保险，五险一金里强制缴纳。第二支柱为企业年金或职业年金，又称补充养老保险，为企业各自实施。第三支柱则是个人养老金，为个人缴纳，自愿参加。  个人养老资金账户是一个有政策支持和税收优惠的资金账户，是咱们国家专门鼓励个人用来长期累积养老资金的账户！三、医疗保险3.1 医保的类型  城乡居民基本医疗保险  城乡居民基本医疗保险是指将新型农村合作医疗（简称新农合）和城镇居民基本医疗保险（简称城镇居民医保）两项制度整合在一起，建立一个统一的城乡居民基本医疗保险（简称城乡居民医保）制度。而新农合只是保障农民朋友看病就医的一项制度，必须得农村户口才能参保，农村户口还要以家庭为单位整户参保。保障内容是有不同，城镇居民医保主要保住院和门诊大病兼顾普通门诊，所以住院及门诊大病待遇都要高于新农合。另外新农合的门诊待遇要高于城镇居民医保。  城镇职工基本医疗保险3.2 医保个人账户国家财政部发布《关于做好2019年城乡居民基本医疗保障工作的通知》，其中明确表示将实行个人账户的，应于2020年底前取消，已取消个人账户的，不得恢复或变相设置。只有城乡居民医保中的个人（家庭）账户会被取消，城镇职工医保不会受到该《通知》的影响。2022年9月1日前已分配的个人账户资金(即已计入医保专用存折或具有金融功能的社保卡中的资金)仍可随时自由支取。自2022年9月1日起，个人账户资金实行记账管理，参保人员不可自由支取，只能在就医、购药等规定范围定向使用。  Q：城乡居民医疗保险可以药店买药吗？  A：城乡居民医疗保险不可以在药店买药，因为城乡居民保险没有个人账户，其统筹账户只能用于支付参保居民符合规定的门诊、住院费用。3.3 异地就医3.3.1 异地就医备案      3.3.1.1 报销原则    遵循“就医地目录，参保地政策”原则。      3.3.1.2 异地就医备案有效期    一般来说，异地就医备案有效期为6-12个月。关于异地就医备案的有效期各地政策并不统一，因此在备案前建议咨询参保地医保部门进行详细了解。  在外地出差时急诊住院，来不及提前办理异地就医备案的，针对这种情况大部分省市要求住院三日内办理好备案，也有部分省市以住院时间为备案有效期，只要出院前完成备案即可。若是未办理备案直接在异地就医，医保经办机构可以不予报销，不过部分参保地也支持报销，但有降低报销比例的可能。具体的规定需要根据参保地的医保异地备案政策而定，可拨打参保地医保中心的电话咨询。      3.3.1.3 取消京津跨省异地就医备案（2023-02-10起）    进一步方便河北省参保群众到京津看病就医，2023年2月6日，河北省医疗保障局发布《关于取消我省参保群众到京津跨省异地就医备案手续有关事宜的通知》，自2023年2月10日起，河北省参保人员在已开通跨省异地就医住院、门诊费用直接结算的京津医疗保障定点医疗机构和定点零售药店看病就医，不再办理异地就医备案手续，持医保电子凭证或社会保障卡直接结算。  通知明确，自2月10日起，河北省参加职工基本医疗保险和城乡居民基本医疗保险人员，在已开通跨省异地就医住院、门诊费用直接结算的京津医疗保障定点医疗机构和定点零售药店看病就医，不再办理异地就医备案手续，持医保电子凭证或社会保障卡直接结算。  河北省参保群众在京津医保定点医药机构看病就医，执行就医地规定的支付范围及有关规定（基本医疗保险药品、医疗服务项目和医用耗材等支付范围），执行参保地同级别定点医药机构基本医疗保险基金起付标准、支付比例、最高支付限额、门诊慢特病病种范围等有关政策。3.3.2 异地就医直接结算的条件      参保人员已按参保地相关规定办理跨省异地就医登记备案。    住院就医的异地医院已开通全国异地就医直接结算。    已办理过社会保障卡，信息完整并可正常就医使用。  3.3.3 异地就医直接结算流程      先备案：跨省就医之前需要在参保地的经办机构进行备案。    选定点：从公布的名单中选定定点医疗机构，参保人员可登录人社部社会保险网上查询系统（si.12333.gov.cn）查询可供选择直接结算的全国异地定点医疗机构。    持卡就医。  3.4 医保待遇3.4.1 医保报销      住院费用报销   住院费用凡是在医保范围内的，报销70%以上。（异地住院前需要先进行备案，使用社保卡办理住院）    高血压、糖尿病，“两病”门诊用药报销    需先到医保、医院认定后方可报销    慢性病门诊用药报销  需先到医保、医院认定后方可报销    大病报销     超过大病起付线可以报销最低60%以上。  （各地市起付线、报销分段及比例都不一样，具体咨询所在地医保部门即可）  3.4.2 药品分类及报销比例  药品分甲乙丙类：      甲类100%报销    乙类丙类各地略有不同，但都是报销一定比例    丙类是自费，不报销  3.4.3 起付线  同一年度内，第二次及以后住院，起付线减半，与门诊全年累计计算免赔额不一样的是，住院报销的免赔额是每次都要计算的，超过免赔额才能报销。3.5 医保制度延伸3.5.1 大病医疗  医保的“二次报销”其实是城乡居民大病保险报销，它是基本医疗保险制度的拓展和延伸，主要针对大病患者的高额医疗费用，在基本医保支付的基础上给予进一步的支付。 大病保险对病种无限制。经城乡居民基本医保按规定支付后，个人年度累计负担的政策范围内的医疗费用超过大病保险起付标准以上的部分，由大病保险予以保障。3.5.2 门诊慢特病3.6 转移和合并《社会保险法》第三十二条规定：“个人跨统筹地区就业的，其基本医疗保险关系随本人转移，缴费年限累计计算”。也就是说，医保关系转移到其他城市，它的缴费年限也是累积的，不会因为断缴而清零，也不会因为换城市而受到影响。3.6.1转移步骤      登录“北京市社会保险网上服务平台”，点击【查询管理】，在下拉菜单中选择【打印医疗保险转移接续参保凭证】；    认真阅读《转移接续转出业务事项告知承诺书》后点击【确认】；    点击【提交申请】；    界面会生成《基本医疗保障参保(合)凭证》，选择【下载打印】，点击【保存】。  3.7 城乡居民基本医疗保险3.7.1 缴费      3.7.1.1 缴费时间    每年的城乡居民医保缴费时间一般集中在10月至12月之间（个别地区会延长到次年2月底），缴纳下一年度的城乡居民医疗保险。参保人员应在征缴期内每月的1-25日之间缴费。25日下午5：30至当月月底是封账期，不能缴费。            3.7.1.2 补缴        断缴时间在三个月之内补缴的，在这期间发生的住院费用可以报销，这就意味着职工医疗保险的断缴时间在三个月之内的补缴，属于连续缴费年限。    医疗保险缴费断缴时间超过三个月，六个月之内的，允许补缴，但在这期间发生的医疗费用不能报销，通过补缴以后缴费年限计算为连续缴费年限；    断缴时间超过六个月的就不能补缴了，只能作为重新缴费，但重新缴费以后的缴费年限和以前的缴费年限，仍然可以累计计算为缴费年限。    部分地区政策显示，连续缴费超过5年的，自第6年起，二级、三级医疗机构报销比例上调5个百分点。        3.7.1.3 断缴    如果在征缴期内不交医保，可能会有如下影响：      以今年为例，如果不交2021年的医保费用，那么如果在2021年遇到需要住院的情况，要么只能自费，要么补缴了2021年的医保费之后才能报销。补缴的话，不但需要缴纳2021年医保费用及长期护理费，连同财政补贴的550元，也需要您自掏腰包（是不是有些不划算）。    同时，国家正在推行的门诊报销政策（部分地市已出台）也无法享受。    如发生连续断交的，发生的医疗费用可能需要降低报销比例后进行报销，如累计不缴费年限过多，可能不予报销。    如果职工医保断缴超过3个月，个人账户的钱不会清零，累计缴费年限也不会清零，不过连续缴费年限会重新开始计算。    中断缴费3个月以内的灵活就业人员，足额补缴欠缴的医保费后，视为连续缴费，欠缴期间发生的医疗费用予以补支。    中断缴费3个月以上的灵活就业人员，视为初次参保，等待期（6个月）重新计算，自重新缴费之月起6个月后开始享受医保待遇。  3.7.2 补贴      3.7.2.1 特殊人群补贴    1、特殊人群包括      重度残疾人。即残疾等级为一级、二级的视力残疾、听力残疾、言语残疾、肢体残疾、智力残疾、精神残疾和多重残疾的残疾人及四级以上残疾军人；    贫困人员。即具有本地户籍的建档立卡贫困人口（包括已脱贫继续享受政策人口和未脱贫人口）、低保对象、特困人员等困难群体；    部分地区的独生子女、双女户、高龄老人等也作为特殊人群。    2、特殊人群缴费比例  有些需要缴纳部分，有些不用缴纳，具体咨询参保地相关部门。如果在社保医保部门登记为了特殊人群，且在缴费页面提示特殊人群或0档次，那么就可以不用缴费；如果没有提示特殊人群或0档次，需要联系医保部门核实信息状态。  重要提示：低保户、残疾人等特殊缴费人群，需要在登记时提供相应的资料，在医保登记审核通过后才可以享受减免。  3.7.3 医保待遇（Z2021）      3.7.3.1 起付标准    统筹区内乡镇卫生院150元，一级医疗机构及社区卫生服务中心300元，县、区属二级医疗机构400元，市属及其他二级医疗机构800元，三级医疗机构1500元；转外医疗机构3000元。每次住院均扣除起付标准；一个自然年度内多次住院的，县、区属二级及以上医疗机构起付标准依次降低10%，但最低不得低于300元。      3.7.3.2 政策范围内的医疗费用报销标准    统筹区内乡镇卫生院95%，一级医疗机构及社区卫生服务中心85%，县、区属二级医疗机构80%，市属及其他二级医疗机构70%，三级医疗机构60%；转外医疗机构55%。  参保人员符合规定的住院分娩费用按以下标准予以补助：顺产1000元，剖腹产2000元。因产后并发症等产生的符合规定的住院医疗费用纳入统筹基金支付范围。3.7.4 领取政策      3.7.4.1 领取条件    在退休前男性交满25-30年，女性退休前交满20-25年，退休后可以免费享受。如果退休时缴费年限不够，可以一次性补缴剩余费用，然后才可以免费享受。      3.7.4.2 领取条件（北京）    北京女性20年，男性25年。3.8 城镇职工基本医疗保险  Q：医保异地转移时个人账户的余额会转移吗？  A：2021年11月，国家医保局、财政部共同印发《基本医疗保险关系转移接续暂行办法》，明确在办理医保转移接续时，个人账户有余额的，同时办理个人账户余额划转手续，转入地经办机构在核对信息无误后，将转入的个人账户金额计入参保人的个人账户。  也就是，参加职工基本医疗保险的在职人员，将外省市缴费年限转入新参保地时，如果其医保个人账户有剩余资金，个人账户资金将并入新参保地的个人账户，进行统一管理。3.9 电子社保卡和医保电子凭证四、生育保险4.1 生育保险并入医疗保险（2020-01）以前很多地方都不允许灵活就业人员参加生育保险。这也是让人最值得争议的地方，不过好在2019年国家就推动生育保险并入基本医疗保险，未来，只要参加基本医疗保险，就可以享受生育保险待遇了。五、工伤保险工伤保险个人不需缴费，全部由用人单位承担，职工发生事故伤害或者按照职业病防治法规定被诊断、鉴定为职业病，所在单位应当自事故伤害发生之日或者被诊断、鉴定为职业病之日起30日内向统筹地区社会保险行政部门提出工伤认定申请，遇有特殊情况经报社会保险行政部门同意，申请时限可以适当延长，用人单位未按前款规定提出工伤认定申请的工伤职工或者其近亲属、工会组织在事故伤害发生之日或者被诊断、鉴定为职业病之日起1年内可以直接向用人单位所在地统筹地区社会保险行政部门提出工伤认定申请。六、失业保险失业人员应在终止或者解除劳动合同之日起60日内到受理其单位失业保险业务的经办机构申领失业保险金。  Q：失业保险可以领多久？  A：领取失业保险金的期限最长不得超过24个月。      累计缴费时间1年以上不满2年的，可以领取3个月失业保险金;    累计缴费时间2年以上不满3年的，可以领取6个月失业保险金;    累计缴费时间3年以上不满4年的，可以领取9个月失业保险金;    累计缴费时间4年以上不满5年的，可以领取12个月失业保险金;    累计缴费时间5年以上的，按每满一年增发一个月失业保险金的办法计算，确定增发的月数。  七、公积金7.1 公积金缴费7.1.1 缴费时间  公积金一般规定的时间是每月发工资后的5个工作日内内缴纳到公积金账户。7.1.2 缴费基数  为上一年度的月平均工资总额（按照国家统计局有关工资总额构成或者本市工资总额构成的规定确定）。7.1.3 缴存比例  公积金缴纳的比例是“单位+个人”部分合计的，具体范围是单边5%到12%，也就是说单位和个人均不可以低于5%，也不可以高于12%。如果计算合计的话，则缴纳比例是10%至24%之间。7.1.4 补缴  可以补缴，但是补交只能由单位缴纳，个人是不能补缴的。单位存在整体逾期补缴住房公积金行为，且同时符合以下两个条件的，视为正常缴存：① 一次性补缴3个月以内（含3个月）住房公积金；② 缴存行为发生在自最初欠缴月份次月起以内（含3个月）。不符合以上条件的单位逾期补缴以及非单位整体逾期补缴的，视为非正常补缴。7.2 公积金转移接续7.2.1 转接  公积金转接可通过全国住房公积金小程序办理。公积金转移后年限也是累积的。转移公积金后只要公积金无断交的情况出现就算是连续缴存。7.2.2 合并  Q：住房公积金在不同城市可以开两个账户吗?  A：可以，现在国家公积金还没有实现全国联网，故如果在不同省份工作的话，就会涉及到重新开立公积金账户的问题，所以一个身份证号可以在不同城市拥有两个公积金账户。7.3 公积金提取7.3.1 提取条件  非京籍人员与单位解除劳动关系后，住房公积金个人账户封存满半年且未在异地继续缴存，可申请销户提取住房公积金。7.3.2 提取流程  1、登录系统  登录北京住房公积金网（ gjj.beijing.gov.cn ），点击首页右侧【个人网上业务平台】，选择【个人网上业务平台（北京中心）】，点击【注册用户登录】，输入账号、密码和验证码登录北京住房公积金个人网上业务平台办理业务（未注册的用户可在登录页面办理注册开通）。  提示：个人注册仅支持已办理住房公积金联名卡的缴存人。操作步骤：点击登录页面的【注册开通】，根据系统提示，填写校验个人信息，阅读并勾选确认《综合服务渠道个人用户注册协议》，填写联名卡验证信息，设置公积金交易密码和登录密码，完成注册。  2、选择提取事项，录入提取信息  点击页面左侧【我要提取-提取公积金-提取申请】，在新事项申请列表中选择你要办理的提取事项（如租房提取选择第 8 项；如全额购房选择第 6 项；如贷款购房选择第 7 项），进入事项申请页面，系统自动反显用户基本信息。选择【收款人联名卡银行】后系统自动反显相应的银行卡号，将需要填写的内容补充齐全。  3、个人授权、承诺  阅读并勾选《个人信息核查授权、承诺书》，点击【提交】，系统显示提交成功。  4、提交申请，打印回单  在提交成功页面，点击【打印回单】，打印《北京住房公积金管理中心业务凭证回单》，如需查询业务办理机构，点击【经办网点】，点击【确定】，提取申请完成。  提示：申请事项提交成功后，申请人可点击页面左侧【我要提取-提取公积金-提取申请】， 在页面下方“网上可提取事项记录”栏中，点击【查看明细】，可以查询已申请事项详情，点击【打印回单】，可以补打《北京住房公积金管理中心业务凭证回单》。  5、上交材料  以上步骤完成后，请最晚于当月 10 号之前将《北京住房公积金管理中心业务凭证回单》、本人身份证原件（如果是购房，同时携带购房提取的其他材料）交给单位，办理完成后会及时邮件通知。7.3.3 提取的影响  1、影响公积金贷款额度  公积金账户余额会影响公积金贷款额度，一般情况下公积金贷款额度是公积金余额的10到20倍，所以客户提取公积金以后就会影响到以后申请公积金贷款的额度，对于打算使用公积金贷款买房的客户来说影响比较大。不过客户公积金账户里面本身就有很多的资金，按规定已经完全能够满足以后的贷款需求的话，在这种情况下客户还是可以适当的提取一部分公积金来减轻自己的压力。  2、影响公积金提取  提取住房公积金都是需要有一定的理由的，比如说如果用户使用租房的理由提取了住房公积金，那么在两年内用户都无法对公积金再次办理租房提取。另外公积金每年提取次数也是有限制的，客户不能重复多次的提取公积金，所以在决定要提取公积金以前，客户需要做好相关的准备，尽量将需要的资金按规定一次提取到位。  3、影响二套房的认定  名下有一次住房记录、贷款记录或购房提取公积金记录的可以认定为二套房，会直接导致办理房贷时的首付比例增加。如果被认定是二套房了，还可能会导致客户申请的公积金贷款额度减少，贷款利率也会增加，客户在买房的时候压力会更大。  4、无法申请公积金贷款  客户提取公积金以后，如果导致公积金账户余额过低，那么在之后的几个月时间里面可能无法办理公积金贷款，会影响客户的买房计划。如果客户将公积金全部提取出来了，那就意味着在接下来比较长的一段时间里面无法申请公积金贷款，所以客户如果有使用公积金贷款买房的计划，那么在提取公积金的时候就要谨慎一些。  5、对开展信用贷款有影响  有一些平台推出的个人信用贷款产品对于公积金可能会有要求，如果客户将公积金全部取出来，可能会导致公积金账户被封存，这种情况下在申请某些贷款的时候会被平台直接拒贷。7.4 公积金贷款  Q：公积金贷款就是公积金还款吗？  A：公积金贷款不一定是使用公积金进行还款。公积金贷款的含义是借款人公积金账户进行贷款，申请公积金贷款需要满足申请条件，申请通过以后，借款人需要每个月进行还款。至于进行还款的钱是不是借款人的公积金账户，没有特别的规定，借款人可以使用公积金账户里的钱进行还款，也可以把借款人银行卡里的钱转到还款的银行卡里进行还款。  Q：用公积金贷款后还能提取公积金吗?  A：公积金贷款申请成功之后是可以再提取公积金的。但是需要在用户每月还款之后公积金账户内还有余额的情况下，用户才能提取公积金贷款。如果在还款之后公积金账户里面就没有余额的话，则无法提取公积金。7.4.1 商贷转公贷  如果你是第一套住房的话，住房公积金贷款要比商业贷款利息低一个百分点，但必须是你取得房产证之后才能申请商业贷款转住房公积金贷款。7.4.2 异地公积金贷款  换工作到异地，涉及到异地贷款问题。比如深圳的住房公积金贷款仅支持在深圳市内购买住房，如果你想用深圳的公积金去买老家的房，那就得咨询老家的公积金中心，深圳公积金管理中心则要开具异地贷款缴存证明。目前并非所有城市都支持异地公积金贷款的，如果要在其他城市常驻工作，并且买房，可能就得把公积金转移到那个城市。7.4.3 贷款额度计算  一般可贷多少钱，取决于你公积金账户余额：公积金贷款额度最高不能超过个人公积金账户存储额的n倍，这里的n，各地规定不一，比如上海目前是15倍，我市目前是20倍（最高限额80万）。如果暂时没有买房的需求，公积金还可以选择提取一部分出来，但如果取出太多，以上海为例，可能账户余额的15倍会低于上海贷款最高限额。所以，如果要取出公积金，也得保证余额的15倍至少高于当地最高限额50万。剩下的，能取就取出来吧。八、补充医疗保险8.1 补充医疗报销蓝卡“补充医药报销蓝卡”（以下简称报销蓝卡）是“拥军惠军健康守护计划”中的一项针对社保内和社保外医药报销的强有力的补充服务，由中国太平主承保，中国人保、中国人寿共保的公益保险服务产品，针对目录内提供社保内、外药品，指定医院、药店的补充药品报销服务。让现/退役军人及其他优抚对象享受实实在在的优惠。8.1.1 蓝卡申领  注意：2021年12月31日前未领取成功的用户于2022年4月25日进行二次申领，申领微信必须使用纸质版备案中填写的手机号注册的微信。8.1.2 蓝卡激活  注意：通过核实后统一于2022年4月25日生效。如因退役军人未登记相关信息系统而导致身份核实未通过的，需要在2022年5月20日前，到当地退役军人服务部门录入身份信息，并提供第二次再核实机会，通过核实后统一于2022年5月25日生效。8.1.3 服务公众号  中网健康公众号8.1.4 一些问题  1、卡具体服务  （1）院内用药。针对在指定医院门诊发生的部分常见慢病，且在指定目录内的药品费用进行一定比例的补充报销；（2）药店购药。针对在指定合作线下药店，符合指定目录内的药品费用进行一定比例的报销；（3）线上互联网医院及线上购药平台。针对发生在指定线上互联网医院及线上购药平台的目录内购药费用进行一定比例的报销，此模式药品目录覆盖最全面，可线上问诊和开药，并支持送药到家（配送范围内）。具体相关医院、药店、线上医药机构及药品目录，激活生效前将统一进行公示。  2、生过病的可以领取补充医药报销蓝卡吗  对于已经生病的人群也是可以领取补充医药报销蓝卡的。  3、没有社保可以报销吗  没有社保也可以报销的。  4、医药报销蓝卡是由哪个机构提供的  由中国太平主承、中国人保、中国人寿，三家保险单位共保。  5、补充医药报销蓝卡只限于门诊用药吗  不只限于门诊用药，在“补充医药报销蓝卡”目录，可享受所有指定医院、指定药店的购药补充报销。  6、补充医药报销蓝卡保障期限是多久  保障期限为一年，一年激活一次。  7、补充医药报销蓝卡药品报销有次数限制吗  指定目录内用药，每次报销额度最高300元，年度最高报销100次。如线上领取时填写定向用药（已患疾病范围用药），则年度最高报销150次。  8、买完药如何获取补充医药报销蓝卡的报销款  购药完成，上传相关票据，审核通过后，报销款项会打到您填写信息时预留的本人名下银行卡号里。  9、此蓝卡以后是否免费  本产品是一款带有公益性质的保险产品，由央企保险公司主承并捐赠、爱心药企主动让利、有关社会公益组织捐赠支持、有关互联网平台提供免费服务，是在国家鼓励引导社会力量关爱退役军人的形势下，多方社会力量合力关爱退役军人的积极尝试和具体成果。本次“补充医药报销蓝卡”有效期为一年，自激活日起计算，有效期内不收费。2022年产品试运行期间，将动员吸引更多相关企业社会力量参与，原则上运行良好的基础上，成功申领的用户可在产品存续有效期间享受免费，具体以后期正式公示为准。  10、“报销蓝卡”怎么查询是否办理成功  关注“中网健康”公众号后，您可在服务中心——个人中心——我的保单中进行查询。  11、《补充医药报销蓝卡》第二年收费吗  本产品是一款公益保险产品，在保证2022年试运行阶段项目运行良好，2021年申请成功的用户可在产品存续期间享受长期免费。  12、退役军人领取成功后是不是所有家属都能享受报销服务  补充医药报销蓝卡是以一人一卡的形式发放，需每人通过微信关注《中网健康》公众号进行领取，未领取的家属，无法享受报销服务。  13、领取医药报销蓝卡之后，在哪些地方购药可以报销  蓝卡激活生效后，在指定医院、指定线上互联网医疗机构、线上医药平台和指定线下药店购买指定目录内的药品即可报销。  14、报销额度是每个人的额度还是每个家庭的额度  蓝卡采用一人一卡制，单次最高报销额度和次数是针对每个人的，不按照家庭统计。但使用范围是限定在指定的线下医院、指定的线上互联网医疗机构、指定线下药店，发生的指定目录内的药品费用。  15、三家保险公司共保出险时找谁报销  统一为线上报销方式，保障生效后，您可直接在《中网健康》公众号，进入《补充医药报销蓝卡》保单，点击申请报销，按要求上传资料后即可申请线上报销。"
  },
  
  {
    "title": "1.档案管理",
    "url": "/posts/dangan-guanli/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-30 13:47:00 +0800",
    





    
    "snippet": "一、 个人档案1.1 毕业后档案去向  如果是去机关、国有企事业单位等用人单位就业的，档案会转到用人单位进行管理。  如果是去没有人事档案管理权限的非公单位就业的，档案可以转递到就业地或户籍地的公共就业和人才服务机构进行管理，北京、上海等超大型城市原则上转递到户籍地县级以上公共就业和人才服务机构进行管理。  如果是未就业、出国留学或者创业，档案一般转至户籍地公共就业和人才服务机构。1.2 如...",
    "content": "一、 个人档案1.1 毕业后档案去向  如果是去机关、国有企事业单位等用人单位就业的，档案会转到用人单位进行管理。  如果是去没有人事档案管理权限的非公单位就业的，档案可以转递到就业地或户籍地的公共就业和人才服务机构进行管理，北京、上海等超大型城市原则上转递到户籍地县级以上公共就业和人才服务机构进行管理。  如果是未就业、出国留学或者创业，档案一般转至户籍地公共就业和人才服务机构。1.2 如何查询个人档案存放地当事人没有及时去人才中心报到，是不会影响个人档案的，并且档案也不会丢失，其档案将会由当地人才中心保管。另外，需要注意的是：报到证是有期限的，如果报到证过期或者丢失了，一定要及时补办，以免带来不便。如果想要知道自己档案在哪个地方，就要先看一下报到证上所写的地方，如果写的是人才中心，则说明档案就在当地的人才中心；如果写的是人才局，则档案在当地的人才局。依据法规对国家规定的应当立卷归档的材料，必须按照规定，定期向本单位档案机构或者档案工作人员移交，集中管理，任何个人不得据为己有。拿回档案需要所在人才中心、人才局或单位办理。档案必须通过专门的渠道寄送，自己携带的不收。可以先给学校档案室打电话查询档案发到了哪里，然后找到这个存放档案的人才市场或者有档案管理权限的公司查询。二、 党员关系和档案2.1 组织关系转移      入党积极分子换工作单位，组织关系要转吗    入党积极分子需要转组织关系。要求入党的积极分子调动工作时，调出单位党组织应将培养、教育的有关材料转给调入单位党组织。 转移正式组织关系须开具“中国共产党党员组织关系介绍信”，转移临时组织关系须开具“党员证明信”。    按照党章规定，每个党员不论职务高低，都必须编入党的一个支部、小组或其他特定组织，参加党的组织生活，接受党内外群众的监督。        工作单位没有党组织，组织关系转到哪儿    根据《中共中央组织部关于做好高校毕业生党员组织关系管理工作的通知》：工作单位尚未建立党组织的，可将组织关系转移到单位所在地或本人居住地的街道、乡镇党组织，也可随同档案转移到县以上政府所属公共就业和人才服务机构党组织。如果不接收，可以向街道党委或区委组织部反映。  2.2 党员档案      应届毕业生党员组织转接未转，党员档案会被寄回生源地吗    组织关系是用介绍信进行转递，而入党材料是作为重要的材料归到学籍档案中一起转递，当然有部分学校是分开，原则上是不能分开进行转递，入党材料只是人事档案的一部分，从干部人事档案的分类中就可以看出，党团材料归到人事档案中的第六大类。        入党积极分子毕业后未及时办理转接手续    给个人档案所在的人才市场打电话询问党员培养材料如何调取。需要党支部开查阅党员培养材料的证明，可以本人去办理也可以委托人去办理。  三、 干部身份3.1 应届毕业生签了私企怎么保留自己的干部身份在私企上班，保留干部身份的人事手续，是你的毕业档案已经报到落档在原籍的人社局里，或在人社局的人才中心代理或托管。你的毕业档案，通过报到证，由学校转移到地方政府的人社局（或人社局的人才中心），以报到证上的报到签证为凭，有报到签证的，就是干部档案身份，简称“干部身份”。没有报到签证的，仍然是“学生身份”。超过报到证上的报到时间两年后，还没报到签证的，将失去就业前的“干部身份”。没有干部身份的，想考公、考事编就麻烦了。一旦进入国企，工资还会晚一年调整，即干部身份的不需要实习期，而学生身份的需要一年的实习期。在私企上班，没有这些问题，因为，私企没有国家干部的管理模式，也不享受干部待遇。四、 报到证4.1 超过报到期而未报到的处理方法      超过报到期而未超过择业期    如果只是超过1个月报到期未超过2年择业期的，这种情况就不需要担心，只有报到证没有出现损毁、丢失的情况，那携带报到证前往报到地点报到即可，没有什么影响。        超过2年择业期限    如上面所说的情况，超过2年择业期未报到，则视为自动放弃并作废，如果这时候需要报到证则需要补办“新的报到证”，才能顺利报到。  4.2 不报到会影响公务员考试吗毕业生在找到正式工作之后就需要签订就业协议，进行报到。因为报到证是今后转正和干部身份的重要证明。所以如果没有在规定时间内正常报到可能会造成毕业生失去干部身份，影响公务员的考试。报到证对毕业生就业的影响主要是用人单位以报到证为依据，接收安排毕业生工作，并接转毕业生的人事档案、户口迁移手续等，报到证代表了毕业生的干部关系。4.3 应届毕业生没去报到能考公务员吗没有报道是不影响参加公务员考试的 只要是你符合国家公务员招考的其他条件就是可以按照报名程式进行报名考试的。4.4 没报到会影响公务员考试吗影响不大，到时补办，有相应的补办程式。"
  },
  
  {
    "title": "Maven如何查看依赖冲突",
    "url": "/posts/maven-ruhe-chakan-yilai-chongtu/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2020-12-30 13:47:00 +0800",
    





    
    "snippet": "什么是依赖冲突Maven是个很好用的依赖管理工具，但是再好的东西也不是完美的。Maven的依赖机制会导致Jar包的冲突。举个例子，现在你的项目中，使用了两个Jar包，分别是A和B。现在A需要依赖另一个Jar包C，B也需要依赖C。但是A依赖的C的版本是1.0，B依赖的C的版本是2.0。这时候，Maven会将这1.0的C和2.0的C都下载到你的项目中，这样你的项目中就存在了不同版本的C，这时Ma...",
    "content": "什么是依赖冲突Maven是个很好用的依赖管理工具，但是再好的东西也不是完美的。Maven的依赖机制会导致Jar包的冲突。举个例子，现在你的项目中，使用了两个Jar包，分别是A和B。现在A需要依赖另一个Jar包C，B也需要依赖C。但是A依赖的C的版本是1.0，B依赖的C的版本是2.0。这时候，Maven会将这1.0的C和2.0的C都下载到你的项目中，这样你的项目中就存在了不同版本的C，这时Maven会依据依赖路径最短优先原则，来决定使用哪个版本的Jar包，而另一个无用的Jar包则未被使用，这就是所谓的依赖冲突。如何查看依赖冲突使用Maven命令：cd &lt;含有pom.xml的文件夹&gt;mvn dependency:tree -Dverbose -DoutputFile=&lt;文件名&gt;.txt-(io.netty:netty-common:jar:4.0.56.Final:compile - omitted for duplicate表示存在依赖冲突。-(io.netty:netty-common:jar:4.0.56.Final:compile - omitted for conflict with 4.1.36表示存在依赖冲突并且强制使用了4.1.36版本。如何解决依赖冲突解决依赖冲突的方法，就是使用Maven提供的标签，就像下面这样：&lt;dependency&gt;      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;      &lt;version&gt;2.10.0&lt;/version&gt;      &lt;exclusions&gt;            &lt;exclusion&gt;              &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;              &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;                 &lt;/exclusion&gt;      &lt;/exclusions&gt;&lt;/dependency&gt;log4j-core本身是依赖了log4j-api，但是因为一些其他的模块也依赖了log4j-api，并且两个log4j-api版本不同，所以我们使用标签排除掉log4j-core所依赖的log4j-api，这样Maven就不会下载log4j-core所依赖的log4j-api了，也就保证了我们的项目中只有一个版本的log4j-api。"
  },
  
  {
    "title": "Java注解规范",
    "url": "/posts/java-zhujie-guifan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-30 11:47:00 +0800",
    





    
    "snippet": "一、注解的原则优雅的注解通常要满足三要素。  Nothing is strange没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。  Less is more从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规...",
    "content": "一、注解的原则优雅的注解通常要满足三要素。  Nothing is strange没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。  Less is more从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。    // 根据id获取信息【废话注解】getMessageById(id)        Advance with the time注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。二、注解格式注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。2.1 包注解包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。/** * 落地质量检测 * 1. 用来解决什么问题 * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等;  * 模拟不同的网络：2G，3G，4G，wifi等 * * 2. 如何实现 * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络， * OS参数，获取到浏览器返回结果。 * * 注意： 网络环境配置信息{@link cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum} * 目前使用是常规速度，可以根据实际情况进行调整 *  * @author cruder * @time 2019/12/7 20:3 下午 */package cn.mycookies.landingpagecheck;2.2 类注接javadoc注解中，每个类都必须有注解。/*** Copyright (C), 2019-2020, Jann  balabala...** 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....** @author   类创建者姓名 保持对齐* @date     创建日期 保持对齐* @version  版本号 保持对齐*/2.3 属性注解在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。/** 提示信息 */private String userName;/** * 密码 */private String password;2.4 方法注释在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。/**  * 方法的详细说明，能干嘛，怎么实现的，注意事项...  *  * @param xxx   参数1的使用说明， 能否为null  * @return 返回结果的说明， 不同情况下会返回怎样的结果  * @throws 异常类型   注明从此类方法中抛出异常的说明  */2.5 构造方法注释在每个构造方法前面必须加上注释，注释模板如下：/**  * 构造方法的详细说明  *  * @param xxx   参数1的使用说明， 能否为null  * @throws 异常类型   注明从此类方法中抛出异常的说明  */三、注意事项在使用注解时应该注意一下几点：  枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。  保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。int id = 1;// 反例：不要使用行尾注释//反例：换行符与注释之间没有缩进int age = 18;// 正例：姓名String name;/** * 1. 多行注释 *  * 2. 对于不同的逻辑说明，可以用空行分隔 */"
  },
  
  {
    "title": "Java命名规范",
    "url": "/posts/java-mingming-guifan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-30 11:47:00 +0800",
    





    
    "snippet": "一、Java中的命名规范好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，类一般采用大驼峰命名，方法和局部变...",
    "content": "一、Java中的命名规范好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。            类型      约束      例                  项目名      全部小写，多个单词用中划线分隔‘-’      spring-cloud              包名      全部小写      com.alibaba.fastjson              类名      单词首字母大写      Feature, ParserConfig,DefaultFieldDeserializer              变量名      首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写      password, userName              常量名      全部大写，多个单词，用’_‘分隔      CACHE_EXPIRED_TIME              方法      同变量      read(), readObject(), getById()      二、包命名包名统一使用小写，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。包名的构成可以分为以下几四部分【前缀】【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：            前缀名      例      含义                  indi（或onem ）      indi.发起者名.项目名.模块名.……      个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。              pers      pers.个人名.项目名.模块名.……      个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人              priv      priv.个人名.项目名.模块名.……      私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。              team      team.团队名.项目名.模块名.……      团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有              顶级域名      com.公司名.项目名.模块名.……      公司项目，copyright由项目发起的公司所有      三、类命名类名使用大驼峰命名形式，类命通常时名词或名词短语，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是统一就好。            属性      约束      例                  抽象类      Abstract 或者 Base 开头      BaseUserService              枚举类      Enum 作为后缀      GenderEnum              工具类      Utils作为后缀      StringUtils              异常类      Exception结尾      RuntimeException              接口实现类      接口名+ Impl      UserServiceImpl              领域模型相关      /DO/DTO/VO/DAO      正例：UserDAO 反例： UserDo， UserDao              设计模式相关类      Builder，Factory等      当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory              处理特定功能的      Handler，Predicate, Validator      表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate              测试类      Test结尾      UserServiceTest， 表示用来测试UserService类的              MVC分层      Controller，Service，ServiceImpl，DAO后缀      UserManageController，UserManageDAO      四、方法方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。4.1 返回真伪值的方法注：Prefix-前缀，Suffix-后缀，Alone-单独使用            位置      单词      意义      例                  Prefix      is      对象是否符合期待的状态      isValid              Prefix      can      对象能否执行所期待的动作      canRemove              Prefix      should      调用方执行某个命令或方法是好还是不好,应不应该，或者说推荐还是不推荐      shouldMigrate              Prefix      has      对象是否持有所期待的数据和属性      hasObservers              Prefix      needs      调用方是否需要执行某个命令或方法      needsMigrate      4.2 用来检查的方法            单词      意义      例                  ensure      检查是否为期待的状态，不是则抛出异常或返回error code      ensureCapacity              validate      检查是否为正确的状态，不是则抛出异常或返回error code      validateInputs      4.3 按需求才执行的方法            位置      单词      意义      例                  Suffix      IfNeeded      需要的时候执行，不需要的时候什么都不做      drawIfNeeded              Prefix      might      同上      mightCreate              Prefix      try      尝试执行，失败时抛出异常或是返回errorcode      tryCreate              Suffix      OrDefault      尝试执行，失败时返回默认值      getOrDefault              Suffix      OrElse      尝试执行、失败时返回实际参数中指定的值      getOrElse              Prefix      force      强制尝试执行。error抛出异常或是返回值      forceCreate, forceStop      4.4 异步相关方法            位置      单词      意义      例                  Prefix      blocking      线程阻塞方法      blockingGetUser              Suffix      InBackground      执行在后台的线程      doInBackground              Suffix      Async      异步方法      sendAsync              Suffix      Sync      对应已有异步方法的同步方法      sendSync              Prefix or Alone      schedule      Job和Task放入队列      schedule, scheduleJob              Prefix or Alone      post      同上      postJob              Prefix or Alone      execute      执行异步方法（注：我一般拿这个做同步方法名）      execute, executeTask              Prefix or Alone      start      同上      start, startJob              Prefix or Alone      cancel      停止异步方法      cancel, cancelJob              Prefix or Alone      stop      同上      stop, stopJob      4.5 回调方法            位置      单词      意义      例                  Prefix      on      事件发生时执行      onCompleted              Prefix      before      事件发生前执行      beforeUpdate              Prefix      pre      同上      preUpdate              Prefix      will      同上      willUpdate              Prefix      after      事件发生后执行      afterUpdate              Prefix      post      同上      postUpdate              Prefix      did      同上      didUpdate              Prefix      should      确认事件是否可以发生时执行      shouldUpdate      4.6 操作对象生命周期的方法            单词      意义      例                  initialize      初始化。也可作为延迟初始化使用      initialize              pause      暂停      onPause，pause              stop      停止      onStop，stop              abandon      销毁的替代      abandon              destroy      同上      destroy              dispose      同上      dispose      4.7 与集合操作相关的方法            单词      意义      例                  contains      是否持有与指定对象相同的对象      contains              add      添加      addJob              append      添加      appendJob              insert      插入到下标n      insertJob              put      添加与key对应的元素      putJob              remove      移除元素      removeJob              enqueue      添加到队列的最末位      enqueueJob              dequeue      从队列中头部取出并移除      dequeueJob              push      添加到栈头      pushJob              pop      从栈头取出并移除      popJob              peek      从栈头取出但不移除      peekJob              find      寻找符合条件的某物      findById      4.8 与数据相关的方法            单词      意义      例                  create      新创建      createAccount              new      新创建      newAccount              from      从既有的某物新建，或是从其他的数据新建      fromConfig              to      转换      toString              update      更新既有某物      updateAccount              load      读取      loadAccount              fetch      远程读取      fetchAccount              delete      删除      deleteAccount              remove      删除      removeAccount              save      保存      saveAccount              store      保存      storeAccount              commit      保存      commitChange              apply      保存或应用      applyChange              clear      清除数据或是恢复到初始状态      clearAll              reset      清除数据或是恢复到初始状态      resetAll      4.9 成对出现的动词            单词      意义      单词      意义                  get      获取      set      设置              add      增加      remove      删除              create      创建      destory      移除              start      启动      stop      停止              open      打开      close      关闭              read      读取      write      写入              load      载入      save      保存              create      创建      destroy      销毁              begin      开始      end      结束              backup      备份      restore      恢复              import      导入      export      导出              split      分割      merge      合并              inject      注入      extract      提取              attach      附着      detach      脱离              bind      绑定      separate      分离              view      查看      browse      浏览              edit      编辑      modify      修改              select      选取      mark      标记              copy      复制      paste      粘贴              undo      撤销      redo      重做              insert      插入      delete      移除              add      加入      append      添加              clean      清理      clear      清除              index      索引      sort      排序              find      查找      search      搜索              increase      增加      decrease      减少              play      播放      pause      暂停              launch      启动      run      运行              compile      编译      execute      执行              debug      调试      trace      跟踪              observe      观察      listen      监听              build      构建      publish      发布              input      输入      output      输出              encode      编码      decode      解码              encrypt      加密      decrypt      解密              compress      压缩      decompress      解压缩              pack      打包      unpack      解包              parse      解析      emit      生成              connect      连接      disconnect      断开              send      发送      receive      接收              download      下载      upload      上传              refresh      刷新      synchronize      同步              update      更新      revert      复原              lock      锁定      unlock      解锁              check out      签出      check in      签入              submit      提交      commit      交付              push      推      pull      拉              expand      展开      collapse      折叠              begin      起始      end      结束              start      开始      finish      完成              enter      进入      exit      退出              abort      放弃      quit      离开              obsolete      废弃      depreciate      废旧              collect      收集      aggregate      聚集      五、变量&amp;常量命名5.1 变量命名变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如computedValues，index，变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加is_ 前缀)。5.2 常量命名常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。public class HelloWorld {     // 局部常量(正例)    public static final long USER_MESSAGE_CACHE_EXPIRE_TIME = 3600;        // 局部常量(反例，命名不清晰）    public static final long MESSAGE_CACHE_TIME = 3600;        // 全局常量    private static final String ERROR_MESSAGE = \" error message\";     // 成员变量    private int currentUserId;     /**     * 控制台打印 {@code message} 信息     * @param message 消息体，局部常量     */    public void sayHello(final String message){        System.out.println(\"Hello world!\");    } }常量一般都有自己的业务含义,不要害怕长度过长而进行省略或者缩写。如，用户消息缓存过期时间的表示。六、通用命名规则  尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例： BeiJing， HangZhou反例： validateCanShu  命名过程中尽量不要出现特殊的字符，常量除外。  尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。  妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。  如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。"
  },
  
  {
    "title": "1.居住",
    "url": "/posts/juzhu/",
    "categories": "MyNotes, 3_ZhengCeFaGui",
    "tags": "",
    "date": "2020-12-29 13:47:00 +0800",
    





    
    "snippet": "一、住房1.1 物业1.1.1 物业服务收费管理办法（2022-10-28）为加强物业服务收费管理，进一步规范物业服务收费行为，维护业主和物业服务人的切身利益，促进我省物业服务行业健康发展，根据《中华人民共和国民法典》《中华人民共和国价格法》《物业管理条例》《物业服务收费管理办法》等法律法规和政策规定，结合实际，会同省住房城乡建设厅共同起草了《物业服务收费管理办法》。现将征求意见稿予以通告，...",
    "content": "一、住房1.1 物业1.1.1 物业服务收费管理办法（2022-10-28）为加强物业服务收费管理，进一步规范物业服务收费行为，维护业主和物业服务人的切身利益，促进我省物业服务行业健康发展，根据《中华人民共和国民法典》《中华人民共和国价格法》《物业管理条例》《物业服务收费管理办法》等法律法规和政策规定，结合实际，会同省住房城乡建设厅共同起草了《物业服务收费管理办法》。现将征求意见稿予以通告，向社会公开征求意见。  第十条【成本构成】 实行物业服务费用包干制的，物业服务费用的构成包括物业服务成本、法定税费和物业服务人的利润。  实行物业服务费用酬金制的，预收的物业服务资金包括物业服务支出和物业服务人的酬金。   物业服务成本或者物业服务支出构成一般包括以下部分：管理服务人员的工资、社会保险和按规定提取的福利费等；物业共用部位、共用设施设备的日常运行、维护费用；物业管理区域清洁卫生费用；物业管理区域绿化养护费用；物业管理区域秩序维护费用；办公费用；物业管理企业固定资产折旧；物业共用部位、共用设施设备及公众责任保险费用；经业主同意的其他费用。   物业共用部位、共用设施设备的大修、中修和更新、改造费用，应当通过专项维修资金予以列支，不得计入物业服务支出或者物业服务成本。建筑区划红线内供水（含二次加压调蓄）设备依法依规移交供水企业管理的，其运行维护、修理更新等费用计入供水成本，不计入物业服务支出或者物业服务成本。1.2 供暖  采暖期：11月1日 - 3月31日  缴费标准：采暖费 = 采暖计费面积（房屋建筑面积×75%） × 5个月 × 采暖费单价（居民采暖费5.91元/㎡·月）  报停：8月12日 - 10月15日二、租房2.1 北京居住登记卡外地户籍来京人员自到达本市之日起3日内，应当到居住地来京人员和出租房屋服务站(简称“流管站”)申报暂住登记，并领取《北京市居住登记卡》。《北京市居住登记卡》作为来京人员申报暂住登记的凭证。《居住登记卡》是申领《居住证》的基础，发放对象是在京居住不满6个月，或者满6个月但不符合在京有合法稳定就业、合法稳定住所、连续就读条件之一，无法申领《居住证》的外地户籍来京人员。目前，持有《居住登记卡》或《居住证》均可以办理身份证异地换领、车管驾照业务、住建委房屋过户业务。汽车摇号、出入境证件办理需要提供《居住证》。三、购房3.1 购房政策2023年8月25日，近日住房城乡建设部、中国人民银行、金融监管总局联合印发了《关于优化个人住房贷款中住房套数认定标准的通知》，推动落实购买首套房贷款“认房不用认贷”政策措施。通知明确，居民家庭（包括借款人、配偶及未成年子女）申请贷款购买商品住房时，家庭成员在当地名下无成套住房的，不论是否已利用贷款购买过住房，银行业金融机构均按首套住房执行住房信贷政策。可能很多人不太懂“认房不认贷”是什么意思，认房不认贷的重点在“房”上，这里有个简单的公式，供大家理解一下：  有房+贷款还清 = 二套房；  有房+贷款没还清 = 二套房；  没房（或卖掉）+ 贷款还清 = 首套房；  没房（或卖掉）+ 贷款没还清 = 首套房。3.2 购房贷款市住房公积金管理中心发布通知，2024年5月9日（星期四）起，各管理部、营业部开始正式办理商转公（住房公积金贷款置换商业银行个人住房贷款业务）贷款业务。  什么是商转公贷款？  商转公贷款是指我市住房公积金缴存职工，将本人已办理且尚未结清的我市商业性住房贷款，经市住房公积金管理中心与原商业贷款银行同意后，转为个人住房公积金贷款。  为什么要实施商转公贷款？  实施商转公主要是为了更好满足缴存职工刚性和改善性住房需求，让更多的缴存职工有机会享受住房公积金制度红利，减少房贷利息支出，减轻家庭还贷压力。目前，住房公积金贷款较商贷在利率方面有一定的优势，现商业住房贷款首套房贷款年利率3.75%，住房公积金首套房贷款年利率3.1%。  申请商转公贷款需要符合哪些条件？  我市缴存职工在市行政区域内购买自住住房，办理了商业住房贷款（不含住房公积金组合贷款）且符合以下条件的，可申请商转公贷款业务：（一）符合市住房公积金个人住房贷款条件；（二）借款申请人应为具有完全民事行为能力的自然人，是原商业贷款的主借款人及所购住房的产权人，在我市连续足额缴存住房公积金6个月以上（含6个月），且账户处于正常缴存状态；（三）个人住房商业贷款尚未结清，已还款12个月以上且处于正常还款状态，在还款期内无逾期记录；（四）已取得所购买自住住房的《不动产权证书》，或转为以商业贷款银行为抵押权人的《不动产登记证明》；（五）原商业贷款银行同意借款申请人办理商转公贷款手续并提前结清贷款；（六）所购住房能够提供抵押担保，除原商业贷款设定的抵押登记外，无其他抵押、查封、居住权设定等权利限制情形。  我市商转公贷款有几种办理方式？各有什么特点？  我市商转公贷款有先还后贷和顺位抵押两种方式，借款申请人可根据自身情况选择其中一种方式：（一）先还后贷方式，缴存职工在商转公贷款审核通过后，需自筹资金先行结清原商业贷款。该方式流程简单、手续方便、业务周期短。该方式相较于顺位抵押方式，需先自筹资金。（二）顺位抵押方式，缴存职工在未结清原商业贷款，且抵押权人仍为原商业银行的情况下，办理顺位抵押登记，住房公积金贷款结清原商业贷款。该方式缴存职工无需自筹全部资金结清原商业贷款，可最大限度减少职工筹集资金压力、降低置换成本。相较于先还后贷方式，环节相对较多、业务周期相对较长。  商转公贷款具体办理流程是什么？  （一）采用先还后贷方式，按下列程序办理：1、借款人提出申请，中心审定贷款额度和期限并告知借款人。借款人30个工作日内结清原商业贷款并解除原抵押登记，逾期未完成视同自动放弃；2、借款人持原商业贷款结清证明、《不动产权证书》或《房屋所有权证》及其他相关材料与中心及其放款银行签订借款及抵押合同，并办理贷款相关手续，将住房公积金贷款划入借款人个人还款账户。（二）采用顺位抵押方式，按下列程序办理：1、借款人提出申请，中心审定商转公贷款额度和期限并告知借款人。原商业贷款银行出具《商转公贷款同意书》、借款人签署《个人承诺书》，中心及其放款银行与借款人签订借款及抵押合同，并办理贷款相关手续；2、受托银行与借款人、原商业贷款银行到不动产登记部门申请办理顺位抵押登记手续，按顺位设立新的抵押权，将住房公积金贷款划入借款人原商业贷款银行结清商业贷款；3、借款人配合受托银行办结商业贷款抵押注销登记手续，受托银行的抵押权顺位相应向前。  住房公积金组合贷款中的商业贷款能否办理商转公贷款？  不可以。商转公贷款只受理纯商业住房贷款转为纯公积金贷款，组合贷款中的原商业贷款不能申请办理商转公贷款。  商业住房贷款能否转为住房公积金组合贷款？  不可以。商业住房贷款只能转为纯住房公积金贷款，差额部分需借款人自行结清。  商转公的贷款额度、年限、利率与正常住房公积金贷款有没有区别？  商转公贷款期限和利率均按照现行市住房公积金个人住房贷款相关规定执行。商转公贷款额度在符合我市住房公积金贷款最高额度相关规定的同时，不得超过申请商转公贷款时个人住房商业贷款的即时余额（保留到千位整数）。  申请商转公贷款需要准备哪些材料？  借款申请人应提供符合市住房公积金个人住房贷款政策规定的贷款资料外，还应提供以下资料： （一）个人住房商业贷款借款合同、借款借据、近12个月的还款明细及余额单；（二）所购住房的《不动产权证书》或《不动产登记证明》复印件；（三）采用先还后贷方式的借款申请人提供原商业贷款结清证明；（四）采用顺位抵押方式的借款申请人提供原商业贷款银行出具的《商转公贷款同意书》；（五）其他相关资料。  异地缴存职工可否申请商转公贷款？  不可以。现阶段我市商转公贷款业务仅支持本市缴存职工。  办理商转公贷款收取费用吗？  我中心所有住房公积金贷款业务包括商转公业务均不收取任何费用。请广大缴存职工知悉，谨防上当受骗。四、落户4.1 北京积分落户  2018年，北京积分落户人数6019人，分数线90.75分。  2019年，北京积分落户人数6007人，分数线93.58分。  2020年，北京积分落户人数6032人，分数线97.13分。  2021年，北京积分落户人数6045人，分数线100.88分。"
  },
  
  {
    "title": "2.实习就业",
    "url": "/posts/shixi-jiuye/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-29 13:47:00 +0800",
    





    
    "snippet": "一、互联网招聘平台      高校毕业生就业服务平台：http://job.mohrss.gov.cn/202008gx/index.jhtml可以按岗位查询，也可按地域查询。        中国公共招聘网：https://job.mohrss.gov.cn提供岗位信息、招聘会信息，还有招聘岗位排行榜、职场小贴士等等。        中国国家人才网：https://www.newjobs.c...",
    "content": "一、互联网招聘平台      高校毕业生就业服务平台：http://job.mohrss.gov.cn/202008gx/index.jhtml可以按岗位查询，也可按地域查询。        中国公共招聘网：https://job.mohrss.gov.cn提供岗位信息、招聘会信息，还有招聘岗位排行榜、职场小贴士等等。        中国国家人才网：https://www.newjobs.com.cn高校毕业生可通过完善个人信息获得平台精准匹配推送的岗位或者通过平台搜索自主投递简历找到心仪的工作。        就业在线：https://www.jobonline.cn国家级招聘求职服务平台，可以在这里完成从创建、编辑、修改、投递简历到查询面试、入职信息等找工作全流程。另外，就业在线还提供简历核验服务，经核验的简历将有特殊标识，提升简历的竞争力。  二、毕业生就业政策2.1 失业补助应届高校毕业生当年未就业的，在第二年1-6月的每月10日前(遇公休日顺延)向户籍所在地的市、县(区)失业保险机构提出申请并提供相关材料。失业补助金标准为毕业生户籍所在地失业保险金低标准的90%。领取期限长为6个月，6月份为申领和发放的截止期。毕业生在领取失业补助金期间实现就业的；或家庭经济状况出现明显好转的；或无正当理由3次拒不接受劳动保障部门组织的就业培训和介绍就业的，将停止领取失业补助金。三、三方协议3.1 签三方注意事项  要看填写的用人单位名称是否与单位的有效印鉴名称一致，如果不一致，协议无效。  填写自己的专业名称时，要与学校教务处的专业名称一致，不能简写。  外企、合资企业、私企一般采用试用期，根据合同期的长度，可以从1-3个月不等，通常试用期为3个月，不得超过6个月。国家机关、高校、研究所一般采用见习期，通常为一年。  不少单位为了留住学生，以高额违约金约束学生。学生在协商中要力争取消违约金这一条规定。或者尽量降低，通常违约金不得超过5000元。  学生在签订协议时，要严格按照规定的步骤进行。等用人单位填写完毕、盖章后再到学校就业指导中心签证盖章。以防单位在填写时，工资待遇等与过去承诺的大相径庭。学生却因为自己和学校都已经签字盖章，而无法挽回。  只有签署了三方协议，拿回学校，学校才会在毕业后派发派遣证。拿着派遣证到工作单位报到，才能就此开始计算工龄，同时毕业生拥有干部身份（每年基本6月25日毕业，所以6月18日前必须将三方交到学校）。四、劳动合同4.1 签劳动合同注意事项      先试用再签合同    《劳动合同法》第十九条规定，“试用期包含在劳动合同期限内。劳动合同仅约定试用期的，试用期不成立，该期限为劳动合同期限”。但试用阶段不签劳动合同、仅签订试用期合同等情况比比皆是。        试用期期限    《劳动合同法》第十九条规定，劳动合同期限三个月以上不满一年的，试用期不得超过一个月；劳动合同期限一年以上不满三年的，试用期不得超过二个月；三年以上固定期限和无固定期限的劳动合同，试用期不得超过六个月。        拒交或欠交社保    一旦劳动关系建立，用人单位就应该依法为劳动者缴纳社会保险。如果用人单位在试用期拒绝为劳动者办理社会保险，劳动者可以向劳动和社会保障部门投诉；劳动者以此为理由解除劳动合同的用人单位还应支付赔偿金。很多用人单位都以试用期不用交社保，过了试用期再为毕业生办理社保为由拒交或欠交社保。        劳动合同内容    在通知试用前，务必要先签订劳动合同，看清合同单位名称、法人代表等信息，注意检查薪资、职位是否和录用函上相同，合同是否包含劳动合作期限、工作内容、劳动保护和条件、报酬等内容。  4.2 这些合同要慎签  口头合同：没有签署书面合同文件。  简单合同：条文没有细节约束。  抵押合同：要求缴纳证件或财务。  双面合同：一份合法的“假”合同，一份不合法的“真”合同。  生死合同：含有“工伤概不负责”等字眼。  “暗箱”合同：不向求职者讲明合同内容。  卖身合同：要求几年内求职者不可跳槽至同行业公司工作。  霸王合同：合同只从单位角度出发，求职者处于被动地位。五、各地就业信息网"
  },
  
  {
    "title": "2.车辆",
    "url": "/posts/cheliang/",
    "categories": "MyNotes, 3_ZhengCeFaGui",
    "tags": "",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "一、北京车辆限制条例1.1 限行  限行政策（2021-11-01起）          六环内：进京证（六环内），一次7天，一年12次      六环外：进京证（六环外），一次7天，不限次数      1.2 限号北京市尾号限行规定1.3 禁行顺义区道路限制时间：7:00 - 9:00、17:00 - 19:00外地车（含临时号牌、含办理进京通行证）禁行二、北京车辆摇号2.1 摇号时间三、...",
    "content": "一、北京车辆限制条例1.1 限行  限行政策（2021-11-01起）          六环内：进京证（六环内），一次7天，一年12次      六环外：进京证（六环外），一次7天，不限次数      1.2 限号北京市尾号限行规定1.3 禁行顺义区道路限制时间：7:00 - 9:00、17:00 - 19:00外地车（含临时号牌、含办理进京通行证）禁行二、北京车辆摇号2.1 摇号时间三、车检3.1 车检新规3.1.1 2022-10-01起3.1.2 2024车检新规2024年车辆年检新规主要包括以下几个方面的变化：  取消六项传统检测项目：          车速表误差检测      动力性检测      噪音检测      悬架检测      电子手刹检测      尾气排放检测        新增三项检测内容：          电动汽车电池检测      车载信息系统检测      智能化应用检测        免检范围扩大：          9座及以下的非营运小型载客汽车，享受10年内每2年检测1次的政策。      新购买的私家车将享受6年的免检待遇。      7座至9座的汽车也划入6年免检范围（不包括面包车）。        年检周期调整：          对于达到国家标准的新车，年检周期延长至3年一次。对于达到超低排放和零排放标准的新能源车辆，年检频率减少至5年一次。      车龄10年内的家用车只需两次上线检测。      d车龄6到10年的车辆，上线检验调整为2次，即第六年和第八年各一次。      车龄10年以上的车辆，每年需要进行一次检测；15年后则需要每半年测试一次。      3.2 车检过程  准备行驶证原件、身份证原件、交强险副本原件、车船税证明，将车开到检测站。  到收费窗口领取申请表并缴纳费用，然后等待做尾气检测。  检测员核对发动机号和汽车外观后，会将车开到线上做尾气检测，检测不合格的需要维修后再回来重新检测。  通过检测后，到查询窗口检查违章情况，有违章的需要处理完毕后再回来年检。  无违章的，工作人员会在表格上盖章，然后车主持外观检测单，到外观工位等待检测；  外观检测的工作人员会检查汽车的灯光、车身、悬架等外观部位。  通过后，即可进行上线检测，测试汽车的制动、操控性能，灯光、底盘等部件。  通过检测后，到总检处盖章，再到收费窗口缴费，工作人员就会在行驶证副页上签注，并核发新的检验合格标志。四、车险4.1 车险新规（2022）2022年不计免赔没有取消，而是加入了车损险中。也就是说，不计免赔并不是取消了，而是被捆绑进入了车损险中一起销售。除了不计免赔险之外，还有自燃险、盗抢险、玻璃险、无法找到第三方险、发动机涉水险也都被捆绑进入了车损险中一起销售。五、行驶证5.1 行驶证更换车辆行驶证不需要更换，但是需要年检。行驶证需要更换，与其说更换，不如说是签注。行驶证是没有有效期的，只要机动车能通过年检，行驶证就会一直有效。虽然没有有效期，但行驶证上有一个检验有效期，这个日期就是汽车的检验有效期，汽车通过年检后，工作人员就会在行驶证的副页上进行签注，即打印新的检验有效期。六、车辆行驶6.1 事故处理流程撞车后如果未造成人身伤亡，当事人对事实及成因无争议的，在记录交通事故的时间、地点、对方当事人的姓名和联系方式、机动车牌号、驾驶证号、保险凭证号、碰撞部位，并共同签名后，撤离现场，自行协商损害赔偿事宜。当事人对交通事故事实及成因有争议的，应当迅速报警。开车出了事故的处理流程（有人员伤亡或双方存在争议）  事故发生后立即停车保护现场，有人员伤亡的马上抢救伤员；  迅速报警并通知保险公司；  等待交通警察赶赴现场勘验处理；  交警出具事故责任认定书，当事人共同请求调解的，交警可以当场对损害赔偿争议进行调解。对道路交通事故造成人员伤亡和财产损失需要勘验、检查现场的，交通管理部门将会按照勘察现场工作规范进行。公安机关交通管理部门对经过勘察、检查现场的交通事故将会在勘察现场之日起10日内制作交通事故责任认定书。对需要检验、鉴定的，会在检验、鉴定结果确定之日起5日内制作交通事故认定书。七、车辆报废机动车报废标准一览表（2024）2024年私家车报废标准的主要变化是取消了15年的强制报废年限，改为按照汽车的实际运行里程来判断是否需要报废。‌这一变化意味着，私家车不再受到15年报废年限的限制，车主可以根据汽车的实际状况和需求，选择何时进行报废处理‌。取消15年报废年限后，汽车报废标准将根据实际运行里程来决定。当汽车的累计运行里程达到一定数值时，需要进行报废处理。此外，汽车在达到一定运行里程后，需要进行安全技术检验，如果车辆在检验过程中发现问题，可能需要进行维修或更换零部件，以确保车辆的安全性能‌。"
  },
  
  {
    "title": "3.笔试",
    "url": "/posts/bishi/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Windows10系统字体模糊",
    "url": "/posts/win10-ziti-mohu/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "故障原因这个不是字体的问题，是电脑的特效较高，阴影较为清晰。解决方案把阴影效果关掉。在计算机图标点击“右键”，选择“属性”，高级系统设置 —— 高级 —— 性能 —— 设置 —— 把“在桌面上为图标标签使用阴影”的勾去掉。",
    "content": "故障原因这个不是字体的问题，是电脑的特效较高，阴影较为清晰。解决方案把阴影效果关掉。在计算机图标点击“右键”，选择“属性”，高级系统设置 —— 高级 —— 性能 —— 设置 —— 把“在桌面上为图标标签使用阴影”的勾去掉。"
  },
  
  {
    "title": "Windows10打开图片时提示“在禁用UAC时，无法激活此应用”",
    "url": "/posts/win10-wufa-dakai-tupian/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "故障描述Windows10正式版打开图片时提示“在禁用UAC时，无法激活此应用”。解决方案1打开“运行”，输入’msconfig’并按回车键进入“系统配置”程序界面。切换到“工具”选项卡，选中“更改UAC设置”项，点击“启动”按钮。此时将直接打开“用户账户控制设置”窗口，将“用户账户控制”级别设置为除“从不通知”之外的其它级别，点击“确定”按钮。接下来我们必须重启一下计算机，才能使“用户账户...",
    "content": "故障描述Windows10正式版打开图片时提示“在禁用UAC时，无法激活此应用”。解决方案1打开“运行”，输入’msconfig’并按回车键进入“系统配置”程序界面。切换到“工具”选项卡，选中“更改UAC设置”项，点击“启动”按钮。此时将直接打开“用户账户控制设置”窗口，将“用户账户控制”级别设置为除“从不通知”之外的其它级别，点击“确定”按钮。接下来我们必须重启一下计算机，才能使“用户账户控制（UAC）”功能得到生效。解决方案2打开“运行”，输入Regedit运行注册表，找到HKEY_LOCAL_MACHINE——SOFTWARE——Microsoft——Windows——CurrentVersion——Policies\\System——EnableLUA的值，把数值数据改为1，修改完成后关机重启。UACUAC(User Account Control，用户帐户控制)是微软为提高系统安全而在Windows Vista中引入的新技术，它要求用户在执行可能会影响计算机运行的操作或执行更改影响其他用户的设置的操作之前，提供权限或管理员‌密码。通过在这些操作启动前对其进行验证，UAC可以帮助防止恶意软件和间谍软件在未经许可的情况下在计算机上进行安装或对计算机进行更改。通俗的说：UAC指在打开应该程序时需要用户手动授权。"
  },
  
  {
    "title": "命令提示符无法执行命令",
    "url": "/posts/DOS-jiemian-wufa-zhixing-mingling/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "故障描述可以运行cmd打开命令提示符界面，但是无法执行命令，所有的命令都提示xx不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法修改环境变量，在path变量值后添加%SystemRoot%\\system32，故障修复。",
    "content": "故障描述可以运行cmd打开命令提示符界面，但是无法执行命令，所有的命令都提示xx不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法修改环境变量，在path变量值后添加%SystemRoot%\\system32，故障修复。"
  },
  
  {
    "title": "JQuery下载页面所有图片",
    "url": "/posts/xiazai-yemian-quanbu-tupian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function () {    var imglist = $(\"body\").find(\"img\");    for (var i = 0; i &lt; imglist.length; i...",
    "content": "&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function () {    var imglist = $(\"body\").find(\"img\");    for (var i = 0; i &lt; imglist.length; i++) {        downloadImage($(imglist[i]).attr(\"data-src\"), i);    }});function downloadImage(path, imgName) {    var _OBJECT_URL;    var request = new XMLHttpRequest();    request.addEventListener('readystatechange', function (e) {        if (request.readyState == 4) {            _OBJECT_URL = URL.createObjectURL(request.response);            var $a = $(\"&lt;a&gt;&lt;/a&gt;\").attr(\"href\", _OBJECT_URL).attr(\"download\", imgName);            $a[0].click();        }    });    request.responseType = 'blob';    request.open('get', path);    request.send();}&lt;/script&gt;"
  },
  
  {
    "title": "3.疫苗",
    "url": "/posts/yimiao/",
    "categories": "MyNotes, 3_ZhengCeFaGui",
    "tags": "",
    "date": "2020-12-27 13:47:00 +0800",
    





    
    "snippet": "一、疫苗知识1.1 肺炎疫苗  23价肺炎疫苗  接种对象：2周岁以上，年老体弱、患有慢性疾病以及免疫功能低下人群免疫程序：注射一针就可以了。接种以后疫苗产生保护性抗体，具有5年左右的效力。如有较高感染风险，5年后可加强1剂。  13价肺炎疫苗（国产）  接种对象：6周龄~5岁（6周岁生日前）婴幼儿和儿童免疫程序：1.5~6月龄：3+1剂次，基础免疫间隔2个月以上，12~15月龄加强免疫7~...",
    "content": "一、疫苗知识1.1 肺炎疫苗  23价肺炎疫苗  接种对象：2周岁以上，年老体弱、患有慢性疾病以及免疫功能低下人群免疫程序：注射一针就可以了。接种以后疫苗产生保护性抗体，具有5年左右的效力。如有较高感染风险，5年后可加强1剂。  13价肺炎疫苗（国产）  接种对象：6周龄~5岁（6周岁生日前）婴幼儿和儿童免疫程序：1.5~6月龄：3+1剂次，基础免疫间隔2个月以上，12~15月龄加强免疫7~11月龄：2+1剂次，基础免疫间隔2个月以上，12月龄以后加强免疫12~23月龄：2剂次，间隔2个月以上2岁~5岁：1剂次  13价肺炎疫苗（进口）  接种对象：8周龄至15月龄婴幼儿免疫程序：1.5~6月龄：3+1剂次，基础免疫间隔4~8周，12~15月龄加强免疫1.2 手足口疫苗手足口病疫苗最好在6个月到5岁之间进行注射，因为这个时间段之内最有可能发生手足口病，出现手足口病的重症。手足口病的疫苗目前只针对肠道病毒71型的感染，病毒感染之后，造成手足口病重症的可能性比较大。当6个月之前，孩子可以从母乳中获得一定量的抗体，这些抗体很有可能也有针对肠道病毒71型的抗体，这个时候注射手足口病疫苗的获益可能不是太大，有可能承受疫苗带来的全身发热等不良反应，在6个月之后进行注射的意义比较大。超过了5岁，患者出现手足口病之后，出现重症的可能性也不大，注射疫苗获益就会比较小，建议在6个月到5岁之间，进行注射手足口病的疫苗。我国自行研制的EV71灭活疫苗，肌注两剂，间隔28日。1.3 水痘疫苗建议1~3岁的儿童接种一剂量，4~6岁加强一剂，要注意至少间隔三个月。接种水痘疫苗后一般无反应，在接种6-18天内少数人可有短暂一过性的发热或轻微皮疹，一般无需治疗会自行消退，必要时可对症治疗。水痘疫苗是终生免疫的。1997年水痘疫苗在中国上市，为第二类疫苗自愿接种，接种医生按照说明书应用，全国没有推荐的、统一的接种程序。我国大部分省市实行1剂次水痘接种策略。2012月10月31日，北京将水痘疫苗接种程序调整为：满18月龄接种第1剂，满4岁接种第2剂。国内除了北京外，国内越来越多的省市开始将水痘疫苗调整为两剂次，并且还有些城市将两剂次水痘疫苗纳入了免疫规划中。 广东：2017年10月16日，将水痘疫苗接种程序调整为自愿自费接种2剂次：12~24月龄接种第1剂，4~6周岁接种第2剂。天津：2017年5月1日起，2016年5月1日之后出生的儿童，满1周岁可免费接种第1剂水痘疫苗，满4周岁免费接种第2剂水痘疫苗。上海：2017年，将水痘疫苗接种程序调整为两针法，即12月龄和4周岁各接种1剂次水痘疫苗。自2018年8月1日起，将水痘疫苗纳入上海市免疫规划。1.4 B型流感嗜血杆菌结合疫苗2-6月龄儿童注射3针，间隔1-2个月，18月龄加强1剂；6-12个月龄儿童注射2针，间隔1个月，18月龄加强接种1剂；1-5岁儿童注射1针。1.5 DTaP-IPV-Hib五联疫苗五联疫苗包含了百白破、灭活脊灰、流感嗜血杆菌（Hib）三种疫苗成分。适用于2月龄以上婴幼儿，2、3、4月龄和18-24月龄各接种1剂。第1、2、3剂相邻两剂次间隔≥28天，第3、4剂次之间间隔≥6个月1.6 出血热疫苗适用于16-60岁流行性出血热疫区易感人群，按0、14天程序接种两针，基础免疫后6个月加强一针。1.7 狂犬疫苗犬类动物咬伤或抓伤者按0、3、7、14、28（或30）天或者0、7、21天程序接种，越早接种越好，咬伤严重者在医生指导下酌情加用抗狂犬病被动免疫制剂，特殊职业人群或宠物饲养者按0、7、21（或28）天程序做预防注射。1.8 轮状病毒疫苗2个月-3岁以内的婴儿每年口服一次。1.9 霍乱疫苗2岁或2岁以上儿童，青少年和有接触或传播危险的成年人初次免疫者分别于0、7、28天口服，每次一粒，接受过免疫人员可视疫情于流行季节前加强一次。1.10 HPV疫苗1.11 流感疫苗  灭活疫苗：灭活疫苗的优点是免疫原性比较强，抗体产生的效果也很好，缺点是副作用发生的几率比较高，不适合12岁以下的儿童使用。  裂解疫苗：裂解疫苗保留了病毒的抗原成分，去除了病毒核酸和大蛋白，优点是副作用发生的几率比较小，而且保留了较高的免疫原性，缺点是工艺比较复杂，还需要使用裂解剂。  亚单位疫苗：亚单位疫苗只保留了流感病毒的神经氨酸酶和血凝素蛋白，抗原成分比较单一，其优点是副作用比较小，而且价格低廉，缺点是免疫性较弱。  减毒活疫苗：是由流感病毒通过解毒得到的，但是流感病毒容易发生变异，如果接种了这种疫苗，但是病毒出现了变异，是没有太大效果的。目前，在我国批准上市的流感疫苗主要是有三种，是三价的灭活疫苗、三价的减毒活疫苗、四价的灭活疫苗。二、接种政策2.1 接种政策（2020）2.1.1 脊灰疫苗1月7日，国家卫生健康委网站发布消息称，国家卫生健康委、财政部、工业和信息化部、国家药监局联合发布了《关于国家免疫规划脊髓灰质炎疫苗和含麻疹成分疫苗免疫程序调整相关工作的通知》，对脊髓灰质炎疫苗和含麻疹成分疫苗免疫程序作出调整。脊灰疫苗和含麻疹成分疫苗均为国家免疫规划疫苗。《通知》指出，自2019年12月起，将脊灰疫苗免疫程序调整为前两剂次使用脊灰灭活疫苗(IPV)，第3、4剂次使用脊灰减毒活疫苗(OPV)；2019年10月1日后出生的儿童，未完成第2剂脊灰疫苗接种的，在接种第2剂次脊灰疫苗时，按照调整后的免疫程序接种IPV。自2020年6月起，对含麻疹成分疫苗免疫程序作出调整，8月龄和18月龄各接种1剂次麻腮风联合疫苗(MMR)。中国疾控中心免疫规划中心主要负责人表示，2016年5月1日，我国调整了脊灰疫苗免疫程序，适龄儿童常规免疫第1剂次接种IPV，第2、3、4剂次接种OPV。免疫程序此次调整后，可进一步提高Ⅱ型脊灰病毒抗体水平，同时保留针对I型和III型病毒的肠道黏膜免疫水平，阻断相应型别病毒的传播。2.2 接种政策（2021）2.2.1 脊灰疫苗延续了2019年底国家卫健委调整后的方案，即【2+2（注射2剂IPV + 口服2剂bOPV）】。同时，最新版明确提出：如儿童已按免疫程序完成4剂次含IPV成分疫苗接种（如：五联疫苗），则4岁可不再接种bOPV。2.2.2 补种年龄针对儿童疫苗补种的年龄，从14岁提高到18岁，也就是所有未成年人未完成相关免疫规划疫苗接种，都可根据实际情况进行相关疫苗补种。三、接种程序"
  },
  
  {
    "title": "4.面试",
    "url": "/posts/mianshi/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-27 13:47:00 +0800",
    





    
    "snippet": "一、面试要点1.1 面试需要关注的问题  项目信息：项目内容、工作地点、是否稳定是否出差  加班调休：年假、周末双休、是否加班加班补助  试用社保：试用期时长、试用期缴纳社保、缴纳比例  工资薪酬：一年几薪、其他福利提供食宿、月薪多少1.2 简历要点  简历名称：全名 + 求职岗位 + 手机号码  简历内容：专业和工作经验只写和求职岗位相关联的，突出核心竞争力  简历格式：PDF  简历照片...",
    "content": "一、面试要点1.1 面试需要关注的问题  项目信息：项目内容、工作地点、是否稳定是否出差  加班调休：年假、周末双休、是否加班加班补助  试用社保：试用期时长、试用期缴纳社保、缴纳比例  工资薪酬：一年几薪、其他福利提供食宿、月薪多少1.2 简历要点  简历名称：全名 + 求职岗位 + 手机号码  简历内容：专业和工作经验只写和求职岗位相关联的，突出核心竞争力  简历格式：PDF  简历照片：用证件照  投递时间：工作日8:30 - 10:00是黄金时间段  投递邮件：标题：全名 + 求职岗位 + 是否有经验 + 手机号码，正文：简单的自我介绍 + 求职意向 + 工作经验 + 优点1.3 求职软件要点绝大多数的招聘软件的人才管理界面都差不多。会显示候选人的 头像，姓名，基本信息（年龄，工作时长，学历，居住地），活跃度，教育经历，工作经历。工作经历里直接显示入离职时间，工作时长，公司，职位。HR筛的时候看到硬性要求（年龄学历专业等）不合适的候选人直接就点不合适了，是不会再点进去看详细简历的。大家求职时看到的“感兴趣”，应该是这里的“合适”。HR筛硬性条件的时候会直接点“合适”“不合适”。所以“感兴趣”其实指的是硬性条件符合要求了。之后HR还会在“合适”的候选人里筛选更匹配岗位的候选人联系。如果大家要找工作，在线简历一定要好好写！！！因为前程无忧只有候选人投递之后后台才能看到附件简历，而且如果候选人太多有时候HR会懒得下载一个个附件简历，直接看在线简历，如果在线简历写得很烂可能HR就直接pass了。1.4 职业技能术语  数据库      熟悉Oracle、MySQL、SQL Server数据库，熟练使用SQL语句操作数据库；    掌握Java、Oracle、MySQL基本语法；    熟练掌握运用SQLServer、Oracle、MySql等数据库及操作语言；    熟练Oracle数据库的操作，能够编写存储过程，熟悉Mysql和SqlServer数据库；    前端      熟练使用HTML、CSS、JavaScript三大前端语言；    熟悉常用的前端语言框架，如jQuery；    掌握HTML5、JavaScript、VUE前端技术；    熟练使用jsp、servlet进行web应用开发；    能熟练使用Javascript、Ajax、CSS技术提高系统的友好性、可操作性、提升用户体验效果；    灵活使用Html、DHtml等网页设计语言，理解XML标记语言；    框架      掌握Spring Boot开发框架，使用该框架搭建项目；    掌握Spring Boot开发框架及Spring Cloud常用组件；    熟练使用Spring、Struts、Mybatis、Hibernate常用框架；    掌握Dubbo、Zookeeper服务框架；    精通Struts、Hibernate、Spring开源框架，并熟练运用MVC设计模式，并具有使用这些技术的丰富经验。    开发模式      熟练使用SpringMVC开发模式；    熟练应用Struts+Hibernate，SSH2框架和MVC三层架构开发模式；    编程思想      熟练面向对象编程思想，扎实的Java基础知识；    具有面向对象思想，扎实的编程功底以及良好的编码习惯；    性能      掌握Redis缓存技术、Solr索引技术；    掌握RocketMQ队列；    掌握RocketMQ队列，优化系统性能；    web      熟悉servlet的生命周期，可以用servlet完成小型web项目；    能熟练运用servlet中的Filter和Listener；    熟悉servlet中的cookie和session；    熟练使用Jsp，HTML，JavaScript，Jquery，Ajax，Css等WEB客户端技术；    版本控制      熟练使用Git、SVN工具进行协同开发；    熟练使用SVN、Git进行版本控制和代码维护    开发工具      熟练使用Eclipse、Maven等开发和构建工具；    中间件      掌握Tomcat、Weblogic容器部署及使用方法；    熟练掌握Tomcat、Weblogic、JBoss等Web容器以及J2EE容器的配置以及部署；    系统      掌握Linux操作系统，熟练使用常用Linux命令；    了解Linux系统下常用开发工具的安装和操作；    缺陷管理      掌握Jira、禅道、BugFree等缺陷管理工具；    其他      了解http协议，可以通过http watch查看b/s的信息交互；    了解设计模式，代码重构和项目过程管理，能够编写文档；  二、历史面试题汇总事务的隔离级别  由低到高：读未提交、读已提交、重复读、串行化。  读现象是在多个事务并发执行时，在读取数据方面可能碰到的问题。包括脏读、不可重复读、幻读。      脏读：读到了脏数据，即无效数据。    不可重复读：是指在数据库访问中，一个事务内的多次相同查询却返回了不同数据。    幻读：指同一个事务内多次查询返回的结果集不一样，比如增加了行记录。    备注：不可重复读对应的是修改，即update操作。幻读对应的是插入操作。幻读是不可重复读的一种特殊场景。要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但是随之带来的，隔离级别越高，并发能力越低。所以，需要根据业务去进行衡量，具体场景应该使用哪种隔离级别。  Read uncommitted(读未提交)  提供了事务间最小限度的隔离。就是一个事务可以读取另一个未提交事务的数据。示例：小明去商店买衣服，付款的时候，小明正常付款，钱已经打到商店老板账户，但是小明发起的事务还没有提交。就在这时，商店老板查看自己账户，发现钱已到账，于是小明正常离开。小明在走出商店后，马上回滚差点提交的事务，撤销了本次交易。结果：小明未付钱买到了衣服，商店老板实际未收到小明的付款。分析：商店老板查看自己的资金账户，这个时候看到的是小明还没有提交事务的付款。这就是脏读。注意：处于该隔离级别的事务A与B，如果事务A使用事务B不提交的变化作为计算的基础，然后哪些未提交的变化被事务A撤销，这就导致了大是的数据错误变化。  Read committed(读已提交)  该级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的同一SQL在其他事务执行前后返回的是不同的结果。一个事务要等另一个事务提交后才能读取数据。示例：小明卡里有1000元，准备与几个朋友聚餐消费，消费1000元，当他买单时(事务开启)，收费系统检测到他卡里有1000元。就在检测完毕的时候，小明女朋友发现小明有私房钱，全部转走并提交。当收费系统准备扣款时，再检查小明卡里的金额，发现已经没钱了，付款不成功。小明此时就会很纳闷，明明有钱的呀，钱呢?分析：该示例中同一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。该隔离级别可以解决脏读问题。  Repeatable read(重复读)  在开始读取数据(事务开启)时，不再允许修改操作示例：还是小明有1000元，准备跟朋友聚餐消费这个场景，当他买单(事务开启)时，收费系统检测到他卡里有1000元，这个时候，他的女朋友不能转出金额。接下来，收费系统就可以扣款成功了。分析：重复读可以解决不可重复读的问题。  Serializable(序列化)  数据库事务的最高隔离级别。在此级别下，事务串行执行。可以避免脏读、不可重复读、幻读等读现象。但是效率低下耗费数据库性能，不推荐使用。事务的特征  原子性、一致性、隔离性、持久性。分布式事务  分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务。分布式事务的四种方案包括两阶段提交（2PC）、补偿事务（TCC）、本地消息表（异步确保）和最大努力通知。      两阶段提交（2PC）：这是一种通过引入协调者来协调参与者行为，并最终决定这些参与者是否要真正执行事务的方案。它分为两个阶段：准备阶段和提交阶段。在准备阶段，协调者询问参与者事务是否执行成功，参与者发回事务执行结果。如果事务在每个参与者上都执行成功，协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。存在的问题包括同步阻塞、单点问题、数据不一致和太过保守。    补偿事务（TCC）：这是一种针对每个操作注册一个与其对应的确认和补偿（撤销）操作的方案。它分为三个阶段：Try阶段主要是对业务系统做检测及资源预留；Confirm阶段主要是对业务系统做确认提交；Cancel阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。优点是跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些。缺点是比较明显的，在2,3步中都有可能失败。    本地消息表（异步确保）：这是一种在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息的方案。本地事务能保证这个消息一定会被写入本地消息表中。之后将本地消息表中的消息转发到Kafka等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。优点是一种非常经典的实现，避免了分布式事务，实现了最终一致性。    最大努力通知：这是一种基于可靠消息服务的分布式事务解决方案，通过定期校对的方式处理任务完成后发送消息的情况。它通过最大努力通知机制来确保消息的传递和可靠性。  Spring Cloud五大组件      Eureka：该系统下还分为Eureka服务端和Eureka客户端，Eureka服务端用作服务注册中心，支持集群部署。Eureka客户端是一个Java客户端，用来处理服务注册与发现。    Ribbon：客户端负载均衡，提供客户端的软件负载均衡算法。    Hystrix：断路器，它的作用是保护系统，控制故障范围。    Zuul：提供API网关，路由，负载均衡等作用。    Spring Cloud Config：分布式配置，提供服务端和客户端，服务器存储后端的默认实现使用Git。  Ribbon的工作方式  通过服务发现和负载均衡策略来分配请求到不同的服务提供者，原理是使用拦截器将缓存中的服务列表经过一定算法对server name进行替换。有如下几种负载均衡策略：      轮询（RoundRobin）：对所有请求，轮流分配到各个服务器。    随机（Random）：随机选择一个服务器来处理请求。    响应时间加权（ResponseTimeWeighted）：服务器响应时间越长，接收的请求越少，加权策略会减少其被选择的几率。    区域权重（ZoneAvoidance）：复杂的策略，考虑服务器所在区域的性能和服务器的可用性。    并发量（ClientConfigEnabled）：根据配置文件中的设定，选择并发量最低的服务器。  MySQL和Oracle的特点      Oracle是大型数据库，MySQL是中小型数据库    MySQL是开源的，Oracle价格非常高    Oracle支持大并发，大访问量，是OLTP最好的工具    安装所用的空间差别也是很大的，MySQL安装完后才152M而Oracle有3G左右，且使用的时候Oracle占用特别大的内存空间和其他机器性能。  数据库优化      选取最适用的字段属性，减少类型间的转换    将表中的字段宽度设置的尽可能小    使用连接来代替子查询    使用联合（UNION）来代替手动创建的临时表  微服务如何划分模块      单一责任原则（SRP）：每个微服务应只负责一个特定的功能或领域，避免多职责混合。    松耦合：不同微服务之间应尽量减少直接依赖，通过异步通信机制如消息队列或事件总线来解耦服务之间的直接依赖。    基于业务功能划分：按照业务功能进行模块划分，例如投放服务、营销活动服务、呼叫服务等。这种方法有助于保持服务的独立性和可维护性。    基于流程架构和业务架构：从跨系统交互流程出发，分析业务交互接口点，识别关键的业务服务能力。这种方法有助于确保每个微服务都能独立完成其业务逻辑。    数据驱动：基于数据架构进行模块划分，确保每个微服务能够独立处理其数据。这种方法有助于提高数据处理的效率和准确性。    合理划分模块数量：传统的大业务系统在划分微服务模块时，建议划分到6到8个模块比较合适，随着IT成熟度的提高，可以进一步细化。  HashMap和HashTable的区别      两者最主要的区别在于Hashtable是线程安全，而HashMap则非线程安全    HashMap可以使用null作为key，而Hashtable则不允许null作为key    HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类  Cookie和Session的区别  Cookie和Session是两种常见的用于存储用户数据的技术手段，它们在实现机制、安全性、存储位置等方面存在显著区别。      存储位置 Cookie：存储在客户端（浏览器）上。Session：存储在服务器端。    安全性Cookie：相对不安全，因为数据存储在客户端，容易被篡改或窃取。Session：更安全，因为数据存储在服务器端，并且通常会进行加密处理。    数据类型Cookie：只能存储字符串类型的数据，如果需要存储非ASCII字符，还需要进行编码。Session：可以存储任何类型的数据，是一个容器，可以存储更复杂的数据结构。    有效期Cookie：有效期取决于浏览器的设置，可以是永久性的，也可以是有限期的。Session：通常在会话结束或者浏览器关闭时结束，或者在一定时间内无活动后自动结束。    依赖关系Cookie：不一定依赖于Session，但Session可以通过Cookie来识别用户身份。Session：依赖于Cookie来传递会话ID，以便服务器能够识别用户。  HashMap和HashTable的线程安全性      HashMap几乎可以等价于HashTable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而HashTable则不行)。    HashTable是线程安全的，多个线程可以共享一个HashTable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。    由于HashTable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过HashTable。    HashMap不能保证随着时间的推移Map中的元素次序是不变的。  Maven查看jar包依赖结构的命令mvn dependency:tree -Dincludes='*persistence*'  persistence是你想要查找的jar包的名字的一部分。Docker和K8S的区别      抽象层次不同：Docker提供了一种容器化的技术，而Kubernetes提供了一个容器编排和管理的平台。Docker更关注如何构建和打包容器，而Kubernetes更关注如何在集群上管理和运行这些容器。    管理范围不同：Docker主要用于本地开发和单主机环境中的容器管理，而Kubernetes适用于多主机或云环境中的容器编排和调度。    功能不同：Docker提供了基本的容器操作，如启动、停止和删除容器。而Kubernetes提供了更高级和复杂的功能，如自动伸缩、负载均衡和服务发现。    应用程序生命周期管理：Kubernetes更关注整个应用程序的生命周期管理，包括部署、自动扩展、更新和回滚。而Docker更注重容器本身的构建和管理。    缩放能力：Kubernetes提供了自动伸缩功能，可以根据应用程序的负载情况自动调整容器的数量。Docker只能手动进行缩放操作。    高可用性：Kubernetes提供了高可用性的能力，可以在集群中的不同节点上运行容器，并根据需要重新启动或迁移容器。Docker只能在单个主机上运行容器。    需要注意的是，Docker和Kubernetes并不是互斥的，而是可以互补使用的。在实际应用中，通常使用Docker来构建和打包应用程序的容器镜像，然后使用Kubernetes来管理和调度这些容器。这两个工具可以一起使用，以便获得更好的容器化和应用程序管理体验。总而言之，Kubernetes和Docker在容器化技术中发挥着不同的角色。Docker提供了容器化的基本功能，而Kubernetes提供了容器编排和管理的高级功能。它们可以一起使用，以便帮助开发人员更好地构建、部署和管理应用程序。三、面试技巧在面试时，经过寒暄后，一般面试官会让你介绍项目经验。最常见的问法是，说下你最近的（或最拿得出手的）一个项目。一般来说，面试官会根据介绍的项目的背景来提问题，假设面试时会问10个问题，那么至少有5个问题会根据候选人所介绍的项目背景来问。候选人如果没有说好，那么就没法很好地引导后继问题了，就相当于把提问权完全交给面试官了。3.1 在面试前准备项目描述            要素      你      面试官                  对你以前的项目和技能      很了解      只能听你说，只能根据你说的内容做出判断              在面试过程中的职责      在很短的时间内防守成功即可      如果找不出漏洞，就只能算你以前做过              准备时间      充足      一般在面试前30分钟阅读你的简历              沟通过程      可以出错，但是别出关键性的错误      不会太为难你，除非你太差              技巧      可以从网上找到足够多的面试题      其实就问些通用的有规律的问                  提问方式      目的                  让你描述工作经验和项目（极有可能是最近的），看看你说的是否和简历上一致      看你是否真的做过这些项目              看你简历上项目里用到的技术，比如框架、数据库，然后针对这些技术提些基本问题      还是验证你是否做过项目，同时看你是否了解这些技术，为进一步提问做准备              针对某个项目，不断深入地问一些技术上的问题，或者从不同侧面问一些技术实现，看你前后回答里面是否有矛盾      深入核实你的项目细节              针对某些技术，问些项目里一定会遇到的问题，比如候选人说做过数据库那么就会问索引方面的问题      通过这类问题，核实候选人是否真的有过项目经验（或者仅仅是学习经验）      3.2 准备项目的各种细节这些是你实际的项目经验，那么一旦让面试官感觉你都说不上来，可信度就很低了。不少人是拘泥于项目里做了什么业务，以及代码实现的细节，这就相当于把后继提问权直接交给面试官，下表列出一些不恰当的回答方式。            回答方式      后果                  我在XX软件公司做了XX门户网站项目，这个项目做到了XX功能，具体是XX和XX模块，各模块做了XX功能，客户是XX，最后这个项目挣了XX钱      直接打断，因为业务需求我不需要了解，我会直接问他项目里的技术              （需要招聘一个Java后端开发，会SpringMVC）最近一个项目我是用C#实现的，实现了……或者我最近做的不是开发，而是测试…..或者我最近的项目没有用到SpringMVC      提问，你最近用到SSH技术的项目是什么时候，然后在评语上写：最近XX时间没有接触过SSH              在毕业设计的时候（或者在读书的时候，在学习的时候，在XX培训学校，在XX实训课程中）      直接打断，提问你这个是否商业项目，如果不是，你有没有其他的商业经验，如果没有商业项目经验，除非是校招，否则就直接结束面试              描述项目时，一些关键要素（比如公司、时间、所用技术等）和简历上的不匹配      我们会深究这个不一致的情况，如果时简历造假，那么可能直接中断面试，如果真的是笔误，那么就需要提供合理的解释      在避免上述不恰当回答的同时，大家可以按下表的要素准备项目介绍。            要素      样式                  控制在1分钟里面，讲出项目基本情况，比如项目名称，背景，给哪个客户做，完成了基本的事情，做了多久，项目规模多大，用到哪些技术，数据库用什么，然后酌情简单说一下模块，重点突出背景，技术，数据库和其他和技术有关的信息      我在XX公司做了XX外汇保证金交易平台，客户是XX银行，主要完成了挂盘，实盘成交，保证金杠杆成交等功能，数据库是Oracle，前台用到JS等技术，后台用到Java的SSH，几个人做了X个月，不需要详细描述各种功能模块，不需要说太多和业务有关但和技术无关的，如果面试官感兴趣，等他问              要主动说出你做了哪些事情，这部分的描述一定要和你的技术背景一致      我做了外汇实盘交易系统，挂单成交系统，XXX模块，做了X个月              描述你在项目里的角色      我主要是做了开发，但在开发前，我在项目经理的带领下参与了业务调研，数据库设计等工作，后期我参与了测试和部署工作              可以描述用到的技术细节，特别是你用到的技术细节，这部分尤其要注意，你说出口的，一定要知道，因为面试官后面就根据这个问的。你如果做了5个模块，宁可只说你能熟练说上口的2个      用到了Java里面的集合，JDBC…等技术，用到了SpringMVC等框架，用技术链接数据库              这部分你风险自己承担，如果可以，不露声色说出一些热门的要素，比如Linux，大数据，大访问压力等，但一旦你说了，面试官就会直接问细节      这个系统里，部署在Linux上，每天要处理的数据量是XX，要求是在4小时，1G内存的情况下处理完5千万条数据，平均访客是每分钟XXX      面试前，一定要有自信，但也要避免如下的一些情况。            要避免的情况      正确的做法      原因                  回答很简单，问什么答什么，往往就用一句话回答      把你知道的都说出来，重点是突出你知道的思想，框架      问：SSH用过吗？答：用过问：在什么项目里用到？答：一个保险项目              说的太流利      适当停顿，边思考边说      让面试官感觉你在背准备的东西，这样后面问题就很难              项目介绍时什么都说      就说些刚才让准备的一些，而且要有逻辑的说      会让面试官感觉你思路太乱              别太多介绍技术细节，就说你熟悉的技术      技术面点到为止，等面试官来问      你说到的所有技术要点，都可能会被深问，面试官一般有自己的面试节奏，如果你在介绍时就说太多技术细节，很有可能被打断，从而没法说出你准备好的亮点      3.3 不露痕迹地说出面试官爱听的话在项目介绍的时候，面试官很想听一些关键点，只要你说出来，而且这些相关问题回答的比较好，这绝对是加分项。下面表格是面试官爱听的关键点和对应的说辞。            关键点      说辞                  能考虑到代码的扩展性，有参与框架设计的意识      我的项目XX保险项目，用到SSH技术，数据库是Oracle，开发的时候，我会先和项目经理一起设计框架，并参与了框架的构建链接数据库的时候，我们用到了DAO，这样做的理由是，把SQL语句封装到DAO层，一旦要扩展功能模块，就可以不用做太多的改动。              有调优意识，能通过监控发现问题点，然后解决      在开发阶段，我就注意到内存的性能问题和SQL运行的时间问题，在压力测试阶段 ，我会通过XX工具来监控内存和数据库，发现待提升的代码点，然后通过查资料来优化，最后等项目上线后，我们会部署监控系统，一旦发现内存和数据库问题，我们会第一时间解决。      3.4 一定要主动找一切机会说出你拿得出手的，而且当前也非常热门的技术。3.5 不要犯低级错误下列是会导致你直接出局的错误回答。            错误类型      导致的后果                  前后矛盾，后面的回答无法证明你的项目描述，比如一开始说用到了SpringMVC，后面没法说出最基本的实现，比如不知道Spring有哪些类，或者没法说出项目的细节。      我会怀疑这个项目的真实性，我就会进一步问：数据库用什么，数据量多少，多少人做了多长时间，一旦再出现明显漏洞，比如一个小项目用到非常多的时间，那么就不仅仅是技术问题，而是在面试过程中企图蒙混过关的性质了。              项目里一定会用到的基本概念性问题都回答不上，Spring的依赖注入概念是什么，怎么用的，或者Hibernate的一对多怎么实现。      一旦被发现概念不知道，就会通过更多问题确认，如果被确认很弱，这就相当严重，因为技术能力差和技术没用过是两个截然不同的状况，技术没用过会导致直接出局              面试时说出的工作经验和简历上的不一致。      我会直接怀疑简历时编的，会让候选人解释，即使是说简历写错了，我也会问比较深入的问题来核实他的技能和能力。              简历上的技能描述和回答出来的明显不一致，比如明明是只会简单的Linux，但吹的天花乱坠。      我会通过一些比较深的问题核实其他技能，找出其他方面吹嘘的水分。所以建议，你可以适当的夸张，但是别太过分，比如你在项目里没搭建框架但平时学习时搭建过，你可以写XX项目的框架是你搭建的，但你不能说你是一个架构师，非常了解项目的底层。              让面试官感觉你不稳定，很浮躁，比如说话不庄重，或者面试时打扮非常不正规，就穿背心来。      即使你技术再好，这个会可能导致你直接出局。我对油嘴滑舌的候选人一般会直接写上不好的评语。              明说不能加班，不能出差。      其实虽然有这一问，但是公司里未必真的会加班出差，但听到这类回答，说明这个人不能承受大压力工作，或者责任心不强，大多数公司是不会要这种人的。      四、HR面请你自我介绍一下你自己      企业最希望知道的是求职者能否胜任工作。    介绍自己最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等。    条理要清晰，层次要分明，不宜过长。    企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”，企业喜欢有礼貌的求职者。  你有什么业余爱好      体现自己积极主动的性格、团队合作的精神、深入学习的意愿等。  你最大的优点和缺点      优点可以回答沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱等。    通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、爱忌妒人、非常懒、脾气大、工作效率低，企业肯定不会录用你。    绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。    企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分，企业喜欢聪明的求职者。  为什么选择我们公司      面试官试图从中了解你求职的动机、愿望以及对此项工作的态度。    建议从行业、企业和岗位这三个角度来回答。    面试前一定要做好功课，可以在网上查一下该公司的主营业务、发展方向和近期重大战略调整等。    可以回答一些详细的原因，像“贵公司的高技术开发环境很吸引我”、“贵公司在近几年来在市场上很有竞争力”、“贵公司能够给我提供一个与众不同的发展路径”。这些都显示出你已做了一些调查，也说明你有较为具体的职业规划。  如果我录用你，你将怎样开展工作      如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体方法。    可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作”。  我们为什么录用你      招聘单位一般会录用这样的应聘者：基本符合条件、对这份工作感兴趣、有足够的信心。    如“我符合贵公司的招聘条件，凭我目前掌握的技能、高度的责任感和良好的适应能力及学习能力，完全能胜任这份工作”。  你在前一家公司的离职原因是什么      避免把离职原因说的太详细、太具体。    避免掺杂主观负面感受，如“太辛苦”、“人际关系太复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某员工”等。    但也不能躲闪、回避，如“想换换环境”、“个人原因”等。    不能表现出对上一份工作的怨言，最好从自身发展来表明离职原因，比如，遭遇职业的天花板，或前份工作与自己的长期职业生涯规划不合等，也可以表明应聘的新职位对自己是很好的机会。  你对加班的看法      回答提示：实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。    回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。  你对薪资的要求      回答提示：如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。    回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。    回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能 根据我的情况和市场标准的水平，给我合理的薪水。    回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，知道像自己这样学历的雇员有什么样的价值。  你何时可以入职      最好回答“如果被录用的话，到职日可按公司要求的时间入职”。如果做不到，可以告知用人单位，但需要表明愿意在能力所及范围内尽快到岗。  说说你对行业、技术发展趋势的看法      面试前可以在网上查找该行业、该企业的相关信息、做足功课，包括公司各个部门发展情况。企业欢迎的是知己，而不是盲人。  在五年的时间内，你的职业规划      回答提示：这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。但是近几年来，许多公司都已经建立了专门的技术途径。这些工作地位往往被称作“顾问”、“参议技师”或“高级软件工程师”等等。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。  你朋友对你的评价      回答提示： 想从侧面了解一下你的性格及与人相处的问题。    回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。    回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。  你还有什么问题要问吗      回答提示：企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。  如果工作一段时间发现你不适合这个职位怎么办      回答提示：一段时间发现工作不适合我，有两种情况：①如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。  五、技术面ArrayList和LinkedList底层  ArrayList的底层是一个Object类型的数组，初始时，数组的长度为0。当添加元素时，数组会根据需要自动扩容。当ArrayList中的元素数量超过当前数组的容量时，ArrayList会创建一个新的更大的数组，并将原数组中的元素复制到新数组中。默认情况下，ArrayList会将数组的大小扩大为当前容量的1.5倍。ArrayList通过索引来访问元素，ArrayList在随机访问元素时效率很高。当插入或删除元素时，ArrayList需要移动其他元素以保持数组的连续性，在需要频繁插入和删除元素的情况下，建议使用LinkedList。LinkedList底层的数据结构是基于双向循环链表的，且头结点中不存放数据。由于LinkedList是基于链表的结构，访问元素时需要从头节点开始遍历链表，直到找到目标元素。因此，访问效率比ArrayList要低。在链表中插入或删除元素时，只需要修改相应节点的引用即可，不需要像数组那样移动其他元素。因此，插入和删除元素的操作比ArrayList高效。MyBatis中#与$的区别      #是预编译处理，$是字符串替换。    MyBatis在处理#时，会将SQL中的#替换为?号，使用PreparedStatement的set方法来赋值；在处理$时，就是把$替换成变量的值。    使用#可以有效的防止SQL注入，提高系统安全性。  Callable和Runnable的区别      Runnable没有返回值，而实现Callable接口的任务线程能返回执行结果。    Callable接口实现类中的run方法允许异常向上抛出，可以在内部外理try catch，但是Runnable接口实现类中run方法的异常必须在内部处理，不能抛出。  重写和重载的区别      定义不同：重载是定义相同的方法名、参数不同，重写是子类重写父类的方法    范围不同：重载是在一个类中，重写是子类与父类之间的    多态不同：重载是编译时的多态性，重写是运行时的多态性    参数不同：重载的参数个数、参数类型、参数的顺序可以不同，重写父类子方法参数必须相同    修饰不同：重载对修饰范围没有要求，重写要求重写方法的修饰范围大于被重写方法的修饰范围  git pull和fetch  git fetch是下载远程仓库的最新更新，但不会自动合并，git pull是下载远程仓库的最新更新并自动合并。数组和链表的区别      数组从栈上分配内存，链表从堆上分配内存    数组在内存中连续，链表在内存中不连续    数组的长度固定，不支持动态改变数组的大小，链表支持动态增删元素    数组存在越界风险，链表无越界风险    数组通过下标访问，访问效率高，链表从头遍历，访问效率低    数组的使用场景：当线性表的操作操作主要是进行查找，很少插入和删除时使用，链表的使用场景：当线性表要求频繁插入和删除时使用  Spring Boot的核心功能  Spring Boot最核心的功能就是自动配置，这一切都基于约定优于配置的原则，使用Spring Boot时我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。extends和implements区别  extends是继承某个类，继承之后可以使用父类方法，也可以重写弗父类方法，implements是实现一个或多个接口，实现一个接口就是要实现该接口的所有方法，抽象类除外TCP与UDP区别  TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，适用于要求可靠传输的应用。UDP是一种无连接的、不可靠的、基于数据报文的传输层协议，适用于实时应用。设计模式      单例模式              懒汉式：为了不让其他类直接访问该成员，懒汉式单例在使用时创建对象。懒汉式如果在创建实例对象时不加上synchronized则会导致对对象的访问不是线程安全的。        饿汉式：在类加载时创建一个对象。饿汉式是线程安全的，在类创建的同时就已经创建好一个静态的对象供系统使用，以后不在改变。              工厂模式              简单工厂模式：对于简单工厂，用于生产同一结构中的任意产品，对于新增产品不适用。以生产“电风扇”为例，只能批量生产电风扇。        工厂方法模式：对于工厂方法，在简单工厂的基础上，生产同一等级结构中笃定产品，可以支持新增产品。以生产汽车为例，可以通过此工厂生产各种类型的汽车。        抽象工厂模式：用于生产不同种类（品牌）的相同类型（迷你，SUV），对于新增品牌可以，不支持新增类型。用于生产不同种类（品牌）的相同类型。              适配器模式：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。    装饰模式：应用场景:1.需要扩展一个类的功能；2.动态的为一个对象增加功能，而且还能动态撤销(继承不能做到这一点，继承的功能是静态的，不能动态增加)。缺点:产生过多相似的对象，不易排错。    代理模式：应用场景：如果已有的方法在使用的时候需要对原有的方法进行改进，采用一个代理类调用原有的方法，且对产生的结果进行控制，这种方法就是代理模式。使用代理模式，可以将功能划分的更加清晰，有助于后期维护。    观察者模式：多个对象间存在一对多关系，当一个对象发生改变时，会把这种改变通知给其他多个对象，从而影响其他对象的行为。  MySQL的四种搜索引擎      InnoDB：如果要提供提交、回滚、崩溃恢复能力的事物安全(ACID兼容)能力，并要求实现并发控制，InnoDB是一个好的选择    MyISAM：如果数据表主要用来插入和查询记录，读操作明显多于写操作，存储量较大，则MyISAM引辈能提供较高的处理效率    Memory：如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果    Archive：如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive    使用哪一种引学需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能Java性能调优  主要从这几个方面进行考虑      减少cookie的使用    使用Nginx静态资源缓存处理    文件进行压缩传输处理    JVM进程大小设置  @RestController和@Controller的区别      @RestController相当于@Controller和@ResponseBody合在一起的作用    如果使用@RestController则返回的是return里面的内容，无法返回到指定的页面    如果要返回到指定的页面，则需要用@Controller配合视图解析器    如果需要返回JSON等内容，则需要在对应的方法上加上@ResponseBody注解  http与https区别      https协议需要到CA申请证书，需要交费    http是明文传输，数据未加密，安全性差，https则是具有安全性的SSL加密传输协议，安全性好    http端口是80，https端口是443    http相应速度快，https比http更耗费服务器资源  消息队列如何防止重复消费  利用幂等性的思想      消息全局ID或者生成一个唯一标识（如时间戳、UUID等），作为数据库主键，每次消费消息之前根据消息ID去判断该消息是否已消费过，如果已经消费过，则不处理这条消息，否则正常消费消息，并且进行入库操作。    利用Redis的setnx命令，给消息分配一个全局ID，消费该消息时，先去Redis中查询有没有消费记录，无则以键值对的形式写入Redis，有则不消费该消息。  Spring Ioc和Aop      Ioc：容器来处理创建对象、管理对象、管理之间的依赖    Aop：对对象行为的一个监督与控制，主要是事务和日志  synchronized代码块和方法的区别  synchronized代码块比方法范围更小，更能精确地控制冲突限制访问区域，更高效。Nginx  Nginx的特点      高并发、高性能、高稳定性、低资源消耗、配置简单    模块化架构使得它的扩展性非常好    异步非阻塞的事件驱动模型这点和Node.js相似    无需重启可不间断运行    热部署、平滑升级    完全开源，生态好    Nginx最重要的几个使用场景      静态资源服务    反向代理服务，包括缓存、负载均衡等    API服务    Nginx的优点      1、作为Web服务器，Nginx处理静态文件、索引文件、自动索引的效率非常高    2、作为代理服务器，Nginx可以实现无缓存的反向代理加速，提高网站运行速度    3、作为负载均衡服务器，Nginx既可以在内部直接支持Railsi和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡    4、在性能方面，Nginx是专门为性能优化而开发的，实现上非常注重效率。它采用内核Poll模型，可以支持更多的并发连接，最大可以支持对5万个并发连接数的响应，而且只占用很低的内存资源    5、在稳定性方面，Nginx采取了分阶段资源分配技术，使得CPU与内存的占用率非常低    6、在高可用方面，Nginx支持热部署，启动速度特别迅速，因此可以在不间断服务的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7x24小时不间断地运行  @LoadBalanced的作用是什么  描述RestTemplate对象，用于告诉Spring框架，在使用RestTempalte进行服务调用时，这个调用过程会被一个拦截器进行拦截，然后在拦截器内部，启动负载均衡策略。Spring Boot Actuator原生端点  原生端点分为三大类：      应用配置类：获取应用程序中加载的应用配置、环境变量、自动化配置报告等与Spring Boot应用密切相关的配置类信息。    度量指标类：获取应用程序运行过程中用于监控的度量指标，比如：内存信息、线程池信息、HTTP请求统计等。    操作控制类：提供了对应用的关闭等操作类功能。  Spring管理事务的方式      编程式事务，在代码中硬编码    声明式事务：在配置文件中声明    基于XML的声明式事务    基于注解的声明式事务  Spring Boot的核心注解  Spring Boot的核心注解是@SpringBootApplication，它也是启动类使用的注解，主要包含了3个注解：      @SpringBootConfiguration：它组合了@Configuration注解，实现配置文件的功能。    @EnableAutoConfiguration：具有打开自动配置的功能，也可以关闭某个自动配置的选项。    @ComponentScan：用于Spring组件扫描。  Spring Boot自动配置原理是什么  @EnableAuto Configuration注解、@Configuration注解和@ConditionalOnClass注解组成了Spring Boot白动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。具体是通过Maven读取每个starter中的spring.factories文件，该文件配置了所有需要被创建在spring容器中的bean。Spring Boot配置加载顺序  Spring Boot配置加载顺序优先级是：propertiese文件、YAML文件、系统环境变量、命令行参数。bootstrap.properties比application.properties优先加载，而且bootstrap里面的属性不能被覆盖。Spring Boot是否可以使用XML配置  通过@ImportResource注解加载XML配置。Filter和Interator的区别      Filter过滤器是在请求进入Tomcat容器之后，请求进入Servlet之前执行。Filter是Servlet规定规范的。Interator拦截器是在Servlet和Controller控制器之间执行。Interator是SpringframeWork中规定的。    Filter的主要作用是过滤字符编码、做一些业务逻辑判断，主要用于对用户请求进行预处理，同时也可以进行逻辑判断。Interator的主要作用是拦截用户请求，进行处理，比如判断用户登录情况、权限验证，只针对Controller请求进行处理。  SpringMVC的工作流程      用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)    DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller,只是得知)    DispatcherServleti调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller    HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet    DispatcherServlet将ModelAndView?交给ViewReslover视图解析器解析，然后返回真正的视图    DispatcherServlet将模型数据填充到视图中    DispatcherServlet将结果响应给用户    组件说明      DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。    HandlerMapping：处理器映射器，它根据用户访问的URL映射到对应的后端处理器Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。    HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图ModelAndView对象。    ViewResolver：视图解析器，将ModelAndView逻辑视图解析为具体的视图（如JSP)。    Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的Controller类。        数据库性能调优如何做    项目参与的核心设计有哪些    HashMap及线程安全的ConcurrentHashMap，以及各自优劣势    Java如何实现线程安全    Synchronized和Lock哪个更好    HashMap中的get()方法是如何实现的    HashMap可以用在哪些场景    JVM，垃圾回收机制，内存划分等    SQL优化，常用的索引    做过哪些Java开发相关的项目    对哪些技术比较熟悉    多线程状态图，状态如何流转    死锁，死锁原因    页锁、乐观锁、悲观锁    乐观锁如何保证线程安全    用过线程池吗，对应的好处，如何用    两个10G的文件，里面是一些URL，内存只有1G，如何将这两个文件合并，找到相同的URL    1000个多并发线程，10台机器，每台机器4核的，设计线程池大小    代码题：两个有序数组，数组中存在重复数字，合并成一个有序数组，去除重复数字    JVM性能调优都做了什么    分布式系统原理：CAP，最终一致性，幂等操作等    高并发情况下，我们系统是如何支撑大量的请求的    集群如何同步会话状态    常用NOSQL，有做过比较    什么情况会出现雪崩，以及如何应对    负载均衡的原理    数据库事务属性    工作中觉得哪方面欠缺    期望薪水    为什么要离开现在的公司  大数据相关名词      数据仓库：              Hive（基于Hadoop的数据仓库工具）        HBase（分布式的、面向列的开源数据库）              框架：Hadoop（大数据处理开源框架）              模块：Hadoop HDFS（分布式存储系统）        模块：Hadoop YARN（任务调度和集群资源管理）        模块：Hadoop MapReduce（基于Hadoop YARN的大型数据集并行计算处理系统）        其他模块：Pig（运行在Hadoop上，对大型数据集进行分析和评估的平台）        其他模块：Spark（Hadoop数据快速通用的计算引擎）        其他模块：ZooKeeper（分布式的、开源的分布式应用程序协调服务，是Hadoop、HBase的重要组件）              数据传输：Sqoop（Hive、HBase、Hadoop等数据仓库和数据库之间的数据传输工具）  "
  },
  
  {
    "title": "4.资讯",
    "url": "/posts/hangye/",
    "categories": "MyNotes, 3_ZhengCeFaGui",
    "tags": "",
    "date": "2020-12-26 13:47:00 +0800",
    





    
    "snippet": "北京生活必备通讯录",
    "content": "北京生活必备通讯录"
  },
  
  {
    "title": "5.教师资格证(职业资格继续教育)",
    "url": "/posts/jiaoshizigezheng/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-26 13:47:00 +0800",
    





    
    "snippet": "一、报名条件  年龄要求：未达到国家法定退休年龄。  学历条件：具备大学专科及以上学历即可，对专业无要求。  普通话要求：二级乙等以上。  其他：丧失教师资格人员，不得报名参加考试；被撤销教师资格的人员，5年内不得报名参加考试；受到剥夺政治权利，或故意犯罪受到有期徒刑以上刑事处罚的人员，不得报名参加考试；参加教师资格考试有作弊行为，按照《国家教育考试违规处理办法》处以1-3年暂停参加考试的人...",
    "content": "一、报名条件  年龄要求：未达到国家法定退休年龄。  学历条件：具备大学专科及以上学历即可，对专业无要求。  普通话要求：二级乙等以上。  其他：丧失教师资格人员，不得报名参加考试；被撤销教师资格的人员，5年内不得报名参加考试；受到剥夺政治权利，或故意犯罪受到有期徒刑以上刑事处罚的人员，不得报名参加考试；参加教师资格考试有作弊行为，按照《国家教育考试违规处理办法》处以1-3年暂停参加考试的人员，处罚期内不得报名参加考试。二、报名时间目前，教师资格证考试在全国28个省(自治区、直辖市)内实行统考，每年上下半年各组织一次笔试和面试，山西和云南2省仅在每年下半年举办。通常，笔试报名时间在1月和9月，面试报名时间在4月和12月。具体报名时间详见报名公告。三、报名流程教师资格证报名包括网上报名、审核确认、网上缴费3个步骤。  网上报名：考生在规定时间内，登录中小学教师资格考试网站(http://ntce.neea.edu.cn)进行网上注册。如实填写个人信息以及上传本人照片。  审核确认：网上报名成功后，进行网上审核或现场确认。具体审核方式详见当地的报名公告里要求，如果是现场审核，一定要把相关材料备齐。  网上缴费：审核通过后，必须在规定时间内，重新登陆报名系统缴纳考试费，缴费成功后，报名完成。四、考试科目  笔试：综合素质(小学)、教育教学知识与能力两个科目。  面试：面试分为结构化面试、试讲和答辩3个环节。主要考核申请人职业道德、心理素质、仪表仪态、言语表达、思维品质等教学基本素养和教学设计、教学实施、教学评价等教学基本技能。五、学习途径聚师课堂六、附件附件：河北省2020年下半年中小学教师资格考试（笔试）公告.pdf"
  },
  
  {
    "title": "Redis异常：Could not get a resource from the pool",
    "url": "/posts/redis-yichang-wufa-huoqu-lianjie/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2020-12-26 13:47:00 +0800",
    





    
    "snippet": "报错信息redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool  at redis.clients.util.Pool.getResource(Pool.java:22)  at com.derbysoft.jredis.longkeytest.Borrow...",
    "content": "报错信息redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool  at redis.clients.util.Pool.getResource(Pool.java:22)  at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22)  at java.lang.Thread.run(Thread.java:662)  Caused by: java.util.NoSuchElementException: Timeout waiting for idle object  at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134)  at redis.clients.util.Pool.getResource(Pool.java:20)  ... 2 more  redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the poolat redis.clients.util.Pool.getResource(Pool.java:22)at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22)at java.lang.Thread.run(Thread.java:662)Caused by: java.util.NoSuchElementException: Timeout waiting for idle objectat org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134)at redis.clients.util.Pool.getResource(Pool.java:20)... 2 more产生原因客户端去Redis服务器拿连接（代码描述的是租用对象borrowObject）的时候，池中无可用连接，即池中所有连接被占用，且在等待时候设定的超时时间后还没拿到时，报出此异常。解决办法调整JedisPoolConfig中maxActive为适合自己系统的阀值。&lt;bean id=\"dataJedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt;    &lt;property name=\"maxActive\" value=\"300\" /&gt;    &lt;property name=\"maxIdle\" value=\"100\" /&gt;    &lt;property name=\"maxWait\" value=\"10000\" /&gt;    &lt;property name=\"testOnBorrow\" value=\"true\" /&gt;&lt;/bean&gt;  "
  },
  
  {
    "title": "6.在职考研(学历学位继续教育)",
    "url": "/posts/zaizhikaoyan/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-25 13:47:00 +0800",
    





    
    "snippet": "一、报名1.1 网上预报名时间2016年9月24日至9月27日，每天9:00-22:00。1.2 网上报名时间2016年10月10日至10月31日，每天9:00-22:00。逾期不再补报，也不得再修改报名信息。1.3 报名流程考生登录“中国研究生招生信息网”（公网网址：http://yz.chsi.com.cn，教育网址：http://yz.chsi.cn，以下简称“研招网”）浏览报考须知，...",
    "content": "一、报名1.1 网上预报名时间2016年9月24日至9月27日，每天9:00-22:00。1.2 网上报名时间2016年10月10日至10月31日，每天9:00-22:00。逾期不再补报，也不得再修改报名信息。1.3 报名流程考生登录“中国研究生招生信息网”（公网网址：http://yz.chsi.com.cn，教育网址：http://yz.chsi.cn，以下简称“研招网”）浏览报考须知，确定报考单位、考试方式以及专项计划，按教育部、省级教育招生考试机构、报考点以及报考招生单位的网上公告要求报名。报名期间将对考生学历（学籍）信息进行网上校验，并在考生提交报名信息三天内反馈校验结果。考生可随时上网查看学历（学籍）校验结果。考生也可在报名前或报名期间自行登录“中国高等教育学生信息网”（网址：http://www.chsi.com.cn）查询本人学历（学籍）信息。未通过学历（学籍）校验的考生应及时到学籍学历权威认证机构进行认证，在现场确认时将认证报告交报考点核验。网上报名有关具体要求和注意事项，详见《2017年全国硕士研究生招生工作管理规定》（已在教育部官网http://www.moe.edu.cn公开）及“研招网”报考须知。建议广大考生合理安排报名时间，避开报名初期、末期高峰，避免网络拥堵。1.4 报名要求硕士研究生招生考试报名包括网上报名和现场确认两个阶段。所有参加硕士研究生招生考试的考生均须进行网上报名，并到报考点现场确认网报信息、缴费和采集本人图像等相关电子信息。应届本科毕业生原则上应选择就读学校所在省（区、市）的报考点办理网上报名和现场确认手续；单独考试考生应选择招生单位所在地省级教育招生考试机构指定的报考点办理网上报名和现场确认手续；工商管理、公共管理、旅游管理和工程管理等专业学位考生和其他考生应选择工作或户口所在地省级教育招生考试机构指定的报考点办理网上报名和现场确认手续。网上报名技术服务工作由全国高等学校学生信息咨询与就业指导中心负责。现场确认由省级教育招生考试机构负责组织相关报考点进行。二、现场确认2.1 现场确认时间具体时间由各省级教育招生考试机构根据本地区报考情况自行确定和公布。请考生及时关注各省级教育招生考试机构发布的公告，在规定时间内到指定地点现场核对并确认个人网上报名信息。逾期不再补办。2.2 现场确认程序  考生到报考点指定的地方进行现场确认。  考生提交本人居民身份证、学历学位证书（普通高校、成人高校、普通高校举办的成人高校学历教育应届本科毕业生持学生证）和网上报名编号，由报考点工作人员进行核对。报考“退役大学生士兵”专项硕士研究生招生计划的考生还应提交本人《入伍批准书》和《退出现役证》原件或复印件。 在录取当年9月1日前可取得国家承认本科毕业证书的自学考试和网络教育本科生，须凭颁发毕业证书的省级自学考试机构或网络教育高校出具的相关证明方可办理网上报名现场确认手续。  未通过网上学历（学籍）校验的考生应及时到学籍学历权威认证机构进行认证，在现场确认时将认证报告交报考点核验。  考生应认真了解并严格按照报考条件及相关政策要求选择填报志愿。现场确认时要对本人网上报名信息进行认真核对并确认，报名信息经考生确认后一律不作修改。因不符合报考条件及相关政策要求，或因网报信息填写错误、填报虚假信息而造成不能考试、复试或录取的，后果由考生本人承担。  考生应按规定缴纳报考费。  考生应按报考点规定配合采集本人图像等相关电子信息。2.3 打印准考证2016年12月15日至12月26日，考生可凭网报用户名和密码登录“研招网”下载打印《准考证》。《准考证》正反两面在使用期间不得涂改。考生凭下载打印的《准考证》及居民身份证参加考试。请考生务必妥善保管个人网报用户名、密码及《准考证》、居民身份证等证件，避免泄露丢失造成损失。三、考试3.1 初试时间2017年全国硕士研究生招生考试初试时间为：2016年12月24日至12月25日（每天上午8:30-11:30，下午14:00-17:00）。超过3小时的考试科目在12月26日进行（起始时间8:30，截止时间由招生单位确定，不超过14:30）。考试时间以北京时间为准。不在规定日期举行的硕士研究生入学考试，国家一律不予承认。3.2 初试科目初试方式均为笔试。  12月24日上午 思想政治理论、管理类联考综合能力  12月24日下午 外国语  12月25日上午 业务课一  12月25日下午 业务课二  12月26日 考试时间超过3小时的考试科目每科考试时间一般为3小时；建筑设计等特殊科目考试时间最长不超过6小时。详细考试时间、考试科目及有关要求等请见《准考证》及考点和招生单位公告。四、政策变化考虑到近年来研究生考试招生改革不断深化，教育部提醒广大考生注意相关政策变化。  2017年起，临床医学类专业学位与医学学术学位硕士研究生初试业务课考试科目分别设置，临床医学专业学位设“临床医学综合能力”（分中、西医两类）统考科目，医学学术学位业务课由招生单位按一级学科自主命题。同时，调剂录取阶段，报考临床医学类专业学位硕士研究生的考生可按相关政策调剂到其他专业，报考其他专业（含医学学术学位）的考生不可调剂到临床医学类专业学位。  为进一步完善高校学生参军入伍优惠政策，鼓励更多高素质高校学生参军入伍，2017年继续安排5000名“退役大学生士兵”专项计划，招生高校比去年增加39所，同时进一步明确界定了报考条件。  进一步规范单独考试招生，明确招生单位不得按单位、行业、地域等限定单独考试生源范围，也不得设置其他歧视性条件。具体招考政策请考生认真阅读《2017年全国硕士研究生招生工作管理规定》和《2017年全国硕士研究生招生考试公告》，以及省级教育招生考试机构和招生单位发布的相关招考信息，如有疑问，可及时咨询相关招生单位和省级教育招生考试机构。五、其他招生考试其他有关事项，请参见《2017年全国硕士研究生招生工作管理规定》，或及时登录“研招网”浏览查询报考须知和各相关单位网上公告。为帮助考生了解招生政策，各研究生招生单位将于9月19日至23日在“研招网”上开展2017年全国硕士研究生招生宣传咨询周活动，届时有关研究生招生单位将在线回答广大考生提问。六、附件附件：考研流程-2017.pdf"
  },
  
  {
    "title": "7.公务员和事业编",
    "url": "/posts/gongwuyuan-he-shiyebian/",
    "categories": "MyNotes, 1_ZhiYeGuiHua",
    "tags": "",
    "date": "2020-12-24 13:47:00 +0800",
    





    
    "snippet": "一、考试时间  2022省考报名时间          报名时间：2月26日9:00至3月2日17:00      资格审查时间：截止时间为3月3日12:00      缴费时间：截止时间为3月3日17:00      8月2日，参加面试的考生在公务员考试专题网站下载打印《面试通知单》。面试具体考点、时间及有关要求等详见《面试通知单》。      二、报名方式  2022省考报名方式    ...",
    "content": "一、考试时间  2022省考报名时间          报名时间：2月26日9:00至3月2日17:00      资格审查时间：截止时间为3月3日12:00      缴费时间：截止时间为3月3日17:00      8月2日，参加面试的考生在公务员考试专题网站下载打印《面试通知单》。面试具体考点、时间及有关要求等详见《面试通知单》。      二、报名方式  2022省考报名方式          http://www.hebgwyks.gov.cn      三、报名条件年龄限制：一般截止到36岁四、考试内容考试内容，国考和省考都是两门：行测和申论（部分岗位会加试专业知识，具体看报名职位表）。国考，根据所报考岗位行政级别的不同，试卷分副省级和地市级两类。两类试卷总体一致，侧重点各有不同，部分模块的题型和题量有所区别，在复习时要有针对性，避免做无用功。比如在行测考试中，「判断推理」模块第一部分「逻辑判断」，副省级试卷和地市级试卷的考点和要求有很大区别，需要针对性地复习。省考，考试内容与国考基本一致，区别在于题量和难度不同。复习的时候，使用国考的教材就完全可以应对省考。不管是中公、华图还是粉笔，各家辅导机构的课程开发都是以国考大纲为蓝本，针对国考的教材和课程也是质量最高的，针对省考的教材和课程相对而言质量就差一些。我在复习的过程中，全程使用的都是中公的国考辅导教材。此外，需要注意的是：不同省份的考点设置会有所区别，比如「数量关系」模块一般包括两部分：「数学计算」和「数字推理」，其中「数字推理」在近年的国考和很多省考中已经消失了，完全可以不看。但是在江苏省考中，「数字推理」必考且是重点，需要认真复习。五、考试题型  判断推理  数量关系  言语理解与表达  资料分析  常识判断  申论六、报名费用根据关于“省招录公务员考试报名费每人10元，考试费每人每科45元”的规定，只参加公共科目两科考试的，每人缴纳100元，另需加试专业科目考试的，每人缴纳145元。七、报名岗位数量每人只能报考一个职位。八、如何准备资料国考和省考都是考行测和申论，而且考的知识点基本都是一样的，所以无论是国考还是省考的学习资料基本都是通用的。不过有个别省份会考一些特色题，需要本省专用的学习资料！（教材也是同理）"
  },
  
  {
    "title": "待办列表",
    "url": "/posts/daiban-liebiao/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "  1  2",
    "content": "  1  2"
  },
  
  {
    "title": "Java实现文件下载功能，自动弹出保存窗口",
    "url": "/posts/java-shixian-wenjian-xiazai-gongneng/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "public void download() {    String filePath = this.queueService.getCsvFilePathById(id);//所要下载的文件路径，从数据库中查询得到，当然也可以直接写文件路径，如：C:\\\\Users\\\\Administrator\\\\Desktop\\\\csv\\\\号码_utf8_100.csv    try {        F...",
    "content": "public void download() {    String filePath = this.queueService.getCsvFilePathById(id);//所要下载的文件路径，从数据库中查询得到，当然也可以直接写文件路径，如：C:\\\\Users\\\\Administrator\\\\Desktop\\\\csv\\\\号码_utf8_100.csv    try {        File file = new File(filePath);        String fileName = filePath.substring(filePath.lastIndexOf(File.separator)+1);//得到文件名        fileName = new String(fileName.getBytes(\"UTF-8\"),\"ISO8859-1\");//把文件名按UTF-8取出并按ISO8859-1编码，保证弹出窗口中的文件名中文不乱码，中文不要太多，最多支持17个中文，因为header有150个字节限制。        response.setContentType(\"application/octet-stream\");//告诉浏览器输出内容为流        response.addHeader(\"Content-Disposition\", \"attachment;filename=\"+fileName);//Content-Disposition中指定的类型是文件的扩展名，并且弹出的下载对话框中的文件类型图片是按照文件的扩展名显示的，点保存后，文件以filename的值命名，保存类型以Content中设置的为准。注意：在设置Content-Disposition头字段之前，一定要设置Content-Type头字段。        String len = String.valueOf(file.length());        response.setHeader(\"Content-Length\", len);//设置内容长度        OutputStream out = response.getOutputStream();        FileInputStream in = new FileInputStream(file);        byte[] b = new byte[1024];        int n;        while((n=in.read(b))!=-1){            out.write(b, 0, n);        }        in.close();        out.close();    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}"
  },
  
  {
    "title": "Prism支持的语言",
    "url": "/posts/prism-zhichi-de-yuyan/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "语法  ```javanew Test();```This is the list of all 218 languages currently supported by Prism, with their corresponding alias, to use in place of xxxx in the language-xxxx (or lang-xxxx) class:  Mark...",
    "content": "语法  ```javanew Test();```This is the list of all 218 languages currently supported by Prism, with their corresponding alias, to use in place of xxxx in the language-xxxx (or lang-xxxx) class:  Markup - markup, html, xml, svg, mathml, ssml, atom, rss  CSS - css  C-like - clike  JavaScript - javascript, js  ABAP - abap  Augmented Backus–Naur form - abnf  ActionScript - actionscript  Ada - ada  AL - al  ANTLR4 - antlr4, g4  Apache Configuration - apacheconf  APL - apl  AppleScript - applescript  AQL - aql  Arduino - arduino  ARFF - arff  AsciiDoc - asciidoc, adoc  6502 Assembly - asm6502  ASP.NET (C#) - aspnet  AutoHotkey - autohotkey  AutoIt - autoit  Bash - bash, shell  BASIC - basic  Batch - batch  BBcode - bbcode, shortcode  Bison - bison  Backus–Naur form - bnf, rbnf  Brainfuck - brainfuck  BrightScript - brightscript  Bro - bro  C - c  Concurnas - concurnas, conc  C# - csharp, cs, dotnet  C++ - cpp  CIL - cil  CoffeeScript - coffeescript, coffee  CMake - cmake  Clojure - clojure  Crystal - crystal  Content-Security-Policy - csp  CSS Extras - css-extras  D - d  Dart - dart  DAX - dax  Diff - diff  Django/Jinja2 - django, jinja2  DNS zone file - dns-zone-file, dns-zone  Docker - docker, dockerfile  Extended Backus–Naur form - ebnf  Eiffel - eiffel  EJS - ejs, eta  Elixir - elixir  Elm - elm  Embedded Lua templating - etlua  ERB - erb  Erlang - erlang  Excel Formula - excel-formula, xlsx, xls  F# - fsharp  Factor - factor  Firestore security rules - firestore-security-rules  Flow - flow  Fortran - fortran  FreeMarker Template Language - ftl  G-code - gcode  GDScript - gdscript  GEDCOM - gedcom  Gherkin - gherkin  Git - git  GLSL - glsl  GameMaker Language - gml, gamemakerlanguage  Go - go  GraphQL - graphql  Groovy - groovy  Haml - haml  Handlebars - handlebars  Haskell - haskell, hs  Haxe - haxe  HCL - hcl  HLSL - hlsl  HTTP - http  HTTP Public-Key-Pins - hpkp  HTTP Strict-Transport-Security - hsts  IchigoJam - ichigojam  Icon - icon  Structured Text (IEC 61131-3) - iecst  Inform 7 - inform7  Ini - ini  Io - io  J - j  Java - java  JavaDoc - javadoc  JavaDoc-like - javadoclike  Java stack trace - javastacktrace  Jolie - jolie  JQ - jq  JSDoc - jsdoc  JS Extras - js-extras  JS Templates - js-templates  JSON - json, webmanifest  JSONP - jsonp  JSON5 - json5  Julia - julia  Keyman - keyman  Kotlin - kotlin  LaTeX - latex, tex, context  Latte - latte  Less - less  LilyPond - lilypond, ly  Liquid - liquid  Lisp - lisp, emacs, elisp, emacs-lisp  LiveScript - livescript  LLVM IR - llvm  LOLCODE - lolcode  Lua - lua  Makefile - makefile  Markdown - markdown, md  Markup templating - markup-templating  MATLAB - matlab  MEL - mel  Mizar - mizar  Monkey - monkey  MoonScript - moonscript, moon  N1QL - n1ql  N4JS - n4js, n4jsd  Nand To Tetris HDL - nand2tetris-hdl  NASM - nasm  NEON - neon  nginx - nginx  Nim - nim  Nix - nix  NSIS - nsis  Objective-C - objectivec, objc  OCaml - ocaml  OpenCL - opencl  Oz - oz  PARI/GP - parigp  Parser - parser  Pascal - pascal, objectpascal  Pascaligo - pascaligo  PC-Axis - pcaxis, px  PeopleCode - peoplecode, pcode  Perl - perl  PHP - php  PHPDoc - phpdoc  PHP Extras - php-extras  PL/SQL - plsql  PowerQuery - powerquery, pq, mscript  PowerShell - powershell  Processing - processing  Prolog - prolog  .properties - properties  Protocol Buffers - protobuf  Pug - pug  Puppet - puppet  Pure - pure  PureBasic - purebasic, pbfasm  Python - python, py  Q (kdb+ database) - q  QML - qml  Qore - qore  R - r  Racket - racket, rkt  React JSX - jsx  React TSX - tsx  Ren’py - renpy, rpy  Reason - reason  Regex - regex  reST (reStructuredText) - rest  Rip - rip  Roboconf - roboconf  Robot Framework - robotframework, robot  Ruby - ruby, rb  Rust - rust  SAS - sas  Sass (Sass) - sass  Sass (Scss) - scss  Scala - scala  Scheme - scheme  Shell session - shell-session  Smalltalk - smalltalk  Smarty - smarty  Solidity (Ethereum) - solidity, sol  Solution file - solution-file, sln  Soy (Closure Template) - soy  SPARQL - sparql, rq  Splunk SPL - splunk-spl  SQF: Status Quo Function (Arma 3) - sqf  SQL - sql  Stylus - stylus  Swift - swift  TAP - tap  Tcl - tcl  Textile - textile  TOML - toml  Template Toolkit 2 - tt2  Turtle - turtle, trig  Twig - twig  TypeScript - typescript, ts  T4 Text Templates (C#) - t4-cs, t4  T4 Text Templates (VB) - t4-vb  T4 templating - t4-templating  UnrealScript - unrealscript, uscript, uc  Vala - vala  VB.Net - vbnet  Velocity - velocity  Verilog - verilog  VHDL - vhdl  vim - vim  Visual Basic - visual-basic, vb  WarpScript - warpscript  WebAssembly - wasm  Wiki markup - wiki  Xeora - xeora, xeoracube  XML doc (.net) - xml-doc  Xojo (REALbasic) - xojo  XQuery - xquery  YAML - yaml, yml  Zig - zig"
  },
  
  {
    "title": "Markdown语法",
    "url": "/posts/markdown-yufa/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "Markdown标题使用=和-标记一级和二级标题我展示的是一级标题=================我展示的是二级标题-----------------使用#号标记使用#号可表示1-6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推。# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题Markdown段落Markdown段落没有特...",
    "content": "Markdown标题使用=和-标记一级和二级标题我展示的是一级标题=================我展示的是二级标题-----------------使用#号标记使用#号可表示1-6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推。# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题Markdown段落Markdown段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。Markdown字体*斜体文本*  _斜体文本_  **粗体文本**  __粗体文本__  ***粗斜体文本***  ___粗斜体文本___分割线**** * ******- - -----------删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。下划线下划线可以通过HTML的&lt;u&gt;带下划线文本&lt;/u&gt;标签来实现。脚注脚注是对文本的补充说明。Markdown脚注的格式如下：[^要注明的文本]，以下实例演示了脚注的用法：创建脚注格式类似这样 [^foot]。[^foot]: 脚注示例！！！创建脚注格式类似这样 1。Markdown列表Markdown支持有序列表和无序列表。无序列表使用*、+或是减号-作为列表标记，这些标记后面要添加一个空格，然后再填写内容。有序列表使用数字并加上.号来表示。列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可。* 列表    * 列表  列表          列表      Markdown区块Markdown区块引用是在段落开头使用&gt;符号 ，然后后面紧跟一个空格符号。另外区块是可以嵌套的，一个&gt;符号是最外层，两个&gt;符号是第一层嵌套，以此类推。&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套   最外层      第一层嵌套          第二层嵌套      区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项      第一项    第二项              第一项        第二项        第三项            列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。* 第一项    &gt; 区块1      &gt; 区块2* 第二项  第一项          区块1区块2        第二项Markdown代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）。代码区块代码区块使用4个空格或者一个制表符（Tab 键）。你也可以用```包裹一段代码，并指定一种语言（也可以不指定）。Markdown链接链接使用方法如下：[链接名称](链接地址)或者&lt;链接地址&gt;这是一个链接 链接或者https://www.baidu.com高级链接我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用1作为网址变量[链接][1]这个链接用test作为网址变量 [链接][test]然后在文档的结尾为变量赋值（网址）[1]: http://www.baidu.com/[test]: http://www.baidu.com/这个链接用1作为网址变量链接这个链接用test作为网址变量链接然后在文档的结尾为变量赋值（网址）Markdown图片开头一个感叹号!。接着一个方括号[]，里面放上图片的替代文字。接着一个普通括号()，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’属性的文字。![图片](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png \"baidu\")  当然，你也可以像网址那样对图片网址使用变量:![图片][1]  [1]: https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.pngMarkdown还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的&lt;img&gt;标签。&lt;img src=\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\" width=\"50%\"&gt;Markdown表格Markdown制作表格使用| 来分隔不同的单元格，使用-来分隔表头和其他行。|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |            表头      表头                  单元格      单元格              单元格      单元格      对齐方式我们可以设置表格的对齐方式：  -:设置内容和标题栏居右对齐。  :-设置内容和标题栏居左对齐。  :-:设置内容和标题栏居中对齐。| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |            左对齐左对齐左对齐      左对齐左对齐左对齐      居中对齐居中对齐居中对齐                  单元格      单元格      单元格              单元格      单元格      单元格      Markdown高级技巧支持的HTML元素不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。目前支持的HTML元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：使用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;重启电脑使用Ctrl + Alt + Del重启电脑转义Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符。Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号            脚注示例！！！ &#8617;      "
  },
  
  {
    "title": "GitBook启动脚本",
    "url": "/posts/gitbook-qidong-jiaoben/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "@echo off clsTITLE GitBook 管理菜单color 1fgoto menu:menuecho.echo                        ╭──────────────╮echo    ╭─────────┤       GitBook 管理菜单      ├╮echo    │ 主菜单           │                        ...",
    "content": "@echo off clsTITLE GitBook 管理菜单color 1fgoto menu:menuecho.echo                        ╭──────────────╮echo    ╭─────────┤       GitBook 管理菜单      ├╮echo    │ 主菜单           │                             │ │echo    │                  ╰────────────── ╯ │echo    │ [1]初始化GitBook                                   │echo    │                                                    │echo    │ [2]下载GitBook插件                                 │echo    │                                                    │echo    │ [3]启动GitBook         [0]退出                     │echo    ╰──────────────────────────╯echo.echo. 请输入选择项目的序号：set /p  ID=if \"%id%\"==\"1\"  goto cmd1if \"%id%\"==\"2\" goto cmd2if \"%id%\"==\"3\" goto cmd3IF \"%id%\"==\"0\"  exitIF not \"%id%\"== \"\" goto cmd0pause:cmd1echo 正在初始化GitBookecho 请稍等...gitbook initecho  初始化GitBook已经完成！pause &gt;nulgoto menu:cmd2echo 正在下载GitBook插件echo 请稍等...gitbook installecho  下载GitBook插件已经完成！pause &gt;nulgoto menu:cmd3echo 正在启动GitBookecho 请稍等...gitbook serveecho  启动GitBook已经完成！pause &gt;nulgoto menu:cmd0echo 你的选择无效，请按任意键返回菜单！pause &gt;nulgoto menu"
  },
  
  {
    "title": "使用gitbook build命令导出的HTML不能跳转",
    "url": "/posts/gitbook-daochu-de-html-buzhichi-tiaozhuan/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "原因GitBook新版本不支持HTML跳转功能，所以要降版本至2.6.7。解决办法如下第一步生成时指定GitBook的版本, 本地没有会先下载。gitbook build --gitbook=2.6.7 可能会报错，如下操作，列出本地所有的GitBook版本。gitbook ls 卸载对应的GitBook版本（新版本需要先卸载，也可以先下载2.6.7版本，这样两个版本会共存，默认使用最新版本...",
    "content": "原因GitBook新版本不支持HTML跳转功能，所以要降版本至2.6.7。解决办法如下第一步生成时指定GitBook的版本, 本地没有会先下载。gitbook build --gitbook=2.6.7 可能会报错，如下操作，列出本地所有的GitBook版本。gitbook ls 卸载对应的GitBook版本（新版本需要先卸载，也可以先下载2.6.7版本，这样两个版本会共存，默认使用最新版本）。gitbook uninstall 3.2.3第二步运行命令。gitbook build会出来几行提示信息，不用管，现在可以跳转了，试下吧。  注：如果遇到:Error loading version latest: Error: Cannot find module ‘internal/util/types’，则需要降低node的版本。"
  },
  
  {
    "title": "GitBook常用插件",
    "url": "/posts/gitbook-changyong-chajian/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "{    \"pluginsConfig\": {        // 给GitBook的目录添加数字，添加章节序号        \"theme-default\": {            \"showLevel\": true        },        // 代码高亮插件的配置        \"prism\": {            \"css\": [                \"p...",
    "content": "{    \"pluginsConfig\": {        // 给GitBook的目录添加数字，添加章节序号        \"theme-default\": {            \"showLevel\": true        },        // 代码高亮插件的配置        \"prism\": {            \"css\": [                \"prism-themes/themes/prism-atom-dark.css\"            ]        },        \"anchor-navigation-ex\": {            \"showLevel\": false,             \"showGoTop\": true        },        \"edit-link\": {            \"base\": \"https://github.com/\",            \"label\": \"编辑此页面\"        },        \"favicon\": {            \"shortcut\": \"assets/img/favicon.ico\",            \"bookmark\": \"assets/img/favicon.ico\",            \"appleTouch\": \"assets/img/favicon.ico\",            \"appleTouchMore\": {                \"120x120\": \"assets/img/favicon.ico\",                \"180x180\": \"assets/img/favicon.ico\"            }        },        \"hide-element\": {            \"elements\": [\".gitbook-link\"]        },        \"tbfed-pagefooter\": {            \"copyright\":\"\",            \"modify_label\": \"该文件最后修改时间：\",            \"modify_format\": \"YYYY-MM-DD HH:mm:ss\"        },        \"github\": {            \"url\": \"https://github.com/\"        },        \"code\": {            \"copyButtons\": false        }    },    \"plugins\": [        \"-toggle-chapters\",        \"expandable-chapters\",        \"-chapter-fold\",                \"splitter\",                \"anchor-navigation-ex\",                \"-lunr\",        \"-search\",        \"search-pro\",                \"-highlight\",        \"prism\",        \"prism-themes\",                \"edit-link\",                \"favicon\",                \"hide-element\",                \"tbfed-pagefooter\",                \"github\",                \"copy-code-button\",                \"emphasize\",                \"code\"    ]}"
  },
  
  {
    "title": "PLSQL无法使用like查询，无法查询中文",
    "url": "/posts/plsql-wufa-shiyong-like-chaxun-wufa-cahxun-zhongwen/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2020-12-21 13:47:00 +0800",
    





    
    "snippet": "问题描述  中文乱码。  中文显示没有乱码，中文作为条件无法查询。  like无法查询出中文内容。问题原因以上三种情况是因为Oracle客户端和服务器端的编码方式不一样导致。解决办法首先要查询Oracle服务器的语言、地域和字符集，然后将查询结果设置为本地的环境变量：NLS_LANG，具体如下：      查询Oracle服务器的语言、地域和字符集     select * from nls...",
    "content": "问题描述  中文乱码。  中文显示没有乱码，中文作为条件无法查询。  like无法查询出中文内容。问题原因以上三种情况是因为Oracle客户端和服务器端的编码方式不一样导致。解决办法首先要查询Oracle服务器的语言、地域和字符集，然后将查询结果设置为本地的环境变量：NLS_LANG，具体如下：      查询Oracle服务器的语言、地域和字符集     select * from nls_database_parameters;        查询结果中：          NLS_LANGUAGE表示语言，      NLS_TERRITORY表示地域      NLS_CHARACTSET表示字符集        将他们三个按照语言_地域.字符集的格式拼接起来，就有了AMERICAN_AMERICA.AL32UTF8（注意：这里要根据你自己的Oracle服务器的这三个值进行拼接）        设置本地环境变量（PLSQL优先从环境变量中获取属性），右击我的电脑 -&gt; 属性 -&gt; 高级系统设置-&gt; 环境变量 -&gt; 系统变量栏，新增如下记录：     NLS_LANG = AMERICAN_AMERICA.AL32UTF8      "
  },
  
  {
    "title": "Linux rm命令",
    "url": "/posts/linux-rm-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "常用的几个参数为“-f -i -r -v”-i删除前逐一询问确认。这个参数有一个好处，当在删除大量文件或目录的时候，可以防止我们误操作删除的文件或目录。-f即使原档案属性设为唯读，强制删除，系统不会逐一让我们确认。-r将目录及以下之档案文件一并删除。注意:如果rm不带此参数，是不能删除目录的。-v或–verbose 　显示指令执行后的结果信息。",
    "content": "常用的几个参数为“-f -i -r -v”-i删除前逐一询问确认。这个参数有一个好处，当在删除大量文件或目录的时候，可以防止我们误操作删除的文件或目录。-f即使原档案属性设为唯读，强制删除，系统不会逐一让我们确认。-r将目录及以下之档案文件一并删除。注意:如果rm不带此参数，是不能删除目录的。-v或–verbose 　显示指令执行后的结果信息。"
  },
  
  {
    "title": "JS限制字段输入长度",
    "url": "/posts/js-xianzhi-ziduan-shuru-changdu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "window.onload = function() {     document.getElementById(\"text1\").maxLength = 50;    document.getElementById(\"text2\").maxLength = 200;};",
    "content": "window.onload = function() {     document.getElementById(\"text1\").maxLength = 50;    document.getElementById(\"text2\").maxLength = 200;};"
  },
  
  {
    "title": "JS实现Sleep函数",
    "url": "/posts/js-shixian-sleep-hanshu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "&lt;script&gt; window.onload = function() {    sleep(5000);    alert(\"OK\"); } function sleep(numberMillis) {    var now = new Date();    var exitTime = now.getTime() + numberMillis;    while (true)...",
    "content": "&lt;script&gt; window.onload = function() {    sleep(5000);    alert(\"OK\"); } function sleep(numberMillis) {    var now = new Date();    var exitTime = now.getTime() + numberMillis;    while (true) {       now = new Date();       if (now.getTime() &gt; exitTime)          return;    } }&lt;/script&gt;"
  },
  
  {
    "title": "JS将数字格式化成货币（钱）格式",
    "url": "/posts/js-jiangshuzi-geshihua-wei-huobigeshi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "function formatMoney(number, places, symbol, thousand, decimal) {    number = number || 0;    places = !isNaN(places = Math.abs(places)) ? places : 2;    symbol = symbol !== undefined ? symbol : \"$...",
    "content": "function formatMoney(number, places, symbol, thousand, decimal) {    number = number || 0;    places = !isNaN(places = Math.abs(places)) ? places : 2;    symbol = symbol !== undefined ? symbol : \"$\";    thousand = thousand || \",\";    decimal = decimal || \".\";    var negative = number &lt; 0 ? \"-\" : \"\",        i = parseInt(number = Math.abs(+number || 0).toFixed(places), 10) + \"\",        j = (a = i.length) &gt; 3 ? a % 3 : 0;    return symbol + negative + (j ? i.substr(0, j) + thousand : \"\")                   + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + thousand)                   + (places ? decimal                   + Math.abs(number - i).toFixed(places).slice(2) : \"\");}// 把12345.67变成美元格式，$12,345.67console.log(formatMoney(12345.67));// 把12345.67变成人民币格式，并保留3位小数，￥12,345.670console.log(formatMoney(12345.67, 3, \"￥\"));// 把$12,345.67变成纯数字12345.67console.log(parseFloat('$12,345.67'.replace(/[^0-9-.]/g, '')));"
  },
  
  {
    "title": "JS获取当前月的前12个月",
    "url": "/posts/js-huoqu-dangqianyue-de-qian12geyue/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "var dataArr = [];var data = new Date();var year = data.getFullYear();data.setMonth(data.getMonth()+1, 1) //获取到当前月份,设置月份for (var i = 0; i &lt; 12; i++) {    data.setMonth(data.getMonth() - 1); //每次循...",
    "content": "var dataArr = [];var data = new Date();var year = data.getFullYear();data.setMonth(data.getMonth()+1, 1) //获取到当前月份,设置月份for (var i = 0; i &lt; 12; i++) {    data.setMonth(data.getMonth() - 1); //每次循环一次月份值减1    var m = data.getMonth() + 1;    m = m &lt; 10 ? \"0\" + m : m;    dataArr.push(data.getFullYear() + \"-\" + (m))}console.log(dataArr)运行结果"
  },
  
  {
    "title": "Git上传文件不区分大小写的问题",
    "url": "/posts/git-shangchuan-buqufen-daxiaoxie/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-12-17 13:47:00 +0800",
    





    
    "snippet": "问题文件名称最初新建的时候是大写，但是后面想要改成小写的，修改完提交的时候使用git status命令发现并没有修改的记录，提交之后在Git上也没有修改。解决办法因为Git默认是不区分大小写的，所以git status是不会提示你有修改的。  通过git config --get core.ignorecase查看默认配置  通过git config core.ignorecase fals...",
    "content": "问题文件名称最初新建的时候是大写，但是后面想要改成小写的，修改完提交的时候使用git status命令发现并没有修改的记录，提交之后在Git上也没有修改。解决办法因为Git默认是不区分大小写的，所以git status是不会提示你有修改的。  通过git config --get core.ignorecase查看默认配置  通过git config core.ignorecase false设置为区分大小写然后git status就可以看到修改的东西了，然后进行正常的操作就可以提交了。最好是一开始就把Git的默认配置修改掉（区分大小写的模式），后面的操作其实也可以直接本地先备份再删除提交。"
  },
  
  {
    "title": "Jackson反序列化错误的解决方法",
    "url": "/posts/json-fanxuliehua-cuowu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "错误信息com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException：Unrecognized field，出现这种问题的情况是由于JSON里面包含了实体没有的字段导致反序列化失败。第一种解决方案// ObjectMapper对象添加String s = \"{\\\"id\\\":1,\\\"name\\\":\\\"test\\\",\\\"age\\...",
    "content": "错误信息com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException：Unrecognized field，出现这种问题的情况是由于JSON里面包含了实体没有的字段导致反序列化失败。第一种解决方案// ObjectMapper对象添加String s = \"{\\\"id\\\":1,\\\"name\\\":\\\"test\\\",\\\"age\\\":19}\";ObjectMapper mapper = new ObjectMapper();mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);User user = mapper.readValue(s, User.class);第二种解决方案// 在需要转化的对象的类中添加注解，注解信息如下：@JsonIgnoreProperties(ignoreUnknown = true)public class User..."
  },
  
  {
    "title": "一个数组中的元素复制到另一个数组",
    "url": "/posts/jiang-shuzu-zhong-de-yuansu-fuzhi-dao-lingyige-shuzu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "使用函数arraycopy(Object src, int srcPos, Object dest,  int destPos, int length)，其中五个参数分别表示为：  src— 被复制的数组  srcPos —从第几个元素开始复制  dest —要复制到的数组  destPos —从第几个元素开始粘贴  length —一共需要复制的元素个数public static void...",
    "content": "使用函数arraycopy(Object src, int srcPos, Object dest,  int destPos, int length)，其中五个参数分别表示为：  src— 被复制的数组  srcPos —从第几个元素开始复制  dest —要复制到的数组  destPos —从第几个元素开始粘贴  length —一共需要复制的元素个数public static void main(String[] args) {    char a1[] = {'a', 'b', 'c', 'd', 'e', 'f'};    char b1[] = {'1', '2', '3', '4', '5', '6'};    System.arraycopy(b1, 1, a1, 3, b1.length-3);    System.out.println(new String(a1));    System.out.println(new String(b1));}输出结果abc234123456"
  },
  
  {
    "title": "Java中创建数组的三种方式",
    "url": "/posts/java-zhong-chuangjian-shuzu-de-sanzhong-fangshi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "public static void main(String[] args) {    //创建数组的第一种方法，指定数组长度    int[] arr1 = new int[6];    //创建数组的第二种方法，创建并初始化    int[] arr2 = {1, 2, 3, 4};    //创建数组的第三种方法    int[] arr3 = new int[]{1, 2, 3, 4...",
    "content": "public static void main(String[] args) {    //创建数组的第一种方法，指定数组长度    int[] arr1 = new int[6];    //创建数组的第二种方法，创建并初始化    int[] arr2 = {1, 2, 3, 4};    //创建数组的第三种方法    int[] arr3 = new int[]{1, 2, 3, 4, 5};}"
  },
  
  {
    "title": "Java将JSON转为对象数组的方法",
    "url": "/posts/java-jiang-json-zhuanwei-duixiangshuzu-de-fangfa/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "第一种方法String jsonStr = \"[{\\\"id\\\": \\\"0\\\", \\\"ip\\\": \\\"123\\\", \\\"mac\\\": \\\"456\\\"},                    {\\\"id\\\": \\\"1\\\", \\\"ip\\\": \\\"111\\\", \\\"mac\\\": \\\"222\\\"}]\";List&lt;User&gt; userList = new ArrayList&lt;User...",
    "content": "第一种方法String jsonStr = \"[{\\\"id\\\": \\\"0\\\", \\\"ip\\\": \\\"123\\\", \\\"mac\\\": \\\"456\\\"},                    {\\\"id\\\": \\\"1\\\", \\\"ip\\\": \\\"111\\\", \\\"mac\\\": \\\"222\\\"}]\";List&lt;User&gt; userList = new ArrayList&lt;User&gt;();ObjectMapper mapper = new ObjectMapper();// 避免JSON里面包含了实体没有的字段导致反序列化失败mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);// 转为对象数组userList = mapper.readValue(jsonStr,             mapper.getTypeFactory().constructCollectionType(List.class, User.class));第二种方法String jsonStr = \"[{\\\"id\\\": \\\"0\\\", \\\"ip\\\": \\\"123\\\", \\\"mac\\\": \\\"456\\\"},                    {\\\"id\\\": \\\"1\\\", \\\"ip\\\": \\\"111\\\", \\\"mac\\\": \\\"222\\\"}]\";List&lt;User&gt; userList = new ArrayList&lt;User&gt;();JSONArray jsonArray = JSONArray.parseArray(jsonStr);for (int i = 0; i &lt; jsonArray.size(); i++) {    User user = new User();    JSONObject object = (JSONObject) jsonArray.get(i);    user.setId(object.get(\"id\"));    user.setIp(object.get(\"ip\"));    user.setMac(object.get(\"mac\"));    userList.add(user);}"
  },
  
  {
    "title": "Tomcat各目录的作用",
    "url": "/posts/tomcat-ge-mulu-de-zuoyong/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-12-16 13:47:00 +0800",
    





    
    "snippet": "binbin目录主要是用来存放Tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是以.bat结尾的（windows命令），很多环境变量的设置都在此处，例如可以设置JDK路径、Tomcat路径。  startup用来启动Tomcat  shutdown用来关闭Tomcat  修改catalina可以设置Tomcat的内存confconf目录主要是用来存放Tomca...",
    "content": "binbin目录主要是用来存放Tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是以.bat结尾的（windows命令），很多环境变量的设置都在此处，例如可以设置JDK路径、Tomcat路径。  startup用来启动Tomcat  shutdown用来关闭Tomcat  修改catalina可以设置Tomcat的内存confconf目录主要是用来存放Tomcat的一些配置文件。  server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码  web.xml可以设置Tomcat支持的文件类型  context.xml可以用来配置数据源之类的  tomcat-users.xml用来配置管理Tomcat的用户与权限  在Catalina目录下可以设置默认加载的项目liblib目录主要用来存放Tomcat运行需要加载的jar包，例如，像连接数据库的jdbc的包我们可以加入到lib目录中来。logslogs目录用来存放Tomcat在运行过程中产生的日志文件（清空不会对Tomcat运行带来影响）。  在Windows环境中，控制台的输出日志在catalina.xxxx-xx-xx.log文件中  在Linux环境中，控制台的输出日志在catalina.out文件中temptemp目录用来存放Tomcat在运行过程中产生的临时文件（清空不会对tomcat运行带来影响）。webappswebapps目录用来存放应用程序，当Tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用。当然，你也可以把应用程序放置在磁盘的任意位置，在配置文件中映射好就行。workwork目录用来存放Tomcat在运行时的编译后文件，例如JSP编译后的文件。  清空work目录，然后重启Tomcat，可以达到清除缓存的作用"
  },
  
  {
    "title": "一台机器上启动多个Tomcat",
    "url": "/posts/ruhe-zai-yitai-fuwuqi-shang-qidong-duoge-tomcat/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-12-16 13:47:00 +0800",
    





    
    "snippet": "如果需要在一台机器上启动多个Tomcat服务器，在默认设置下肯定会发生端口冲突。为实现这个效果，只需修改conf子目录中的server.xml文件即可。共需修改三处：修改http访问端口（默认为8080端口）:&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\"connectionTimeout=\"20000\"redirectPort=\"8443\" UR...",
    "content": "如果需要在一台机器上启动多个Tomcat服务器，在默认设置下肯定会发生端口冲突。为实现这个效果，只需修改conf子目录中的server.xml文件即可。共需修改三处：修改http访问端口（默认为8080端口）:&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\"connectionTimeout=\"20000\"redirectPort=\"8443\" URIEncoding=\"gb2312\"/&gt;修改Shutdown端口（默认为8005端口）:&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt;修改JVM启动端口（默认为8009端口）:&lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;"
  },
  
  {
    "title": "启动Tomcat时窗口一闪而过的解决方法",
    "url": "/posts/qidong-tomcat-chuangkou-yishanerguo/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-12-16 13:47:00 +0800",
    





    
    "snippet": "进入Tomcat的安装目录，看到圈出红色的3个bat文件，一般通过startup.bat启动Tomcat时流程是startup-&gt;catalina-&gt;setclasspath-&gt;catalina，如果这3个bat文件里面有一个出现错误的话就是启动失败。先打开startup.bat，在最后加上一句pause再次执行startup.bat，就会看到上图，当按任意的键时cmd窗口...",
    "content": "进入Tomcat的安装目录，看到圈出红色的3个bat文件，一般通过startup.bat启动Tomcat时流程是startup-&gt;catalina-&gt;setclasspath-&gt;catalina，如果这3个bat文件里面有一个出现错误的话就是启动失败。先打开startup.bat，在最后加上一句pause再次执行startup.bat，就会看到上图，当按任意的键时cmd窗口又是一闪而过了。但是这已经确定了环境变量都是正确的。为了更加详细的看到信息，我们再来更改一句：找到call \"%EXECUTABLE%\" start %CMD_LINE_ARGS%把里面的start替换为run再来看看cmd窗口里面输出错误信息了"
  },
  
  {
    "title": "搭建SVN服务器时报错：Cannot query proxy blanket：no such interface supported (0x80004002)",
    "url": "/posts/dajian-svn-fuwuqi-shi-baocuo/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2020-12-14 13:47:00 +0800",
    





    
    "snippet": "一、错误信息Cannot query proxy blanket: no such interface supported (0x80004002)二、解决方案这个错误只会在有NVIDIA独立显卡的笔记本上出现，只要切换到集成显卡即可，步骤为：  打开NVIDIA控制面板。  选择3D设置-&gt;管理3D设置。  选择集成显卡作为优先的图形处理器。  点击应用。三、备注1、如何打开NVID...",
    "content": "一、错误信息Cannot query proxy blanket: no such interface supported (0x80004002)二、解决方案这个错误只会在有NVIDIA独立显卡的笔记本上出现，只要切换到集成显卡即可，步骤为：  打开NVIDIA控制面板。  选择3D设置-&gt;管理3D设置。  选择集成显卡作为优先的图形处理器。  点击应用。三、备注1、如何打开NVIDIA控制面板如果安装了NVIDIA显卡驱动，就可以在电脑桌面空白处点击鼠标右键，然后选择进入“NVIDIA控制面板”，如果没有的话，可以按照以下方法操作：  打开控制面板。  在打开的窗口右上角的“查看方式”选择大图标就可以找到“NVIDIA控制面板”。  打开“NVIDIA控制面板”后在窗口的左上方点击“桌面”然后把“添加桌面上下文菜单”勾选上，这样以后在桌面的空白处鼠标右键就能找到。2、NVIDIA控制面板打不开  首先可以在添加删除程序里面完整卸载原有NVIDIA驱动程序，并在NVIDIA官网下载相应的驱动，安装完成后再重启电脑。  其次可以尝试依次打开控制面板→管理工具→服务，并找到NVIDIA Driver Helper Service和NVIDIA Update Service Daemon两个选项，然后将他们的启动类型先改成手动，接着点启动，然后再改为自动，服务状态同样都改成启动。进行设置后，再尝试看能否打开NVIDIA控制面板。  这里还可以看下msconfig系统配置里面的启动选项里有没跟NVIDIA相关的选项的，有的话就打上勾，接着再重新打开试试。"
  },
  
  {
    "title": "使用Nexus搭建Maven私服",
    "url": "/posts/nexus-dajian-maven-sifu/",
    "categories": "Knowledge, Nexus",
    "tags": "Nexus",
    "date": "2020-12-14 13:47:00 +0800",
    





    
    "snippet": "为什么要搭建Nexus私服，原因很简单，有些公司不提供外网给项目组人员，因此就不能使用Maven访问远程的仓库，所以很有必要在局域网里找一台有外网权限的机器，搭建Nexus私服，然后开发人员连到这台私服上，这样的话就可以通过这台搭建了Nexus私服的电脑访问Maven的远程仓库。1、首先确定我们的环境安装好Maven，JDK等必须的环境。  2、这些都准备好之后，去下载最新版本的Nexus，...",
    "content": "为什么要搭建Nexus私服，原因很简单，有些公司不提供外网给项目组人员，因此就不能使用Maven访问远程的仓库，所以很有必要在局域网里找一台有外网权限的机器，搭建Nexus私服，然后开发人员连到这台私服上，这样的话就可以通过这台搭建了Nexus私服的电脑访问Maven的远程仓库。1、首先确定我们的环境安装好Maven，JDK等必须的环境。  2、这些都准备好之后，去下载最新版本的Nexus，下载地址：http://www.sonatype.org/nexus/go。3、下载完成后解压，打开目录nexus-2.4.0-09-bundle\\nexus-2.4.0-09\\bin\\jsw 这个目录下面你会发现有很多系统版本的Nexus环境，根据个人的电脑系统选择对应的版本。打开一个版本你会看到如下:一般都是将Nexus安装成Windows服务，所以点击install-nexus.bat，访问http://localhost:8081/nexus/启动后如下页面，在右上角有个Log in的超链接，点击登录，默认的用户名是admin，密码是admin123。 登录后你可以在左侧修改登录信息：4、接下来，我们配置一下Maven的代理服务器(前提是你的电脑不能连接外网，如果可以上外网，这里也没有意思，只是介绍一下)，在左侧菜单找到如图：点击查看右边有很多选项，找到这里添加你的代理服务器就可以了。5、接下来，好像这里都不需要怎么配置的，这里还有一个可能需要注意一下的，就是3rd party、Snapshots、Releases这三个，分别用来保存第三方jar（典型的oracle数据库的jar驱动包），项目组内部的快照、项目组内部的发布版。我目前只是用3rd party这个第三方的功能，将maven仓库中没有构件的jar包上传到服务器。如何将第三方的jar上传到nexus上面呢?如下：举例上传oracle的驱动包。那么现在Nexus已经安装好，怎么使用上传的jar包呢，很简单，前提是你已经建立了一个Maven的项目。含有pom.xml这个文件，在这个文件中添加如下：先去服务器看看jar的Maven构件：然后在pom.xml中添加如下的本地仓库地址：到此，完成了Nexus私服的搭建，项目组开发人员开发时，只要在项目的pom.xml文件中，添加如下pom.xml信息即可获取私服的jar。如果添加其他的构件时，会先在Nexus私服下载好，以后才会下载到本地。以后，如果发现私服已经存在某一jar包，则会直接从私服下载，如果没有再去网络上下载。这就是搭建私服的好处。6、将Mavan的settings.xml配置文件与私服关联，修改settings.xml配置文件：在&lt;servers&gt;标签里添加如下内容，配置私服的账号和密码 &lt;server&gt;    &lt;id&gt;Demo&lt;/id&gt;    &lt;username&gt;admin&lt;/username&gt;    &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;    在&lt;mirrors&gt;标签里添加如下内容，配置私服的地址&lt;mirror&gt;    &lt;id&gt;nexus&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;url&gt;http://l27.0.0.1:8081/nexus/content/repositories/nexue-test/&lt;/url&gt;&lt;/mirror&gt;"
  },
  
  {
    "title": "IntelliJ IDEA快捷键",
    "url": "/posts/intelliJ-idea-kuaijiejian/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2020-12-14 13:23:00 +0800",
    





    
    "snippet": "IDEA原生导包：Alt + Enter快速切换下一行：Shift + Enter查看继承关系：F4查看类结构：Ctrl + o整体修改变量名或方法名：Ctrl + Shift + r生成try catch方法：Alt + Shift + z查找文件：Shift + Shift抽取方法：Alt + Shift + m打开最近修改的文件：Ctrl + e快速搜索类中错误：Ctrl + Shif...",
    "content": "IDEA原生导包：Alt + Enter快速切换下一行：Shift + Enter查看继承关系：F4查看类结构：Ctrl + o整体修改变量名或方法名：Ctrl + Shift + r生成try catch方法：Alt + Shift + z查找文件：Shift + Shift抽取方法：Alt + Shift + m打开最近修改的文件：Ctrl + e快速搜索类中错误：Ctrl + Shift + q 选择要粘贴的内容：Ctrl + Shift + v查找方法在哪里被调用：Ctrl + Alt + h查看类的继承结构图：Ctrl + Alt + u  格式化代码：Ctrl + Alt + lEclipse模式查看方法在哪里被调用：Ctrl + g查看调用层次：Ctrl + Alt + h  查看子类方法实现：Ctrl + Alt + b 全局搜索：Ctrl + h生成getter和setter：Alt + Insert格式化：Ctrl + A选中，然后Ctrl + I打开和关闭列模式：Alt + Shift + Insert   去除所有未引用的包：Ctrl + Alt + o"
  },
  
  {
    "title": "SpringMVC接收form表单提交的数组数据",
    "url": "/posts/springmvc-jieshou-form-biaodan-tijiao-de-shuzu-shuju/",
    "categories": "Knowledge, SpringMVC",
    "tags": "SpringMVC",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "前端页面&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=\"...",
    "content": "前端页面&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=\"test\"  method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt;            &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[0].x\"/&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[0].y\"/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[1].x\"/&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[1].y\"/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[2].x\"/&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[2].y\"/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;input type=\"submit\" value=\"Submit\"&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;实体类public class Point {    private Integer x;    private Integer y;    public Integer getX() {        return x;    }    public void setX(Integer x) {        this.x = x;    }    public Integer getY() {        return y;    }    public void setY(Integer y) {        this.y = y;    }}实体类集合封装类SpringMVC不能用List接收，但可以用包装了List成员的对象接收public class PointModel {    private List&lt;Point&gt; points;    public List&lt;Point&gt; getPoints() {        return points;    }    public void setPoints(List&lt;Point&gt; points) {        this.points = points;    }}控制器@Controllerpublic class PointController {    @PostMapping(\"/test\")    @ResponseBody    public String testPost(PointModel pointModel){        System.out.println(JSON.toJSONString(pointModel));        return JSON.toJSONString(pointModel);    }}"
  },
  
  {
    "title": "< select>标签的回显",
    "url": "/posts/select-biaoqian-de-huixian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "&lt;div class=\"form-group\"&gt;    &lt;label class=\"col-sm-2\" contenteditable=\"true\" for=\"test\"&gt;数字&lt;/label&gt;    &lt;div class=\"col-xs-12\"&gt;        &lt;select id=\"num\" class=\"num\" name=\"num\"...",
    "content": "&lt;div class=\"form-group\"&gt;    &lt;label class=\"col-sm-2\" contenteditable=\"true\" for=\"test\"&gt;数字&lt;/label&gt;    &lt;div class=\"col-xs-12\"&gt;        &lt;select id=\"num\" class=\"num\" name=\"num\"&gt;            &lt;option value=\"00\" /&gt;            &lt;option value=\"01\"&gt;01&lt;/option&gt;            &lt;option value=\"02\"&gt;02&lt;/option&gt;            &lt;option value=\"03\"&gt;03&lt;/option&gt;        &lt;/select&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var num = ${ json }.dateMap.num;    var num_el = $(\"#num\").find(\"option\");    for (var i = 0; i &lt; num_el.length; i++) {        var num_val = num_el.eq(i).val();        if (num_val == num) {            num_el.eq(i).attr(\"selected\", true);        }    }&lt;/script&gt;"
  },
  
  {
    "title": "JQuery如何判断为null、undefined、NaN",
    "url": "/posts/jquery-ruhe-panduan-kongzhi/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "判断是否为null&lt;script type=\"text/javascript\"&gt;    var tmp = null;    if (tmp == null) {        alert(\"null\");    }&lt;/script&gt;运行结果：会弹窗null判断是否为undefined&lt;script type=\"text/javascript\"&gt;    v...",
    "content": "判断是否为null&lt;script type=\"text/javascript\"&gt;    var tmp = null;    if (tmp == null) {        alert(\"null\");    }&lt;/script&gt;运行结果：会弹窗null判断是否为undefined&lt;script type=\"text/javascript\"&gt;    var tmp = undefined;    if (typeof (tmp) == \"undefined\") {        alert(\"undefined\");    }&lt;/script&gt;结果：弹出undefined说明：typeof(a)的作用是返回变量a的类型的字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”判断是否为NaN&lt;script type=\"text/javascript\"&gt;    var tmp = 0 / 0;    var temp = parseInt(\"a\");    if (isNaN(tmp) &amp;&amp; isNaN(temp)) {        alert(\"NaN\");    }&lt;/script&gt;结果：弹出NaN，可以看出当出现字符串转化数字异常的时候回返回NaN，0除以0也会返回NaN说明：如果把NaN与任何值（包括其自身）相比得到的结果均是false，所以要判断某个值是否是NaN，不能使用 == 或 === 运算符。 提示：isNaN()函数通常用于检测parseFloat()和parseInt()的结果，以判断它们表示的是否是合法的数字。当然也可以用isNaN()函数来检测算数错误，比如用0作除数的情况。 判断undefined和null&lt;script type=\"text/javascript\"&gt;    var tmp = undefined;    if (tmp == undefined) {        alert(\"null or undefined\");    } &lt;/script&gt;或者：&lt;script type=\"text/javascript\"&gt;    var tmp = undefined;    if (tmp == null) {        alert(\"null or undefined\");    }&lt;/script&gt;结果：都可以弹出：null or undefined&lt;script type=\"text/javascript\"&gt;    if (null == undefined) {        alert(\"null == undefined\");    }&lt;/script&gt;结果：弹出： null == undefined说明：null == undefined判断undefined、null与NaN&lt;script type=\"text/javascript\"&gt;    var tmp = null; //这里tmp可以使 null undefine NaN 都可以进入判断语句    if (!tmp) {        alert(\"null or undefined or NaN\");    }&lt;/script&gt;结果：弹出：null or undefined or NaN总结：一般不那么区分就使用这个足够"
  },
  
  {
    "title": "JQuery获取元素的属性及对元素操作",
    "url": "/posts/jquery-huoqu-yuansu-de-shuxing-ji-dui-yuansu-caozuo/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "获取宽度为百分比(%)的对象具体宽度(px)&lt;div id=\"panel\"&gt;    &lt;div id =\"a\" style=\"width:66%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    $(document).ready(function () {        alert($(...",
    "content": "获取宽度为百分比(%)的对象具体宽度(px)&lt;div id=\"panel\"&gt;    &lt;div id =\"a\" style=\"width:66%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    $(document).ready(function () {        alert($(\"#a\").innerWidth());\t});&lt;/script&gt;获取元素自身的HTML$(\"#panel\").prop(\"outerHTML\");复制元素$(\"#panel\").clone()关于元素包裹的演示&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;演示文档&lt;/title&gt;    &lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt;    &lt;style&gt;        li{background: #ccc;margin-top: 25px;width: 150px;}        .orange{background: orange}        .red{background: red}        .green{background: green}        .ccc{background: #ccc;}        #div1{width: 200px;height: 25px;}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"div1\" class=\"ccc\"&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li class=\"orange\"&gt;列表项1&lt;/li&gt;        &lt;li class=\"red\"&gt;&lt;i&gt;列表项2&lt;/i&gt;&lt;/li&gt;        &lt;li class=\"green\"&gt;列表项3&lt;/li&gt;    &lt;/ol&gt;    &lt;input id=\"btn1\" type=\"button\" value='wrap'&gt;    &lt;input id=\"btn2\" type=\"button\" value='wrapAll'&gt;    &lt;input id=\"btn3\" type=\"button\" value='unwrap'&gt;    &lt;input id=\"btn4\" type=\"button\" value='wrapInner'&gt;        &lt;script type=\"text/javascript\"&gt;        $(function () {            $('#btn1').click(function () {                // 在div元素中包裹每个i元素                $('li').wrap($('#div1'));            })            $('#btn2').click(function () {                // 在div元素中包裹所有i元素                $('li').wrapAll($('#div1'));            })            $('#btn3').click(function () {                // 移除所有i元素的父元素                $('li').unwrap();            })            $('#btn4').click(function () {                // 在每个i元素的内容上包裹div元素                $('li').wrapInner($('#div1'));            })        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "JQuery的attr()和prop()的区别",
    "url": "/posts/jquery-prop-hanshu-he-attr-hanshu-de-qubie/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-09 13:47:00 +0800",
    





    
    "snippet": "根据官方的建议，具有 true 和 false 两个值的属性，如 checked, selected 或者 disabled 使用 prop()，其他的使用 attr()",
    "content": "根据官方的建议，具有 true 和 false 两个值的属性，如 checked, selected 或者 disabled 使用 prop()，其他的使用 attr()"
  },
  
  {
    "title": "JQuery判断下拉和单选是否选中并获取值和索引",
    "url": "/posts/jquery-panduan-xiala-danxuan-shifou-xuanzhong/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-09 13:47:00 +0800",
    





    
    "snippet": "select判断option是否被选中$(\"#mySelect\").is(\":checked\"); // false是未被选中，true是被选中$(\"#mySelect\").attr('checked') == undefined; // false是未被选中，true是被选中获取select选中的值$(\"#mySelect option:selected\").val();$(\"#mySel...",
    "content": "select判断option是否被选中$(\"#mySelect\").is(\":checked\"); // false是未被选中，true是被选中$(\"#mySelect\").attr('checked') == undefined; // false是未被选中，true是被选中获取select选中的值$(\"#mySelect option:selected\").val();$(\"#mySelect\").find('option:selected').val();$(\"#mySelect\").val();获取select选中的索引$('#mySelect').prop('selectedIndex');$(\"#mySelect option:selected\").index();radio判断radio是否被选中&lt;html&gt;    &lt;head&gt;        &lt;script src=\"http://libs.baidu.com/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;        &lt;script type=\"text/javascript\"&gt;            $(document).ready(function () {                $(\"input\").click(function () {                    if ($(this).prop(\"checked\")) {                        alert($('input:radio[name=\"sex\"]:checked').val());                    }                });            });        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        男&lt;input type=\"radio\" name=\"sex\" value=\"male\"/&gt;        女&lt;input type=\"radio\" name=\"sex\" value=\"female\"/&gt;    &lt;/body&gt;&lt;/html&gt;获取radio选中的值$('input:radio[name=\"sex\"]:checked').val();"
  },
  
  {
    "title": "JQuery获取字符串字节长度",
    "url": "/posts/jquery-huoqu-zifuchuan-zijie-changdu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-09 13:47:00 +0800",
    





    
    "snippet": "function getByteLen(val) {    var len = 0;    for (var i = 0; i &lt; val.length; i++) {        var code = val.charCodeAt(i);        if (code &gt;= 0 &amp;&amp; code &lt;= 128) {            len += 1...",
    "content": "function getByteLen(val) {    var len = 0;    for (var i = 0; i &lt; val.length; i++) {        var code = val.charCodeAt(i);        if (code &gt;= 0 &amp;&amp; code &lt;= 128) {            len += 1;        } else {            len += 2;        }    }    return len;}"
  },
  
  {
    "title": "Linux退出vi编辑模式",
    "url": "/posts/linux-vi-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "按ESC键跳到命令模式，然后：:w         保存文件但不退出vi:w file    将修改另外保存到file中，不退出vi:w!        强制保存，不推出vi:wq        保存文件并退出vi:wq!       强制保存文件，并退出viq:         不保存文件，退出vi:q!        不保存文件，强制退出vi:e!        放弃所有修改，从上次保存...",
    "content": "按ESC键跳到命令模式，然后：:w         保存文件但不退出vi:w file    将修改另外保存到file中，不退出vi:w!        强制保存，不推出vi:wq        保存文件并退出vi:wq!       强制保存文件，并退出viq:         不保存文件，退出vi:q!        不保存文件，强制退出vi:e!        放弃所有修改，从上次保存文件开始再编辑"
  },
  
  {
    "title": "Linux常用命令",
    "url": "/posts/linux-changyong-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "ps -ef|grep tomcat                 查看Tomcat进程kill -9 进程号                      杀进程./startup.sh                       启动Tomcattail -f catalina.out               查看Tomcat日志信息echo -n \"\" &gt; catalina.o...",
    "content": "ps -ef|grep tomcat                 查看Tomcat进程kill -9 进程号                      杀进程./startup.sh                       启动Tomcattail -f catalina.out               查看Tomcat日志信息echo -n \"\" &gt; catalina.out          清空Tomcat日志nohup java -jar xxx.jar &amp;          启动Spring Boot工程nohup java -jar xxx.jar --server.port=8080 &amp;                                      启动Spring Boot工程时指定端口号clear                              清除信息pwd                                查看当前路径cat /etc/redhat-release            系统安装时CentOS默认的发行版信息  du -sh /home/*                     查看用户使用的存储空间的大小du -sh *|sort -h                   按占用空间大小排序df -h                              查看系统硬盘大小ls -lh xxx                         查看文件大小yum list installed |grep jdk       查看系统是否安装了JDKrpm -qa|grep \"软件或者包的名字\"    查找软件是否安装rpm -e \"包名\"                      卸载软件zip -r test.20170216.zip test      zip压缩tar -zcvf a.tar.gz a.txt           创建文件a的gzip压缩的tar包tar -zxvf a.tar.gz                 释放a.tar.gz包的内容mv a.txt b.txt                     将a.txt重命名为b.txtmv 文件名 路径名                   移动文件到指定目录cp -R 源路径 目标路径              复制文件cp 文件 新文件名                   复制一个文件为新文件grep 字符串 文件                   收索某个字符串           #根据pid查询启动文件所在目录lsof -p PID | grep cwd# 根据pid查询进程的启动目录cd /proc/29539(pid)ls -ail# 查看Nginx监听的端口ps aux|grep nginxnetstat -anp|grep (pid)# 杀死Tomcat进程ps -ef|grep tomcat|grep -v 'grep'|awk '{print $2}' |xargs kill -9# 查看操作操作系统版本、内存等信息uname －a# 查看版本当前操作系统内核信息cat /proc/version# 查看当前操作系统版本信息cat /proc/version# 查看版本当前操作系统发行版信息cat /etc/issue# 或cat /etc/redhat-release# 查看当前系统的发行版本信息lsb_release -a# 查看当前所有的TCP端口netstat -ntlp # 查看所有80端口的使用情况netstat -ntulp | grep 80# 查看某一端口的链接客户端IPnetstat -anp |grep 80# 查看某一端口的连接数量netstat -pnt |grep :80 |wc# 查看进程的线程数量ps -o nlwp &lt;pid&gt;# 生成dump文件# 如果JDK是安装版的可以执行jmap -dump:format=b,file=/home/oper/dump.hprof 14912# 如果JDK不是按照版本需要进入到JDK的bin目录下./jmap -dump:format=b,file=/home/oper/dump.hprof 14912(服务的进程id)"
  },
  
  {
    "title": "JQuery在iframe中查找元素",
    "url": "/posts/jquery-zai-iframe-zhong-chazhao-yuansu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "$(window).on('load', function () {    $('#mainiframe').contents().find('#myTab').remove();});",
    "content": "$(window).on('load', function () {    $('#mainiframe').contents().find('#myTab').remove();});"
  },
  
  {
    "title": "JQuery为input绑定触发事件",
    "url": "/posts/jquery-wei-input-bangding-chufa-shijian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "输入框正在输入时$(\"#ipt\").on('input', function() {    if (!($('#ipt').val() == '')) {        $(\".cancle_ico\").removeClass('hide');    } else {        $(\".cancle_ico\").addClass('hide');    }})输入框得到焦点时$(\"#ip...",
    "content": "输入框正在输入时$(\"#ipt\").on('input', function() {    if (!($('#ipt').val() == '')) {        $(\".cancle_ico\").removeClass('hide');    } else {        $(\".cancle_ico\").addClass('hide');    }})输入框得到焦点时$(\"#ipt\").on('focus', function() {    if (!($('#ipt').val() == '')) {        $(\".cancle_ico\").removeClass('hide');    } else {        $(\".cancle_ico\").addClass('hide');    }})输入框失去焦点时$(\"#ipt\").on('blur', function() {    if (($('#ipt').val() == '')) {        $(\".cancle_ico\").addClass('hide');    } else {        $(\".cancle_ico\").removeClass('hide');    }})"
  },
  
  {
    "title": "JQuery使用Replace函数替换全部匹配项",
    "url": "/posts/jquery-shiyong-replace-hanshu-tihuan-quanbu-pipeixiang/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "JQuery的Replace仅能替换第一个匹配的内容，例如：var str = \"a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;\";var Newstr = str.Replace(\"&lt;br/&gt;\", \"\");alert(Newstr); // 内容为：ab&lt;br/&gt;c&lt;br/&gt;要替换全部匹配项，可以使用正则表达式：var str ...",
    "content": "JQuery的Replace仅能替换第一个匹配的内容，例如：var str = \"a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;\";var Newstr = str.Replace(\"&lt;br/&gt;\", \"\");alert(Newstr); // 内容为：ab&lt;br/&gt;c&lt;br/&gt;要替换全部匹配项，可以使用正则表达式：var str = \"a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;\";re = new RegExp(\"&lt;br/&gt;\", \"g\");// 第一个参数是要替换掉的内容，第二个参数\"g\"表示替换全部（global）。var Newstr = str.Replace(re, \"\"); // 第一个参数是正则表达式。alert(Newstr); // 内容为：abc"
  },
  
  {
    "title": "JQuery检查字段是否为空",
    "url": "/posts/jquery-jiancha-ziduan-shifou-weikong/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        al...",
    "content": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        alert(\"输入框1不能为空！\");        flag = false;    }    if (flag &amp;&amp; test2) {        flag = true;    } else if (flag) {        alert(\"输入框2不能为空！\");        flag = false;    }    return flag;}或function checkIsNull() {    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (!test1) {        alert(\"输入框1不能为空！\");        return;    }    if (!test2) {        alert(\"输入框2不能为空！\");        return;    }}"
  },
  
  {
    "title": "JQuery检查输入内容是否包含特殊字符",
    "url": "/posts/jquery-jiancha-shuru-neirong-shifou-baohan-teshu-zifu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "调用函数判断function checkNameReg(val) {     var regEn = /[@#$%^&amp;*()[\\]]/im,        regCn = /[@#￥%……&amp;*[\\]]/im;    if(regEn.test(val) || regCn.test(val)) {        return false;    }    return true...",
    "content": "调用函数判断function checkNameReg(val) {     var regEn = /[@#$%^&amp;*()[\\]]/im,        regCn = /[@#￥%……&amp;*[\\]]/im;    if(regEn.test(val) || regCn.test(val)) {        return false;    }    return true; }或直接在键入的时候将特殊符号替换$(function() {    $(\"#TEST\").keyup(function() {          var inputNumber = $(this).val();        inputNumber = inputNumber.replace(/[@#\\$%\\^&amp;\\*\\……\\￥]/g, '');        $(this).val(inputNumber);    });});IE使用特殊字符替换时光标跳到最后的解决方法$(function () {    $(\"#TEST\").keyup(function () {        var text = $(this).val();        var nowPosition = $(this).getCursorPosition();        var textLength = text.length;        text = text.replace(/[@#\\$\\^&amp;\\*\\……\\￥]/g, '');        if (text.length - textLength &lt; 0) {            nowPosition = nowPosition - 1;        }        $(this).val(text);        var txtFocus = document.getElementById(\"TEST\");        var isIE = false || !!document.documentMode;        if (isIE) {            var range = txtFocus.createTextRange();            range.move(\"character\", nowPosition);            range.select();        } else {            txtFocus.setSelectionRange(nowPosition, nowPosition);            txtFocus.focus();        }    });});(function ($, undefined) {    $.fn.getCursorPosition = function () {        var el = $(this).get(0);        var pos = 0;        if ('selectionStart' in el) {            pos = el.selectionStart;        } else if ('selection' in document) {            el.focus();            var Sel = document.selection.createRange();            var SelLength = document.selection.createRange().text.length;            Sel.moveStart('character', -el.value.length);            pos = Sel.text.length - SelLength;        }        return pos;    }})(jQuery);"
  },
  
  {
    "title": "$ is not defined",
    "url": "/posts/$-is-not-defined/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "报错信息ReferenceError: $ is not defined [详细了解]&lt;script type=\"text/javascript\"&gt;    $(function () {        alert(\"OK\");    });&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"...",
    "content": "报错信息ReferenceError: $ is not defined [详细了解]&lt;script type=\"text/javascript\"&gt;    $(function () {        alert(\"OK\");    });&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"&gt;&lt;/script&gt;修改办法，把JQuery代码放在引用JQuery文件引入的后面&lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    $(function () {        alert(\"OK\");    });&lt;/script&gt;"
  },
  
  {
    "title": "JS实现禁用浏览器后退",
    "url": "/posts/js-shixian-jinzhi-liulanqi-houtui/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "这种方式，可以消除后退的所有动作，包括键盘、鼠标手势等产生的后退动作。&lt;script language=\"javascript\"&gt;    //防止页面后退    history.pushState(null, null, document.URL);    window.addEventListener('popstate', function () {        histo...",
    "content": "这种方式，可以消除后退的所有动作，包括键盘、鼠标手势等产生的后退动作。&lt;script language=\"javascript\"&gt;    //防止页面后退    history.pushState(null, null, document.URL);    window.addEventListener('popstate', function () {        history.pushState(null, null, document.URL);    });&lt;/script&gt;"
  },
  
  {
    "title": "JS常用函数",
    "url": "/posts/js-changyong-hanshu-zhengli/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "Math.abs()取绝对值var a = -20;var b = Math.abs(a);",
    "content": "Math.abs()取绝对值var a = -20;var b = Math.abs(a);"
  },
  
  {
    "title": "JQuery的页面加载完毕事件",
    "url": "/posts/jquery-yemian-jiazai-wanbi-shijian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "第一种$(document).ready(function() {    // do something});$(document)把原生的document这个DOM对象转换为JQuery对象，转换完成后才能调用。其中ready方法ready(fn)表示的是页面结构被加载完毕后执行传入函数fn。第二种$(function() {    // do something});当页面加载完毕后执行...",
    "content": "第一种$(document).ready(function() {    // do something});$(document)把原生的document这个DOM对象转换为JQuery对象，转换完成后才能调用。其中ready方法ready(fn)表示的是页面结构被加载完毕后执行传入函数fn。第二种$(function() {    // do something});当页面加载完毕后执行里面的函数，这一种相对简单，用的最多。第三种window.οnlοad = function() {    // do something}上面两种方式与window.onload的区别为：  JQuery中的页面加载完毕事件，表示的是页面结构被加载完毕（不包含图片等非文字媒体文件）；  window.onload指页面包含图片等文件在内的所有元素都加载完成，如:&lt;img src=”htttp://baidu.com/1.jpg”/&gt;，onload必须等页面中的图片、声音、图像等远程资源被加载完毕后才调用，而JQuery中只需要页面结构被加载完毕就可以调用。"
  },
  
  {
    "title": "JQuery控制输入字段的长度",
    "url": "/posts/jquery-kongzhi-shuru-ziduan-de-changdu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "$(\"#TEST\").attr(\"onkeyup\", \"checkLength(this, 50);\"); // 设置触发事件var checkLength = function(dom, maxLength) {    var l = 0;    for(var i = 0; i &lt; dom.value.length; i++) {        if (/[\\u4e00-\\u9fa...",
    "content": "$(\"#TEST\").attr(\"onkeyup\", \"checkLength(this, 50);\"); // 设置触发事件var checkLength = function(dom, maxLength) {    var l = 0;    for(var i = 0; i &lt; dom.value.length; i++) {        if (/[\\u4e00-\\u9fa5]/.test(dom.value[i])) {            l+=2;        } else {            l++;        }        if (l &gt; maxLength) {            dom.value = dom.value.substr(0,i);            break;        }    }};  "
  },
  
  {
    "title": "JQuery获取相邻元素",
    "url": "/posts/jquery-huoqu-xianglin-yuansu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "JQuery里我们要获取某个元素的相邻元素时，可以用到的命令有三个：  next()：用来获取下一个同辈元素。  prev()：用来获取上一个同辈元素。  siblings()：用来获取所有的同辈元素。下面来看看简单的实例：&lt;div&gt;    &lt;p id=\"1\"&gt;1&lt;/p&gt;    &lt;p id=\"2\"&gt;2&lt;/p&gt;    &lt;p id...",
    "content": "JQuery里我们要获取某个元素的相邻元素时，可以用到的命令有三个：  next()：用来获取下一个同辈元素。  prev()：用来获取上一个同辈元素。  siblings()：用来获取所有的同辈元素。下面来看看简单的实例：&lt;div&gt;    &lt;p id=\"1\"&gt;1&lt;/p&gt;    &lt;p id=\"2\"&gt;2&lt;/p&gt;    &lt;p id=\"3\"&gt;3&lt;/p&gt;&lt;/div&gt;&lt;script language=\"javascript\"&gt;    $(\"#2\").next(); // 这个获取的等同于$(\"#3\")    $(\"#2\").prev(); // 这个获取的等同于$(\"#1\")    $(\"#2\").siblings(); // 这个获取的等同于$(\"#1, #3\")&lt;/script&gt;"
  },
  
  {
    "title": "JQuery对象和DOM元素的互转",
    "url": "/posts/jquery-he-dom-yuansu-huzhuan/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "JQuery对象转成DOM元素id选择器 $(“#id”)[0]&lt;input type=\"text\" id=\"tx\" value=\"44\"&gt;&lt;script&gt;$(function() {    // 通过id选择器获取Jquery对象    var tx =  $(\"#tx\");    // 转成dom对象    var domObj = tx[0];    alert...",
    "content": "JQuery对象转成DOM元素id选择器 $(“#id”)[0]&lt;input type=\"text\" id=\"tx\" value=\"44\"&gt;&lt;script&gt;$(function() {    // 通过id选择器获取Jquery对象    var tx =  $(\"#tx\");    // 转成dom对象    var domObj = tx[0];    alert(domObj.value);})&lt;/script&gt;id选择器 $(“#id”).get(0)&lt;input type=\"text\" id=\"tt\" value=\"33\"&gt;&lt;script&gt;$(function() {    // 通过id选择器获取Jquery对象    var tx =  $(\"#tx\");    // 转成dom对象    var domObj =  tx.get(0);    alert(domObj.value);})&lt;/script&gt;标签选择器 $(“input”).eq(0)[0]$(“input”).eq(0)[0] 或 $(“标签名”).get(0) // 下标从0开始    &lt;input type=\"text\" name=\"tt\" value=\"33\"&gt;&lt;input type=\"text\" name=\"tt\" value=\"44\"&gt;&lt;script&gt;$(function() {       // 通过标签选择器获取Jquery对象（多个）    var jqObj = $(\"input\");    // 获取单个jquery对象    var jq = jqObj.eq(0);    // 获取dom对象    var domObj = jqObj.get(0);})&lt;/script&gt;DOM元素转成Jquery对象&lt;input type=\"text\" id=\"tx\" value=\"33\"&gt;&lt;script&gt;$(function() {       // 获取DOM元素    var domObj =  document.getElementById(\"tx\");    // 转成Jquery对象    var jq = $(domObj);})&lt;/script&gt;"
  },
  
  {
    "title": "JQuery发送POST请求",
    "url": "/posts/jquery-fasong-post-qingqiu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "$.post(\"/test/test/deleteAction.do\", function(data) {    alert(data);});",
    "content": "$.post(\"/test/test/deleteAction.do\", function(data) {    alert(data);});"
  },
  
  {
    "title": "JQuery获取当前点击元素的自定义属性",
    "url": "/posts/huoqu-dianji-duixiang-de-shuxing/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "&lt;a onclick=\"goTest(this)\" myAttr=\"${data}\"&gt;点击删除&lt;/a&gt;';传this过去即可function goTest(e) {    var data = $(e).attr(\"myAttr\");    $(\"form\").attr(\"action\", \"goTest.do?data=\" + data).submit();    ...",
    "content": "&lt;a onclick=\"goTest(this)\" myAttr=\"${data}\"&gt;点击删除&lt;/a&gt;';传this过去即可function goTest(e) {    var data = $(e).attr(\"myAttr\");    $(\"form\").attr(\"action\", \"goTest.do?data=\" + data).submit();     return false;}"
  },
  
  {
    "title": "将< a>标签转为POST方式提交",
    "url": "/posts/a-biaoqian-zhuanwei-post-fangshi-tijiao/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "点击&lt;a&gt;标签调用JS函数提交，使用Ajax请求后台，发现无法获得ModelAndView返回的View，无法跳转页面，因此将&lt;a&gt;标签跳转改为POST方式提交。function goTest(el) {    var href = $(el).attr(\"href\"); // 获取&lt;a&gt;标签的href    $(\"form\").attr(\"action\"...",
    "content": "点击&lt;a&gt;标签调用JS函数提交，使用Ajax请求后台，发现无法获得ModelAndView返回的View，无法跳转页面，因此将&lt;a&gt;标签跳转改为POST方式提交。function goTest(el) {    var href = $(el).attr(\"href\"); // 获取&lt;a&gt;标签的href    $(\"form\").attr(\"action\", \"web.goTest.do\").submit(); // 将href赋值给action然后提交    return false; // 取消&lt;a&gt;标签默认动作}"
  },
  
  {
    "title": "JQuery四舍五入保留两位小数",
    "url": "/posts/jquery-sishewuru-baoliuliangwei-xiaoshu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-06 13:47:00 +0800",
    





    
    "snippet": "function gettoDecimal(num) {    var result = parseFloat(num);    if (isNaN(result)) {        return false;    }    result = Math.round(num * 100) / 100;    var s_x = result.toString();    var pos_d...",
    "content": "function gettoDecimal(num) {    var result = parseFloat(num);    if (isNaN(result)) {        return false;    }    result = Math.round(num * 100) / 100;    var s_x = result.toString();    var pos_decimal = s_x.indexOf('.');    if (pos_decimal &lt; 0) {        pos_decimal = s_x.length;        s_x += '.';    }    while (s_x.length &lt;= pos_decimal + 2) {        s_x += '0';    }    return s_x;}注:  indexOf() 方法对大小写敏感  如果要检索的字符串值没有出现，则该方法返回-1"
  },
  
  {
    "title": "JQuery获取当前日期",
    "url": "/posts/jquery-huoqu-dangqian-riqi/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-06 13:47:00 +0800",
    





    
    "snippet": "function getNowDate(){    var myDate = new Date;    var year = myDate.getFullYear(); // 获取当前年    var mon = myDate.getMonth() + 1; // 获取当前月    var date = myDate.getDate(); // 获取当前日    var h = myDate...",
    "content": "function getNowDate(){    var myDate = new Date;    var year = myDate.getFullYear(); // 获取当前年    var mon = myDate.getMonth() + 1; // 获取当前月    var date = myDate.getDate(); // 获取当前日    var h = myDate.getHours(); // 获取当前小时数(0-23)    var m = myDate.getMinutes(); // 获取当前分钟数(0-59)    var s = myDate.getSeconds(); // 获取当前秒    var week = myDate.getDay();    var weeks = [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"];    return year + \"年\" + mon + \"月\" + date + \"日\" + \" \"     + h + \"时\" + m + \"分\" + s + \"秒\" + \" \" + weeks[week];}"
  },
  
  {
    "title": "NodeJS安装",
    "url": "/posts/nodejs-anzhuang/",
    "categories": "Knowledge, NodeJS",
    "tags": "NodeJS",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "下载首先去到官网：https://nodejs.org/en/download/下载对应的版本：接着选择好路径，一路安装即可。新版的NodeJS自带npm ，所以无需重新安装npm，安装结束后，在cmd输入node -v和npm -v即可显示安装成功：配置路径和环境变量安装之后，我们需要对路径进行重新配置，如果不重新配置路径，则下载的moudle还是在C盘，例如在安装路径下新建两个文件夹：用...",
    "content": "下载首先去到官网：https://nodejs.org/en/download/下载对应的版本：接着选择好路径，一路安装即可。新版的NodeJS自带npm ，所以无需重新安装npm，安装结束后，在cmd输入node -v和npm -v即可显示安装成功：配置路径和环境变量安装之后，我们需要对路径进行重新配置，如果不重新配置路径，则下载的moudle还是在C盘，例如在安装路径下新建两个文件夹：用来存放模块和缓存。创建之后，我们在窗口输入：# 配置npm全局安装目录npm config set prefix D:\\nodejs\\node_global# 配置npm缓存目录npm config set cache D:\\nodejs\\node_cache# 查看配置结果npm config ls接着需要修改环境变量，找到此电脑点击右键，进入属性设置窗口，点击高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; Path变量 –&gt; 编辑 –&gt; 新建，输入配置成功的默认全局安装路径D:\\nodejs\\node_global  把路径改成你的安装路径，如我的：修改默认镜像将默认镜像设置为淘宝镜像。npm config set registry https://registry.npm.taobao.org下载测试上面已经配置好了路径，接着，我们下载一个moudle试试npm install express -g-g 表示全局下载的意思，这样下载的moudle才会到我们配好好的路径下，如果不加-g参数，则下载的模块会安装在当前路径下。"
  },
  
  {
    "title": "Log4j日志文件乱码",
    "url": "/posts/log4j-rizhi-wenjian-luanma/",
    "categories": "Knowledge, Log4j",
    "tags": "Log4j",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "在默认语言非中文（或者说默认语言不支持中文的）的Windows、Linux、Unix上，用Log4j打印日志，出现乱码，常见的就是一堆问号。解决方法如果是log4j.properties为配置文件，比如log4j.appender.A1=org.apache.log4j.RollingFileAppenderlog4j.appender.A1.File=all.log加入一行log4j.ap...",
    "content": "在默认语言非中文（或者说默认语言不支持中文的）的Windows、Linux、Unix上，用Log4j打印日志，出现乱码，常见的就是一堆问号。解决方法如果是log4j.properties为配置文件，比如log4j.appender.A1=org.apache.log4j.RollingFileAppenderlog4j.appender.A1.File=all.log加入一行log4j.appender.A1=org.apache.log4j.RollingFileAppenderlog4j.appender.A1.Encoding=UTF-8log4j.appender.A1.File=all.log 如果是log4j.xml为配置文件，比如&lt;appender name=\"A1\" class=\"org.apache.log4j.RollingFileAppender\"&gt;&lt;param name=\"File\" value=\"all.log\" /&gt;......&lt;/appender&gt;加入一行&lt;appender name=\"A1\" class=\"org.apache.log4j.RollingFileAppender\"&gt;&lt;param name=\"Encoding\" value=\"UTF-8\" /&gt;&lt;param name=\"File\" value=\"all.log\" /&gt;......&lt;/appender&gt;"
  },
  
  {
    "title": "Jira REST API调用方式",
    "url": "/posts/jira-rest-api-diaoyong-fangfa/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "调用Jira REST API时的权限验证采用basic authentication这种验证方式，主要考虑到简单易行、操作方便。具体的操作方法为在请求的http header中添加Authorization参数，取值为Basic base64(username:password)，这里的username和password是企业自己部署的JIRA平台的登陆账号和密码。Jira REST AP...",
    "content": "调用Jira REST API时的权限验证采用basic authentication这种验证方式，主要考虑到简单易行、操作方便。具体的操作方法为在请求的http header中添加Authorization参数，取值为Basic base64(username:password)，这里的username和password是企业自己部署的JIRA平台的登陆账号和密码。Jira REST API：https://docs.atlassian.com/software/jira/docs/api/REST/5.1.3/#id120417package com.jira.test.util;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.mail.MessagingException;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.HttpStatus;import org.apache.http.client.config.CookieSpecs;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.springframework.util.Base64Utils;import com.jira.test.model.vo.JiraAttachment;import com.jira.test.model.vo.JiraAttachmentVo;public class JiraAttachmentUtil {    private static final String BASE_URL = \"http://localhost:8080/rest/api/2/issue/\";     private static final String ADMIN_ACCOUNT = \"admin\";    private static final String ADMIN_PASSWORD = \"admin\";    /**     * @Title: getAttachmentUrlList     * @Description: 获取当前issue关联所有附件的下载链接     * @param issueId issue的id     * @return     * @throws IOException     * @throws MessagingException List&lt;String&gt;     */    public static List&lt;Map&lt;String, Object&gt;&gt; getAttachmentList(String issueId) throws IOException, MessagingException {        String body = \"\";        JiraAttachmentVo jiraAttachmentVo = new JiraAttachmentVo(); // 根据Jira返回的json数据格式建立的vo类        List&lt;Map&lt;String, Object&gt;&gt; attachmentList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 作为返回的数据集，也可以是json或其他类型                // 权限验证        String basic_auth = \"Basic \"; // 后面一定要跟一个空格        basic_auth += Base64Utils.encodeToString((ADMIN_ACCOUNT + \":\" + ADMIN_PASSWORD).getBytes());                // 请求API接口的相关实体类        CloseableHttpClient closeableHttpClient = HttpClients.createDefault();        RequestConfig defaultConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).build();        HttpResponse httpResponse = null;                // 权限验证参数设置        HttpGet httpGet;        httpGet = new HttpGet(BASE_URL + issueId);        httpGet.setConfig(defaultConfig);        httpGet.setHeader(\"Accept\", \"application/json\");        httpGet.setHeader(\"Content-Type\", \"application/json\");        httpGet.setHeader(\"Authorization\", basic_auth);                try {            // 开始请求            httpResponse = closeableHttpClient.execute(httpGet);            // 返回数据            if (HttpStatus.SC_OK == httpResponse.getStatusLine().getStatusCode()) {                HttpEntity httpEntity = httpResponse.getEntity();                if (httpEntity != null) {                    body = EntityUtils.toString(httpEntity, \"UTF-8\");                    System.out.println(\"jira返回数据：\" + body);                    jiraAttachmentVo = JsonUtil.toBean(body, JiraAttachmentVo.class);                    if (null != jiraAttachmentVo &amp;&amp; null != jiraAttachmentVo.getFields()                            &amp;&amp; jiraAttachmentVo.getFields().getAttachment().size() &gt; 0) {                        for (JiraAttachment jiraAttachment : jiraAttachmentVo.getFields().getAttachment()) {                            Map&lt;String, Object&gt; attachmentMap = new HashMap&lt;String, Object&gt;();                            attachmentMap.put(\"content\", jiraAttachment.getContent());                            attachmentMap.put(\"created\", jiraAttachment.getCreated());                            attachmentMap.put(\"filename\", jiraAttachment.getFilename());                            attachmentMap.put(\"id\", jiraAttachment.getId());                            attachmentList.add(attachmentMap);                        }                    }                }            }        } catch (IOException e) {            e.printStackTrace();        } finally {            closeableHttpClient.close();        }        return attachmentList;    }    /**      * @Title: createIssue      * @Description: 创建issue     * @param jiraIssueVo     * @return     * @throws IOException JiraIssueResponseVo     */     private static JiraIssueResponseVo createIssue(JiraIssueVo jiraIssueVo) throws IOException {        String body = \"\";        JiraIssueResponseVo jiraIssueResponseVo = new JiraIssueResponseVo();        // 权限验证        String basic_auth = \"Basic \";        basic_auth += Base64Utils.encodeToString((ADMIN_ACCOUNT + \":\" + ADMIN_PASSWORD).getBytes());        // 请求API接口的相关实体类        CloseableHttpClient closeableHttpClient = HttpClients.createDefault();        HttpResponse httpResponse = null;        // 参数设置        String param = JSON.toJSONString(jiraIssueVo);        StringEntity stringEntity = new StringEntity(param, Charset.forName(\"UTF-8\"));        stringEntity.setContentEncoding(\"UTF-8\");        stringEntity.setContentType(\"application/json\");        // 权限验证参数设置        HttpPost httpPost;        httpPost = new HttpPost(BASE_URL);        httpPost.setHeader(\"Content-Type\", \"application/json; charset=UTF-8\");        httpPost.setHeader(\"Authorization\", basic_auth);        httpPost.setEntity(stringEntity);        try {            // 请求开始            httpResponse = (HttpResponse) closeableHttpClient.execute(httpPost);            // 返回数据            if (HttpStatus.SC_OK == httpResponse.getStatusLine().getStatusCode()) {                HttpEntity httpEntity = httpResponse.getEntity();                if (httpEntity != null) {                    body = EntityUtils.toString(httpResponse.getEntity(), \"UTF-8\");                    System.out.println(\"jira返回数据：\" + body);                    jiraIssueResponseVo = JsonUtil.toBean(body, JiraIssueResponseVo.class);                }            }        } catch (IOException e) {            e.printStackTrace();        } finally {            closeableHttpClient.close();        }        return jiraIssueResponseVo;    }}"
  },
  
  {
    "title": "MySQL、SQLServer、Oracle三种数据库的JDBC连接方式",
    "url": "/posts/sanzhong-shujuk-jdbc-lianjiefangshi/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "MySQLClass.forName(\"com.mysql.jdbc.Driver\");String url = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF8\";Connection connection = DriverManager.getConnection(url, username, password);State...",
    "content": "MySQLClass.forName(\"com.mysql.jdbc.Driver\");String url = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF8\";Connection connection = DriverManager.getConnection(url, username, password);Statement stmt = connection.createStatement();Result result = stmt.executeUpdate(sql);SQLServerClass.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");String url = \"jdbc:microsoft.sqlserver://localhost:1433/test\";Connection connection = DriverManager.getConnection(url, username, password);Statement stmt = connection.createStatement();Result result = stmt.executeUpdate(sql);OracleClass.forName(\"oracle.jdbc.driver.OracleDriver\");String url = \"jdbc:oracle:thin:@localhost:1521:test\";Connection connection = DriverManager.getConnection(url, username, password);PreparedStatement pstmt = connection.prepareStatement(sql);pstmt.setString(\"param\");Result result = pstmt.executeUpdate();"
  },
  
  {
    "title": "JDBC各大数据库的连接字符串和驱动类",
    "url": "/posts/geda-shujuku-lianjiechuan/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "OracledriverClass：oracle.jdbc.OracleDriverurl：jdbc:oracle:thin:@localhost:1521:dbnameMySQLdriverClass：com.mysql.jdbc.Driverurl：jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=tru...",
    "content": "OracledriverClass：oracle.jdbc.OracleDriverurl：jdbc:oracle:thin:@localhost:1521:dbnameMySQLdriverClass：com.mysql.jdbc.Driverurl：jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=true // 注意: 高版本的MySQL需要显示指定useSSLDB2driverClass：com.ibm.db2.jcc.DB2Driverurl：jdbc:db2://localhost:50000/dbnameSybasedriverClass：com.sybase.jdbc.SybDriverurl：jdbc:sybase:Tds:localhost:5007/dbnamePostgreSQLdriverClass：org.postgresql.Driverurl：jdbc:postgresql://localhost/dbnameSQLServerdriverClass：com.microsoft.sqlserver.jdbc.SQLServerDriverurl：jdbc:sqlserver://localhost:1433; DatabaseName=dbname"
  },
  
  {
    "title": "JDBC操作数据库出现中文乱码",
    "url": "/posts/caozuo-shujuku-chuxian-luanma/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "通过JDBC操作数据库表时，如果记录中有中文，可能会碰到乱码的问题。主要原因是字符编码（characterEncoding）不正确，包括以下几个方面：  在数据库服务器上创建表格时没有选择支持中文的编码方式；  建立JDBC连接时没有指明支持中文的编码方式；建议在创建表格和建立JDBC连接时都采用utf-8编码。具体方法如下：  创建数据库表时，选择character与collation时都...",
    "content": "通过JDBC操作数据库表时，如果记录中有中文，可能会碰到乱码的问题。主要原因是字符编码（characterEncoding）不正确，包括以下几个方面：  在数据库服务器上创建表格时没有选择支持中文的编码方式；  建立JDBC连接时没有指明支持中文的编码方式；建议在创建表格和建立JDBC连接时都采用utf-8编码。具体方法如下：  创建数据库表时，选择character与collation时都选utf-8  建立JDBC连接时在url中加入characterEncoding=utf-8，以MySQL为例代码如下：Class.forName(\"com.mysql.jdbc.Driver\").newInstance();String url = \"jdbc:mysql://localhost:3306/db1?characterEncoding=utf-8\";String dbUsername = \"root\";String dbPassword = \"root\";Connection conn = DriverManager.getConnection(url, dbUsername, dbPassword);"
  },
  
  {
    "title": "Windows下Docker打开新窗口报错",
    "url": "/posts/docker-dakai-xinchuangkou-baocuo/",
    "categories": "Knowledge, Docker",
    "tags": "Docker",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "错误信息error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.26/containers/json: open  //./pipe/docker_engine: The system cannot find the file specified. In the default daemon configurati...",
    "content": "错误信息error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.26/containers/json: open  //./pipe/docker_engine: The system cannot find the file specified. In the default daemon configuration on Windows, the docker client must be run elevated to connect. This error may also indicate that the docker daemon is not running.解决方法打开新窗口后执行@FOR /f \"tokens=*\" %i IN ('docker-machine env default') DO @%idefault是docker-machine的name，可以通过docker-machine -ls查看"
  },
  
  {
    "title": "Solr精准查询",
    "url": "/posts/solr-jingzhun-chaxun/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "外面加上双引号，必须是双引号，就可以了。UserRealname : 某某家长// 改为UserRealname : \"某某家长\" ",
    "content": "外面加上双引号，必须是双引号，就可以了。UserRealname : 某某家长// 改为UserRealname : \"某某家长\" "
  },
  
  {
    "title": "Solr管理界面详解",
    "url": "/posts/solr-guanlijiemian-xiangjie/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "solr服务器管理界面可以查看系统状态、solr设置、分词检测、查询索引、增减core、查看日志等。1. Dashboard（仪表盘）访问http://localhost:8080/solr时，出现该主页面，可查看到Solr运行时间、Solr版本，系统内存、虚拟机内存的使用情况。2. Logging（日志）显示Solr运行出现的异常或错误。3. Core Admin（core管理）主要有Ad...",
    "content": "solr服务器管理界面可以查看系统状态、solr设置、分词检测、查询索引、增减core、查看日志等。1. Dashboard（仪表盘）访问http://localhost:8080/solr时，出现该主页面，可查看到Solr运行时间、Solr版本，系统内存、虚拟机内存的使用情况。2. Logging（日志）显示Solr运行出现的异常或错误。3. Core Admin（core管理）主要有Add Core（添加核心）， Unload（卸载核心），Rename（重命名核心），Reload（重新加载核心），Optimize（优化索引库）Add Core是添加core：主要是在instanceDir对应的文件夹里生成一个core.properties文件。  name：给core起的名字；  instanceDir：与我们在配置Solr到Tomcat里时的solr_home里新建的core文件夹名一致；  dataDir:确认Add Core时，会在new_core目录下生成名为data的文件夹；  config：new_core下的conf下的config配置文件(solrconfig.xml)；  schema: new_core下的conf下的schema文件(schema.xml)。确认Add Core时，会在new_core下生成data文件夹，与core.properties文件。core.properties文件里内容如下：4. Java Propertie（Java属性）可查看到Java相关的一些属性的信息。5. Core Selecter（core选择器）需要在Core Admin里添加了core后才有可选项，这里以已经添加好的ims_advertiser_core为例。5.1 overview（概览）包含基本统计如当前文档数；和实例信息如当前核心的配置目录；5.2 Analysis（分析）检验分词效果，如图，我们对companyName字段进行了分词（至于哪些字段能分词，取决于在schema.xml文件里配置该字段时的type是否为配置的分词器类型text_ik）&lt;!-- 这里的text_ik就是下面name属性的值 --&gt;&lt;field name=\"companyName\" type=\"text_ik\" indexed=\"false\" stored=\"true\" multiValued=\"false\" /&gt;&lt;!-- 配置IK分词器 --&gt;&lt;fieldType name=\"text_ik\" class=\"solr.TextField\" positionIncrementGap=\"100\"&gt;    &lt;analyzer type=\"index\"&gt;        &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" isMaxWordLength=\"false\"/&gt;        &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt;    &lt;/analyzer&gt;    &lt;analyzer type=\"query\"&gt;        &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" isMaxWordLength=\"false\"/&gt;        &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt;    &lt;/analyzer&gt;&lt;/fieldType&gt; 这里的高亮背景色是灰色5.3 Dataimport（导入数据）前提是已经配置好了相关的配置，详情参见：Solr从数据库导入数据  Comman选项：full_import：全导入；delta_import:增量导入。所谓delta-import主要是对于数据库（也可能是文件等等）中增加或者被修改的字段进行导入。主要原理是利用每次我们进行import的时候在solr.home\\conf下面生成的dataimport.properties文件，此文件里面有最近一次导入的相关信息。这个文件如下：    #Tue Jul 19 10:15:50 CST 2016advertiser.last_index_time=2016-07-19 10:15:49last_index_time=2016-07-19 10:15:49        其实last_index_time是最近一次索引（full-import或者delta-import）的时间。通过比较这个时间和我们数据库表中的timestamp列即可得出哪些是之后修改或者添加的。    Verbose：  Clean：在索引开始构建之前是否删除之前的索引，默认为true。  Commit：在索引完成之后是否提交。默认为true。  Optimize：是否在索引完成之后对索引进行优化。默认为true。  Debug：是否以调试模式运行，适用于交互式开发（interactive development mode）之中。请注意，如果以调试模式运行，那么默认不会自动提交，请加参数commit=true。  Entity：Entity是document下面的标签data-config.xml。使用这个参数可以有选择的执行一个或多个Entity 。使用多个Entity参数可以使得多个Entity同时运行。如果不选择此参数那么所有的都会被运行。  Start,Rows：  Custom Parameters：  Excute：执行导入。  Refresh Status：刷新后才能看到数据发生了变化，如果刷新后数据还是0，说明未导入。5.4 Documents（索引文档）Documents（索引文档）索引的相关操作，如：增加，修改，删除等，例如我们要增加一个索引（companyName）的办法：1.先要在Solr的D:\\solr_home\\mycore1\\conf的schema.xml配置文件下，增加相关的字段field&lt;field name=\"a\" type=\"text_ik\" indexed=\"false\" stored=\"true\" multiValued=\"false\" /&gt;否则会出现如下错误：Status: errorError: Bad RequestError:{  \"responseHeader\": {    \"status\": 400,    \"QTime\": 1  },  \"error\": {    \"msg\": \"ERROR: [doc=126] unknown field 'companyName'\",    \"code\": 400  }}2.在如下页面，选择/update，文档格式选择json，然后submit提交。这样索引就增加上了。修改与增加一样，都是/update,删除为/delete。成功之后,我们去query里查询数据就能查到我们刚添加的数据。  Request-Handler(qt)：要进行的操作（update\\delete）。  Document Type：类型，有JSON、XML等格式。  Document(s)：内容，手动写的内容。  Commit Within：  Overwrite：为true,说明如果id重复则覆盖以前的值;为false说明如果id重复不覆盖以前的值。  Boost：好像是什么版本，没用过。5.5 Files（文件）solr_home下的core下的conf下的相关文件，可单击查看里面的内容。5.6 Query（查询页面）查询的结果要显示哪个字段,就得将schema.xml文件配置字段时的stored属性设为true。查询索引的文档，包含是否存在，排序是否正确等。 进入该页面后，直接点击Execute Query时，在右侧会生查回数据：  Request-Handler(qt)：  q：查询字符串（必须的）。*:*表示查询所有；keyword:东看表示按关键字“东看”查询  fq：Filter query过滤查询。使用Filter Query可以充分利用Filter Query Cache，提高检索性能。作用：在q查询符合结果中同时是fq查询符合的(类似求交集)，例如：q=mm&amp;fq=date_time：[20081001 TO 20091031]，找关键字mm，并且date_time是20081001到20091031之间的。  sort：排序。格式如下：字段名 排序方式；如advertiserId desc表示按id字段降序排列查询结果。  start,rows：表示查回结果从第几条数据开始显示，共显示多少条。  fl：field list。指定查询结果返回哪些字段。多个时以空格“ ”或逗号“,”分隔。不指定时，默认全返回。  df：default field默认的查询字段，一般默认指定。  Raw Query Parameters：  wt：write type。指定查询输出结果格式，我们常用的有json格式与xml格式。在solrconfig.xml中定义了查询输出格式：xml、json、python、ruby、php、phps、custom。  indent：返回的结果是否缩进，默认关闭，用indent=true | on开启，一般调试json,php,phps,ruby输出才有必要用这个参数。  debugQuery：设置返回结果是否显示Debug信息。  dismax：  edismax：  hl：high light高亮。hl=true表示启用高亮  hl.fl：用空格或逗号隔开的字段列表（指定高亮的字段）。要启用某个字段的highlight功能，就得保证该字段在schema中是stored。如果该参数未被给出，那么就会高亮默认字段，standard handler会用df参数，dismax字段用qf参数。你可以使用星号去方便的高亮所有字段。如果你使用了配符，那么要考虑启用hl.requiredFieldMatch选项。  hl.simple.pre：  hl.requireFieldMatch：如果置为true，除非该字段的查询结果不为空才会被高亮。它的默认值是false，意味着它可能匹配某个字段却高亮一个不同的字段。如果hl.fl使用了通配符，那么就要启用该参数。尽管如此，如果你的查询是all字段（可能是使用copy-field指令），那么还是把它设为false，这样搜索结果能表明哪个字段的查询文本未被找到  hl.usePhraseHighlighter：如果一个查询中含有短语（引号框起来的）那么会保证一定要完全匹配短语的才会被高亮。  hl.highlightMultiTerm：如果使用通配符和模糊搜索，那么会确保与通配符匹配的term会高亮。默认为false，同时hl.usePhraseHighlighter要为true。  facet：分组统计，在搜索关键字的同时,能够按照Facet的字段进行分组并统计。  facet.query：Facet Query利用类似于Filter Query的语法提供了更为灵活的Facet。通过facet.query参数，可以对任意字段进行筛选。  facet.field：需要分组统计的字段，可以多个。  facet.prefix：表示Facet字段值的前缀。比如facet.field=cpu&amp;facet.prefix=Intel，那么对cpu字段进行Facet查询，返回的cpu都是以Intel开头的， AMD开头的cpu型号将不会被统计在内。  spatial：  spellcheck：拼写检查。"
  },
  
  {
    "title": "Solr复制域的作用",
    "url": "/posts/solr-fuzhiyu-de-zuoyong/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "复制域常用于多域搜索，如：电商项目中搜索商品，既要在名字域中搜索也要在描述域中搜索，传统的做法需要手工写两次，而solr想发送一次请求，可到两个域中搜索，为此，引入了复制域的概念，将两个域的域名复制到一个text文本域中。Solr复制域可以将多个索引字段结合到一起作为查询使用的域，逻辑上拓展了可查询对象的范围。将一个字段的值作为复制字段，给其设置新的数据类型，如数值类型，可以作为排序字段来使...",
    "content": "复制域常用于多域搜索，如：电商项目中搜索商品，既要在名字域中搜索也要在描述域中搜索，传统的做法需要手工写两次，而solr想发送一次请求，可到两个域中搜索，为此，引入了复制域的概念，将两个域的域名复制到一个text文本域中。Solr复制域可以将多个索引字段结合到一起作为查询使用的域，逻辑上拓展了可查询对象的范围。将一个字段的值作为复制字段，给其设置新的数据类型，如数值类型，可以作为排序字段来使用，而不影像其模糊查询的效果。"
  },
  
  {
    "title": "Solr查询语句",
    "url": "/posts/solr-chaxun-yuju/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "基本字段查询key:中国key:*中   // 结束值为“中”的值key:中*   // 开始值为“中”的值key:*中*  // 含有“中”的值强制不分词key:'中国'多字段与或关系 OR/ANDkey:(02 OR 10 OR 11 OR 12 )key:(02 AND 10 AND 11 AND 12 )key1:01 AND key2:02多字段不包含关系 NOTproduct_n...",
    "content": "基本字段查询key:中国key:*中   // 结束值为“中”的值key:中*   // 开始值为“中”的值key:*中*  // 含有“中”的值强制不分词key:'中国'多字段与或关系 OR/ANDkey:(02 OR 10 OR 11 OR 12 )key:(02 AND 10 AND 11 AND 12 )key1:01 AND key2:02多字段不包含关系 NOTproduct_name:(* NOT 1)    // 字段不含1product_name:(* NOT *1)   // 字段结束时不为1product_name:(* NOT 1*)   // 字段开始时不为1范围查询total_price:[5000 TO 10000]   // 数值区间registration_date:['2011-04-27 17:22:55' TO '2013-04-27 17:22:55']   // 时间区间"
  },
  
  {
    "title": "SQL中EXISTS的用法",
    "url": "/posts/sql-zhong-esists-de-yongfa/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "功能EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。EXISTS与IN的使用效率的问题，通常情况下采用EXISTS要比IN效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。用法在插入记录前，需要检查这条记录是否已经...",
    "content": "功能EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。EXISTS与IN的使用效率的问题，通常情况下采用EXISTS要比IN效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。用法在插入记录前，需要检查这条记录是否已经存在，只有当记录不存在时才执行插入操作，可以通过使用 EXISTS 条件句防止插入重复记录。示例INSERT INTO TableIn (ANAME, ASEX)SELECT top 1 '张三', '男' FROM TableInWHERE not exists (select * from TableIn where TableIn.AID = 7)"
  },
  
  {
    "title": "Firefox如何启用Pocket for Firefox",
    "url": "/posts/firefox-ruhe-qiyong-pocket/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "  在地址栏，输入about:config，然后按回车。  有时会出现警告页面。点击我了解此风险，请继续！，以打开about:config页面。  在偏好列表上面的搜索栏里输入pocket。  点击首选项extensions.pocket.enabled旁边的按钮设其值为true。  Pocket是Firefox的内置功能。此时，它会在地址栏中添加一个Pocket按钮，在我的足迹菜单里添加一...",
    "content": "  在地址栏，输入about:config，然后按回车。  有时会出现警告页面。点击我了解此风险，请继续！，以打开about:config页面。  在偏好列表上面的搜索栏里输入pocket。  点击首选项extensions.pocket.enabled旁边的按钮设其值为true。  Pocket是Firefox的内置功能。此时，它会在地址栏中添加一个Pocket按钮，在我的足迹菜单里添加一个查看Pocket列表选项。"
  },
  
  {
    "title": "数据库三范式",
    "url": "/posts/shujuk-sanfanshi/",
    "categories": "Knowledge, Database",
    "tags": "Database",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "三范式解释1NF：字段不可分;原子性字段不可再分，否则就不是关系数据库; 2NF：有主键，非主键字段依赖主键;唯一性，一个表只说明一个事物;  3NF：非主键字段不能相互依赖;每列都与主键有直接关系，不存在传递依赖;不符合1NF的例子表字段1，字段2(字段2.1，字段2.2)，字段3 …… (关系数据库中create不出这样的表)存在问题因为设计不出这样的表，所以没有问题。不符合2NF的例子...",
    "content": "三范式解释1NF：字段不可分;原子性字段不可再分，否则就不是关系数据库; 2NF：有主键，非主键字段依赖主键;唯一性，一个表只说明一个事物;  3NF：非主键字段不能相互依赖;每列都与主键有直接关系，不存在传递依赖;不符合1NF的例子表字段1，字段2(字段2.1，字段2.2)，字段3 …… (关系数据库中create不出这样的表)存在问题因为设计不出这样的表，所以没有问题。不符合2NF的例子表学号，姓名，年龄，课程名称，成绩，学分这个表明显说明了两个事务:学生信息，课程信息存在问题  数据冗余，每条记录都含有相同信息；  删除异常：删除所有学生成绩，就把课程信息全删除了；  插入异常：学生未选课，无法记录进数据库；  更新异常：调整课程学分，所有行都调整。修正学生：Student(学号，姓名，年龄)； 课程：Course(课程名称，学分)； 选课关系：SelectCourse(学号，课程名称，成绩)。 满足2NF只消除了插入异常。不符合3NF的例子表学号，姓名，年龄，所在学院，学院联系电话，关键字为单一关键字”学号”; 存在依赖传递: (学号) → (所在学院) → (学院地点，学院电话) 存在问题  数据冗余：有重复值；  更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况  删除异常修正 学生：(学号，姓名，年龄，所在学院)； 学院：(学院，地点，电话)。"
  },
  
  {
    "title": "转发和重定向的参数传递",
    "url": "/posts/zhuanfa-he-chongdingxiang-de-canshuchuandi/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-11-30 13:47:00 +0800",
    





    
    "snippet": "重定向跳转超链接标签&lt;a&gt;就是一种重定向跳转，这样的跳转request对象是传不到下一个页面的，下一个页面得到的request对象是一个新的对象，而不是上一个页面传过来的，得不到上一个页面的数据。如果你想通过这种方法跳转的话，那就要用&lt;a href=\"a.jsp?参数名=参数值\"&gt;传递参数，在下一个页面用request.getParameter(\"参数名\")得到值。转...",
    "content": "重定向跳转超链接标签&lt;a&gt;就是一种重定向跳转，这样的跳转request对象是传不到下一个页面的，下一个页面得到的request对象是一个新的对象，而不是上一个页面传过来的，得不到上一个页面的数据。如果你想通过这种方法跳转的话，那就要用&lt;a href=\"a.jsp?参数名=参数值\"&gt;传递参数，在下一个页面用request.getParameter(\"参数名\")得到值。转发跳转这种跳转request对象会被传往下一个页面，可以用&lt;jsp:forward page=\"/a.jsp\"/&gt;，这样你可以把参数用request.setAttribute()的方法存进request对象里，再到下一个页面用request.getAttribute()得到参数。两种方法最明显的区别是，重定向跳转当你从a.jsp到b.jsp页面的时候，地址栏的地址已经由a.jsp变为b.jsp;相反，转发跳转当你从a.jsp到b.jsp页面的时候，地址栏仍然是a.jsp。"
  },
  
  {
    "title": "JSP页面拼装项目地址",
    "url": "/posts/jsp-yemian-pinzhuang-xiangmu-dizhi/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-11-30 13:47:00 +0800",
    





    
    "snippet": "&lt;% String path = request.getContextPath(); String basePath = request.getScheme()    + \"://\" + request.getServerName()    + \":\" + request.getServerPort()    + path;%&gt;&lt;!-- JSP中引用地址 --&gt;&lt...",
    "content": "&lt;% String path = request.getContextPath(); String basePath = request.getScheme()    + \"://\" + request.getServerName()    + \":\" + request.getServerPort()    + path;%&gt;&lt;!-- JSP中引用地址 --&gt;&lt;%=basePath %&gt;/TcService/insertTcService.controller"
  },
  
  {
    "title": "静态包含和动态包含",
    "url": "/posts/jingtaibaohan-he-dongtaibaohan/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-11-30 13:47:00 +0800",
    





    
    "snippet": "区别      书写上不同静态包含：&lt;%@include file=\"1.jsp\"%&gt;动态包含：&lt;jsp:include page=\"1.jsp\"&gt;&lt;/jsp:include&gt;&lt;%@include file=\"1.jsp\"%&gt;是指令元素；&lt;jsp:include page=\"1.jsp\"/&gt;是行为元素。        最终编译成Ja...",
    "content": "区别      书写上不同静态包含：&lt;%@include file=\"1.jsp\"%&gt;动态包含：&lt;jsp:include page=\"1.jsp\"&gt;&lt;/jsp:include&gt;&lt;%@include file=\"1.jsp\"%&gt;是指令元素；&lt;jsp:include page=\"1.jsp\"/&gt;是行为元素。        最终编译成Java文件的数目不同静态包含在转换成为Java文件的时候将包含文件的内容”复制”到主体文件，然后作为一个整体编译。最终编译为一个Java文件。动态包含是各个JSP文件分别转换，分别编译。最终编程成多个Java文件。        执行时间不同静态包含发生在：JSP–&gt;Java文件阶段。动态包含发生在：执行class文件阶段，动态加入。        静态包含在两个文件中不能有相同的变量，动态包含允许由于静态包含相当于将包含文件内容直接复制到主体文件中，如果出现相同的变量，就会出现覆盖等问题，导致文件出错。而动态包含相当于调用不同的JSP，变量所在的空间不同，自然不会出现覆盖等现象。        无论是动态包含还是静态包含，其request对象都是相同的，也就是同一个request对象静态包含最终编译成一个Java文件，有一个request对象很好理解。而动态包含最终编译成多个JSP文件，为何会使用一个request对象呢？其实这些JSP组合的过程是一个请求转发的过程，自然也使用同一个request对象了。  注意  两个JSP页面的&lt;%@page contentType=\"text/html;charset=gbk\"%&gt;应该保持一致  不能通过fileurl向被包含的JSP页面传递参数，因为静态包含是发生在JSP页面转换为servlet的转换期间，此时的参数是服务器端设置的死的参数，完全没有经过客户端，这种参数是没有意义的，如&lt;%@include file=\"fileurl?user=admin\"%&gt;，而且此时会报错。  包含的JSP页面与被包含的JSP页面共用一个request内置对象。比如说在客户端访问包含页面时地址栏后面直接加上参数后传递，这种形式的传参是客户端送来的，两个页面都能够访问此参数。我们可以通过这两个页面合成的servlet中可以看到有传递的参数成为servlet的成员变量。  包含的JSP页面与被包含的JSP页面最好没有重复的HTML标签。否则会发生覆盖现象。  动态包含传参方式：&lt;jsp:include page=\"a.jsp\"&gt;    &lt;jsp:param name=\"age\" value=\"123\"&gt;&lt;/ jsp:include&gt;"
  },
  
  {
    "title": "Chrome小恐龙",
    "url": "/posts/dino/",
    "categories": "Games",
    "tags": "Games",
    "date": "2020-11-29 13:47:00 +0800",
    





    
    "snippet": "             \t                                                                                                                                                                     ",
    "content": "             \t                                                                                                                                                                     "
  },
  
  {
    "title": 2048,
    "url": "/posts/2048/",
    "categories": "Games",
    "tags": "Games",
    "date": "2020-11-29 13:47:00 +0800",
    





    
    "snippet": "\t\t\t\t\t\t\t2048\t\t\t\t\t\t\t\t\t\t\t\t\t最佳: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t分数: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t游戏结束🙈再试一次\t\t\t\t\t\t\t重新启动游戏\t\t\t\t\t\t\t",
    "content": "\t\t\t\t\t\t\t2048\t\t\t\t\t\t\t\t\t\t\t\t\t最佳: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t分数: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t游戏结束🙈再试一次\t\t\t\t\t\t\t重新启动游戏\t\t\t\t\t\t\t"
  },
  
  {
    "title": "Filter拦截中忽略指定url和资源",
    "url": "/posts/guolvqi-fangxing-zhiding-dizhi/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "web.xml中的配置&lt;filter&gt;    &lt;filter-name&gt;SystemAuthorityFilter&lt;/filter-name&gt;    &lt;filter-class&gt;platform.filter.SystemAuthorityFilter&lt;/filter-class&gt;    &lt;init-param&gt;    ...",
    "content": "web.xml中的配置&lt;filter&gt;    &lt;filter-name&gt;SystemAuthorityFilter&lt;/filter-name&gt;    &lt;filter-class&gt;platform.filter.SystemAuthorityFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;IGNORE_URL&lt;/param-name&gt;        &lt;param-value&gt;/login/login.do,/test/test.do&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;IGNORE_DIR&lt;/param-name&gt;        &lt;param-value&gt;/css/,/images/,/script/&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;SystemAuthorityFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;"
  },
  
  {
    "title": "Git检出和提交代码至远程仓库",
    "url": "/posts/git-ruhe-jianchu-he-tijiao-daima/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "我们使用Git需要先安装Git工具，这里给出下载地址：https://git-for-windows.github.io/从远程仓库检出代码找到自己在GitHub上的代码仓库，点击Clone or dowload会出现一个地址，复制这个地址备用。  打开我的电脑，选择一个盘，比如F盘，右键空白处点击git bash here，打开命令行。输入如下命令，克隆Test repository到Te...",
    "content": "我们使用Git需要先安装Git工具，这里给出下载地址：https://git-for-windows.github.io/从远程仓库检出代码找到自己在GitHub上的代码仓库，点击Clone or dowload会出现一个地址，复制这个地址备用。  打开我的电脑，选择一个盘，比如F盘，右键空白处点击git bash here，打开命令行。输入如下命令，克隆Test repository到Test文件夹中git clone https://github.com/JiayiLi/Test.git # 地址替换成你之前复制的地址将代码推送到远程仓库将要提交的文件复制粘贴至F盘的Test文件夹中，接着输入命令cd Test，进入Test文件夹，接下来依次输入以下代码即可完成提交操作：git add .                 # 别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来git commit -m  \"提交信息\"  # “提交信息”里面换成你的备注信息，如“first commit”git push -u origin master # 此操作是把本地仓库push到GitHub上面，此步骤需要输入帐号和密码"
  },
  
  {
    "title": "Java中使用FreeMarker导出Word文档",
    "url": "/posts/java-shiyong-freemarker-shengcheng-word-wendang/",
    "categories": "Knowledge, FreeMarker",
    "tags": "FreeMarker",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "制作模板在制作模板时需要注意的一些问题如下：  用Microsoft Office Word 2003或以上的版本来制作，不要用WPS做。  关于图片，一定要插入一张图片，方便后面找到图片的位置好进行替换。  一些需要动态生成的数据，如个人信息，用personInfo（其他字段也行，建议和程序中的VO字段对应）来代替，注意，单词要先用一个文本框写好，再复制黏贴过来，不要在Word上手动敲，不...",
    "content": "制作模板在制作模板时需要注意的一些问题如下：  用Microsoft Office Word 2003或以上的版本来制作，不要用WPS做。  关于图片，一定要插入一张图片，方便后面找到图片的位置好进行替换。  一些需要动态生成的数据，如个人信息，用personInfo（其他字段也行，建议和程序中的VO字段对应）来代替，注意，单词要先用一个文本框写好，再复制黏贴过来，不要在Word上手动敲，不然再转成xml时单词会被拆散，也不要直接黏贴过来一个${personInfo}，还是会被拆散，最好直接黏贴一个单词过来，在xml中再找到这个单词再添加${}。  表格只需要画一行，循环在xml中配置。模板画好之后，直接将Word另存为xml格式，保存完后将Word关掉，用Notepad++打开保存的xml格式的文档找到你写的单词如stdName。在单词前后加上${}，所有你写的单词都加上。搜索w:tr找到表格。在表格标签&lt;w:tr&gt;的首尾分别加上&lt;#list expList as exp&gt;和&lt;/#list&gt;标签，并且标签里的单词要改成${exp.time}这种形式。解释一下：list标签可以使标签内的表格自动循环生成相应的行数，expList是自己命名的，是表格的数据来源，是一个list集合，exp是别名。 搜索&lt;pkg:binaryData&gt;，你会发现这个标签里的内容特别多，这就是你画模板时插入的图片的BASE64字符串。将&lt;pkg:binaryData&gt;标签里的内容删完，替换为${images}，这样就可以在代码中设置，然后导出自己获取的图片了，当然名字自己取，叫img也可以，只要在代码中和这对应就好了。将上面修改好的xml文档保存好，点击重命名将其类型修改为ftl。至此，模板就制作好了，在后面代码中要用的模板就是template.ftl。Java代码private void exportWord(String ssdw, String image64Str, String stdName, String personInfo, List&lt;FamilyInfo&gt; familyInfos,                        Map&lt;String, String&gt; maps) {    Map&lt;String, Object&gt; dataMap = new HashMap&lt;String, Object&gt;();    // ssdw 是职员信息    dataMap.put(\"orgName\", ssdw);    // image64Str 是职员的照片转换后的BASE64字符串    dataMap.put(\"images\", image64Str);    // stdName 是职员信息    dataMap.put(\"stdName\", stdName);    // personInfo 是职员信息    dataMap.put(\"personInfo\", personInfo);    // familyList 是职员的家庭信息的集合，对应模板中的表格    List&lt;Map&lt;String, Object&gt;&gt; familyList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    for (int i = 0; i &lt; familyInfos.size(); i++) {        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"gx\", familyInfos.get(i).getYbrgx());        map.put(\"xm\", familyInfos.get(i).getCyxm());        map.put(\"dwjzw\", familyInfos.get(i).getDwjzw());        familyList.add(map);    }    dataMap.put(\"familyList\", familyList);    // expList 是职员的工作经历信息的集合，对应模板中的表格    List&lt;Map&lt;String, Object&gt;&gt; expList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    Iterator&lt;Entry&lt;String, String&gt;&gt; it = maps.entrySet().iterator();    while (it.hasNext()) {        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        Map.Entry&lt;String, String&gt; entity = (Entry&lt;String, String&gt;) it.next();        map.put(\"time\", entity.getKey());        map.put(\"experience\", entity.getValue());        expList.add(map);    }    dataMap.put(\"expList\", expList);    @SuppressWarnings(\"deprecation\")    Configuration configuration = new Configuration();    configuration.setDefaultEncoding(\"utf-8\");    // 有两种方式获取你的模板，模板在项目中时用第一个，模板在本地时用第二个。    // 注意：两种方式的路径都只需要写到模板的上一级目录    configuration.setClassForTemplateLoading(this.getClass(), \"/tem\");    // configuration.setDirectoryForTemplateLoading(new File(\"C:/\"));      File outFile = new File(\"D:/outFilessa\" + Math.random() * 10000 + \".doc\"); // 输出路径    Template t = null;      Writer out = null;    try {        t = configuration.getTemplate(\"template.ftl\", \"utf-8\"); // 获取模板        out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFile), \"utf-8\"));         // 如果想由浏览器指定下载位置，则使用下面代码        // String filename = \"模板.doc\";        // response.setContentType(\"application/ms-excel;charset=UTF-8\");        // response.setHeader(\"Content-Disposition\", \"attachment;filename=\".concat(String.valueOf(URLEncoder.encode(filename, \"UTF-8\"))));        // out = new BufferedWriter(new OutputStreamWriter(response.getOutputStream(), \"utf-8\"));        t.process(dataMap, out);    } catch (Exception e) {        e.printStackTrace();      } finally {        try {            out.close();        } catch (IOException  e1) {            e.printStackTrace();         }    }}"
  },
  
  {
    "title": "FreeMarker如何格式化数字",
    "url": "/posts/freemarker-geshihua-shuzi/",
    "categories": "Knowledge, FreeMarker",
    "tags": "FreeMarker",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "// 如果小数点后不足两位，用\"0\"代替${num?string('0.00')} // 输出为：1239765.46 // 如果小数点后多余两位，就只保留两位，否则输出实际值 ${num?string('#.##')} // 输出为：1,239,765.46 // 整数部分每三位用\",\"分割，并且保证小数点后保留两位，不足用\"0\"代替${num?string(',###.00')} // ...",
    "content": "// 如果小数点后不足两位，用\"0\"代替${num?string('0.00')} // 输出为：1239765.46 // 如果小数点后多余两位，就只保留两位，否则输出实际值 ${num?string('#.##')} // 输出为：1,239,765.46 // 整数部分每三位用\",\"分割，并且保证小数点后保留两位，不足用\"0\"代替${num?string(',###.00')} // 输出为：1,239,765.46 // 整数部分每三位用\",\"分割，并且小数点后多余两位就只保留两位，不足两位就取实际位数${num?string(',###.##')} // 输出为：012.70 // 整数部分如果不足三位（000），前面用\"0\"补齐，否则取实际的整数位${num?string('000.00')} "
  },
  
  {
    "title": "Bitbucket-4.10.1安装和破解",
    "url": "/posts/bitbucket-anzhuang-he-pojie/",
    "categories": "Knowledge, Bitbucket",
    "tags": "Bitbucket",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "需要安装的环境有：jdk、mysql、git安装官网下载Bitbucket的安装包atlassian-bitbucket-4.10.1-x64.bin，运行安装程序，系统默认http端口为7990，服务端口为8006，安装时可以根据自己需要重新输入，安装成功后，启动服务，可以通过http://localhost:7990访问。破解停止服务，并上传文件atlassian-extras-deco...",
    "content": "需要安装的环境有：jdk、mysql、git安装官网下载Bitbucket的安装包atlassian-bitbucket-4.10.1-x64.bin，运行安装程序，系统默认http端口为7990，服务端口为8006，安装时可以根据自己需要重新输入，安装成功后，启动服务，可以通过http://localhost:7990访问。破解停止服务，并上传文件atlassian-extras-decoder-v2-3.3.0.jar和atlassian-extras-legacy-3.3.0.jar，路径为atlassian/bitbucket/4.10.1/atlassian-bitbucket/WEB-INF/lib，上传完成后重启服务。汉化下载Bitbucket4.10.1中文语言包（下载地址：https://translations.atlassian.com/dashboard/download?lang=zh_CN#/Bitbucket/4.11.0-rc1），在插件管理中上传语言插件。创建Jira连接点击”设置(Settigns)” -&gt; “应用程序连接(Application Links)”, 填入Jira的地址: http://192.168.X.X/8080后, 点击创建链接即可。安装过程截图"
  },
  
  {
    "title": "微信公众号自动应答的实现",
    "url": "/posts/weixin-zidong-yingda/",
    "categories": "Knowledge, WeChat",
    "tags": "WeChat",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "开发主要分为以下几个步骤：  申请测试公众号  配置服务器地址  验证服务器地址的有效性  接收消息，回复消息申请测试公众号  记录：不知道如何使用微信公众号进行调试，百度了很多资料，发现微信公众平台提供了相当好的测试工具，这是一个模拟的公众号，我们可以用自己的微信关注该公众号，然后进行接口调试。第一步首先要申请一个测试的微信公众号，便于调试，地址：https://mp.weixin.qq....",
    "content": "开发主要分为以下几个步骤：  申请测试公众号  配置服务器地址  验证服务器地址的有效性  接收消息，回复消息申请测试公众号  记录：不知道如何使用微信公众号进行调试，百度了很多资料，发现微信公众平台提供了相当好的测试工具，这是一个模拟的公众号，我们可以用自己的微信关注该公众号，然后进行接口调试。第一步首先要申请一个测试的微信公众号，便于调试，地址：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login配置服务器地址在测试号页面上有接口配置信息选项，在这个选项下面进行配置：有两个配置项：服务器地址（URL），Token，在正式的公众号上还有一个选项EncodingAESKey。  URL：开发者用来接收微信消息和事件的接口URL。  Token：可以任意填写，用作生成签名（该Token和接口URL中包含的Token进行比对，从而验证安全性）。  EncodingAESKey：由开发者手动填写或随机生成，将用作消息体加解密密钥。当输入URL和Token点击保存的时候，需要后台启动并且验证Token通过之后才能保存，不然会保存失败，所以先把后台代码启动起来。  记录：验证方式在这里可以找到。在验证的时候始终调不到后台，后来发现需要将本地的服务器映射到外网，这里使用了nat123，但是这个软件用了两天就不能用了，需要收费，于是换成了Sunny-Ngrok，这里推荐使用Sunny-Ngrok，用起来相当顺手。这些工作做完之后就可以保存配置了。验证服务器地址的有效性当填写URL，Token，点击保存时，微信会通过GET的方式把微信加密签名（signature），时间戳（timestamp），随机数（nonce）和随机字符串（echostr）传到后台，通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。验证步骤如下：  将token、timestamp、nonce三个参数进行字典序排序。  将三个参数字符串拼接成一个字符串进行sha1加密。  获得加密后的字符串与signature对比，如果相等，返回echostr，表示配置成功，否则返回null，配置失败。签名校检工具类：package com.weixin.util;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class WeixinCheckoutUtil {        private static String token = \"you_token\";    public static boolean checkSignature(String signature, String timestamp,     String nonce) {        String[] arr = { token, timestamp, nonce };        sort(arr);        StringBuilder content = new StringBuilder();        for (int i = 0; i &lt; arr.length; i++) {            content.append(arr[i]);        }        MessageDigest md = null;        String tmpStr = null;        try {            md = MessageDigest.getInstance(\"SHA-1\");            byte[] digest = md.digest(content.toString().getBytes());            tmpStr = byteToStr(digest);        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        content = null;        return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;    }    private static String byteToStr(byte[] byteArray) {        String strDigest = \"\";        for (int i = 0; i &lt; byteArray.length; i++) {            strDigest = strDigest + byteToHexStr(byteArray[i]);        }        return strDigest;    }    private static String byteToHexStr(byte mByte) {        char[] Digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',         'A', 'B', 'C', 'D', 'E', 'F' };        char[] tempArr = new char[2];        tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4 &amp; 0xF)];        tempArr[1] = Digit[(mByte &amp; 0xF)];        String s = new String(tempArr);        return s;    }    public static void sort(String[] a) {        for (int i = 0; i &lt; a.length - 1; i++) {            for (int j = i + 1; j &lt; a.length; j++) {                if (a[j].compareTo(a[i]) &lt; 0) {                    String temp = a[i];                    a[i] = a[j];                    a[j] = temp;                }            }        }    }    }签名校验请求控制器package com.weixin.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.weixin.util.WeixinCheckoutUtil;@RestControllerpublic class WeixinCheckController {        @RequestMapping(value = \"/wx\", method = { RequestMethod.GET })    public String doGet(String signature, String timestamp,     String nonce, String echostr) {        // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功        if (signature != null &amp;&amp; WeixinCheckoutUtil.checkSignature(signature,          timestamp, nonce)) {            return echostr;        }        return null;    }}接收消息，回复消息  记录：微信服务器设置如果使用了安全模式，后台需要对报文进行解密，而且响应微信服务器的报文也需要加密。调试可以使用微信公众平台接口调试工具jar包依赖微信服务器发送过来的是XML格式的消息，所以我们可以采用开源框架dom4j去解析XML。而weixin-popular则是微信消息体加密及解密需要的。&lt;dependency&gt;    &lt;groupId&gt;dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.liyiorg&lt;/groupId&gt;    &lt;artifactId&gt;weixin-popular&lt;/artifactId&gt;    &lt;version&gt;2.8.24&lt;/version&gt;&lt;/dependency&gt;Message实体public class Message {    private String signature;    private String timestamp;    private String nonce;    private String openid;    private String msg_signature;    private String encrypt_type;}回调接口消息、事件回调跟校验回调是同一个接口地址，但是请求方式为POST。消息、事件会以xml格式的传输到后台，后台解析xml进行处理。package com.weixin.service.impl;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import com.qq.weixin.mp.aes.WXBizMsgCrypt;public class WechatCallbackServiceImpl implements WechatCallbackService {        private static String TOKEN = \"\";    private static String ENCODINGAES_KEY = \"\";    private static String APPID = \"\";    public void doPost(HttpServletRequest request, HttpServletResponse response)                             throws Exception {        request.setCharacterEncoding(\"UTF-8\");        response.setCharacterEncoding(\"UTF-8\");        PrintWriter out = response.getWriter();        String content = \"\"; // 应答消息        String msg = \"\"; // 用户发来的消息        String wechatId = \"\"; // 发送方帐号        String openid = \"\"; // 开发者微信号                try {            /** 获取回调入参 **/            String encryptType = request.getParameter(\"encrypt_type\"); // 加密类型            String timestamp = request.getParameter(\"timestamp\"); // 时间戳            String nonce = request.getParameter(\"nonce\"); // 随机数            String msgSignature = request.getParameter(\"msg_signature\"); // 加密签名            /** 对不同模式下的报文进行处理 **/            WXBizMsgCrypt pc = new WXBizMsgCrypt(TOKEN, ENCODINGAES_KEY, APPID);            String requestXml = streamToString(request);            String result = \"\";            if ((encryptType != null)                     &amp;&amp; (!\"\".equals(encryptType))                     &amp;&amp; (\"aes\".equals(encryptType))) {                // 安全模式，解密                result = pc.decryptMsg(msgSignature, timestamp, nonce, requestXml);            } else {                // 明文模式                result = requestXml;            }                        /** 解析XML报文 **/            Document doc = DocumentHelper.parseText(result);            Element root = doc.getRootElement();            List&lt;Element&gt; elelist = root.elements();            Map&lt;String, String&gt; map = new HashMap();            for (Element e : elelist) {                map.put(e.getName(), e.getText());            }            wechatId = (String) map.get(\"ToUserName\");            openid = (String) map.get(\"FromUserName\");            msg = (String) map.get(\"Content\");            /** 对消息进行响应 **/            if (msg.contains(\"消息\")) {                content = \"后台接收到了消息！\";            } else {                content = \"\";            }                        /** 拼装响应报文 **/            String responseXml = \"\"                 + \"&lt;xml&gt;\"                     + \"&lt;ToUserName&gt;&lt;![CDATA[\" + openid + \"]]&gt;&lt;/ToUserName&gt;\"                     + \"&lt;FromUserName&gt;&lt;![CDATA[\" + wechatId + \"]]&gt;&lt;/FromUserName&gt;\"                     + \"&lt;CreateTime&gt;\" + System.currentTimeMillis() + \"&lt;/CreateTime&gt;\"                    + \"&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\"                     + \"&lt;Content&gt;&lt;![CDATA[\" + content + \"]]&gt;&lt;/Content&gt;\"                + \" &lt;/xml&gt;\";                        /** 安全模式下对响应报文进行加密 **/            if ((encryptType != null)                     &amp;&amp; (!\"\".equals(encryptType))                     &amp;&amp; (\"aes\".equals(encryptType))) {                responseXml = pc.encryptMsg(responseXml, timestamp, nonce);            }                        /** 响应 **/            if (\"\".equals(content)) {                out.println(\"\");            } else {                out.println(responseXml);            }        } catch (Exception e) {            throw new Exception(\"回调接口发生错误，错误信息：\" + e.toString());        }    }    private String streamToString(HttpServletRequest request) throws IOException {        BufferedReader reader = new BufferedReader(                new InputStreamReader(request.getInputStream()));        StringBuilder sb = new StringBuilder();        try {            String line;            while ((line = reader.readLine()) != null) {                sb.append(line);            }        } catch (IOException e) {            e.printStackTrace();        }        return sb.toString();    }}回调接口控制器package com.weixin.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.weixin.util.WeixinCheckoutUtil;import com.weixin.service.WechatCallbackService;@RestControllerpublic class WeixinCheckController {    @Autowired    private WechatCallbackService wechatCallbackService;        @RequestMapping(value = \"/wx\", method = { RequestMethod.GET })    public String doGet(String signature, String timestamp,     String nonce, String echostr) {        if (signature != null &amp;&amp; WeixinCheckoutUtil.checkSignature(signature,          timestamp, nonce)) {            return echostr;        }        return null;    }    @RequestMapping(value = \"/wx\", method = { RequestMethod.POST })    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws Exception {        wechatCallbackService.doPost(request, response);    }}不同消息体报文的封装可以参考微信官方文档或者微信公众平台开发入门教程[2020版]  参考：1、java实现微信公众号token验证2、微信官方文档3、微信公众平台开发入门教程[2020版]"
  },
  
  {
    "title": "对微信服务器发送来的报文解密时报错：illegal Key Size",
    "url": "/posts/jiemi-shi-baocuo/",
    "categories": "Knowledge, WeChat",
    "tags": "WeChat",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "问题在加密解密时遇到这个问题：java.security.InvalidKeyException:illegal Key Size问题原因这是因为微信在进行数据传输的时候，会进行加密，微信使用的AES加密是256位，Java默认使用的解密包是local_policy.jar和US_export_policy.jar，但是这个默认的只支持128位的解密(java版本在1.8.0_161之后就没...",
    "content": "问题在加密解密时遇到这个问题：java.security.InvalidKeyException:illegal Key Size问题原因这是因为微信在进行数据传输的时候，会进行加密，微信使用的AES加密是256位，Java默认使用的解密包是local_policy.jar和US_export_policy.jar，但是这个默认的只支持128位的解密(java版本在1.8.0_161之后就没有这个问题了，默认是支持)。我们的版本低于1.8.0_161，默认是只支持128位的解密。解决办法  到这里选择下载Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 1.4.2  下载jce_policy-1_4_2.zip后解压，放入$JAVA_HOME/jre/lib/security/目录下替换原来的jar包。  重启服务"
  },
  
  {
    "title": "使用Excel生成SQL语句",
    "url": "/posts/shiyong-excel-shengcheng-sql/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "\"update TEST_TABLE set co1='\"&amp;A1&amp;\"', co2='\"&amp;B1&amp;\"', co3='\"&amp;C1&amp;\"' where co4='\"&amp;D1&amp;\"'\"",
    "content": "\"update TEST_TABLE set co1='\"&amp;A1&amp;\"', co2='\"&amp;B1&amp;\"', co3='\"&amp;C1&amp;\"' where co4='\"&amp;D1&amp;\"'\""
  },
  
  {
    "title": "查询数据库所有表的所有字段",
    "url": "/posts/chaxun-suoyoubiao-de-suoyou-ziduan/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "MySQL数据库SELECT table_name, column_nameFROM information_schema. COLUMNSWHERE table_schema = 'testdb'AND table_name IN ( SELECT  TABLE_NAME FROM  INFORMATION_SCHEMA. TABLES WHERE  TABLE_SCHEMA = 'tes...",
    "content": "MySQL数据库SELECT table_name, column_nameFROM information_schema. COLUMNSWHERE table_schema = 'testdb'AND table_name IN ( SELECT  TABLE_NAME FROM  INFORMATION_SCHEMA. TABLES WHERE  TABLE_SCHEMA = 'testdb')ORDER BY table_name, column_nameOracle数据库SELECT A .table_name, A .COLUMN_NAMEFROM user_tab_columns AWHERE TABLE_NAME IN (  SELECT   table_name  FROM   user_tables )ORDER BY A .table_nameSQLServer数据库SELECT table_name, column_nameFROM information_schema.columnsWHERE table_name IN (  SELECT   TOP 100 PERCENT name  FROM   sysobjects  WHERE   xtype = 'u' )ORDER BY table_name"
  },
  
  {
    "title": "Linux中查看进程的端口号，查看哪个进程占用了该端口",
    "url": "/posts/linux-duankoujijincheng/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "知道进程，查看进程的端口号[root@localhost ~]# ps -ef|grep ssh961 ?         00:00:00 sshd...[root@localhost ~]# netstat -anp|grep 961tcp   0   0 0.0.0.0:22   0.0.0.0:*   LISTEN   961/sshd         ...          查看...",
    "content": "知道进程，查看进程的端口号[root@localhost ~]# ps -ef|grep ssh961 ?         00:00:00 sshd...[root@localhost ~]# netstat -anp|grep 961tcp   0   0 0.0.0.0:22   0.0.0.0:*   LISTEN   961/sshd         ...          查看哪个进程占用了某个端口[root@localhost ~]# netstat -anp|grep 22tcp   0   0 0.0.0.0:22   0.0.0.0:*   LISTEN   961/sshd            ...[root@localhost ~]# ps -ef|grep sshd961 ?        00:00:00 sshd1154 ?        00:00:00 sshd1156 ?        00:00:00 sshd"
  },
  
  {
    "title": "查看当前目录下文件及文件夹的大小",
    "url": "/posts/linux-chakan-dangqian-muluxia-wenjian-daxiao/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "# 查看当前目录下各个文件及目录占用空间大小du -sh *# 按兆（M）来排序du -sh * | sort -rn",
    "content": "# 查看当前目录下各个文件及目录占用空间大小du -sh *# 按兆（M）来排序du -sh * | sort -rn"
  },
  
  {
    "title": "Git切换远程仓库地址",
    "url": "/posts/git-qiehuan-yuancheng-cangku-dizhi/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "Git仓库的服务器IP地址变了，本地代码挺多，重新检出太占时间，可以修改一个什么配置让本地仓库和新的远程仓库建立关联吗， 答案是肯定的！方式一：修改远程仓库地址git remote -v  # 查看当前远程仓库地址git remote set-url origin &lt;new url&gt;  # 修改远程地址为新的地址 &lt;new url&gt; 改为新的地址方式二：先删除远程仓库...",
    "content": "Git仓库的服务器IP地址变了，本地代码挺多，重新检出太占时间，可以修改一个什么配置让本地仓库和新的远程仓库建立关联吗， 答案是肯定的！方式一：修改远程仓库地址git remote -v  # 查看当前远程仓库地址git remote set-url origin &lt;new url&gt;  # 修改远程地址为新的地址 &lt;new url&gt; 改为新的地址方式二：先删除远程仓库地址，然后再添加git remote -v  # 查看当前远程仓库地址git remote rm origin  # 删除现有远程仓库git remote add origin url  # 添加新远程仓库"
  },
  
  {
    "title": "Git推送代码时报错：error:src refspec master does not match any",
    "url": "/posts/git-push-baocuo/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "将git push origin master 改成git push origin HEADHEAD指向当前工作的branch，master不一定指向当前工作的branch",
    "content": "将git push origin master 改成git push origin HEADHEAD指向当前工作的branch，master不一定指向当前工作的branch"
  },
  
  {
    "title": "如何防止U盘拷贝",
    "url": "/posts/ruhe-fangzhi-youpan-kaobei/",
    "categories": "Knowledge, SECURITY",
    "tags": "SECURITY",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "拒绝移动存储权限gpedit.msc——用户配置——管理模板——系统——可移动存储访问——所有可移动存储类——拒绝所有权限——已启用隐藏右键send to删除SendTo文件夹HKEY_CLASSES_ROOT\\AllFilesystemObjects\\shellex\\ContextMenuHandlers\\SendTo添加磁盘写保护HKEY_LOCAL_MACHINE\\SYSTEM\\Cur...",
    "content": "拒绝移动存储权限gpedit.msc——用户配置——管理模板——系统——可移动存储访问——所有可移动存储类——拒绝所有权限——已启用隐藏右键send to删除SendTo文件夹HKEY_CLASSES_ROOT\\AllFilesystemObjects\\shellex\\ContextMenuHandlers\\SendTo添加磁盘写保护HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\storagedevicepolicies解除写保护：writeprotect”=dword:00000000添加写保护：writeprotect”=dword:00000001隐藏U盘盘符HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\USBSTOR隐藏：Start”=dword:00000004显示：Start”=dword:00000003"
  },
  
  {
    "title": "常用DOS命令",
    "url": "/posts/changyong-dos-mingling/",
    "categories": "Knowledge, DOS",
    "tags": "DOS",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "calc -----------启动计算器  control --------打开控制面板 cleanmgr -------磁盘清理eventvwr -------事件查看器mplayer2 -------简易widnowsmediaplayer  Sndvol32 -------音量控制程序 mmc ------------打开控制台write ----------写字板dfrg.msc ...",
    "content": "calc -----------启动计算器  control --------打开控制面板 cleanmgr -------磁盘清理eventvwr -------事件查看器mplayer2 -------简易widnowsmediaplayer  Sndvol32 -------音量控制程序 mmc ------------打开控制台write ----------写字板dfrg.msc -------磁盘碎片整理程序compmgmt.msc ---计算机管理 diskmgmt.msc ---磁盘管理实用程序gpedit.msc -----组策略  lusrmgr.msc ----本机用户和组certmgr.msc ----证书管理实用程序 fsmgmt.msc -----共享文件夹管理器 devmgmt.msc --- 设备管理器 secpol.msc -----本地安全策略 desk.cpl -------显示属性 firewall.cpl ---WINDOWS防火墙 ncpa.cpl -------网络连接 sysdm.cpl ------系统 wscui.cpl ------安全中心sfc.exe --------系统文件检查器chkdsk.exe -----Chkdsk磁盘检查 shutdown -------关机，详细请在cmd中输入shutdown /?logoff ---------注销wmic bios ------查看BIOS信息dxdiag ---------查看系统信息方式1start msinfo32 -查看系统信息方式2winmsd ---------查看系统信息方式3ipconfig/all ---查询IP地址getmac ---------查询MAC地址winver ---------检测windows版本netstat -na ----查看电脑端口号"
  },
  
  {
    "title": "颜色搭配",
    "url": "/posts/yanse-dapei/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "交互按钮设计",
    "url": "/posts/jiaohu-anniu-sheji/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "算法复杂度速查表",
    "url": "/posts/suanfa-fuzadu-suchabiao/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "这篇文章覆盖了计算机科学里面常见算法的时间和空间的大O复杂度图例数据结构操作数组排序算法图操作堆操作大O复杂度图表",
    "content": "这篇文章覆盖了计算机科学里面常见算法的时间和空间的大O复杂度图例数据结构操作数组排序算法图操作堆操作大O复杂度图表"
  },
  
  {
    "title": "Spring Boot @Transactional注解不起作用的两种情况",
    "url": "/posts/shiwu-buqizuoyong-de-liangzhong-teshu-qingkuang/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "1、事务的回滚仅仅对于unchecked的异常有效注解为事务范围的方法中，事务的回滚仅仅对于unchecked的异常有效。对于checked异常无效。也就是说事务回滚仅仅发生在出现RuntimeException或Error的时候。如果希望一般的异常也能触发事务回滚，需要在注解了@Transactional的方法上，将@Transactional回滚参数设为：@Transactional(r...",
    "content": "1、事务的回滚仅仅对于unchecked的异常有效注解为事务范围的方法中，事务的回滚仅仅对于unchecked的异常有效。对于checked异常无效。也就是说事务回滚仅仅发生在出现RuntimeException或Error的时候。如果希望一般的异常也能触发事务回滚，需要在注解了@Transactional的方法上，将@Transactional回滚参数设为：@Transactional(rollbackFor = Exception.class)2、 Service类内部方法调用大概就是Service中有一个方法A，会内部调用方法B， 方法A没有事务管理，方法B采用了声明式事务，通过在方法上声明Transactional的注解来做事务管理。声明式事务是通过AOP动态代理实现的，这样会产生一个代理类来做事务管理，而目标类（service）本身是不能感知代理类的存在的。对于加了@Transactional注解的方法来说，在调用代理类的方法时，会先通过拦截器TransactionInterceptor开启事务，然后在调用目标类的方法，最后在调用结束后，TransactionInterceptor 会提交或回滚事务。在方法A中调用方法B，实际上是通过“this”的引用，也就是直接调用了目标类的方法，而非通过Spring上下文获得的代理类，所以事务是不会开启的。将不同方法放到不同的类中进行调用即可避免此类错误。"
  },
  
  {
    "title": "激活Windows7提示系统保留分区未分配驱动器号",
    "url": "/posts/win7-jihuo-tishi-weifenpei-qudongqihao/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "  鼠标右键点击桌面的“计算机”图标，选择“管理”项  在“计算机管理”窗中，选择“磁盘管理”项，点击打开  找到磁盘大小为“100M”的那个分区  鼠标右键，然后选择“更改驱动器号和路径”，进行驱动器号的设置  然后点击“添加”，选择一个可用的驱动号，比如这里选择“H”即可，然后点击“确定”完成  然后出现添加成功的信息  接下来，点击Windows7“激活”按钮，完成系统的激活即可",
    "content": "  鼠标右键点击桌面的“计算机”图标，选择“管理”项  在“计算机管理”窗中，选择“磁盘管理”项，点击打开  找到磁盘大小为“100M”的那个分区  鼠标右键，然后选择“更改驱动器号和路径”，进行驱动器号的设置  然后点击“添加”，选择一个可用的驱动号，比如这里选择“H”即可，然后点击“确定”完成  然后出现添加成功的信息  接下来，点击Windows7“激活”按钮，完成系统的激活即可"
  },
  
  {
    "title": "CSS实现文字下面波浪线",
    "url": "/posts/geiwenzi-jia-bolangxian/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "方法1.使用径向渐变绘制波浪线一个波浪线循环段是有一个朝上的半个圆弧和一个朝下的半个圆弧组合而成的。所以，我们只要使用径向渐变绘制圆弧，再通过background-position控制两个圆弧的位置，让其前后拼接在一起就可以实现波浪线效果。&lt;style type=\"text/css\"&gt;.flow-wave {    background: radial-gradient(circ...",
    "content": "方法1.使用径向渐变绘制波浪线一个波浪线循环段是有一个朝上的半个圆弧和一个朝下的半个圆弧组合而成的。所以，我们只要使用径向渐变绘制圆弧，再通过background-position控制两个圆弧的位置，让其前后拼接在一起就可以实现波浪线效果。&lt;style type=\"text/css\"&gt;.flow-wave {    background: radial-gradient(circle at 10px -7px, transparent 8px, currentColor 8px, currentColor 9px, transparent 9px) repeat-x,        radial-gradient(circle at 10px 27px, transparent 8px, currentColor 8px, currentColor 9px, transparent 9px) repeat-x;    background-size: 20px 20px;    background-position: -10px calc(100% + 16px), 0 calc(100% - 4px);}&lt;/style&gt;&lt;font class=\"flow-wave\"&gt;段落文字&lt;/font&gt;效果：段落文字方法2.使用SVG波形矢量图作为背景&lt;style type=\"text/css\"&gt;.flow-wave {    background: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 4'%3E%3Cpath fill='none' stroke='red' d='M0 3.5c5 0 5-3 10-3s5 3 10 3 5-3 10-3 5 3 10 3'/%3E%3C/svg%3E\") repeat-x 0 100%;     background-size: 20px auto;}&lt;/style&gt;&lt;font class=\"flow-wave\"&gt;段落文字&lt;/font&gt;效果：段落文字  参考：CSS实现文字下面波浪线"
  },
  
  {
    "title": "为什么越学反而越蠢",
    "url": "/posts/20201118/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "先给你讲个故事，看你有没有中招有一天，你的朋友给你“知识装逼”了一个术语，他推给你一个公众号，你开始关注，觉得哇！大神！长见识！每天刷每天刷每天刷。很多问题也有了解决方法——按照这个进度，过3年就能理解宇宙终极奥义了，慢慢你有了十多个类似的号，承包了你从专业、生活、工作、跑步、减肥、饮食、情感关系……等等所有的领域，有点看不过来的你决定提高效率碎片化学习！利用一切碎片时间，上地铁看一篇，吃饭...",
    "content": "先给你讲个故事，看你有没有中招有一天，你的朋友给你“知识装逼”了一个术语，他推给你一个公众号，你开始关注，觉得哇！大神！长见识！每天刷每天刷每天刷。很多问题也有了解决方法——按照这个进度，过3年就能理解宇宙终极奥义了，慢慢你有了十多个类似的号，承包了你从专业、生活、工作、跑步、减肥、饮食、情感关系……等等所有的领域，有点看不过来的你决定提高效率碎片化学习！利用一切碎片时间，上地铁看一篇，吃饭时看一篇，睡前刷2篇。眼睛看不完，用音频刷，平时看不完，跑步还能刷，但是，还是刷不完！还好有收藏功能，全收藏！这也叫“ 松鼠症 ” —— 不断攒不断攒不断攒……等到收藏超过100篇未读的时候，你终于发现收藏 = 永不再读，这让你沮丧，更让人沮丧的是，你好像距离写文章的大牛越来越远了——在你“学习”的这段时间，这100位大牛好像都更牛逼了一点，而且牛逼的人好像越来越多，观点越来越新，每天都有人用全新的玩法颠覆原来的牛人，—哇，原来这才是对的！别说宇宙奥义了，你对于生活有了深深的怀疑……再好的鸡汤也掩饰不了你日益的郁闷，确实，这个世界LOW的就是刷了无数文章的你你越来越焦虑，终于有一天，你彻底瘫痪了，对自己说，为什么活得这么累？我要做一只猪，一坨肉，一个死尸，你开始转战娱乐、小说和短视频……中招的请举手更加让你想抽自己的是，过了几天你歇过来，你又开始了新一轮的循环，刷刷刷，焦虑症！松鼠症！懒癌！本世纪三大绝症，其实是个死循环为什么会这样？因为，所有的当代人都面临两个问题：信息超载和知识碎片化信息超载老话题不多说了，讲几个数据：全世界每天有4000本书出版，超过4亿个字；纽约时报一天的文字量等于牛顿同时代的人一生的阅读量；一个专业领域，每天大概有200个公众号正在注册，有近1000篇文字正在产生，过去杂家、博物家在现代社会已经不可能存在，即使有，也干不过谷歌度娘。知识的储存能力，人类早就被电脑完胜了，知识的搜索和链接能力，才是学习的核心竞争力。另一个趋势也很明显：知识碎片化。这个碎片化从3个方面开始：1、首先时间和空间被打碎，移动手机允许你在三站地铁里听完一本书；2、其次被打碎的是信息，如果你翻知乎、今日头条或者某个博客，你并不会像看一本书一样，知道前面一章讲什么的，后面即将讲什么，除了标题党，你根本对下一个博客、内容毫无预期，只能被动接受；3、最糟糕的其实是知识结构碎片化，你并不知道是谁，在什么情况下，针对什么问题讲的这句话。所有的信息缺乏了上下文，就是废话。比如说有段时间我刷管理类的文，你会发现在雷军、傅盛、彼得德鲁克、吴伯凡、马云、吴晓波……各位大佬针对同一个问题讲的内容完全不同。到底信哪个？其实雷军讲的是互联网行业；傅盛讲的是小企业逆袭，他正在做投资；彼得德鲁克用管理在讲哲学；吴伯凡老师在讲中西方文化；马云老师在对大众励志；吴晓波其实是用管理谈财经，更重要的是，他们讲话的场合，时间点和对象你一无所知。如果一个人没有搜索能力，他不会知道背景；没有思考能力，不会知道为什么，这样单纯知道一句话，比不知道更糟糕。常年刷微信的人的大脑把前面两个结论放一块，结果很清晰，时间空间碎片化确实能够提高学习的效率（其实也干不过电脑），而信息碎片化和知识结构碎片化带来的，则是学习效率的倒退和焦虑之源，因为他毁掉你的主动搜索能力和主动链接的能力，也就是深度思考的能力，这就是碎片化的陷阱，极大的提高了并没有什么用的信息，而降低了最重要的独立思考的能力。深度思考是件难事，也是件需要时间和空间的事，它远远比迅速点开另一个同样标题很好玩、内容很逗比的标题的文章难得多也长得多，但这个时候，90%的人会选择点开下一个话题，你的浅薄之路也从此开始。这也形成一个上瘾机制，瞬间点开新话题能让你获得“哇我懂了”的廉价快感，但看的信息越多，就见到越多牛人的思想高度，你却无法越无法深度思考。为了抵御这种焦虑，你只好继续打开更多窗口，见证更多顶峰，然后更多焦虑。饮鸩止渴，一直到瘫痪。“我看了本书特好的书！”“是吗是吗说什么的给我讲讲？”“恩……特别好！特别牛！……我讲不出来，给个链接你自己看吧。”是不是这样？所以大部分的人学习，起初是为了解决问题，结果变成了逃避问题。他们越学越焦虑。什么是靠谱的学习方式？观察下那些给你喂知识的专家们怎么做的。他们都挺贼的，专注于一个小领域，以热点为关键词，搜索他们自己专业领域的内容；然后通过新的知识结构表达出来。他们一方面无限度的降低了知识的门槛，其实反而被拉高的是你和他之间的距离。知识创富时代，内容创业时代——无论你怎么说这个领域的弄潮儿，靠的都是这三个能力：在某个专业领域的专注力；与热点、痛点和经典结合的搜索力；以及重新架构的链接能力。  他们知道即使你拿回来一百万个知识的砂砾，也只是沙漠，人们爱看的，是沙子集合成的金字塔，有组织的知识才是核心竞争力。有高度的知识，才有知识压强。在你不断的在沙漠闲逛，他们自己的金字塔盖了起来。怎么办呢？下面是3个把抵御碎片化，让知识“零存整取”的方式：1、学习的起点不是焦虑，而是问题李小龙当年刚回香港，在《欢乐今宵》上节目，节目组请来了一名太极拳拳师，想考验他能不能推到对方。拳师也摆好架子等他来推，结果李小龙一拳打在对方脸上。（此处有人准备直接拉到下面准备开骂，这就是碎片化太厉害，完全不看上下文），李小龙想表达的是，在真实的实战中，没有人会等你摆好架势，只冲着你规定的地方打过来。学习也是一样。在真实生活中，环境和知识都变化太多——你不可能像学校里一样，系统的学好学完一门知识，然后坐在教室等着不超过知识点的考试。大部分时间，生活会先给你一个考试，然后你根据问题，自己找出关键词，开始学习。所以，学习的起点不是某人在朋友圈晒的一本书、推荐的一个微信文、或者这个行业的一个经典教材引发你的焦虑，而应该是你真实遇到的一个问题：      通过不断的思考和对话，一直到能清晰的提出一个明确具体的问题，这时候，已经解决了一半        把问题拆分出关键字，然后开始搜索认知资源        找到你要到资源  2、扩充学习资源——人事网书找学习资源的能力，就是搜索能力。大部分人找资源，第一反应是上网，或买本书。这很容易陷入困境，因为网络是个无底洞，这里翻翻那里看看，一不小心，2天都出不来。要把书里面的内容消化用完至少2周，前提还是你选对了书。信息爆炸时代，最重要的不是增加信息，而是筛选和删除信息。所以其实最好的方式是：      从有经验的人开始，根据你提出的问题，给你清晰的建议、方向和边界        找到行业对标，看看人家是怎么做的        进一步用网络搜索资料和书的总结和评论，最后才是系统的看书  3、721法则：留出足够多的时间练习、思考和讨论行动学习理论认为，人要掌握一门技能，需要有10%的时间学习知识和信息，70%的时间练习和践行，还有20%的时间与人沟通和讨论。这个原则叫做721原则。碎片化学习对于10%的信息接收非常有用，而剩下独处练习的70%和讨论的20%，则需要留出大量时间来系统学习——碎片化学习永远只是系统化学习的辅助。你需要留出足够多整块时间学习。如果能看到这里，顺便说一句——我每周只写一篇不那么好读的干货文，一方面因为我懒，另一方面也因为我并不认为天天刷文能对人有所帮助，每周三晚上，如果能重新思考一个观点，做一点行动和思辨，帮助远远更大。4、输出倒逼输入如何能保证让自己思考有体系？我看过、试过很多方法，最后最有效的只有一个，就是用输出倒逼输入。你可以写文章、讲课、做PPT、做读书笔记、导图……只有一个要求，你的输出有结构。你要先搭好图纸，设计出一个承重结构，然后铺钢筋，最后才放水泥和沙子。先建立一个结构，你的知识和信息量会自动吸附在结构之上。时间一长，你会成为一个能根据结构链接知识的人。很多人会说，我不会写该怎么办？研究新建构主义的王竹立老师有一个观点，把知识零存整取：第一步，叫做积件式写作，就是用ctrlC加ctrlV的方法，先拼出一篇符合逻辑的文字。第二步，进入个性化改写阶段，在第一步的基础上，你可以根据自己的个性化，写出自己的案例，自己的风格，自己的侧重点——现在网络上大部分的写作和讲课都是此类。第三步，创造性重构，在持续的前两步积累下，创造出全新的思路和模型。大部分人的问题，都是看了第二第三步的文章，下结论说自己完全不适合写作，然后放弃。其实每个人都应该动笔从第一步做起，写作不是为了传播，至少为了思考和学习。希望你建立一座自己的金字塔。"
  },
  
  {
    "title": "MyBatis如何传入多个参数",
    "url": "/posts/mybatis-chuanru-duoge-canshu/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2020-11-17 13:47:00 +0800",
    





    
    "snippet": "单个参数javapublic List&lt;Test&gt; getTestList(String id);xml&lt;select id=\"getTestList\" parameterType=\"java.lang.String\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{id}&lt;/se...",
    "content": "单个参数javapublic List&lt;Test&gt; getTestList(String id);xml&lt;select id=\"getTestList\" parameterType=\"java.lang.String\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{id}&lt;/select&gt;多个参数使用索引javapublic List&lt;Test&gt; getTestList(String id, String name);xml&lt;select id=\"getTestList\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{0} and t.name=#{1} &lt;/select&gt;使用Map封装javapublic List&lt;Test&gt; getTestList(HashMap map);xml&lt;select id=\"getTestList\" parameterType=\"hashmap\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{id} and t.name=#{name}    &lt;!-- #{}中的变量名要和map中的key对应 --&gt;&lt;/select&gt;使用注解javapublic List&lt;Test&gt; getTestList(@Param(\"id\") int id, @Param(\"name\") int name);xml&lt;select id=\"getTestList\" resultMap=\"com.test.Test\"&gt;   select t.* from test t where t.id=#{id} and t.name=#{name}&lt;/select&gt;"
  },
  
  {
    "title": "月入10万，难吗？",
    "url": "/posts/20201117/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2020-11-17 13:47:00 +0800",
    





    
    "snippet": "前面说过：赚钱，就是你付出一定的成本，换来一定的回报。归根到底，大家都是出来卖的，无非通过四种方式：  卖信息（中介）  卖钱（投资）  卖他人的注意力（直播）  卖自己的时间（服务）1、卖自己的时间大多数人都靠处在卖自己的时间赚钱这个阶段。没本金、没人脉，只有时间，就只能靠时间来赚钱。也许你学了很多的专业知识，到头来加班加到死，也不过每个月就几千一万的。由于处在这个状态的人太多，竞争太过于...",
    "content": "前面说过：赚钱，就是你付出一定的成本，换来一定的回报。归根到底，大家都是出来卖的，无非通过四种方式：  卖信息（中介）  卖钱（投资）  卖他人的注意力（直播）  卖自己的时间（服务）1、卖自己的时间大多数人都靠处在卖自己的时间赚钱这个阶段。没本金、没人脉，只有时间，就只能靠时间来赚钱。也许你学了很多的专业知识，到头来加班加到死，也不过每个月就几千一万的。由于处在这个状态的人太多，竞争太过于激烈，以至于在面对企业时几乎没什么议价能力，只能任人宰割。少部分聪明一点的人通过学习进修升职的方式来增加自己的劳动效率，增加自己的时间单价，能多赚一点。大部分的人就只能靠加班来增加收入。那些凌晨就出来摆摊的商贩和加班到天亮的职场精英也并没有什么质的区别，收入都和劳动时长挂钩。人一天只有24个小时，意味着靠卖时间赚钱，是有产能上限的。这就是为什么卖时间赚不了大钱的关键。有个笑话是这么说的：王思聪他爸爸给了他5亿，他赚到40亿，翻了8倍！我爸给了我5块，我买了双手套去工地，一天200块，翻了40倍！我们来换算一下，王思聪可能是一年才赚到了40亿，翻了8倍，而你一年搬砖能7万3，足足翻了14600倍。然而这有什么意义呢？王思聪轻轻松松赚了35亿，而你累死累活不过才赚了7万多，零头的零头都不到。而且给王思聪10亿，可能他一年就能赚到80亿，还不需要比原来多付出多少。而给你10块，让你挣14万，大概就得累死在工地上了。想要跳出卖时间的泥潭，关键的关键，是降低劳动边际成本，也就是你不需要付出双倍的工作量，却能获得双倍或者更多的收益。通过卖钱的方式赚钱，就是一种方法。2、卖钱P2P、基金股票、房租、利息，都算是靠钱来赚钱。普通人见过的升值最快的投资应该就算房产了，那收益率可是连P2P都望尘莫及。上个月单价还是1万2，这个月就1万4了，月收益率16.7%，折合成年化，足足有200%！对普通人而言，在这个时代，个人财富增长的主要载体就只有房产增值（当然还有房屋拆迁）。普通白领辛辛苦苦攒了好几年的收入瞬间前功尽弃，赚的再多也追不上资产增值的速度。现在只有极个别的行业(如互联网)，其劳动回报率的增速才有可能高于资本回报率的增速，这其实也可以作为判断一个行业是否是朝阳行业的标尺。香港人把买房叫“上车”，把工薪阶层购置的第一套楼盘叫“上车盘”，其实特别形象——想象一群人跟着汽车跑，只要你能跳上这辆车，你就是在车里坐着躺着，也比外面那些追着跑的人要移动的快。这，就是是靠钱赚钱的魔力。还有一个行业不如房产赚钱这么轻松，但来钱速度也很快，现在也是处在风口，那就是直播。3、卖他人的注意力很多人小时候可能都做过这样的白日梦：“全中国只要每个人给我一块钱我就是亿万富翁了。”现在可能没那么玄乎，但几十万人，平均每个人给你10块钱，你也有几百万了。注意力经济能够达到的规模其实很好计算：假设一个人一天24小时，除了工作8小时睡觉8小时外，还剩8小时，扣掉吃饭逛街，还剩下4小时的纯闲暇时间，那么注意力经济，就是在抢这剩下的4个小时。一个人愿意为闲暇时间支付的开销是固定的，通过简单的计算就能得出平均每分钟的注意力停留时间值多少钱，再乘以关注数，papi酱之类的网络红人就可以开始定价叫售了。 “得屌丝者得天下”，在卖注意力这个行当体现的淋漓尽致，一台电脑一根网线，一年几百万上千万的钱，几乎无本万利，玩的就是群聚效应和屌丝经济。这些新经济的现状有时会让许多传统的，循规蹈矩好好读书上班的人心里不平衡。 就比如说网络直播，一个脸蛋还不错的漂亮姑娘月入十万不是问题，凭的是什么？男屌丝够多，男屌丝手机有支付功能，满足这两点就够了。第一个条件以前一直有，第二个条件最近几年才达成，所以对于这些姑娘来说，尽管没有文凭，甚至也没有进入职场的能力，这个以前自己根本不敢想也想不到的神奇的时代就这样来到了。靠钱赚钱，万一投资失败还可能有一定的财产损失，而靠卖他人注意力赚钱，却几乎不会损失什么。最后一种赚钱方式则既不会有什么损失，也不会太累。4、卖信息信息不对称是白手起家最快的捷径，越不对称，越来钱。古代消息迟滞，商旅靠A地买，B地卖的差价就能赚取巨额财富，这是因为“什么东西在哪里稀缺”的信息是差价的关键，一旦掌握，就站到了价值链的上游。现代有一个常见的例子：房产中介。在很多人心目中那些站在街头，穿着连接西装的房产中介。几乎和“洗剪吹们”是一个档次。但在这些年房价不断上涨的大环境里，北上广深随便一套房子都四五百万，市中心更是千万起跳，中介费即使按1%算也有十多万万。一年成交个几套，就比不少白领挣得多了。要知道2016年前七个月，上海仅二手房就成交了22.8万套。 与此对比，一个新三板公司上板钱的法律审核，律师事务所收费也不过就15万，律师收了钱还要承担法律意见书的责任。而房产中介根本不用负什责任，既不要什么文凭，也不用做太多的事情，甚至现在有很多人是直接上门找中介看房子，连嘴皮子的功夫都省了，十几万中介费就轻松入袋。 当一个人掌握了足够多的信息，撮合行业间的交易，合同谈成后，可以获得不菲的收入，即使谈不成，也不会有什么损失。足够分量的合作只要促成一笔，一年基本就能歇着了。对大多数人而言，只有努力从底层打工干起，做到中高层，掌握大量信息资源后，从做业务切换到做信息掮客，靠撮合行业内的交易来赚钱。或掌握一定的信息后创业，垄断了信息交换节点的人，往往在体系中拥有最大的议价权，什么都不用自己干，光靠指定游戏规则就能赚钱。最后以一个例子收尾吧。一个创业团队10个人，2015年项目分成1000万，头目一个人拿走800万，剩下9个人分200万。活都是手下干的，自己轻轻松松。手下那些人因为处在信息链的下游，所以汤是有的，肉是没有的。"
  },
  
  {
    "title": "访问http://localhost:8080不能显示Tomcat页面",
    "url": "/posts/buneng-xianshi-tomcat-yemian/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-11-16 13:47:00 +0800",
    





    
    "snippet": "排查  确认Tomcat正常安装  确认环境变量配置无误  确认地址无误：http://localhost:8080/  确认这些都是无误的情况下，还是不能访问，就要进一下Tomcat路径下的webapps文件夹下查看是否有ROOT文件夹，这个是Tomcat默认的web项目原因部署项目出错的话，把webapps目录下文件夹清空了，重新部署，这样就附带的把ROOT文件夹清理掉了，所以就显示不了...",
    "content": "排查  确认Tomcat正常安装  确认环境变量配置无误  确认地址无误：http://localhost:8080/  确认这些都是无误的情况下，还是不能访问，就要进一下Tomcat路径下的webapps文件夹下查看是否有ROOT文件夹，这个是Tomcat默认的web项目原因部署项目出错的话，把webapps目录下文件夹清空了，重新部署，这样就附带的把ROOT文件夹清理掉了，所以就显示不了解决方法重新安装一下，或者找到ROOT文件夹复制过来就能正常访问了"
  },
  
  {
    "title": "SVN客户端如何修改登陆账号",
    "url": "/posts/svn-kehuduan-xiugai-denglu-zhanghao/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2020-11-16 13:47:00 +0800",
    





    
    "snippet": "首先找到一个空白地方.右键单击,找到如图的菜单(例如桌面)进入svn的设置界面出现清除框.选择你要清除的.确定即可. 下次你再用svn提交代码的时候.就会提示你输入用户名和密码了",
    "content": "首先找到一个空白地方.右键单击,找到如图的菜单(例如桌面)进入svn的设置界面出现清除框.选择你要清除的.确定即可. 下次你再用svn提交代码的时候.就会提示你输入用户名和密码了"
  },
  
  {
    "title": "SVN插件如何修改登录账号",
    "url": "/posts/svn-chajian-xiugai-denglu-zhanghao/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2020-11-16 13:47:00 +0800",
    





    
    "snippet": "打开Window菜单栏中的Perference，打开Eclipse配置，搜索框输入svn，然后点击SVN，找到下方SVN接口，查看下svn是什么类型的接口，如果是JavaHL打开我的电脑\\系统安装盘\\用户 打开之后，在搜索栏里面输入auth 找到这个文件夹之后打开，然后删除这个文件夹里面的文件，重启Eclipse，使用svn的时候就会要求重新输入账号密码了Eclipse的svn类型一般为Ja...",
    "content": "打开Window菜单栏中的Perference，打开Eclipse配置，搜索框输入svn，然后点击SVN，找到下方SVN接口，查看下svn是什么类型的接口，如果是JavaHL打开我的电脑\\系统安装盘\\用户 打开之后，在搜索栏里面输入auth 找到这个文件夹之后打开，然后删除这个文件夹里面的文件，重启Eclipse，使用svn的时候就会要求重新输入账号密码了Eclipse的svn类型一般为JavaHL类型，路径在C:\\Users\\Administrator\\AppData\\Roaming\\Subversion\\auth，要是实在找不到可以全局搜索在C盘如果svn的接口类型是SVNKit，则删除eclipse\\configuration\\org.eclipse.core.runtime下的文件"
  },
  
  {
    "title": "Oracle 使用SQL语句对索引的操作",
    "url": "/posts/oracle-chuangjian-suoyin/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-11-15 13:47:00 +0800",
    





    
    "snippet": "创建索引-- 创建索引create index index_name on table_name(column_name) ;-- 创建联合索引create index index_name on table_name(column_name1, column_name2) ;使用索引-- 使用索引select * from table_name where column_name = 1;",
    "content": "创建索引-- 创建索引create index index_name on table_name(column_name) ;-- 创建联合索引create index index_name on table_name(column_name1, column_name2) ;使用索引-- 使用索引select * from table_name where column_name = 1;"
  },
  
  {
    "title": "使用Ajax方式实现form表单的提交",
    "url": "/posts/ajax-shixian-form-biaodan-tijiao/",
    "categories": "Knowledge, Ajax",
    "tags": "Ajax",
    "date": "2020-11-15 13:47:00 +0800",
    





    
    "snippet": "在使用form表单的时候,一旦点击提交触发submit事件，一般会使得页面跳转，页面间的跳转等行为的控制权往往在后端，后端会控制页面的跳转及数据传递，但是在某些时候不希望页面跳转，或者说想要将控制权放在前端，通过js来操作页面的跳转或者数据变化。一般这种异步的操作，我们都会想到Ajax方式，因此在实现了功能后就整理了这篇文章，通过Ajax方式实现form表单的提交并进行后续的异步操作。常见的...",
    "content": "在使用form表单的时候,一旦点击提交触发submit事件，一般会使得页面跳转，页面间的跳转等行为的控制权往往在后端，后端会控制页面的跳转及数据传递，但是在某些时候不希望页面跳转，或者说想要将控制权放在前端，通过js来操作页面的跳转或者数据变化。一般这种异步的操作，我们都会想到Ajax方式，因此在实现了功能后就整理了这篇文章，通过Ajax方式实现form表单的提交并进行后续的异步操作。常见的form表单提交方式&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;login test&lt;/title&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"expires\" content=\"0\"&gt;        &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;        &lt;meta http-equiv=\"description\" content=\"login test\"&gt;       &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"form-div\"&gt;            &lt;form id=\"form1\" action=\"/users/login\" method=\"post\"&gt;                &lt;p&gt;用户名：&lt;input name=\"userName\" type=\"text\" id=\"txtUserName\" tabindex=\"1\" size=\"15\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;密　码：&lt;input name=\"password\" type=\"password\" id=\"TextBox2\" tabindex=\"2\" size=\"16\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&amp;nbsp&lt;input type=\"reset\" value=\"重置\"&gt;&lt;/p&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;Ajax实现form提交方式&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;login test&lt;/title&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"expires\" content=\"0\"&gt;        &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;        &lt;meta http-equiv=\"description\" content=\"ajax方式\"&gt;        &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt;        &lt;script type=\"text/javascript\"&gt;            function login() {                $.ajax({                    //几个参数需要注意一下                    type: \"POST\",//方法类型                    dataType: \"json\",//预期服务器返回的数据类型                    url: \"/users/login\" ,//url                    data: $('#form1').serialize(),                    success: function (result) {                        console.log(result);//打印服务端返回的数据(调试用)                        if (result.resultCode == 200) {                            alert(\"SUCCESS\");                        };                    },                    error : function() {                        alert(\"异常！\");                    }                });            }        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"form-div\"&gt;            &lt;form id=\"form1\" onsubmit=\"return false\" action=\"##\" method=\"post\"&gt;                &lt;p&gt;用户名：&lt;input name=\"userName\" type=\"text\" id=\"txtUserName\" tabindex=\"1\" size=\"15\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;密　码：&lt;input name=\"password\" type=\"password\" id=\"TextBox2\" tabindex=\"2\" size=\"16\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;&lt;input type=\"button\" value=\"登录\" onclick=\"login()\"&gt;&amp;nbsp;&lt;input type=\"reset\" value=\"重置\"&gt;&lt;/p&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "Oracle 如何查询CLOB字段的值",
    "url": "/posts/chaxun-clob-ziduan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-11-12 13:47:00 +0800",
    





    
    "snippet": "select dbms_lob.substr(column) from table_name;select to_char(column) from table_name;错误发生场景在对视图中的CLOB进行TO_CHAR处理后，在CLOB字段录入字段信息小于4000字符时，查询正常，但当录入字符大于4000字符时，就会发生错误。错误提示：ORA-22835:缓冲区对于CLOB到CHAR转换...",
    "content": "select dbms_lob.substr(column) from table_name;select to_char(column) from table_name;错误发生场景在对视图中的CLOB进行TO_CHAR处理后，在CLOB字段录入字段信息小于4000字符时，查询正常，但当录入字符大于4000字符时，就会发生错误。错误提示：ORA-22835:缓冲区对于CLOB到CHAR转换或BLOB到RAWZ转换而言太小。原因分析在对CLOB进行的TO_CHAR处理，可以理解为将CLOB中存储的信息转换成VARCHAR2，然后再进行展现，对于VARCHAR2来言，最多存储4000个字符，当超出4000字符时，就报错了。错误的大致意思就是超出了VARCHAR2的缓冲大小。解决方案对CLOB字段进行截取，使其在TO_CHAR之前获取的数据小于4000字符，这样在进行TO_CHAR时就不会报错了。截取SQLSUBSTR(column, 1, 4000);需要注意一点，如果是大字段中存在汉字，则需要将汉字所占字节数考虑进入，如一个汉字占2个字节，实际截取字节数为2000。SUBSTR(column, 1, 2000);对CLOB大字段处理的完整SQL如下：TO_CHAR( SUBSTR(column, 1, 2000)) as column;查询SQLselect dbms_lob.substr(column, 4000) from table_name;select TO_CHAR(SUBSTR(column, 1, 2000)) from table_name;  参考：Oracle查询显示CLOB的内容"
  },
  
  {
    "title": "NPM命令",
    "url": "/posts/npm-mingling/",
    "categories": "Knowledge, NodeJS",
    "tags": "NodeJS",
    "date": "2020-11-12 13:47:00 +0800",
    





    
    "snippet": "NPM是随同NodeJS一起安装的包管理工具,能解决NodeJS代码部署上的很多问题，常用的命令有：  清除缓存    npm cache clean --force        显示配置列表    npm config list        淘宝镜像的安装    npm config set registry https://registry.npm.taobao.org --glob...",
    "content": "NPM是随同NodeJS一起安装的包管理工具,能解决NodeJS代码部署上的很多问题，常用的命令有：  清除缓存    npm cache clean --force        显示配置列表    npm config list        淘宝镜像的安装    npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global         淘宝镜像的卸载    npm config set disturl https://npm.taobao.org/dist      "
  },
  
  {
    "title": "Windows非服务模式下如何启动和关闭MySQL数据库",
    "url": "/posts/feifuwu-moshi-xia-qidong-he-guanbi-mysql/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "启动mysqld --standalone关闭mysqladmin -uroot -proot shutdown",
    "content": "启动mysqld --standalone关闭mysqladmin -uroot -proot shutdown"
  },
  
  {
    "title": "< c:forEach>遍历list数组时怎么取出元素下标",
    "url": "/posts/qu-shuzu-xiabiao/",
    "categories": "Knowledge, JSTL",
    "tags": "JSTL",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "&lt;c:forEach var=\"o\" items=\"${orders }\" varStatus=\"st\"&gt;当前迭代的元素：${o.ord_code} 当前迭代的元素：${st.current.ord_code}当前迭代的索引：${st.index} 迭代计数：${st.count}是否是第一次迭代：${st.first} 是否是最后次迭代：${st.last} 示例&lt;c:f...",
    "content": "&lt;c:forEach var=\"o\" items=\"${orders }\" varStatus=\"st\"&gt;当前迭代的元素：${o.ord_code} 当前迭代的元素：${st.current.ord_code}当前迭代的索引：${st.index} 迭代计数：${st.count}是否是第一次迭代：${st.first} 是否是最后次迭代：${st.last} 示例&lt;c:forEach var=\"cost\" items=\"${otherCost}\" varStatus=\"st\"&gt;     &lt;c:if test=\"${!st.last}\"&gt;        &lt;td&gt;${cost}&lt;/td&gt;    &lt;/c:if&gt;    &lt;c:if test=\"${st.last}\"&gt;        &lt;td style=\"border-right: 0px;\"&gt;${cost}&lt;/td&gt;    &lt;/c:if&gt;&lt;/c:forEach&gt; "
  },
  
  {
    "title": "< c:forEach>如何终止循环",
    "url": "/posts/jstl-de-tiaojian-panduan/",
    "categories": "Knowledge, JSTL",
    "tags": "JSTL",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "&lt;c:set var=\"exitId\" value=\"0\"/&gt;&lt;c:forEach items=\"${opinions }\" var=\"map\" varStatus=\"status\"&gt;    &lt;c:if test=\"${exitId eq '0'}\"&gt;&lt;!--for循环里面的操作都写在c:if中--&gt;        &lt;td&gt;在循环&...",
    "content": "&lt;c:set var=\"exitId\" value=\"0\"/&gt;&lt;c:forEach items=\"${opinions }\" var=\"map\" varStatus=\"status\"&gt;    &lt;c:if test=\"${exitId eq '0'}\"&gt;&lt;!--for循环里面的操作都写在c:if中--&gt;        &lt;td&gt;在循环&lt;/td&gt;        &lt;!--如果下标等于5则不会循环出td--&gt;        &lt;c:if test=\"${status.index eq '5'}\"&gt;            &lt;c:set var=\"exitId\" value=\"1\"/&gt;        &lt;/c:if&gt;    &lt;/c:if&gt;&lt;/c:forEach&gt;"
  },
  
  {
    "title": "JQuery的正则匹配",
    "url": "/posts/jquery-de-zhengze-pipei/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "[属性名称] 匹配包含给定属性的元素[att=value] 匹配包含给定属性的元素 (大小写区分)[att*=value] 模糊匹配[att!=value] 不能是这个值[att$=value] 结尾是这个值[att^=value] 开头是这个值[att1][att2][att3]... 匹配多个属性条件中的一个例：JQuery获取class=”abc”的input值$('input[cla...",
    "content": "[属性名称] 匹配包含给定属性的元素[att=value] 匹配包含给定属性的元素 (大小写区分)[att*=value] 模糊匹配[att!=value] 不能是这个值[att$=value] 结尾是这个值[att^=value] 开头是这个值[att1][att2][att3]... 匹配多个属性条件中的一个例：JQuery获取class=”abc”的input值$('input[class=\"abc\"]').val();"
  },
  
  {
    "title": "Ajax案例",
    "url": "/posts/ajax-anli/",
    "categories": "Knowledge, Ajax",
    "tags": "Ajax",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "function queryPasswordById(pass_id) {    var params = {        pass_id : pass_id    };    var param = JSON.stringify(params);    // 加密    // var requestJson1 = btoa(encodeURIComponent(param));    $...",
    "content": "function queryPasswordById(pass_id) {    var params = {        pass_id : pass_id    };    var param = JSON.stringify(params);    // 加密    // var requestJson1 = btoa(encodeURIComponent(param));    $.ajax({        url : \"password/queryPasswordById\",        type : \"post\",        dataType : \"json\",         data : {            requestJson : param        },        async : false,        success : function(data) {            // dataType已为json格式，转换报错：missing ] after element list            // var res = eval(\"(\" + data + \")\");            window.location.href = data; // 跳转，data为后台返回的ModelAndView        }    });}$.ajax ({    type : \"get\",    url : \"checkFile.do?attachId=\" + attachId,    async:false,    success: function(data) {        flag = data;    }});"
  },
  
  {
    "title": "Windows7刷新环境变量的方法",
    "url": "/posts/win7-shuaxin-huanjingbianliang/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中增加或修改环境变量后，需重启系统才能使之生效。有没有什么方法可让它即时生效呢？ 下面介绍一种方法：  　　  以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：set PATH=C:，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，可以发现“我的电脑”-&gt;“属性”-&gt...",
    "content": "在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中增加或修改环境变量后，需重启系统才能使之生效。有没有什么方法可让它即时生效呢？ 下面介绍一种方法：  　　  以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：set PATH=C:，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的PATH值已经生效。  　　不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的。"
  },
  
  {
    "title": "Windows10安装陷入无限循环",
    "url": "/posts/win10-anzhuang-xianru-wuxian-xunhuan/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "故障描述当你安装Windows10到了系统初始化设置界面时，电脑会一遍又一遍地让你进行相同的设置解决方案1、按Ctrl + Shift + F3跳过OOBE（Out-of-box experience）直接进入系统2、进入系统的过程中，会弹出一个错误窗口，上面写着：应用程序无法正常启动0xc00001423、点击确定，之后应该会出现一个系统准备工具，不用管它4、进去之后你就会发现，这是一个残...",
    "content": "故障描述当你安装Windows10到了系统初始化设置界面时，电脑会一遍又一遍地让你进行相同的设置解决方案1、按Ctrl + Shift + F3跳过OOBE（Out-of-box experience）直接进入系统2、进入系统的过程中，会弹出一个错误窗口，上面写着：应用程序无法正常启动0xc00001423、点击确定，之后应该会出现一个系统准备工具，不用管它4、进去之后你就会发现，这是一个残废的系统5、打开“命令提示符”窗口输入字符串命令sfc/scannow回车，之后就是耐心等待命令程序对每个系统文件搜索扫描，然后修复6、上面这些完成后，重启电脑就可以了名称解释：OOBE开箱体验（OOBE）是在安装完Windows后就会进行的一个步骤，在这个步骤，用户需要对Windows进行一些基本设置。"
  },
  
  {
    "title": "Outlook邮箱启动时提示找不到Outlook.pst文件",
    "url": "/posts/outlook-youxiang-qidong-baocun/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "什么是pst文件pst文件是outlook的数据文件，包括邮箱账号的所有信息，比如：收到的邮件，发出的邮件，联系人信息等等。pst文件找不到的主要原因是pst文件被删除，文件路径被修改，或者被移动到其他地方。解决方法1、打开“命令提示符”窗口，使用cd命令切换到“Outlook.exe”所在安装目录2、输入命令outlook /importprf ..prf初始化Outlook数据文件3、初...",
    "content": "什么是pst文件pst文件是outlook的数据文件，包括邮箱账号的所有信息，比如：收到的邮件，发出的邮件，联系人信息等等。pst文件找不到的主要原因是pst文件被删除，文件路径被修改，或者被移动到其他地方。解决方法1、打开“命令提示符”窗口，使用cd命令切换到“Outlook.exe”所在安装目录2、输入命令outlook /importprf ..prf初始化Outlook数据文件3、初始化完成后即可进入outlook邮箱"
  },
  
  {
    "title": "Google Play Store显示“从服务器检索信息时出错，DF-DFERH-01”",
    "url": "/posts/google-play-store-DF-DFERH-01/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "原因是软件要请求的services.googleapis.cn域名被解析到了国内。解决思路就是将该域名解析到国外即可，若是采用代理软件，设置为全局代理。",
    "content": "原因是软件要请求的services.googleapis.cn域名被解析到了国内。解决思路就是将该域名解析到国外即可，若是采用代理软件，设置为全局代理。"
  },
  
  {
    "title": "Eclipse常用快捷键",
    "url": "/posts/eclipse-changyong-kuaijiejian/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "Ctrl + Alt + H       查看一个类的方法被哪些其他的类调用Ctrl + Shift + l     快捷键提示  Ctrl + Shift + R     搜索 Ctrl + 2 + l         自动生成变量名声明(按方法返回值为本地变量赋值），注：Ctrl和2同时按完以后释放，再按l",
    "content": "Ctrl + Alt + H       查看一个类的方法被哪些其他的类调用Ctrl + Shift + l     快捷键提示  Ctrl + Shift + R     搜索 Ctrl + 2 + l         自动生成变量名声明(按方法返回值为本地变量赋值），注：Ctrl和2同时按完以后释放，再按l"
  },
  
  {
    "title": "透过上层div点击下层的元素",
    "url": "/posts/touguo-shangceng-div-dianji-xiaceng/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "pointer-events: none;",
    "content": "pointer-events: none;"
  },
  
  {
    "title": "鼠标指针变成禁止点击的样式",
    "url": "/posts/shubiao-zhizhen-biancheng-jinzhi-dianji/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "/* 是一个红色的圈加一个斜杠，表示禁止的意思 */cursor:no-drop cursor:not-allowed ",
    "content": "/* 是一个红色的圈加一个斜杠，表示禁止的意思 */cursor:no-drop cursor:not-allowed "
  },
  
  {
    "title": "Bootstrap悬浮窗口(popover)",
    "url": "/posts/bootstrap-xuanfuchuang/",
    "categories": "Knowledge, Bootstrap",
    "tags": "Bootstrap",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;悬浮窗口&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /&gt;    &lt;!--JavaScript...",
    "content": "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;悬浮窗口&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /&gt;    &lt;!--JavaScript插件都是依赖jQuery库--&gt;    &lt;script type=\"text/javascript\" src=\"js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\" src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=\"#\" id=\"abc\" class=\"btn btn-lg btn-danger\" data-toggle=\"popover\"&gt;xxxxxx&lt;/a&gt;    &lt;script&gt;        $(function () {            $(\"[data-toggle='popover']\").each(function () {                var element = $(this);                element.popover({                    trigger: 'manual',                    html: true,                    title: 'kkkk',                    placement: 'bottom',                    content: function () {                        return content();                    }                }).on(\"mouseenter\", function () {                    $(this).popover(\"show\");                }).on(\"mouseleave\", function () {                    $(_this).popover(\"hide\")                });            });        });        //模拟动态加载内容(真实情况可能会跟后台进行ajax交互)          function content() {            var data = $(\"&lt;form&gt;&lt;ul&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;粉丝数:&lt;/font&gt;7389223&lt;/li&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;关注:&lt;/font&gt;265&lt;/li&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;微博:&lt;/font&gt;645&lt;/li&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;所在地:&lt;/font&gt;台湾&lt;/li&gt;\"                + \"&lt;input id='btn' type='button' value='关注' onclick='test()'/&gt;&lt;/form&gt;\");            return data;        }        //模拟悬浮框里面的按钮点击操作          function test() {            alert('关注成功');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "对String进行强制转码",
    "url": "/posts/dui-string-jinxing-qiangzhi-zhuanma/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-11-10 11:47:00 +0800",
    





    
    "snippet": "String test = new String(object.getTest().getBytes(\"ISO-8859-1\"), \"UTF-8\");",
    "content": "String test = new String(object.getTest().getBytes(\"ISO-8859-1\"), \"UTF-8\");"
  },
  
  {
    "title": "SQl格式化工具",
    "url": "/posts/sql-geshihua-gongju/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "    SQL-Format                                                                                                                                                                                       ...",
    "content": "    SQL-Format                                                                                                                                                                                                                                                                                                                                                                                                 Format&nbsp;&nbsp;\t\t\t\t\t\t\t\t\t\tCopy&nbsp;&nbsp;\t\t\t\t\t\t\t\t\t\tClear                                                                                                                                                                                                                                                                                                                                                                                                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                                                                                                            "
  },
  
  {
    "title": "Java线程的生命周期",
    "url": "/posts/xiancheng-de-shengming-zhouqi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "Java线程的生命周期",
    "content": "Java线程的生命周期"
  },
  
  {
    "title": "获取客户端的IP地址",
    "url": "/posts/huoqu-kehuduan-ip/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "public String getIpAddr(HttpServletRequest request) {    String ip = \"\";    try {        ip = request.getHeader(\"x-forwarded-for\");        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgno...",
    "content": "public String getIpAddr(HttpServletRequest request) {    String ip = \"\";    try {        ip = request.getHeader(\"x-forwarded-for\");        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {            ip = request.getHeader(\"Proxy-Client-IP\");        }        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {            ip = request.getHeader(\"WL-Proxy-Client-IP\");        }        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {            ip = request.getRemoteAddr();        }    } catch (Exception e) {        e.printStackTrace();        ip = \"\";    }    return ip;}"
  },
  
  {
    "title": "使用gitbook serve命令报错",
    "url": "/posts/gitbook-bao-cuo/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "错误信息在使用gitbook serve启动服务时报错：Error: ENOENT: no such file or directory, stat ‘C:***demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’  原因这一个Bug（Vesion：3.2.3）https://github.com/Gitboo...",
    "content": "错误信息在使用gitbook serve启动服务时报错：Error: ENOENT: no such file or directory, stat ‘C:***demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’  原因这一个Bug（Vesion：3.2.3）https://github.com/GitbookIO/gitbook/issues/1309解决办法用户目录下找到以下文件.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js替换 confirm: true 为 confirm: false"
  },
  
  {
    "title": "GitBook安装",
    "url": "/posts/gitbook-anzhuang/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "1.搭建Nodejs环境前往Node.js官网下载最新版Nodejs windows系统安装包安装成功后再cmd窗体中输入node -v查看是否安装成功2.安装GitBook可视化编写工具  GitBook Editor Windows版  Visual Studio Code下载Markdown All in One插件  Typora3.安装GitBook在任意目录下运行cmd控制台 输...",
    "content": "1.搭建Nodejs环境前往Node.js官网下载最新版Nodejs windows系统安装包安装成功后再cmd窗体中输入node -v查看是否安装成功2.安装GitBook可视化编写工具  GitBook Editor Windows版  Visual Studio Code下载Markdown All in One插件  Typora3.安装GitBook在任意目录下运行cmd控制台 输入:npm install gitbook-cli -g进行安装4.开始使用GitBookrem 初始化gitBookgitbook initrem 下载gitBook插件 gitbook installrem 发布gitBookgitbook serverem 编译gitBookgitbook build"
  },
  
  {
    "title": "界面动效设计",
    "url": "/posts/jiemian_dongxiao_sheji/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "趣味交互动效趣味音量调节动效  by.ALEX BENDER点赞按钮动效  by.Aaron Iker趣味捐赠按钮动画  by.Aaron IkerBUTTON V2  by.Aaron Iker项目管理APP完成动效  by.Leonid Arestov一组可爱的标签栏交互动效  by.Dimest压缩文件动画  by.Aaron IkerAR拍照应用标签栏交互设计  by.Oleg Fr...",
    "content": "趣味交互动效趣味音量调节动效  by.ALEX BENDER点赞按钮动效  by.Aaron Iker趣味捐赠按钮动画  by.Aaron IkerBUTTON V2  by.Aaron Iker项目管理APP完成动效  by.Leonid Arestov一组可爱的标签栏交互动效  by.Dimest压缩文件动画  by.Aaron IkerAR拍照应用标签栏交互设计  by.Oleg Frolov创意举重提交按钮  by.Aaron IkerFILTER UX  by.Yurii家居装修应用动效设计  by.YanBin Tan引导页3D动画  by Minh Pham ✪响应式HTML设计  by.Anton Tkachevwelovedail网站的趣味交互动画  by Dennis Snellenberg智能银行app动效设计  by.Jakub Kośla3D风格引导页设计  by.Ramotion交付执行小动效  by.Saptarshi Prakash3D网页动画设计  by.Barthelemy Chalvet"
  },
  
  {
    "title": "App界面设计欣赏",
    "url": "/posts/app-sheji-xinshang/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "布里萨戈群岛旅游LOGO",
    "url": "/posts/bu-li-sa-ge-qun-dao/",
    "categories": "Design, Logo",
    "tags": "Logo",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "布里萨戈群岛（Isole di Brissago）位于瑞士南部的马焦雷湖，靠近瑞士城镇布里萨戈，是一组由两个岛屿组成的小岛，较大的岛屿（圣潘克拉齐奥）占地25568平方米，较小的岛屿（圣阿波利奈尔）占地8186平方米。其中大岛上有著名的植物园，它由安托瓦内特·圣莱热男爵夫人于1885年创建，园内拥有超过2000多种亚热带植物，具有重要的科学研究价值，吸引了大批专家和植物爱好者前往参观。今年3...",
    "content": "布里萨戈群岛（Isole di Brissago）位于瑞士南部的马焦雷湖，靠近瑞士城镇布里萨戈，是一组由两个岛屿组成的小岛，较大的岛屿（圣潘克拉齐奥）占地25568平方米，较小的岛屿（圣阿波利奈尔）占地8186平方米。其中大岛上有著名的植物园，它由安托瓦内特·圣莱热男爵夫人于1885年创建，园内拥有超过2000多种亚热带植物，具有重要的科学研究价值，吸引了大批专家和植物爱好者前往参观。今年3月份，受到疫情的影响，布里萨戈群岛临时关闭了旅游入口。上周，该岛屿宣布将重新向公众开放。与此同时，布里萨戈群岛还重新设计了旅游LOGO来宣传群岛的旅游文化。由于群岛最显著的特点是由两个小岛组成，所以在LOGO的设计上将两个岛屿抽象化，变为一大一小两个圆点。大的绿色圆点●为圣潘克拉齐奥岛，右下角的小圆点•则代表了圣阿波利奈尔岛。重新开放后，新LOGO也将正式和旅客见面。据悉，在关闭岛屿期间，岛屿的管理机构与设计公司合作完成了新形象的设计，包括员工制服，旅游指导手册，纪念品等周边产品的开发和设计。"
  },
  
  {
    "title": "博客系统 Halo",
    "url": "/posts/halo/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "Halo是一款使用 Spring Boot 框架搭建的现代化的个人开源博客系统。该系统具有完备的 Markdown 编辑器以及文章、页面系统，包含分类/标签/预览图，附件管理，评论系统，主题系统，系统设置等功能。提供的功能halo 博客主站，用来展示我们发布的博客及其他我们编辑的内容。后台管理（halo-admin），用来管理维护我们的博客。评论插件（halo-comment），用来给我们的...",
    "content": "Halo是一款使用 Spring Boot 框架搭建的现代化的个人开源博客系统。该系统具有完备的 Markdown 编辑器以及文章、页面系统，包含分类/标签/预览图，附件管理，评论系统，主题系统，系统设置等功能。提供的功能halo 博客主站，用来展示我们发布的博客及其他我们编辑的内容。后台管理（halo-admin），用来管理维护我们的博客。评论插件（halo-comment），用来给我们的博客添加评论模块。主题库（halo-theme-* ），提供众多博客主题模版。预览链接官网：https://halo.run/Github：https://github.com/halo-dev/halo"
  },
  
  {
    "title": "静态博客写作客户端 Gridea",
    "url": "/posts/gridea/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "当下大多数人可能已经对 Github Pages 不再陌生，他是很多喜欢写文章的人第一次接触的用于免费搭建 Blog 的工具，使用 Github Pages 你能很快速的构建一个简洁却又不失优雅的个人 Blog ，直到现在互联网上还有大量的基于 Github Pages 的个人博客和搭建方法的教程。然而搭建虽然简单，但是管理和上传文章却相对麻烦不少，官方的教程里，你需要经历繁琐的 Git 步...",
    "content": "当下大多数人可能已经对 Github Pages 不再陌生，他是很多喜欢写文章的人第一次接触的用于免费搭建 Blog 的工具，使用 Github Pages 你能很快速的构建一个简洁却又不失优雅的个人 Blog ，直到现在互联网上还有大量的基于 Github Pages 的个人博客和搭建方法的教程。然而搭建虽然简单，但是管理和上传文章却相对麻烦不少，官方的教程里，你需要经历繁琐的 Git 步骤才能发布一篇文章和修改你的个人空间界面。对于那些想更便捷和优雅的操作 Github Pages 写作者来说，我郑重推荐这款工具 Gridea。Gridea提供Mac 、Windows 、Linux 多个版本下载，目前最新版本是v0.9.2。Gridea内置了丰富的主题，可以满足大部分写作者的需求。同时，也提供了主题市场，更多优秀的主题可以选择。Gridea特性  你可以使用最酷的 Markdown 语法，进行快速创作  你可以给文章配上精美的封面图和在文章任意位置插入图片  你可以对文章进行标签分组  你可以自定义菜单，甚至可以创建外部链接菜单  你可以在 或 或 Linux 设备上使用此客户端  你可以使用 或 Coding Pages 向世界展示，未来将支持更多平台  你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统  你可以使用中文简体、中文繁体、英语  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步链接官网：https://gridea.dev/主题：https://gridea.dev/themes/"
  },
  
  {
    "title": "后台管理系统 Dcat Admin",
    "url": "/posts/dcat-admin/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "Dcat Admin是一个基于laravel-admin二次开发而成的后台系统构建工具，只需很少的代码即可快速构建出一个功能完善的高颜值后台系统。内置丰富的后台常用组件，开箱即用，让开发者告别冗杂的HTML代码，对后端开发者非常友好。更新内容Dcat Admin v1.2.0已发布，更新内容如下：功能新增及优化部分  集成editor-md作为内置markdown编辑器，并支持图片上传功能 ...",
    "content": "Dcat Admin是一个基于laravel-admin二次开发而成的后台系统构建工具，只需很少的代码即可快速构建出一个功能完善的高颜值后台系统。内置丰富的后台常用组件，开箱即用，让开发者告别冗杂的HTML代码，对后端开发者非常友好。更新内容Dcat Admin v1.2.0已发布，更新内容如下：功能新增及优化部分  集成editor-md作为内置markdown编辑器，并支持图片上传功能  表格过滤搜索增加panel布局方式  优化数据表格边框模式  工具表单增加buildSuccessScript方法  数据表格表头过滤器重置按钮优化  通过Form::action法设置url时自动拼接路由前缀  按钮样式优化  菜单配色及导航栏样式优化  快速创建功能样式优化  登陆页面优化  进度条样式优化  默认禁用滚动条插件  增加action以及form生成命令对非app目录的支持Bug修复部分  修复数据表格checkbox显示类型不兼容非数组字段值问题  修复登陆页面不兼容Laravel5.5问题"
  },
  
  {
    "title": "密码管理软件 Bitwarden",
    "url": "/posts/bitwarden/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "特性  提供免费和付费选择  适用于团队（企业）和个人  开源  支持自托管  能够作为身份验证器应用（如 Google 身份验证器）  跨平台支持（安卓、iOS、Linux、Windows 和 macOS）  提供浏览器扩展（Firefox,、Chrome、Opera、Edge、Safari）  提供命令行工具  提供网页保管库  能够导入/导出密码  密码生成器  自动填充密码  两步身...",
    "content": "特性  提供免费和付费选择  适用于团队（企业）和个人  开源  支持自托管  能够作为身份验证器应用（如 Google 身份验证器）  跨平台支持（安卓、iOS、Linux、Windows 和 macOS）  提供浏览器扩展（Firefox,、Chrome、Opera、Edge、Safari）  提供命令行工具  提供网页保管库  能够导入/导出密码  密码生成器  自动填充密码  两步身份验证下载地址https://bitwarden.com/"
  },
  
  {
    "title": "去哪儿网机票搜索系统的高并发架构设计",
    "url": "/posts/20201028/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "生成随机id",
    "url": "/posts/shengcheng-suiji-id/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:23:00 +0800",
    





    
    "snippet": "// 需要引入import java.util.UUID包public static String getUUID() {   UUID uuid = UUID.randomUUID();   String str = uuid.toString();   String uuidStr = str.replace(\"-\", \"\");   return uuidStr;}",
    "content": "// 需要引入import java.util.UUID包public static String getUUID() {   UUID uuid = UUID.randomUUID();   String str = uuid.toString();   String uuidStr = str.replace(\"-\", \"\");   return uuidStr;}"
  },
  
  {
    "title": "HTML元素禁用的方法",
    "url": "/posts/html-jinyong-yuansu/",
    "categories": "Knowledge, HTML",
    "tags": "HTML",
    "date": "2020-10-27 13:23:00 +0800",
    





    
    "snippet": "禁用radio，设置为只读，不能选定&lt;input type=\"radio\" name=\"gender\" value=\"1\" disabled/&gt;&lt;span &gt;男&lt;/span&gt;&lt;input type=\"radio\" name=\"gender\" value=\"0\" disabled/&gt;&lt;span &gt;女&lt;/span&gt; 禁用in...",
    "content": "禁用radio，设置为只读，不能选定&lt;input type=\"radio\" name=\"gender\" value=\"1\" disabled/&gt;&lt;span &gt;男&lt;/span&gt;&lt;input type=\"radio\" name=\"gender\" value=\"0\" disabled/&gt;&lt;span &gt;女&lt;/span&gt; 禁用input，设置为只读，不能填写&lt;input name=\"gender\" type=\"text\" value=\"1\" readonly/&gt;禁用select，设置为只读，不能选择&lt;select id=\"test\" name=\"sortId\" disabled&gt;   &lt;option value=\"\"&gt;&lt;/option&gt;   &lt;option value=\"1\"&gt;低&lt;/option&gt;   &lt;option value=\"2\"&gt;中&lt;/option&gt;   &lt;option value=\"3\"&gt;高&lt;/option&gt;&lt;/select&gt;"
  },
  
  {
    "title": "计算相差的月数",
    "url": "/posts/jisuan-xiangcha-de-yueshu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:13:00 +0800",
    





    
    "snippet": "public static int getMonthDiff(Date d1, Date d2) {\tCalendar c1 = Calendar.getInstance();\tCalendar c2 = Calendar.getInstance();\tc1.setTime(d1);\tc2.setTime(d2);\tint year1 = c1.get(Calendar.YEAR);\tint...",
    "content": "public static int getMonthDiff(Date d1, Date d2) {\tCalendar c1 = Calendar.getInstance();\tCalendar c2 = Calendar.getInstance();\tc1.setTime(d1);\tc2.setTime(d2);\tint year1 = c1.get(Calendar.YEAR);\tint year2 = c2.get(Calendar.YEAR);\tint month1 = c1.get(Calendar.MONTH);\tint month2 = c2.get(Calendar.MONTH);\tint day1 = c1.get(Calendar.DAY_OF_MONTH);\tint day2 = c2.get(Calendar.DAY_OF_MONTH);\t// 获取年的差值\tint yearInterval = year1 - year2;\t// 如果 d1的 月-日 小于 d2的 月-日 那么 yearInterval-- 这样就得到了相差的年数\tif (month1 &lt; month2 || month1 == month2 &amp;&amp; day1 &lt; day2) {\t\tyearInterval--;\t}\t// 获取月数差值\tint monthInterval = (month1 + 12) - month2;\tif (day1 &lt; day2) {\t\tmonthInterval--;\t}\tmonthInterval %= 12;\tint monthsDiff = Math.abs(yearInterval * 12 + monthInterval);\treturn monthsDiff;}"
  },
  
  {
    "title": "Java中Array和List的相互转换",
    "url": "/posts/java-zhong-array-he-list-de-zhuanhuan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 11:47:00 +0800",
    





    
    "snippet": "Array转ListString[] array = {\"string1\", \"string2\", \"string3\"};List&lt;String&gt; list = Arrays.asList(array);//Arrays.asList产生一个Arrays内置的类，其中数组用final表示// list.add(\"string4\");  所以不能往其中添加元素for(String ...",
    "content": "Array转ListString[] array = {\"string1\", \"string2\", \"string3\"};List&lt;String&gt; list = Arrays.asList(array);//Arrays.asList产生一个Arrays内置的类，其中数组用final表示// list.add(\"string4\");  所以不能往其中添加元素for(String s : list){    System.out.println(s);}List转ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();list2.add(\"t1\");list2.add(\"t2\");list2.add(\"t3\");//toArray中不指定参数，只能转换为Object类型String[] strings = list2.toArray(new String[list2.size()]);for (String v : strings) {    System.out.println(v);}  参考：Java中Array和List的相互转换"
  },
  
  {
    "title": "使用Calendar类来输出年份、月份等",
    "url": "/posts/shiyong-calendar-huoqu-shijain/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 11:47:00 +0800",
    





    
    "snippet": "import java.util.Calendar;public class Main {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        int day = cal.get(Calendar.DATE);        int month = c...",
    "content": "import java.util.Calendar;public class Main {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        int day = cal.get(Calendar.DATE);        int month = cal.get(Calendar.MONTH) + 1;        int year = cal.get(Calendar.YEAR);        int dow = cal.get(Calendar.DAY_OF_WEEK);        int dom = cal.get(Calendar.DAY_OF_MONTH);        int doy = cal.get(Calendar.DAY_OF_YEAR);         System.out.println(\"当期时间: \" + cal.getTime());        System.out.println(\"日期: \" + day);        System.out.println(\"月份: \" + month);        System.out.println(\"年份: \" + year);        System.out.println(\"一周的第几天: \" + dow);          // 星期日为一周的第一天输出为 1        // 星期一输出为 2，以此类推        System.out.println(\"一月中的第几天: \" + dom);        System.out.println(\"一年的第几天: \" + doy);    }}以上代码运行输出结果为：当期时间: Fri Mar 27 21:44:15 CST 2015日期: 27月份: 3年份: 2015一周的第几天: 6一月中的第几天: 27一年的第几天: 86"
  },
  
  {
    "title": "在springmvc-servlet.xml中设置上传文件的大小限制",
    "url": "/posts/shezhi-shangchuan-wenjian-de-daxiao/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;  &lt;!-- 设置上传文件编码 --&gt;  &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/pr...",
    "content": "&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;  &lt;!-- 设置上传文件编码 --&gt;  &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt;  &lt;!-- 设置上传文件最大为200M--&gt;  &lt;property name=\"maxUploadSize\" value=\"209715200\"&gt;&lt;/property&gt;  &lt;!-- 设置上传最大内存40KB --&gt;  &lt;property name=\"maxInMemorySize\" value=\"40960\"&gt;&lt;/property&gt;&lt;/bean&gt;"
  },
  
  {
    "title": "Oracle 使用SQL语句对序列的操作",
    "url": "/posts/xulie-caozuo/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "创建序列CREATE SEQUENCE test_seq     MINVALUE 1     MAXVALUE 9999999999     START WITH 100000     INCREMENT BY 1     CACHE 20查询所有序列select * from user_sequences;查询特定序列select * from user_sequences where ...",
    "content": "创建序列CREATE SEQUENCE test_seq     MINVALUE 1     MAXVALUE 9999999999     START WITH 100000     INCREMENT BY 1     CACHE 20查询所有序列select * from user_sequences;查询特定序列select * from user_sequences where sequence_name like '%T_SELL_BRAND%';select * from user_sequences where sequence_name = 'SEQ_T_SELL_BRAND';"
  },
  
  {
    "title": "Oracle 使用SQL创建备份表",
    "url": "/posts/chuangjian-beifenbiao/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "create table a_bak as select * from a;",
    "content": "create table a_bak as select * from a;"
  },
  
  {
    "title": "Oracle 取查询结果排序后的第一条记录",
    "url": "/posts/qu-paixuhou-diyitiao-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "select * from (select t.*, row_number() over(order by id) rn from test_order t) t where rn = 1;",
    "content": "select * from (select t.*, row_number() over(order by id) rn from test_order t) t where rn = 1;"
  },
  
  {
    "title": "Oracle 批量删除表、视图、序列、函数",
    "url": "/posts/piliang-shanchu-xulie/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "网上有很多利用函数批量删除的例子，但是个人觉得有些复杂，参考Coding迷这位网友的做法，我认为比较简单。批量删除表、视图、序列、函数前，生成对应的SQL执行脚本，然后执行生成对应的脚本即可。--删除表select 'drop table '||table_name||';' as sqlscript from user_tables; -- drop tables--删除序列select ...",
    "content": "网上有很多利用函数批量删除的例子，但是个人觉得有些复杂，参考Coding迷这位网友的做法，我认为比较简单。批量删除表、视图、序列、函数前，生成对应的SQL执行脚本，然后执行生成对应的脚本即可。--删除表select 'drop table '||table_name||';' as sqlscript from user_tables; -- drop tables--删除序列select 'drop sequence ' || sequence_name||';' as sqlscript from user_sequences; -- drop seqs--删除存储过程select 'drop procedure ' || object_name||';' as sqlscript from user_objects  where object_type='PROCEDURE'; -- drop procedure--删除视图select 'drop view ' || view_name||';' as sqlscript from user_views;  -- drop views--删除函数select 'drop function ' || object_name||';' as sqlscript from user_objects  where object_type='FUNCTION'; -- drop functions  参考：Oracle数据库批量删除表、视图、序列、函数"
  },
  
  {
    "title": "MyBatis的xml文件中如何处理特殊字符",
    "url": "/posts/mybatis-zhong-de-teshu-zifu/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;![CDATA[   包含SQL特殊字符 ]]&gt;",
    "content": "&lt;![CDATA[   包含SQL特殊字符 ]]&gt;"
  },
  
  {
    "title": "MyBatis中使用模糊查询",
    "url": "/posts/mybatis-shiyong-mohu-chaxun/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;if test='testdata != null and testdata !=\"\"'&gt;    AND T.TEST_DATA LIKE CONCAT(CONCAT('%', #{testdata, jdbcType = VARCHAR}), '%') &lt;/if&gt;",
    "content": "&lt;if test='testdata != null and testdata !=\"\"'&gt;    AND T.TEST_DATA LIKE CONCAT(CONCAT('%', #{testdata, jdbcType = VARCHAR}), '%') &lt;/if&gt;"
  },
  
  {
    "title": "JavaScript实现submit按钮的功能",
    "url": "/posts/shoudong-commit/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "document.forms[0].action = \"/demo/test/doSubmit.do?param=0\";document.forms[0].method = \"post\";document.forms[0].submit();\t",
    "content": "document.forms[0].action = \"/demo/test/doSubmit.do?param=0\";document.forms[0].method = \"post\";document.forms[0].submit();\t"
  },
  
  {
    "title": "截图",
    "url": "/posts/jietu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "html&lt;div class=\"demo-container\"&gt;    &lt;div id=\"demo\"&gt;        &lt;div class=\"orange\"&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用...",
    "content": "html&lt;div class=\"demo-container\"&gt;    &lt;div id=\"demo\"&gt;        &lt;div class=\"orange\"&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;button id=\"saveImg\"&gt;截图&lt;/button&gt;css#demo {    background-color: #fff;}.orange {    background-color: orange;    width: 700px;    height: 200px;}javaScript&lt;script src=\"jquery-3.2.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"html2canvas.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    $(\"#saveImg\").on(\"click\", function () {        var getPixelRatio = function (context) {                 // 获取设备的PixelRatio            var backingStore = context.backingStorePixelRatio ||                context.webkitBackingStorePixelRatio ||                context.mozBackingStorePixelRatio ||                context.msBackingStorePixelRatio ||                context.oBackingStorePixelRatio ||                context.backingStorePixelRatio || 1;            return (window.devicePixelRatio || 1) / backingStore;        };        var shareContent = $(\".orange\")[0];        var width = shareContent.offsetWidth;        var height = shareContent.offsetHeight;        var canvas = document.createElement(\"canvas\");        var context = canvas.getContext('2d');        // 将canvas的容器扩大PixelRatio倍，再将画布缩放，将图像放大PixelRatio倍。        var scale = getPixelRatio(context);            canvas.width = width * scale;        canvas.height = height * scale;        canvas.style.width = width + 'px';        canvas.style.height = height + 'px';        context.scale(scale, scale);        var opts = {            scale: scale,            canvas: canvas,            width: width,            height: height,            dpi: window.devicePixelRatio        };        html2canvas(shareContent, opts).then(function (canvas) {            context.mozImageSmoothingEnabled = false;            context.webkitImageSmoothingEnabled = false;            context.msImageSmoothingEnabled = false;            context.imageSmoothingEnabled = false;            var dataUrl = canvas.toDataURL('image/jpeg', 1.0);            var newImg = document.createElement(\"img\");            newImg.src = dataUrl;            newImg.width = width;            newImg.height = height;            saveImg(dataUrl);        });    });    function saveImg(Url) {        debugger        var blob = new Blob([''], { type: 'application/octet-stream' });        var url = URL.createObjectURL(blob);        var a = document.createElement('a');        a.href = Url;        var date = new Date();        a.download = \"screenshot_\" + date.getTime();        var e = document.createEvent('MouseEvents');        e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);        a.dispatchEvent(e);        URL.revokeObjectURL(url);    }&lt;/script&gt;需要的包：  html2canvas.min.js  jquery-3.2.1.min.js"
  },
  
  {
    "title": "iframe自适应高度",
    "url": "/posts/iframe-zishiying-gaodu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;iframe src=\"backtop.html\" frameborder=\"0\" scrolling=\"no\" id=\"test\" οnlοad=\"this.height=100\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;function reinitIframe () {    var iframe = doc...",
    "content": "&lt;iframe src=\"backtop.html\" frameborder=\"0\" scrolling=\"no\" id=\"test\" οnlοad=\"this.height=100\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;function reinitIframe () {    var iframe = document.getElementById(\"test\");    iframe.height = 0; // 只有先设置原来的iframe高度为0，之前的iframe高度才不会对现在的设置有影响    try{        var bHeight = iframe.contentWindow.document.body.scrollHeight;        var dHeight = iframe.contentWindow.document.documentElement.scrollHeight;        var height = Math.max(bHeight, dHeight);        iframe.height = height;    } catch (ex) {    }}window.setInterval(\"reinitIframe()\", 200);&lt;/script&gt;"
  },
  
  {
    "title": "页面弹出框的操作",
    "url": "/posts/dan-chu-kuang-dong-zuo/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "var notice = \"您确认要执行该操作吗？\";var flag = window.confirm(notice);if (flag) {    alert(\"OK\");} else {    alert(\"NO\");}",
    "content": "var notice = \"您确认要执行该操作吗？\";var flag = window.confirm(notice);if (flag) {    alert(\"OK\");} else {    alert(\"NO\");}"
  },
  
  {
    "title": "比较时间大小",
    "url": "/posts/bijiao-shijian-daxiao/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "// 获取页面时间字符串并使用new Date()函数转换为日期格式var date_begin = new Date($(\"#date_begin\").val().replace(\"-\", \"/\").replace(\"-\", \"/\"));var date_end = new Date($(\"#date_end\").val().replace(\"-\", \"/\").replace(\"-\", \"...",
    "content": "// 获取页面时间字符串并使用new Date()函数转换为日期格式var date_begin = new Date($(\"#date_begin\").val().replace(\"-\", \"/\").replace(\"-\", \"/\"));var date_end = new Date($(\"#date_end\").val().replace(\"-\", \"/\").replace(\"-\", \"/\"));// 使用Date.getTime()函数获取时间数比较两个日期之间的大小if(date_begin.getTime() &gt; date_end.getTime()) {    alert(\"起始时间必须小于结束时间！\");}"
  },
  
  {
    "title": "JSP页面获取Controller设置的参数",
    "url": "/posts/jsp-yemain-huoqu-controller-shezhi-de-canshu/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "在controller中设置参数request.setAttribute(\"param\", \"123\");在JSP页面获取该参数var param = '&lt;%=request.getAttribute(\"param\")%&gt;';",
    "content": "在controller中设置参数request.setAttribute(\"param\", \"123\");在JSP页面获取该参数var param = '&lt;%=request.getAttribute(\"param\")%&gt;';"
  },
  
  {
    "title": "JQuery获取元素高度不同方法的区别",
    "url": "/posts/jquery-huoqu-yuansu-gaodu-de-butong-fangfa/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "$ele = $(\"#element\")$ele.height() // 纯内高height$ele.innerHeight() //  height + padding$ele.outerHeight() // height + padding + border$ele.outerHeight(True) // height + padding + border + margin  参考：...",
    "content": "$ele = $(\"#element\")$ele.height() // 纯内高height$ele.innerHeight() //  height + padding$ele.outerHeight() // height + padding + border$ele.outerHeight(True) // height + padding + border + margin  参考：JQuery获取元素高度"
  },
  
  {
    "title": "原生 JS 或 JQuery 实现父窗口传值",
    "url": "/posts/fuchuangkou-chuanzhi/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "做WEB前端开发的过程中，经常会有这样的需求，用户点击【编辑】按钮，弹出一个对话框，在里边修改相应的值，然后把修改后的值显示在原页面，最后点击保存。用window.parent.document.getElementById(\"\").setAttribute(\"value\", \"\")可以很好的解决这个问题。父页面中的代码&lt;!doctype html&gt;&lt;html lang=\"...",
    "content": "做WEB前端开发的过程中，经常会有这样的需求，用户点击【编辑】按钮，弹出一个对话框，在里边修改相应的值，然后把修改后的值显示在原页面，最后点击保存。用window.parent.document.getElementById(\"\").setAttribute(\"value\", \"\")可以很好的解决这个问题。父页面中的代码&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;meta name=\"Keywords\" content=\"\"&gt;        &lt;meta name=\"Description\" content=\"\"&gt;    &lt;/head&gt;    &lt;body style=\"height:3000px\"&gt;        &lt;input type=\"text\" id=\"parent\"&gt;        &lt;button id=\"parentBtn\"&gt;编辑&lt;/button&gt;        &lt;div class=\"clear\" style=\"width:500px;height:200px;border:1px solid red;position:fixed;top:100px;left:100px;display:none\"&gt;            &lt;iframe src=\"son.html\" style=\"border:none\"&gt;&lt;/iframe&gt;        &lt;/div&gt;        &lt;button id=\"content\"&gt;获取内容值&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\" src=\"http://www.zymseo.com/js/demo.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    // 显示子窗口    $(\"#parentBtn\").click(function(){        $(\".clear\").show();    })    // 显示子窗口获取到的值    $(\"#content\").click(function(){        alert($(\"#parent\").val());    })&lt;/script&gt;子页面中的代码&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;meta name=\"Keywords\" content=\"\"&gt;        &lt;meta name=\"Description\" content=\"\"&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=\"text\" id=\"son\"&gt;        &lt;button id=\"sonBtn\"&gt;确定&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\" src=\"http://www.zymseo.com/js/demo.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    $(\"#sonBtn\").click(function(){        var $val = $(\"#son\").val();        // JQuery写法给父页面传值        $(\"#parent\", window.parent.document).val($val);         // 原生javascript写法给父页面传值        // window.parent.document.getElementById(\"parent\").setAttribute(\"value\", $val);        // JQuery写法控制父页面中的某个元素隐藏         $(\".clear\", window.parent.document).hide();         // 原生javascript写法控制父页面中的某个元素隐藏        // window.parent.document.getElementsByClassName(\"clear\")[0].style.display = \"none\";     })&lt;/script&gt;  参考：window.parent.document解决方案【原生js或jQuery 实现父窗口的问题】"
  },
  
  {
    "title": "页面字段空值校验",
    "url": "/posts/yemian-ziduan-kongzhi-jiaoyan/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        al...",
    "content": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        alert(\"输入框1不能为空！\");        flag = false;    }    if (flag &amp;&amp; test2) {        flag = true;    } else if (flag) {        alert(\"输入框2不能为空！\");        flag = false;    }    return flag;}"
  },
  
  {
    "title": "按钮置灰",
    "url": "/posts/anniu-zhihui/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "$(document).ready(function() {  $(\"#button_li\").click(function() {\t  $(this).css(\"pointer-events\", \"none\");\t  $(this).css(\"background-color\", \"gray\");   });});",
    "content": "$(document).ready(function() {  $(\"#button_li\").click(function() {\t  $(this).css(\"pointer-events\", \"none\");\t  $(this).css(\"background-color\", \"gray\");   });});"
  },
  
  {
    "title": "input输入框锁定",
    "url": "/posts/input-shurukuang-suoding/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "$(el).find(\"input[name='a']\").attr(\"style\", \"background-color:#f6f6f6;cursor:no-drop\");$(el).find(\"input[name='a']\").attr(\"readonly\", \"readonly\");$(el).find(\"input[name='a']\").attr(\"onclick\", \"\");$...",
    "content": "$(el).find(\"input[name='a']\").attr(\"style\", \"background-color:#f6f6f6;cursor:no-drop\");$(el).find(\"input[name='a']\").attr(\"readonly\", \"readonly\");$(el).find(\"input[name='a']\").attr(\"onclick\", \"\");$(el).find(\"input[name='a']\").attr(\"onfocus\", \"\");"
  },
  
  {
    "title": "EL表达式判断字符串相等（eq）和不相等（ne）",
    "url": "/posts/el-panduan-xiangdeng-buxiangdeng/",
    "categories": "Knowledge, EL",
    "tags": "EL",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;td class=\"t1\"&gt;  &lt;input type=\"hidden\" class=\"name\" value=\"${name}\"&gt;  &lt;a class=\"c-link fb delete-btn\"&gt;删除&lt;/a&gt;  &lt;a class=\"c-link fb ml10\"&gt;记录&lt;/a&gt;  &lt;!-- 相等（eq）、不相等...",
    "content": "&lt;td class=\"t1\"&gt;  &lt;input type=\"hidden\" class=\"name\" value=\"${name}\"&gt;  &lt;a class=\"c-link fb delete-btn\"&gt;删除&lt;/a&gt;  &lt;a class=\"c-link fb ml10\"&gt;记录&lt;/a&gt;  &lt;!-- 相等（eq）、不相等（ne） --&gt;  &lt;c:if test=\"${staus eq '1'}\"&gt;&lt;a class=\"c-link fb ml10\"&gt;开启流程&lt;/a&gt;&lt;/c:if&gt;  &lt;c:if test=\"${staus ne '1'}\"&gt;&lt;a class=\"c-link fb ml10\"&gt;处理流程&lt;/a&gt;&lt;/c:if&gt;&lt;/td&gt;"
  },
  
  {
    "title": "EL表达式标签判断参数是否为空",
    "url": "/posts/el-panduan-canshu-shifou-weikong/",
    "categories": "Knowledge, EL",
    "tags": "EL",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;c:if test=\"${empty str}\"&gt; str为空 &lt;/c:if&gt;&lt;c:if test=\"${not empty str}\"&gt; str不为空 &lt;/c:if&gt;",
    "content": "&lt;c:if test=\"${empty str}\"&gt; str为空 &lt;/c:if&gt;&lt;c:if test=\"${not empty str}\"&gt; str不为空 &lt;/c:if&gt;"
  },
  
  {
    "title": "DOS命令集",
    "url": "/posts/dos-mingling-ji/",
    "categories": "Knowledge, DOS",
    "tags": "DOS",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": ".                   C:\\DocumentsandSettings\\用户名所在文件夹 ..                  C:\\DocumentsandSettings ...                 我的电脑 \\                   C盘 C:/windows/fonts    字体cmd /k systeminfo   查询系统信息OSK ...",
    "content": ".                   C:\\DocumentsandSettings\\用户名所在文件夹 ..                  C:\\DocumentsandSettings ...                 我的电脑 \\                   C盘 C:/windows/fonts    字体cmd /k systeminfo   查询系统信息OSK                 屏幕键盘"
  },
  
  {
    "title": "选择器的优先级",
    "url": "/posts/xuanzeqi-de-youxianji/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "1.最高优先级是 （直接在标签中的设置样式） &lt;div style=\"color:Red;\"&gt;&lt;/div&gt;2.次优先级是（ID选择器 ,假设级别为100） #myDiv{color:Red;}3.其次优先级是（类选择器，假设级别为10） .divClass{color:Red;}4.最后优先级是 （标签选择器，假设级别是1） div{color:Red;}",
    "content": "1.最高优先级是 （直接在标签中的设置样式） &lt;div style=\"color:Red;\"&gt;&lt;/div&gt;2.次优先级是（ID选择器 ,假设级别为100） #myDiv{color:Red;}3.其次优先级是（类选择器，假设级别为10） .divClass{color:Red;}4.最后优先级是 （标签选择器，假设级别是1） div{color:Red;}"
  },
  
  {
    "title": "使用CSS设置textarea不可拖动",
    "url": "/posts/shezhi-textarea-buke-tuodong/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "默认情况下，我们将鼠标移动到&lt;textarea&gt;的右下角时发现文本域是可以通过拖动的方式改变其大小的，这会影响我们原本的页面布局。若想设置其不可拖动，可为其添加如下属性：&lt;textarea style=\"resize:none;\"&gt;&lt;/textarea&gt;",
    "content": "默认情况下，我们将鼠标移动到&lt;textarea&gt;的右下角时发现文本域是可以通过拖动的方式改变其大小的，这会影响我们原本的页面布局。若想设置其不可拖动，可为其添加如下属性：&lt;textarea style=\"resize:none;\"&gt;&lt;/textarea&gt;"
  },
  
  {
    "title": "使用Jekyll部署自己的博客",
    "url": "/posts/jekyll-anzhuang/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-11 00:34:00 +0800",
    





    
    "snippet": "原理使用Jekyll将Markdown编写的博客生成HTML文件，也就是静态的网页，部署到GitHub上，使用GitHub提供的GitHub Pages功能来运行展示自己的博客，无需自己的数据库和服务器。安装Ruby环境需要在Ruby环境下才可以运行Jekyll，所有首先要安装Ruby环境。根据自己的操作系统下载Ruby的安装包 https://rubyinstaller.org/downl...",
    "content": "原理使用Jekyll将Markdown编写的博客生成HTML文件，也就是静态的网页，部署到GitHub上，使用GitHub提供的GitHub Pages功能来运行展示自己的博客，无需自己的数据库和服务器。安装Ruby环境需要在Ruby环境下才可以运行Jekyll，所有首先要安装Ruby环境。根据自己的操作系统下载Ruby的安装包 https://rubyinstaller.org/downloads/，选择WITH DEVKIT这一栏的安装包，后面编译需要用到DevKit，免去了自己下载安装DevKit的步骤。我这里下载的是 Ruby+Devkit 2.7.2-1 (x64) 。双击安装包进行安装。安装完成后打开cmd窗口，输入ruby -v查看是否安装成功。如下出现Ruby的版本号则表示安装成功。还需要安装RubyGems，RubyGems是Ruby的一个包管理器，RubyGems在功能上与apt-get、portage、yum和npm非常相似。Ruby1.9.1 以后版本已经自带了，所以无需额外下载。打开cmd窗口，输入gem -v查看是否安装RubyGems，如下出现RubyGems的版本号则表示安装成功。切换RubyGems源由于网络原因，导致rubygems.org存放在Amazon S3上面的资源文件间歇性连接失败。所以首先要切换Ruby的gem源，有两个比较好的镜像源可供选择，一个是淘宝，另一个是ruby-china，网上大部分的教程都是用淘宝的，但是我在使用淘宝镜像源https://ruby.taobao.org/的时候发现老是会出现认证错误：Error fetching https://ruby.taobao.org/:SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://rubygems-china.oss-cn-hangzhou.aliyuncs.com/specs.4.8.gz) 原因是淘宝的这个镜像源已经不再维护，所以改用https://gems.ruby-china.org/的镜像源，但是也报错了：Error fetching https://gems.ruby-china.org/: bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz) 原因是服务域名更换了，打开报错地址：https://gems.ruby-china.org/ 会有如下图提示，将org后缀改为com即可。使用以下命令来切换镜像源gem sources  # 查看当前使用的源地址gem sources -r url  # 删除默认的源地址，注：默认的url地址后必须有”/”,否则删不掉gem sources -a url  #添加新的镜像源地址gem sources -u  # 更新源的缓存# 以切换ruby-china为例gem sources  gem sources -r https://rubygems.org/gem sources -a https://gems.ruby-china.com/gem sources -u gem sources  # 查看一下是否切换成功安装Jekyll输入以下命令等待Jekyll安装完成gem install jekyllgem install jekyll -v '指定版本号' # 安装指定版本输入jekyll -v查看是否安装成功，如下出现Jekyll的版本号则表示安装成功。下载Jekyll主题从Jekyll的主题官网 http://jekyllthemes.org/ 下载自己喜欢的主题，并解压到本地。运行Jekyll进入到解压好的主题根目录下，输入以下命令启动Jekylljekyll serve可能会出现以下的错误jekyll serveC:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.13.6/lib/bundler/resolver.rb:366:in `block in verify_gemfile_dependencies_are_found!': Could not find gem 'github-pages x64-mingw32' in any of the gem sources listed in your Gemfile or available on this machine. (Bundler::GemNotFound)        from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.13.6/lib/bundler/resolver.rb:341:in `each'        from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.13.6/lib/bundler/resolver.rb:341:in `verify_gemfile_dependencies_are_found!'下载对应的依赖即可gem install github-pagesgem install github-pages -v 版本号 # 安装指定版本依赖显示以下内容则表示启动成功在浏览器中输入http://localhost:4000/访问，enjoy it。Jekyll的目录结构.├──_config.yml├── _drafts|   ├── begin-with-the-crazy-ideas.textile|   └── on-simplicity-in-technology.markdown├── _includes|   ├── footer.html|   └── header.html├── _layouts|   ├── default.html|   └── post.html├── _posts|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile|   └── 2009-04-26-barcamp-boston-4-roundup.textile├── _site├── .jekyll-metadata└── index.html每个目录的作用            目录      描述                  _config.yml      保存配置数据              _drafts      drafts（草稿）是未发布的文章              _includes      你可以加载这些包含部分到你的布局或者文章中以方便重用              _layouts      layouts（布局）是包裹在文章外部的模板              _posts      这里放的就是文章了              _data      格式化好的网站数据。Jekyll的引擎会自动加载在该目录下所有的yaml文件（后缀是.yml, .yaml, .json或者.csv ）。这些文件可以经由site.data访问。如果有一个members.yml文件在该目录下，你就可以通过site.data.members获取该文件的内容。              _site      一旦Jekyll完成转换，就会将生成的页面放在这里      将博客发布到GitHub首先需要有一个GitHub帐号，其次拥有一个存储库，存储库名称必须是&lt;username&gt;.github.io，&lt;username&gt;就是你的GitHub用户名。然后需要打开GitHub Pages功能  在本地使用jekyll serve命令将md文件编译成HTML文件，然后将_site目录下的内容上传到刚才新建的存储库中，在浏览器打开https://xxx.github.io，就可以看到博客页面了。附几款博客主题  Typecho的主题：未命名 DEFAULT小改模板，预览：未命名  Wordpress的主题：smarty_hankin，预览：hankin"
  },
  
  {
    "title": "Customize the Favicon",
    "url": "/posts/customize-the-favicon/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-11 00:34:00 +0800",
    





    
    "snippet": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons...",
    "content": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files:  browserconfig.xml  site.webmanifestAnd then copy the remaining image files (.PNG and .ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files:            File(s)      From Online Tool      From Chirpy                  *.PNG      ✓      ✗              *.ICO      ✓      ✗        ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition."
  },
  
  {
    "title": "Getting Started",
    "url": "/posts/getting-started/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-09 20:55:00 +0800",
    





    
    "snippet": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of the basic environment. Git also needs to be installed.InstallationCreating a New SiteThere are two ways to cr...",
    "content": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of the basic environment. Git also needs to be installed.InstallationCreating a New SiteThere are two ways to create a new repository for this theme:  Using the Chirpy Starter - Easy to upgrade, isolates irrelevant project files so you can focus on writing.  GitHub Fork - Convenient for custom development, but difficult to upgrade. Unless you are familiar with Jekyll and are determined to tweak or contribute to this project, this approach is not recommended.Option 1. Using the Chirpy StarterSign in to GitHub and browse to Chirpy Starter, click the button Use this template &gt; Create a new repository, and name the new repository USERNAME.github.io, where USERNAME represents your GitHub username.Option 2. GitHub ForkSign in to GitHub to fork Chirpy, and then rename it to USERNAME.github.io (USERNAME means your username).Next, clone your site to local machine. In order to build JavaScript files later, we need to install Node.js, and then run the tool:$ bash tools/init  If you don’t want to deploy your site on GitHub Pages, append option --no-gh at the end of the above command.The above command will:  Check out the code to the latest tag (to ensure the stability of your site: as the code for the default branch is under development).  Remove non-essential sample files and take care of GitHub-related files.  Build JavaScript files and export to assets/js/dist/, then make them tracked by Git.  Automatically create a new commit to save the changes above.Installing DependenciesBefore running local server for the first time, go to the root directory of your site and run:$ bundleUsageConfigurationUpdate the variables of _config.yml as needed. Some of them are typical options:  url  avatar  timezone  langCustomizing StylesheetIf you need to customize the stylesheet, copy the theme’s assets/css/style.scss to the same path on your Jekyll site, and then add the custom style at the end of it.Starting with version 4.1.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, copy the main sass file _sass/jekyll-theme-chirpy.scss into the _sass directory in your site’s source, then create a new file _sass/variables-hook.scss and assign new value.Customing Static AssetsStatic assets configuration was introduced in version 5.1.0. The CDN of the static assets is defined by file _data/origin/cors.yml, and you can replace some of them according to the network conditions in the region where your website is published.Also, if you’d like to self-host the static assets, please refer to the chirpy-static-assets.Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sOr run the site on Docker with the following command:$ docker run -it --rm \\    --volume=\"$PWD:/srv/jekyll\" \\    -p 4000:4000 jekyll/jekyll \\    jekyll serveAfter a few seconds, the local service will be published at http://127.0.0.1:4000.DeploymentBefore the deployment begins, check out the file _config.yml and make sure the url is configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than GitHub Pages, remember to change the baseurl to your project name that starts with a slash, e.g, /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy by Using GitHub ActionsThere are a few things to get ready for.  If you’re on the GitHub Free plan, keep your site repository public.      If you have committed Gemfile.lock to the repository, and your local machine is not running Linux, go the the root of your site and update the platform list of the lock-file:    $ bundle lock --add-platform x86_64-linux      Next, configure the Pages service.      Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar. Then, in the Source section (under Build and deployment), select GitHub Actions from the dropdown menu.        Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically.  At this point, you can go to the URL indicated by GitHub to access your site.Manually Build and DeployOn self-hosted servers, you cannot enjoy the convenience of GitHub Actions. Therefore, you should build the site on your local machine and then upload the site files to the server.Go to the root of the source project, and build your site as follows:$ JEKYLL_ENV=production bundle exec jekyll bOr build the site on Docker:$ docker run -it --rm \\    --env JEKYLL_ENV=production \\    --volume=\"$PWD:/srv/jekyll\" \\    jekyll/jekyll \\    jekyll buildUnless you specified the output path, the generated site files will be placed in folder _site of the project’s root directory. Now you should upload those files to the target server."
  },
  
  {
    "title": "Writing a New Post",
    "url": "/posts/write-a-new-post/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-08 14:10:00 +0800",
    





    
    "snippet": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set.Naming and P...",
    "content": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG]     # TAG names should always be lowercase---  The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:Adding author information in _data/authors.yml (If your website doesn’t have this file, don’t hesitate to create one).&lt;author_id&gt;:  name: &lt;full name&gt;  twitter: &lt;twitter_of_author&gt;  url: &lt;homepage_of_author&gt;And then use author to specify a single entry or authors to specify multiple entries:---author: &lt;author_id&gt;                     # for single entry# orauthors: [&lt;author1_id&gt;, &lt;author2_id&gt;]   # for multiple entries---Having said that, the key author can also identify multiple entries.  The benefit of reading the author information from the file _data/authors.yml is that the page will have the meta tag twitter:creator, which enriches the Twitter Cards and is good for SEO.Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesCaptionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image.![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }  For an SVG, you have to at least specify its width, otherwise it won’t be rendered.Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right.  Once the position is specified, the image caption should not be added.      Normal position    Image will be left aligned in below sample:    ![Desktop View](/assets/img/sample/mockup.png){: .normal }            Float to the left    ![Desktop View](/assets/img/sample/mockup.png){: .left }            Float to the right    ![Desktop View](/assets/img/sample/mockup.png){: .right }      Dark/Light modeYou can make images follow theme preferences in dark/light mode. This requires you to prepare two images, one for dark mode and one for light mode, and then assign them a specific class (dark or light):![Light mode only](/path/to/light-mode.png){: .light }![Dark mode only](/path/to/dark-mode.png){: .dark }ShadowThe screenshots of the program window can be considered to show the shadow effect:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.comOnce img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&lt;img src=\"https://cdn.com/path/to/flower.png\" alt=\"The flower\"&gt;Image PathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&lt;img src=\"/img/path/flower.png\" alt=\"The flower\"&gt;Preview ImageIf you want to add an image at the top of the post, please provide an image with a resolution of 1200 x 630. Please note that if the image aspect ratio does not meet 1.91 : 1, the image will be scaled and cropped.Knowing these prerequisites, you can start setting the image’s attribute:---image:  path: /path/to/image  alt: image alternative text---Note that the img_path can also be passed to the preview image, that is, when it has been set, the  attribute path only needs the image file name.For simple use, you can also just use image to define the path.---image: /path/to/image---LQIPFor preview images:---image:  lqip: /path/to/lqip-file # or base64 URI---  You can observe LQIP in the preview image of post Text and Typography.For normal images:![Image description](/path/to/image){: lqip=\"/path/to/lqip-file\" }Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---PromptsThere are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows:&gt; Example line for prompt.{: .prompt-info }SyntaxInline Code`inline code part`Filepath Hightlight`/path/to/a/file.extend`{: .filepath}Code BlockMarkdown symbols ``` can easily create a code block as follows:```This is a plaintext code snippet.```Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value```  The Jekyll tag {% highlight %} is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it:```shellecho 'No more line numbers!'```{: .nolineno }Specifying the FilenameYou may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=\"path/to/file\" }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains 'Pack' %}  This product's title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.VideosYou can embed a video with the following syntax:{% include embed/{Platform}.html id='{ID}' %}Where Platform is the lowercase of the platform name, and ID is the video ID.The following table shows how to get the two parameters we need in a given video URL, and you can also know the currently supported video platforms.            Video URL      Platform      ID                  https://www.youtube.com/watch?v=H-B46URT4mg      youtube      H-B46URT4mg              https://www.twitch.tv/videos/1634779211      twitch      1634779211      Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts."
  },
  
  {
    "title": "Text and Typography",
    "url": "/posts/text-and-typography/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-08 11:33:00 +0800",
    





    
    "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.HeadingsH1 - headingH2 - headingH3 - headingH...",
    "content": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.HeadingsH1 - headingH2 - headingH3 - headingH4 - headingParagraphQuisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risus, sit amet vulputate urna facilisis ac. Phasellus semper dui non purus ultrices sodales. Aliquam ante lorem, ornare a feugiat ac, finibus nec mauris. Vivamus ut tristique nisi. Sed vel leo vulputate, efficitur risus non, posuere mi. Nullam tincidunt bibendum rutrum. Proin commodo ornare sapien. Vivamus interdum diam sed sapien blandit, sit amet aliquam risus mattis. Nullam arcu turpis, mollis quis laoreet at, placerat id nibh. Suspendisse venenatis eros eros.ListsOrdered list  Firstly  Secondly  ThirdlyUnordered list  Chapter          Section                  Paragraph                    ToDo list  Job          Step 1      Step 2      Step 3      Description list  Sun  the star around which the earth orbits  Moon  the natural satellite of the earth, visible by reflected light from the sunBlock Quote  This line shows the block quote.Prompts  An example showing the tip type prompt.  An example showing the info type prompt.  An example showing the warning type prompt.  An example showing the danger type prompt.Tables            Company      Contact      Country                  Alfreds Futterkiste      Maria Anders      Germany              Island Trading      Helen Bennett      UK              Magazzini Alimentari Riuniti      Giovanni Rovelli      Italy      Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Inline codeThis is an example of Inline Code.FilepathHere is the /path/to/the/file.extend.Code blocksCommonThis is a common code snippet, without syntax highlight and line number.Specific Languageif [ $? -ne 0 ]; then  echo \"The command was not successful.\";  #do the needful / exitfi;Specific filename@import  \"colors/light-typography\",  \"colors/dark-typography\";MathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Mermaid SVG gantt  title  Adding GANTT diagram functionality to mermaid  apple :a, 2017-07-20, 1w  banana :crit, b, 2017-07-23, 1d  cherry :active, c, after b a, 1dImagesDefault (with caption)![Desktop View](](/assets/img/illustration/Index/Jekyll/20190808/mockup.png){: width=”972” height=”589” }Full screen width and center alignmentLeft alignedFloat to leftPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Float to rightPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Dark/Light mode &amp; ShadowThe image below will toggle dark/light mode based on theme preference, notice it has shadows.VideoReverse Footnote            The footnote source &#8617;              The 2nd footnote source &#8617;      "
  }
  
]

