[
  
  {
    "title": "Filebeat启动后自动停止的问题",
    "url": "/posts/filebeat-zidong-tingzhi-de-wenti/",
    "categories": "Knowledge, Filebeat",
    "tags": "Filebeat",
    "date": "2023-06-14 13:47:00 +0800",
    





    
    "snippet": "Linux环境部署的Filebeat在启动正常的情况下自动停止运行。启动Filebeat的指令是：nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;通过对nohup的指令了解后发现，当关闭xshell终端时，断开ssh连接，会导致nohup进程同时终止。解决办法：关闭xshell终端前，先exit退出，断开s...",
    "content": "Linux环境部署的Filebeat在启动正常的情况下自动停止运行。启动Filebeat的指令是：nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp;通过对nohup的指令了解后发现，当关闭xshell终端时，断开ssh连接，会导致nohup进程同时终止。解决办法：关闭xshell终端前，先exit退出，断开ssh连接，然后就可以关闭终端；或者在原来的启动指令上加上disown参数，这个参数会将nohup进程从当前shell的作业列表中清除，从而避免在关闭xshell时nohup进程接收到SIGHUP信号而停止运行:nohup ./filebeat -e -c filebeat.yml &gt;/dev/null 2&gt;&amp;1 &amp; disown"
  },
  
  {
    "title": "宝兰德部署Spring Boot项目",
    "url": "/posts/springboot-zhenghe-baolande/",
    "categories": "Knowledge, BES Web",
    "tags": "BES Web",
    "date": "2023-05-29 13:47:00 +0800",
    





    
    "snippet": "之前在网上找资料看到说Spring Boot部署宝兰德有jar包的改造，这里说明下，如果最终应用要部署在BES单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突。即com单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突，即com.bes.enterprise.logging.internal.Log: ...",
    "content": "之前在网上找资料看到说Spring Boot部署宝兰德有jar包的改造，这里说明下，如果最终应用要部署在BES单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突。即com单实例或者集群版本的话，即通过控制台部署应用，就不能集成宝兰德的内嵌包，否则会造成jar包冲突，即com.bes.enterprise.logging.internal.Log: Provider com.bes.enterprise.jul.formatter.log.BESASLog not a subtype。BES和Tomcat中间件针对springboot的部署方式是一致的，因此这种情况，不需要做单独的改造。只有单集成宝兰德时，才需要在项目中添加相应的jar包，如下所示（程序包由宝兰德提供）            包名      说明                  bes-lite-spring-boot-2.x-starter-9.5.2      核心包，必须              bes-actuator-spring-boot-2.x-starter-9.5.2.jar      监控包，可选              bes-websocket      支持websocket              bes-gmssl      国密安全包，可选              bes-jasper      支持JSP，可选              bes-jdbcra      支持JDBC ，可选      ​项目pom中去掉spring-boot-starter-web的Tomcat依赖，将上面用到的包放到自己的私服后，在pom中添加如下内容：&lt;dependency&gt;    &lt;groupId&gt;com.bes.appserver&lt;/groupId&gt;    &lt;artifactId&gt;bes-lite-spring-boot-2.x-starter&lt;/artifactId&gt;    &lt;version&gt;9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.bes.appserver&lt;/groupId&gt;    &lt;artifactId&gt;bes-websocket&lt;/artifactId&gt;    &lt;version&gt;9.5.2&lt;/version&gt;&lt;/dependency&gt;"
  },
  
  {
    "title": "宝兰德常用命令",
    "url": "/posts/baolande-changyong-mingling/",
    "categories": "Knowledge, BES Web",
    "tags": "BES Web",
    "date": "2023-05-29 13:47:00 +0800",
    





    
    "snippet": "登录命令行控制台./iastool --passport admin创建节点create --node --host 192.168.92.135 --port 1900 --user admin \\--password admin --domainname domain1 node136创建名为domain1的域./iastool create --domain --passport ad...",
    "content": "登录命令行控制台./iastool --passport admin创建节点create --node --host 192.168.92.135 --port 1900 --user admin \\--password admin --domainname domain1 node136创建名为domain1的域./iastool create --domain --passport admin --user admin \\--password admin --adminport 1900 domain1创建名为Node1的节点./iastool create --node --passport admin --domainname domain1 Node1创建名Server1的实例./iastool create --instance --passport admin --node Node1 Server1启动BES的顺序是先启动域，再启动节点，最后启动实例# 启动域domain1 (必须命令行启动)./iastool start --domain --passport admin domain1# 启动节点Node1 (必须命令行启动)./iastool start --node --passport admin --domainname domain1 Node1 # 启动实例Server1 (必须命令行启动)./iastool start --instance --passport admin Server1停止BES的顺序是先停止实例，再停止节点，最后停止域# 停止实例Server1./iastool stop --instance --passport admin Server1 # 停止节点Node1./iastool stop --node --passport admin --domainname domain1 Node1 # 停止域domain1./iastool stop --domain --passport admin domain1创建集群名为Cluster1的集群./iastool create --cluster --passport admin --user admin --password admin Cluster1在集群Cluster1下创建集群实例c1s1（将此实例创建在节点Node1下）./iastool create --instance --passport admin --ajpport 60001 \\--node Node1--cluster Cluster1 c1s1在集群Cluster1下创建集群实例c1s2（将此实例创建在节点Node2下）./iastool create --instance --passport admin --ajpport 60002 \\--node Node2--cluster Cluster1 c1s2部署应用./iastool deploy --passport admin --host localhost --port 1900 --user admin \\--password admin --domain domain1 --target server01 D:\\tmp\\J2EE5WebTest.war解部署应用./iastool undeploy --passport admin --host localhost --port 1900 --user admin \\--password admin --domain domain1 --target server01 J2EE5WebTest"
  },
  
  {
    "title": "MySQL查询主键相关",
    "url": "/posts/mysql-chaxun-zhujian/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2023-05-25 13:47:00 +0800",
    





    
    "snippet": "-- 查询数据库中所有表名和表的主键select table_name,column_name from information_schema.key_column_usage where constraint_name = 'primary' and table_name in (select table_namefrom information_schema.tableswhere ta...",
    "content": "-- 查询数据库中所有表名和表的主键select table_name,column_name from information_schema.key_column_usage where constraint_name = 'primary' and table_name in (select table_namefrom information_schema.tableswhere table_schema = 'testdb' order by table_name)and table_schema = 'testdb';-- 查询数据库中没有主键的表SELECT    a.TABLE_SCHEMA,    a.TABLE_NAME FROM    (    SELECT        TABLE_SCHEMA,        TABLE_NAME     FROM        information_schema.TABLES     WHERE    TABLE_SCHEMA NOT IN \t( 'mysql', 'information_schema', 'performance_schema', 'sys', 'sysdb' )) AS a    LEFT JOIN (    SELECT        TABLE_SCHEMA,        TABLE_NAME     FROM        information_schema.TABLE_CONSTRAINTS     WHERE        CONSTRAINT_TYPE = 'PRIMARY KEY'     AND TABLE_SCHEMA NOT IN \t( 'mysql', 'information_schema', 'performance_schema', 'sys', 'sysdb' )) AS b     ON a.TABLE_SCHEMA = b.TABLE_SCHEMA     AND a.TABLE_NAME = b.TABLE_NAME WHERE    b.TABLE_NAME IS NULL;"
  },
  
  {
    "title": "Redis使用redis-cli连接报错：WRONGPASS invalid username-password pair or user is disabled.",
    "url": "/posts/redis-lianjie-baocuo/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2023-05-24 13:47:00 +0800",
    





    
    "snippet": "报错信息使用redis-cli连接Redis时报错，具体为认证失败问题WRONGPASS invalid username-password pair or user is disabled.。之前输入auth pass即可，但此次在终端窗口有提示需要username。报错原因本机Redis为7.0版本。Redis6.0起，支持ACL权限控制，Redis6.0之前的版本只支持验证密码方式的权...",
    "content": "报错信息使用redis-cli连接Redis时报错，具体为认证失败问题WRONGPASS invalid username-password pair or user is disabled.。之前输入auth pass即可，但此次在终端窗口有提示需要username。报错原因本机Redis为7.0版本。Redis6.0起，支持ACL权限控制，Redis6.0之前的版本只支持验证密码方式的权限控制，格式如下：AUTH &lt;password&gt;。当使用Redis ACLs权限控制时，AUTH 验证格式如下：AUTH &lt;username&gt; &lt;password&gt;，在ACLs模式下，如果传递一个密码参数给AUTH，那么会隐式设置用户名default。解决方法使用auth default &lt;password&gt;验证。"
  },
  
  {
    "title": "Nginx添加ssl模块",
    "url": "/posts/nginx-tianjia-ssl-mokuai/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2023-05-23 13:47:00 +0800",
    





    
    "snippet": "一、在安装时添加ssl模块1、进入源码包所在的目录，进行编译，编译时添加参数–with-http_stub_status_module --with-http_ssl_modulecd /usr/local/nginx-1.20.2./configure --with-http_stub_status_module --with-http_ssl_module2、进行编译与编译安装make ...",
    "content": "一、在安装时添加ssl模块1、进入源码包所在的目录，进行编译，编译时添加参数–with-http_stub_status_module --with-http_ssl_modulecd /usr/local/nginx-1.20.2./configure --with-http_stub_status_module --with-http_ssl_module2、进行编译与编译安装make &amp;&amp; make install3、查看是否含有ssl模块/usr/local/nginx/sbin/nginx -V二、在安装好后添加ssl模块1、进入到源码包所在的目录，进行编译，编译时添加参数./configure --prefix=系统生成的Nginx目录 --with-http_stub_status_module --with-http_ssl_module./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module2、编译（这里不能编译安装）make3、配置Nginx二进制文件cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak4、停掉Nginxkillall nginx5、替换Nginx二进制文件（新的二进制文件在源码包的objs目录里面）cd objscp nginx /usr/local/nginx/sbin/6、查看ssl模块是否已添加/usr/local/nginx/sbin/nginx -V"
  },
  
  {
    "title": "Nginx配置详解",
    "url": "/posts/nginx-peizhi-xiangjie/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2023-05-23 13:47:00 +0800",
    





    
    "snippet": "一、main：全局配置#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;上述配置都是存放在main全局配置模块中的配置项。  use...",
    "content": "一、main：全局配置#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;上述配置都是存放在main全局配置模块中的配置项。  user：用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行；  worker_processes：指定Nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍；  error_log：定义错误日志文件的位置及输出级别【debug/info/notice/warn/error/crit】；  pid：用来指定进程id的存储文件的位置；  worker_rlimit_nofile：用于指定一个进程可以打开最多文件数量的描述。二、events：配置Nginx工作模式events {    worker_connections  1024;    multi_accept on;    use epoll;}上述配置是针对Nginx服务器的工作模式的一些操作配置。  worker_connections：指定最大可以同时接收的连接数量，这里一定要注意，最大连接数量是和worker processes共同决定的；  multi_accept：指定Nginx在收到一个新连接通知后尽可能多的接受更多的连接；  use epoll：配置指定了线程轮询的方法，如果是linux2.6+，使用epoll，如果是BSD如Mac请使用Kqueue。三、http：配置http协议信息作为web服务器，http模块是Nginx最核心的一个模块，配置项也是比较多的，项目中会涉及到很多的实际业务场景，需要根据硬件信息进行适当的配置，常规情况下，使用默认配置即可。http {    # 基础配置    sendfile on;    tcp_nopush on;    tcp_nodelay on;    keepalive_timeout 65;    types_hash_max_size 2048;    # server_tokens off;    # server_names_hash_bucket_size 64;    # server_name_in_redirect off;    include /etc/nginx/mime.types;    default_type application/octet-stream;    # SSL证书配置    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE    ssl_prefer_server_ciphers on;    # 日志配置    access_log /var/log/nginx/access.log;    error_log /var/log/nginx/error.log;    # gzip压缩配置    gzip on;    gzip_disable \"msie6\";    # gzip_vary on;    # gzip_proxied any;    # gzip_comp_level 6;    # gzip_buffers 16 8k;    # gzip_http_version 1.1;    # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;    # 虚拟主机配置    server {        ......    }}基础配置  sendfile on：配置on让sendfile发挥作用，将文件的回写过程交给数据缓冲去去完成，而不是放在应用中完成，这样的话在性能提升有有好处；  tc_nopush on：让Nginx在一个数据包中发送所有的头文件，而不是一个一个单独发；  tcp_nodelay on：让Nginx不要缓存数据，而是一段一段发送，如果数据的传输有实时，性的要求的话可以配置它，发送完一小段数据就立刻能得到返回值；  keepalive_timeout 10：给客户端分配连接超时时间，服务器会在这个时间过后关闭连接，一般设置时间较短，可以让Nginx工作持续性更好；  client_header_timeout 10：设置请求头的超时时间；  client_body_timeout 10：设置请求体的超时时间；  send_timeout 10：指定客户端响应超时时间，如果客户端两次操作间隔超过这个时间，服务器就会关闭这个链接；  limit_conn_zone $binary_remote_addr zone=addr:5m：设置用于保存各种key的共享内存的参数.  limit_conn addr 100: 给定的key设置最大连接数；  server_tokens：虽然不会让Nginx执行速度更快，但是可以在错误页面关闭Nginx版本，提示，对于网站安全性的提升有好处；  include /etc/nginx/mime.types：指定在当前文件中包含另一个文件的指令；  default_type application/octet-stream：指定默认处理的文件类型可以是二进制；  type_hash_max_size 2048：混淆数据，影响三列冲突率，值越大消耗内存越多，散列key冲突率会降低，检索速度更快；值越小key，占用内存较少，冲突率越高，检索速度变慢。日志配置  access_log logs/access.log：设置存储访问记录的日志；  error_log logs/error.log：设置存储记录错误发生的日志。SSL证书加密  ssl_protocols：指令用于启动特定的加密协议，Nginx在1.1.13和1.0.12版本后默认是ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2，TLSv1.1与TLSv1.2要确保OpenSSL &gt;= 1.0.1，SSLv3现在还有很多地方在用但有不少被攻击的漏洞；  ssl prefer server ciphers：设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。压缩配置  gzip on：告诉Nginx采用gzip压缩的形式发送数据，这将会减少我们发送的数据量；  gzip_disable：为指定的客户端禁用gzip功能；我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。  gzip_static：告诉Nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样Nginx就不用再压缩这些文件了；  gzip_proxied：允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求；  gzip_min_length：设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度；  gzip_comp_level：设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置；  gzip_type：设置需要压缩的数据格式。上面例子中已经有一些了，你也可以再添加更多的格式。文件缓存配置  open_file_cache：打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉；  open_file_cache_valid：在open_file_cache中指定检测正确信息的间隔时间；  open_file_cache_min_uses：定义了open_file_cache中指令参数不活动时间期间里最小的文件数；  open_file_cache_errors：指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置；四、server：配置服务器访问信息srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息。server {    listen        80;    server_name   localhost 192.168.1.100;    root          /nginx/www;    index         index.php index.html index.html;    charset       utf-8;    access_log    logs/access.log;    error_log     logs/error.log;    ......}  server：一个虚拟主机的配置，一个http中可以配置多个server；  server_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔；  root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录；  index：用户访问web网站时的全局首页；  charset：用于设置www/路径中配置的网页的默认编码格式；  access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径；  error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径。五、location：配置访问路由location模块是Nginx配置中出现最多的一个配置，主要用于配置路由访问信息，在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location，模块也是一个非常重要的配置模块。location / {    root    /nginx/www;    index   index.php index.html index.htm;}  location /：表示匹配访问根目录；  root：用于指定访问根目录时，访问虚拟主机的web目录；  index：在不指定访问具体资源时，默认展示的资源文件列表。location /api {    proxy_pass http://www.baidu.com;    # 以下是一些反向代理的配置可删除    proxy_redirect     off;     # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP    proxy_set_header   Host $host;     proxy_set_header   X-Real-IP $remote_addr;     proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;     client_max_body_size       10m; #允许客户端请求的最大单文件字节数    client_body_buffer_size    128k; #缓冲区代理缓冲用户端请求的最大字节数    proxy_connect_timeout      300; #Nginx跟后端服务器连接超时时间(代理连接超时)    proxy_send_timeout         300; #后端服务器数据回传时间(代理发送超时)    proxy_read_timeout         300; #连接成功后，后端服务器响应时间(代理接收超时)    proxy_buffer_size          4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小    proxy_buffers              4 32k; #proxy_buffers缓冲区，网页平均在32k以下就设置    proxy_busy_buffers_size    64k; #高负荷下缓冲大小（proxy_buffers*2）    proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传}六、upstream：配置负载均衡upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器。upstream name {    ip_hash;    server 192.168.1.100:8000;    server 192.168.1.100:8001 down;    server 192.168.1.100:8002 max_fails=3;    server 192.168.1.100:8003 fail_timeout=20s;    server 192.168.1.100:8004 max_fails=3 fail_timeout=20s;}  ip_hash：指定请求调度算法，默认是weight权重轮询调度，可以指定；  server host:port：分发服务器的列表配置。          down：表示该主机暂停服务；      max_fails：表示失败最大次数，超过失败最大次数暂停服务；      fail_timeout：表示如果请求受理失败，暂停指定的时间之后重新发起请求。        参考：Nginx基本使用"
  },
  
  {
    "title": "Nginx正常启动，端口没有被监听",
    "url": "/posts/nginx-zhengchang-qidong-duankou-meiyou-jianting/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2023-05-22 13:47:00 +0800",
    





    
    "snippet": "启动nginx服务：/usr/local/nginx/sbin/nginx -c conf/nginx.conf启动完成也没有报错，ps看进程也正常，netstat发现端口没有被监听，也没有错误日志，找了半天最后才发现，conf/nginx.conf使用的是安装目录下面的Nginx配置，没有使用我们制定的配置，也就是说我们要用绝对路径制定Nginx配置，如下：/usr/local/nginx...",
    "content": "启动nginx服务：/usr/local/nginx/sbin/nginx -c conf/nginx.conf启动完成也没有报错，ps看进程也正常，netstat发现端口没有被监听，也没有错误日志，找了半天最后才发现，conf/nginx.conf使用的是安装目录下面的Nginx配置，没有使用我们制定的配置，也就是说我们要用绝对路径制定Nginx配置，如下：/usr/local/nginx/sbin/nginx -c /data/app/nginx/conf/nginx.conf如果不确认用的是哪个配置，可以用-t参数先test一下，终端会显示使用的Nginx配置：/usr/local/nginx/sbin/nginx -c conf/nginx.conf -t"
  },
  
  {
    "title": "Redis Desktop Manager使用SSH连接Redis",
    "url": "/posts/shiyong-ssh-fangshi-lianjie-redis/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2023-05-10 13:47:00 +0800",
    





    
    "snippet": "第一步第二步第三步",
    "content": "第一步第二步第三步"
  },
  
  {
    "title": "如何卸载UniAccessAgent并且不影响网络连接",
    "url": "/posts/ruhe-xiezai-uniacess/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2023-05-10 08:47:00 +0800",
    





    
    "snippet": "下载360安全卫士文件粉碎机独立版，使用文件粉碎机打开C:\\Windows\\LVUAAgentInstBaseRoot目录（使用Windows资源管理器打开无法看到目录下的文件），强力删除目录下的UniAccessAgentBrowser.exe、UniAccessAgentDaemon.exe、UniAccessAgentTray.exe这3个文件，UniAccessAgentUI.exe...",
    "content": "下载360安全卫士文件粉碎机独立版，使用文件粉碎机打开C:\\Windows\\LVUAAgentInstBaseRoot目录（使用Windows资源管理器打开无法看到目录下的文件），强力删除目录下的UniAccessAgentBrowser.exe、UniAccessAgentDaemon.exe、UniAccessAgentTray.exe这3个文件，UniAccessAgentUI.exe和UniAccessAgent.exe这两个文件要留着，这个就是程序的界面，然后UniAccessAgentUI.exe创建一个快捷方式到桌面，如果不能登录内网，双击快捷方式就会弹出桌面管家网络认证的界面，点击其中的登录网络即可。然后重启Windows系统，UniAccessAgent相关的进程就不会自动重启了。"
  },
  
  {
    "title": "JSON转XML工具类",
    "url": "/posts/json-zhuan-xml-gongjulei/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2023-05-10 01:47:00 +0800",
    





    
    "snippet": "import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Test {...",
    "content": "import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Test {    /**     * Json to xml string.     *     * @param json the json     * @return the string     */    public static String jsonToXml(String json){        try {            StringBuffer buffer = new StringBuffer();            buffer.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\");            JSONObject jObj = JSON.parseObject(json);            jsonToXmlstr(jObj,buffer);            return buffer.toString();        } catch (Exception e) {            e.printStackTrace();            return \"\";        }    }    /**     * Json to xmlstr string.     *     * @param jObj   the j obj     * @param buffer the buffer     * @return the string     */    public static String jsonToXmlstr(JSONObject jObj, StringBuffer buffer ){        Set&lt;Map.Entry&lt;String, Object&gt;&gt; se = jObj.entrySet();        for(Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = se.iterator(); it.hasNext(); )        {            Map.Entry&lt;String, Object&gt; en = it.next();            if(en.getValue().getClass().getName().equals(\"com.alibaba.fastjson.JSONObject\")){                buffer.append(\"&lt;\"+en.getKey()+\"&gt;\");                JSONObject jo = jObj.getJSONObject(en.getKey());                jsonToXmlstr(jo,buffer);                buffer.append(\"&lt;/\"+en.getKey()+\"&gt;\");            }else if(en.getValue().getClass().getName().equals(\"com.alibaba.fastjson.JSONArray\")){                JSONArray jarray = jObj.getJSONArray(en.getKey());                for (int i = 0; i &lt; jarray.size(); i++) {                    buffer.append(\"&lt;\"+en.getKey()+\"&gt;\");                    JSONObject jsonobject =  jarray.getJSONObject(i);                    jsonToXmlstr(jsonobject,buffer);                    buffer.append(\"&lt;/\"+en.getKey()+\"&gt;\");                }            }else if(en.getValue().getClass().getName().equals(\"java.lang.String\")){                buffer.append(\"&lt;\"+en.getKey()+\"&gt;\"+en.getValue());                buffer.append(\"&lt;/\"+en.getKey()+\"&gt;\");            }        }        return buffer.toString();    }    /**     * The entry point of application.     *     * @param args the input arguments     */    public static void main(String[] args) {        String xmlstr = jsonToXml(\"{\\\"class\\\": {\\\"student\\\": [{\\\"age\\\": \\\"18\\\",\\\"gender\\\": \\\"男\\\",\\\"name\\\": \\\"张三\\\",\\\"qk\\\": [{\\\"q1\\\": \\\"001\\\",\\\"q2\\\": \\\"002\\\",\\\"q3\\\": \\\"003\\\"},{\\\"q1\\\": \\\"001\\\",\\\"q2\\\": \\\"002\\\",\\\"q3\\\": \\\"003\\\"}]},{\\\"age\\\": \\\"17\\\",\\\"gender\\\": \\\"男\\\",\\\"name\\\": \\\"李四\\\",\\\"qk\\\": {\\\"q1\\\": \\\"005\\\",\\\"q2\\\": \\\"006\\\",\\\"q3\\\": \\\"007\\\"}},{\\\"age\\\": \\\"19\\\",\\\"gender\\\": \\\"女\\\",\\\"name\\\": \\\"王五\\\",\\\"qk\\\": {\\\"q1\\\": \\\"008\\\",\\\"q2\\\": \\\"009\\\",\\\"q3\\\": \\\"010\\\"}}]}}\");        System.out.println(xmlstr);    }}Maven依赖&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.45&lt;/version&gt;&lt;/dependency&gt;  参考：Java代码 json格式数据转化成xml jsonToXml"
  },
  
  {
    "title": "CentOS安装Nginx",
    "url": "/posts/centos-anzhuang-nginx/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-04-11 01:47:00 +0800",
    





    
    "snippet": "1. 下载Nginx安装包http://nginx.org/download/2. 解压Nginx压缩包tar zxvf nginx-1.23.4.tar.gz3. 进入Nginx目录下cd /nginx/nginx-1.23.44. 配置安装运行目录./configure --prefix=/usr/local/nginx5. 出现错误需要安装依赖包yum -y install pcre-...",
    "content": "1. 下载Nginx安装包http://nginx.org/download/2. 解压Nginx压缩包tar zxvf nginx-1.23.4.tar.gz3. 进入Nginx目录下cd /nginx/nginx-1.23.44. 配置安装运行目录./configure --prefix=/usr/local/nginx5. 出现错误需要安装依赖包yum -y install pcre-develyum -y install gccyum -y install openssl openssl-devel# 进行重新配置./configure --prefix=/usr/local/nginx6. 执行编译安装make &amp;&amp; make install7. 安装完毕，进入Nginx下的sbin目录并启动Nginxcd /usr/local/nginx/sbin# 启动nginx./nginx# 或./nginx -c /usr/local/nginx/conf/nginx.conf# 停止nginx./nginx -s stop# 停止nginx（等待进程处理完毕进行关闭）./nginx -s quit# 重启nginx./nginx -s reload# 查看Nginx配置是否正确nginx -t "
  },
  
  {
    "title": "Git清除用户名密码",
    "url": "/posts/git-qingchu-yonghu-xinxi/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2023-04-03 13:47:00 +0800",
    





    
    "snippet": "清空所有用户名和密码git config –system –unset credential.helper如果不好使，那就得去Windows管理凭据里更改了控制面板 — 用户账户 — Windows管理凭据 — 编辑",
    "content": "清空所有用户名和密码git config –system –unset credential.helper如果不好使，那就得去Windows管理凭据里更改了控制面板 — 用户账户 — Windows管理凭据 — 编辑"
  },
  
  {
    "title": "一个域名可以对应多个IP地址吗",
    "url": "/posts/yige-yuming-keyi-duiying-duoge-ip/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-04-03 13:47:00 +0800",
    





    
    "snippet": "一个域名可以对应多个IP的，在用户访问过程中，会指向某一个具体IP，并不会同时访问多个IP。一个域名对应多个IP地址的时候，智能DNS服务器会根据请求的线路、地理位置等信息综合考虑，返回对于该请求最快的IP。如一个域名可以分给电信、联通、南方、北方等多个线路多台分布式的服务器使用，这样对各种用户来说，访问的服务器都是距离自己较近的。",
    "content": "一个域名可以对应多个IP的，在用户访问过程中，会指向某一个具体IP，并不会同时访问多个IP。一个域名对应多个IP地址的时候，智能DNS服务器会根据请求的线路、地理位置等信息综合考虑，返回对于该请求最快的IP。如一个域名可以分给电信、联通、南方、北方等多个线路多台分布式的服务器使用，这样对各种用户来说，访问的服务器都是距离自己较近的。"
  },
  
  {
    "title": "SNAT和DNAT的区别",
    "url": "/posts/snat-he-dnat/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-04-03 13:47:00 +0800",
    





    
    "snippet": "SNAT是原地址转换，DNAT是目标地址转换。区分这两个功能可以简单的由服务的发起者是谁来区分，内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有IP，网关这个地址转换称为SNAT。当内部需要对外提供服务时，外部发起主动连接，路由器或者防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有IP的网关代替内部服务来接收外部的连接，然后在内部做地址转换，此转换...",
    "content": "SNAT是原地址转换，DNAT是目标地址转换。区分这两个功能可以简单的由服务的发起者是谁来区分，内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有IP，网关这个地址转换称为SNAT。当内部需要对外提供服务时，外部发起主动连接，路由器或者防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有IP的网关代替内部服务来接收外部的连接，然后在内部做地址转换，此转换称为DNAT，主要用于内部服务对外发布。"
  },
  
  {
    "title": "MySQL修改密码提示ERROR 1054",
    "url": "/posts/mysql-xiugai-mima-tishi-error/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2023-03-30 09:47:00 +0800",
    





    
    "snippet": "报错信息执行update mysql.user set password=password('password') where user='root';会出现以下错误ERROR 1054 (42S22): Unknown column 'password' in 'field list'。报错原因MySQL数据库下已经没有password这个字段了，password字段改成了authenti...",
    "content": "报错信息执行update mysql.user set password=password('password') where user='root';会出现以下错误ERROR 1054 (42S22): Unknown column 'password' in 'field list'。报错原因MySQL数据库下已经没有password这个字段了，password字段改成了authentication_string。解决办法mysql&gt; update mysql.user set authentication_string=PASSWORD('password') where user='root';Query OK, 1 row affected, 1 warning (0.15 sec)Rows matched: 1 Changed: 1 Warnings: 1"
  },
  
  {
    "title": "MySQL进行删除等操作时卡死",
    "url": "/posts/mysql-shujuku-kasi-zenmeban/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2023-03-30 09:47:00 +0800",
    





    
    "snippet": "报错信息删除MySQL数据库中一个库出现卡死情况。解决办法进入MySQL使用命令show full processlist;查看当前的操作process，然后执行kill processid;删除对应id的process（都删了，或者删除waiting的就行）。",
    "content": "报错信息删除MySQL数据库中一个库出现卡死情况。解决办法进入MySQL使用命令show full processlist;查看当前的操作process，然后执行kill processid;删除对应id的process（都删了，或者删除waiting的就行）。"
  },
  
  {
    "title": "CentOS安装Redis",
    "url": "/posts/centos-anzhuang-redis/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-03-03 01:47:00 +0800",
    





    
    "snippet": "1. 下载Redis安装包https://redis.io/download/2. 安装依赖yum install -y gcc gcc-c++3. 解压并安装redistar -zxvf redis-7.0.11.tar.gzcd redis-7.0.11makecd srcmake install PREFIX=/usr/local/redis4. 整理文件夹cd /usr/local/...",
    "content": "1. 下载Redis安装包https://redis.io/download/2. 安装依赖yum install -y gcc gcc-c++3. 解压并安装redistar -zxvf redis-7.0.11.tar.gzcd redis-7.0.11makecd srcmake install PREFIX=/usr/local/redis4. 整理文件夹cd /usr/local/redismkdir binmkdir datamkdir logmkdir etc5. 迁移常用命令将原编译目录src路径下的常用命令移动到bin目录下mv mkreleasehdr.sh redis-benchmark redis-check-aof redis-cli \\redis-server redis-sentinel /usr/local/redis/bin/将原编译目录redis.conf、sentinel.conf文件移动到etc路径下mv redis.conf /usr/local/redis/etcmv sentinel.conf /usr/local/redis/etc6. 修改Redis配置文件主从复制可以是服务高可用，同时如果数据访问量过大，也可以缓解读取数据压力，能达到高可用，读写分离，服务宕机数据不丢失等目的。实现Redis的主从复制有多种方式，本文采用的是Redis自带的sentinel哨兵机制达到服务高可用及主从复制的目的。根据上面Linux安装单机Redis的步骤，安装三台Redis，如果条件有限也可在一台服务器启动三个不同端口的Redis服务。配置Redis主从很简单，只需要将主机的IP和端口配置到从机的redis.conf文件最后，重启各个从节点的服务，主从复制配置就完成了。# 表示允许远程连接# bind不是针对远程客户端的IP，而是服务器的网卡IP，远程客户端通过服务器的网卡地址来连接Redisbind 0.0.0.0主节点vi redis.confbind * -::*daemonize yes                        # 表明需要在后台运行logfile \"/usr/local/redis/log/redis.log\"masterauth \"123456\"                  # 其它Redis视我为master时的验证密码requirepass \"123456\"                 # 本机Redis的登录密码maxmemory 100mbdir /usr/local/redis/dataport 6379主哨兵vi sentinel.confbind 192.168.182.136daemonize yeslogfile \"/usr/local/redis/log/sentinel.log\"sentinel monitor mymaster 192.168.182.136 6379 2sentinel auth-pass mymaster 123456port 6479dir /usr/local/redis/data-sentinel从节点vi redis.confbind * -::*daemonize yeslogfile \"/usr/local/redis-slave/log/redis.log\"masterauth \"123456\"                  # 其它Redis视我为master时的验证密码requirepass \"123456\"                 # 本机Redis的登录密码maxmemory 100mbdir /usr/local/redis-slave/datareplicaof 192.168.182.136 6379         # master的IP和Redis端口port 26379从哨兵vi sentinel.confbind 192.168.182.136daemonize yeslogfile \"/usr/local/redis-slave/log/sentinel.log\"sentinel monitor mymaster 192.168.182.136 6379 2 # master的IP和Redis端口sentinel auth-pass mymaster 123456port 26479dir /usr/local/redis-slave/data-sentinel7. 启动# 启动主节点/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf# 启动从节点/usr/local/redis-slave/bin/redis-server /usr/local/redis-slave/etc/redis.conf# 启动主节点哨兵/usr/local/redis/bin/redis-sentinel /usr/local/redis/etc/sentinel.conf# 启动从节点哨兵/usr/local/redis-slave/bin/redis-sentinel /usr/local/redis-slave/etc/sentinel.conf8. 登录# 登录主节点/usr/local/redis/bin/redis-cli -h 192.168.182.136 -p 6379 -a 123456# 登录从节点/usr/local/redis/bin/redis-cli -h 192.168.182.136 -p 26379 -a 123456需要认证的输入密码认证，没设置密码可略过192.168.182.136:6379&gt; auth 密码OK192.168.182.136:6379&gt;9. 常用命令info replication # 节点信息CONFIG GET dir   # 数据存放位置10. 验证# 验证主从复制# 在主节点添加key，然后登录从节点查看是否复制到了从节点。# 验证哨兵# 把master的redis服务停掉192.168.182.136:6379&gt; shutdown# 等待5秒后，查看从上的Redis服务是否升级为了master192.168.182.136:6379&gt; info replication# 如果结果中的role为master说明主从切换成功11. 其他安全配置# 重命名或者禁用危险的命令vi redis.confrename-command FLUSHALL \"\"rename-command FLUSHDB  \"\"rename-command PEXPIRE  \"\"rename-command SPOP     \"\"rename-command SREM     \"\"rename-command RENAME   \"\"#rename-command CONFIG   \"\"#rename-command DEL      \"\"FLUSHDB,FLUSHALL,PEXPIRE,DEL,SPOP,SREM,RENAME命令可能无法使用，则不能清空当前数据库，也不能清空所有数据库，也不能设置键的有效时间，也不能删除键，也不能从集合中随机删除元素，也不能删除集合中的元素，也不能重命名键。# 开启protected-mode模式vi redis.confprotected-mode yes我们想要其他机器连接我们的Redis服务，有三种方式：  想办法让Redis运行在protected-mode为no的模式。  如果protected-mode为yes，那么我们可以在Redis服务上设置bind，也就是我们的一台机器有几个IP，指定我们的服务绑定监听本机的哪个IP。  如果protected-mode为yes，除了设置bind外，亦可通过设置密码的形式，也即是设置参数requirepass，从而达到可以从其他机器访问的目标。"
  },
  
  {
    "title": "GitHub访问不了",
    "url": "/posts/github-fangwenman/",
    "categories": "Knowledge, GitHub",
    "tags": "GitHub",
    "date": "2023-03-01 13:47:00 +0800",
    





    
    "snippet": "修改hosts文件，该文件在Windows系统的路径C:\\Windows\\System32\\drivers\\etc\\hosts。把以下内容粘贴到hosts文件中。# GitHub520 Host Start140.82.114.25                 alive.github.com140.82.114.6                  api.github.com185....",
    "content": "修改hosts文件，该文件在Windows系统的路径C:\\Windows\\System32\\drivers\\etc\\hosts。把以下内容粘贴到hosts文件中。# GitHub520 Host Start140.82.114.25                 alive.github.com140.82.114.6                  api.github.com185.199.110.153               assets-cdn.github.com185.199.108.133               avatars.githubusercontent.com185.199.108.133               avatars0.githubusercontent.com185.199.108.133               avatars1.githubusercontent.com185.199.108.133               avatars2.githubusercontent.com185.199.108.133               avatars3.githubusercontent.com185.199.108.133               avatars4.githubusercontent.com185.199.108.133               avatars5.githubusercontent.com185.199.108.133               camo.githubusercontent.com140.82.114.21                 central.github.com185.199.108.133               cloud.githubusercontent.com140.82.112.10                 codeload.github.com140.82.112.21                 collector.github.com185.199.108.133               desktop.githubusercontent.com185.199.108.133               favicons.githubusercontent.com140.82.113.3                  gist.github.com52.217.37.228                 github-cloud.s3.amazonaws.com52.216.35.249                 github-com.s3.amazonaws.com52.216.210.105                github-production-release-asset-2e65be.s3.amazonaws.com52.216.37.201                 github-production-repository-file-5c1aeb.s3.amazonaws.com52.217.201.177                github-production-user-asset-6210df.s3.amazonaws.com192.0.66.2                    github.blog140.82.112.4                  github.com140.82.112.18                 github.community185.199.109.154               github.githubassets.com151.101.129.194               github.global.ssl.fastly.net185.199.110.153               github.io185.199.108.133               github.map.fastly.net185.199.110.153               githubstatus.com140.82.113.26                 live.github.com185.199.108.133               media.githubusercontent.com185.199.108.133               objects.githubusercontent.com13.107.43.16                  pipelines.actions.githubusercontent.com185.199.108.133               raw.githubusercontent.com185.199.108.133               user-images.githubusercontent.com13.107.226.51                 vscode.dev# Update time: 2023-03-01T14:06:17+08:00# Update url: https://raw.hellogithub.com/hosts# Star me: https://github.com/521xueweihan/GitHub520# GitHub520 Host End大部分情况下是直接生效，如未生效可尝试下面的办法刷新DNS，Windows系统在CMD窗口输入：ipconfig /flushdns。以上信息来源于GitHub520，Github地址：https://github.com/521xueweihan/GitHub520。"
  },
  
  {
    "title": "Oracle 连接总是中断",
    "url": "/posts/oracle-lianjie-zongshi-zhongduan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2023-03-01 01:47:00 +0800",
    





    
    "snippet": "报错信息Mon Nov 16 13:41:19 2020**********************************************************************Fatal NI connect error 12170. VERSION INFORMATION:TNS for Linux: Version 11.2.0.4.0 - ProductionOra...",
    "content": "报错信息Mon Nov 16 13:41:19 2020**********************************************************************Fatal NI connect error 12170. VERSION INFORMATION:TNS for Linux: Version 11.2.0.4.0 - ProductionOracle Bequeath NT Protocol Adapter for Linux: Version 11.2.0.4.0 - ProductionTCP/IP NT Protocol Adapter for Linux: Version 11.2.0.4.0 - ProductionTime: 16-NOV-2020 13:41:19Tracing not turned on.Tns error struct:ns main err code: 12535 TNS-12535: TNS:operation timed outns secondary err code: 12560nt main err code: 505 TNS-00505: Operation timed outnt secondary err code: 110nt OS err code: 0Client address: (ADDRESS=(PROTOCOL=tcp)(HOST=10.0.128.100)(PORT=20233))报错原因上述报错表示，一个会话与Oracle实例建立连接之后断开了。断开原因可能是会话空闲，一直没有数据通信，最终连接时间是超过了防火墙设置的最大空闲时长（idle time），最终断开连接。“nt secondary err code” 表示网络传输超时（TCP/IP）。“nt secondary err code” 也指出了操作系统类型。110是Linux x86或者Linux x86-64；238是HP-UX；78是AIX；145是Solaris。解决方法1、增大防火墙的空闲时间。网络一般不大可能修改。2、在sqlnet.ora中增加sqlnet.expire_time参数（单位：分钟）。当连接长时间空闲时，定时模仿客户端与数据库实例之间的通信，确保不会被防火墙断开。$ cat $ORACLE_HOME/network/admin/sqlnet.oraSQLNET.EXPIRE_TIME=1表示空闲连接1分钟客户端与服务端通信一次。加上该参数后，无需重启监听，参数对新连接生效。原有连接可能依然会出现上面的情况，直到所有原有连接遇到上面的问题断开后重新连接时，这个错误会彻底消失。  参考：TNS-12535: TNS:operation timed out TNS-00505: Operation timed out"
  },
  
  {
    "title": "CentOS安装MySQL",
    "url": "/posts/centos-anzhuang-mysql/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-03-01 01:47:00 +0800",
    





    
    "snippet": "1. 检测系统是否有自带MySQL#检查是否安装过MySQLrpm -qa | grep mysql #检查是否存在Mariadb数据库（内置的MySQL数据库），有则强制删除rpm -qa | grep mariadb #强制删除rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 rpm -e --nodeps mariadb-5.5.68-1...",
    "content": "1. 检测系统是否有自带MySQL#检查是否安装过MySQLrpm -qa | grep mysql #检查是否存在Mariadb数据库（内置的MySQL数据库），有则强制删除rpm -qa | grep mariadb #强制删除rpm -e --nodeps mariadb-libs-5.5.68-1.el7.x86_64 rpm -e --nodeps mariadb-5.5.68-1.el7.x86_64 2. 文件上传到Linux服务器后进行解压# 本次安装目录为/data/databasemkdir -p /data/database# 解压MySQl安装包tar -zxvf mysql-5.7.17-linux-glibc2.5-x86_64.tar.gz# MySQL安装包名字太长，为了方便输入，我们更改一下文件夹的名字mv mysql-5.7.17-linux-glibc2.5-x86_64/ mysql-5.7.173. 创建mysql用户组和mysql用户# 创建mysql用户组groupadd mysql# 创建mysql用户并放入mysql用户组useradd -g mysql mysql# 设置mysql密码passwd mysql 4. 建立必要的目录# 数据存放目录mkdir /data/database/mysql-5.7.17/data# 日志目录和日志文件mkdir /data/database/mysql-5.7.17/logtouch /data/database/mysql-5.7.17/log/mysqld.log# pid目录和记录mysqld进程pid的文件mkdir /data/database/mysql-5.7.17/pidtouch /data/database/mysql-5.7.17/pid/mysqld.pid5. 更改所属的组和用户chown -R mysql:mysql /data/database/mysql-5.7.176. 在etc下新建配置文件my.cnf从MySQL-3.X开始，MySQL的配置文件加载顺序最优先就是/etc/my.cnf。# 查找my.cnf的位置/data/database/mysql-5.7.17/bin/mysqld --verbose --help |grep -A 1 'Default options'# MySQL寻找my.cnf的顺序为/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf /home/mysql-5.7.17/my.cnf ~/.my.cnf 新建配置文件my.cnf。cd /etctouch my.cnfvi my.cnf在my.cnf里输入以下配置信息。[client]default-character-set=utf8[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]skip-name-resolve#设置3306端口port = 3306 # 设置mysql的安装目录basedir=/data/database/mysql-5.7.17# 设置mysql数据库的数据的存放目录datadir=/data/database/mysql-5.7.17/data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB # 设置忽略大小写# lower_case_table_names=0 表名存储为给定的大小和比较是区分大小写的# lower_case_table_names = 1 表名存储在磁盘是小写的，但是比较的时候是不区分大小写# lower_case_table_names=2 表名存储为给定的大小写但是比较的时候是小写的lower_case_table_names=1max_allowed_packet=200Msql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES# 定期清理日志expire_logs_days=3log-error=/data/database/mysql-5.7.17/log/mysqld.logpid-file=/data/database/mysql-5.7.17/pid/mysqld.pid7. 初始化数据库有两种方式，在5.7.6之前初始化的方法是：cd /data/database/mysql-5.7.17/bin./mysql_install_db \\--user=mysql \\--basedir=/data/database/mysql-5.7.17/ \\--datadir=/data/database/mysql-5.7.17/data/5.7.6之后的版本初始化数据库不再使用mysql_install_db：cd /data/database/mysql-5.7.17/bin./mysqld \\--user=mysql \\--basedir=/data/database/mysql-5.7.17 \\--datadir=/data/database/mysql-5.7.17/data \\--lower-case-table-names=1 \\--initialize# --lower-case-table-names=1是因为my.cnf中，我们要开启表名大小写敏感# 这个不能在后期设置，必须在安装阶段初始化时进行设置# 否则my.cnf中不可以配置该属性，配置了库会启动失败。如果出现如下图所示则为安装成功，红线部分为生成的默认密码：默认密码一定要记住，一会要用。默认密码在mysqld.log日志里，如果忘记了可以到日志里找。初始化完成后把/etc/my.cnf复制到/data/database/下，然后删除/etc/my.cnf，启动时加载/data/database/my.cnf，防止损坏数据库。8. 配置启动文件cp /data/database/mysql-5.7.17/support-files/mysql.server /etc/init.d/mysqld# 或创建软链ln -s /data/database/mysql-5.7.17/support-files/mysql.server /etc/init.d/mysql9. 创建软链mysqld_safe默认会从/usr/local/mysql/bin目录中去寻找启动脚本mysqld，但是我安装mysql的目录是/data/database/mysql-5.7.17，因此可以在/usr/local/mysql/bin/目录下创建一个/home/mysql-5.7.17/bin/mysqld的软链。mkdir -p /usr/local/mysql/binln -s /data/database/mysql-5.7.17/bin/mysqld /usr/local/mysql/bin/mysqld 10. 配置启动脚本startMySQL.sh#!/bin/shLANG=en_US.UTF-8MYSQL_HOME=/data/database/mysqlPATH=$MYSQL_HOME/bin:$PATH mysqld --defaults-file=/data/database/my.cnf &amp;stopMySQL.sh#!/bin/sh LANG=en_US.UTF-8MYSQL_HOME=/data/database/mysqlPATH=$MYSQL_HOME/bin:$PATHmysqladmin --defaults-file=/data/database/my.cnf  -uroot -p  shutdown echo '查询进程ID和端口监听,没有正常退出的话，自己kill吧！'echo 'ps -ewf | grep mysqld'ps -ewf | grep mysqld echo 'netstat -na |grep 13306'11. 配置环境变量su mysqlvi ~/.bash_profile# 添加以下内容export MYSQL_HOME=/data/database/mysql-5.7.17/export PATH=$PATH:$MYSQL_HOME/bin# 刷新环境变量source ~/.bash_profile  关于环境变量      etc目录下存放系统管理和配置文件 (系统配置)              /etc/profile：为所有的用户设置系统范围的环境变量和启动顺序，当用户登录时读取该文件，该文件被执行并从/etc/profile.d目录的配置文件中搜集shell的设置，这个文件对每个shell都有效。        /etc/bashrc：为每一个运行bash shell的用户执行此文件，当bash shell被打开时该文件被读取。也就是说，当用户shell执行了bash时，运行这个文件。              用户配置              ~/.profile：每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次。默认情况下，它设置一些环境变量，然后执行用户的.bashrc文件。        ~/.bashrc：该文件包含专用于某个用户的bash shell的bash信息，当该用户登录时以及每次打开新的shell时，该文件被读取。        ~/.bash_profile：文件中内容调用的是~/.bashrc文件。            12. 修改临时密码su mysql# 用临时密码登录mysqlmysql -u root –p# 修改成新的密码mysql&gt; set password for root@localhost = password('root');13. 开放远程连接use mysql;# GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '远程连接密码'; grant all privileges on *.* to 'root'@'%' identified by 'root';# 刷新授权flush privileges;# 退出quit;14. 开放3306端口su root# 开启3306firewall-cmd --zone=public --add-port=3306/tcp --permanent# 重启防火墙firewall-cmd --reload# 查看已经开放的端口firewall-cmd --list-ports 15. 设置开机自启# 将服务文件拷贝到init.d下，并重命名为mysql，这一步前面已经做过cp /home/mysql-5.7.17/support-files/mysql.server /etc/init.d/mysqld# 赋予可执行权限chmod +x /etc/init.d/mysqld# 添加服务chkconfig --add mysqld# 显示服务列表chkconfig --list至此，CentOS7安装MySQL-5.7.17完成。16. 新建MySQL用户并授权# 新建用户test1，密码test1mysql&gt; CREATE USER 'test1'@'localhost' IDENTIFIED BY 'test1';# 授予普通DBA管理某个MySQL数据库的权限mysql&gt; grant all privileges on testdb to test1@'localhost'"
  },
  
  {
    "title": "CentOS安装MySQL - 生产环境MySQL安装规划及调优",
    "url": "/posts/centos-anzhuang-mysql-shengchanhuanjing-guihua-ji-tiaoyou/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-03-01 01:47:00 +0800",
    





    
    "snippet": "一、生产环境MySQL部署问题  生产环境MySQL使用yum安装部署，这是大忌，因为生产环境的系统，通常硬件维护、操作系统维护都是分在不同的管理部门进行管理。作为应用厂商使用的自行维护的数据库，使用yum或rpm包安装方式安装，就意味着每次维护都需要root级别的权限，因为不管是my.cnf，还是MySQL的主程序文件，基本都在root用户权限下。每次要进行升级及维护，都需要申请root或...",
    "content": "一、生产环境MySQL部署问题  生产环境MySQL使用yum安装部署，这是大忌，因为生产环境的系统，通常硬件维护、操作系统维护都是分在不同的管理部门进行管理。作为应用厂商使用的自行维护的数据库，使用yum或rpm包安装方式安装，就意味着每次维护都需要root级别的权限，因为不管是my.cnf，还是MySQL的主程序文件，基本都在root用户权限下。每次要进行升级及维护，都需要申请root或sudo权限，这种流程是非常复杂的，因为操作系统root权限太敏感。其次即使你有了root权限，由于是生产系统，你也不大可能在升级的时候，直接yum升级，万一升级失败毫无退路可言。  第二个大忌，就是MySQL的目录没有规划，配置文件内容混乱，没有任何注释。目录不进行合理规划，后期很难升级，打补丁。二、生产环境的特点及约束  业务连续性，数据库作为后端最重要的设施，其重要程度非常高。不论做什么操作，全库不可访问的时间，都应尽量的短，甚至是不能中断。  MySQL这种数据库，需要根据不同的业务场景，专门进行定向优化，所以只要你是会用到MySQL的开发人员，MySQL库从部署、升级、使用、调优，必须完全掌握。  生产操作系统root权限，一般都是被回收管控的，不可以轻易申请到。三、生产环境MySQL部署原则  规避root权限问题，MySQL应在普通用户权限下以二进制包方式或编译方式部署。  MSQL的部署应做到程序、配置、数据三分离，做好良好的目录路径规划。通常如果不是版本跃迁式的升级，MySQL的data路径下的库存储数据文件是通用的，比如8.0.2版本的MySQL库的data路径，可以被8.0.29的直接访问，不会有什么问题。大版本内的库版本升级，通常不需要做全库导出和导入的恢复性操作。  数据库是非常重要的生产设施，MySQL虽然在网上有很多双主、一主多从等等的部署方案。其实在日常使用中，最稳定可靠的方案，还是主从方案。故障率最高的是双主方案。主从方案中，也不建议配置自动化的浮动IP飘动方案或切换方案。生产环境的数据库非常重要，自动化的浮动IP飘动和切换方案，经常会因为网络波动、安全扫描等各种因素，发生IP频繁飘切，影响业务稳定性，诱发业务数据层级问题。  要考虑到并行双测的场景。往往跨大版本数据库升级，除了在测试环境先要做演练之外。生产环境的MySQL部署时，需要考虑到多版本多实例服务器并存的要求。即为了保证秒切，或者瞬间切换，通常的做法是在MySQL所在的服务器上，再装一套目标版本MySQL实例，并且启动起来监听端口设置在不同的端口，进行调试、测试、配置、如果硬盘空间允许，还要进行数据的核查和比对，确保大部分历史数据都一致，以及比对一致点的binlog位置。然后切换时，只是把原主库停止，新库用对应的端口配置文件直接拉起，10秒左右完成切换。四、生产环境MySQL部署知识点4.1 MySQL的配置文件加载顺序（Linux）从MySQL-3.X开始，MySQL的配置文件加载顺序最优先就是/etc/my.cnf，这个很关键，所以为了适应生产环境部署的特点，/etc下的MySQL配置文件最好是全部清除，会为以后多实例并行，多版本并行，安全补丁升级验证带来巨大方便。同时，把/etc/my.cnf等系统默认公共路径的配置文件删掉可以防止误操作搞坏当前库。MySQL服务启动需要读取配置文件，如果存在多个my.cnf 配置文件时，注意加载顺序。不同的大版本加载顺序稍微有差异，但基本就是这几个位置：系统公共配置路径/etc、MySQL程序安装路径、用户HOME路径、其他自定义路径下的my.cnf：/etc/my.cnf/etc/mysql/my.cnf$MYSQL_HMOE/my.cnf~/.my.cnf注意默认是优先匹配原则，即如果它遇到了/etc/my.cnf后面的配置它就不会再去找了。不管是mysqld服务器端程序，还是MySQL客户端程序，都可以采用下面两个参数来强制指定要读取的配置文件路径：-defaults-file=XXX，只读取指定的文件（不再读取其他配置文件）-defaults-extra-file=XXX从其他优先级更高的配置文件中读取全局配置后，再读取指定的配置文件（有些选项可以覆盖掉全局配置从的设定值）不建议使用，除非你能搞清楚多个配置文件之间加载覆盖的关系，否则容易发生混乱。加载细节说明：  没有/etc/my.cnf、/etc/mysql/my.cnf、/usr/etc/my.cnf、 ~/.my.cnf文件，且/usr/bin/mysqld_safe和/usr/sbin/mysqld都没有指定–defaults-file的情况下，也就是没有任何配置文件的情况下所有的配置都是默认值；  my.cnf会覆盖mysql.server里的basedir和datadir配置；  mysqld和mysqld_safe指定–defaults-file的话，那么MySQL的配置文件就是–defaults-file对应的文件，而不是默认的/etc/my.cnf文件；  mysqld或mysqld_safe命令行参数里指定的配置参数最大，其次是–defaults-file指定的my.cnf配置文件参数最大；  mysqld或mysqld_safe指定参数比如–datadir参数则会覆盖/etc/my.cnf的配置；  mysql.server把默认的/etc/my.cnf中的参数传递给mysqld_safe，mysqld_safe再传递给mysqld；  mysql --help | grep ‘Default options’ -A 1查看my.cnf配置文件的读取顺序。4.2 操作系统环境变量知识点环境变量的加载顺序：系统级–&gt;用户级–&gt;脚本会话级，覆盖顺序刚好倒过来，越靠后的会覆盖前面的。我们修改了系统级或者用户级的环境变量时，Windows会当场立即生效（已经打开的cmd或powershell需要关闭再重开才会生效）。Linux一般是远程操作，需要关闭会话窗口重新登录使配置文件生效，或使用source 配置文件全名重新装载环境配置，例如source /etc/bashrc，使其当前立即生效。五、生产环境MySQL安装规划及调优5.1 安装路径规划通常生产环境的主机都是性能比较强的PC服务器，本次安装的目标服务器CPU 48逻辑核，内存376GB，存储2TB。生产环境主机的操作系统通常安装在独立的物理盘，数据盘通常会以RAID 5或者RAID 10来组盘。程序、数据通常都不放在系统盘，要安装在数据盘。本次安装的目标服务器，数据盘挂载在/data下，我们将所有的程序和数据都有规划性的安装在数据盘里。通常数据盘的挂载路径也是直接分配给应用数据方的。/data路径下我们规划MySQL的安装路径：            路径      描述                  /data/database      历代MySQL实例程序的安装根路径。所有的MySQL不同版本实例、data数据、pid、日志、bin-log文件、sock文件全部存于此路径。              /data/database/mysql      软连接，链接到当前正在主用的MySQL实例程序文件夹。也就是tar.gz解开后的二进制版程序文件夹。              /data/database/data      datadir，数据库数据文件存放文件夹。初始化二进制安装程序时，指定该路径，之后初始化过程中会自动创建。              /data/database/log      log-error，MySQL的日志路径，注意这个不是bin-log。              /data/database/binlog      log-bin，MySQL的binlog存储路径，用于保存数据操作日志，用于库的恢复或者主从同步。              /data/database/mysql_data_back      MySQL备份、导入导出等相关数据文件存储的路径。              /data/database/mysql_loaddata      MySQL的数据装载与导出路径。用于业务场景，有时候直接装载文件比insert要快。              /data/database/my.cnf      MySQL实例的配置文件，手动创建编写。              /data/database/mysql.sock      socket，MySQL的socket文件。配置在my.cnf中，MySQL运行后会自动创建。              /data/database/mysql.pid      pid-file，MySQL的pid进程号文件。配置在my.cnf中，MySQL运行后会自动创建。              /data/database/startMysql.sh      MySQL实例的启动脚本，手动创建编写。              /data/database/stopMysql.sh      MySQL实例的启动脚本，手动创建编写。              /data/database/mysql-8.0.29-el7-x86_64      二进制安装包解压后的路径，解压tar包自动会创建。      以上规划路径，除加粗的路径会在操作过程中自动生成外，其它路径均需要手动提前创建好。如果你自己也需要安装，建议你从database层开始使用该路径规划方案。这样做的好处是。首先，每次下载下来的不同版本的MySQL安装tar.gz，二进制包只会在它解压缩的文件夹位置。数据的配置文件、数据文件data、bin-log等都不在其文件夹下。当新版的实例解压测试好之后，只需要切换database/mysql的软连接指向，即可完成数据库的切换。然后放心的把以前解压的mysql-8.0.xx-el7-x86_64路径删除，生产系统路径下除了在升级时会出现两个不同版本的实例文件夹，平时不会显得乱七八糟。很多生产环境，前仆后继的人员折腾之后，后人根本不敢清理相关文件或文件夹，因为搞不清依赖关系。其次，如果是小版本的升级或者打补丁，我们要在测试环境复原生产场景。这时，只需要把MySQL软连接指向的MySQL版本实例程序tar一份到测试环境，然后将生产的MySQL库配置导出，my.cnf拿下来参数改小。就可以做升级测试。测试无误后，就可以先部署新版本程序，然后修改软连接指向，再重启数据库即可！会给以后的运维带来极大的方便。如果遇到大版本升级，比如8.0升级到9.X或者10.X,当然它们现在都还没诞生，我们假设它向后是不兼容的。那么依然用这种路径规划。由于/etc/my.cnf已经被删除，所以我们可以很容易的在database路径下安装9.X的二进制版本，并且临时性的先将它的配置文件、数据库data路径、bin-log等都先指向到临时目录，启动脚本也可以单独写好，将实例在其它不冲突的端口拉起来，非常简单的就可以实现两个库实例的并行运行，方便生产业务、数据的迁移和并行。等到测试期、并行期结束，再进行正式割接，将文件按规划重新梳理好，将旧的MySQL删除即可。由于startMysql.sh来启动MySQL，因此我们将MySQL依赖的重要的系统环境变量，全部设置在shell会话级，这样不管其它应用怎么魔改操作系统，都不会影响到我部署的MySQL的正常运行，因为那些有问题的环境变量，到了启动脚本就会被覆盖掉！对于stopMysql.sh，有些人会说，不需要那么麻烦，直接kill就可以了。这是生产数据库，直接Kill，很可能会导致库表文件损坏，数据丢失等各种问题。因此专业的做法是mysqladmin命令去shutdown数据库。除非shutdown关闭不掉的挂死的情况下，也要先想办法切断MySQL的监听，比如停掉应用，或者让网络防火墙把端口挡住，过一阵CPU利用率，I/O都回落了，再kill。防止数据或表损坏。  生产环境mysql安装规划及调优实践–mysql8.0.29为例"
  },
  
  {
    "title": "Tomcat设置通过IP+PORT访问项目",
    "url": "/posts/tomcat-shezhi-ipheduankou-fangwen-xiangmu/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2023-02-27 13:47:00 +0800",
    





    
    "snippet": "&lt;!-- 在`&lt;host&gt;`之间增加下列代码，docBase改成webapps下面放的项目名称 --&gt;&lt;Context path=\"\" docBase=\"projectName\" debug=\"0\" reloadable=\"true\" /&gt;",
    "content": "&lt;!-- 在`&lt;host&gt;`之间增加下列代码，docBase改成webapps下面放的项目名称 --&gt;&lt;Context path=\"\" docBase=\"projectName\" debug=\"0\" reloadable=\"true\" /&gt;"
  },
  
  {
    "title": "VMware虚拟机CentOS7磁盘扩容",
    "url": "/posts/vmware-centos-kuorong/",
    "categories": "Knowledge, VMware",
    "tags": "VMware",
    "date": "2023-02-26 13:47:00 +0800",
    





    
    "snippet": "1、给虚拟机添加硬盘将虚拟机关机，然后点6VM顶部菜单栏中的显示或隐藏控制台视图按钮来显示已建立的虚拟机的配置信息然后左边菜单栏点击硬盘，在弹出的对话框选中硬盘，并点击扩展按钮，然后在弹出框中的最大磁盘大小修改未所需要的磁盘大小，比如我现在需要扩容30G，原本的磁盘大小是20G，所以我这里将原本的20G修改成50G，然后点击扩展之后会收到提示，然后开启虚拟机，对磁盘进行进一步的配置2、在系统...",
    "content": "1、给虚拟机添加硬盘将虚拟机关机，然后点6VM顶部菜单栏中的显示或隐藏控制台视图按钮来显示已建立的虚拟机的配置信息然后左边菜单栏点击硬盘，在弹出的对话框选中硬盘，并点击扩展按钮，然后在弹出框中的最大磁盘大小修改未所需要的磁盘大小，比如我现在需要扩容30G，原本的磁盘大小是20G，所以我这里将原本的20G修改成50G，然后点击扩展之后会收到提示，然后开启虚拟机，对磁盘进行进一步的配置2、在系统中挂载磁盘开启虚拟机并登录后，使用命令查看当磁盘状态# df -h可看到当前还是原本的20G，并未扩容，首先先通过命令查看到新磁盘的分区# ls /dev/或者使用# fdisk -l然后对新加的磁盘进行分区操作# fdisk /dev/sda期间，如果需要将分区类型的Linux修改为Linux LVM的话需要在新增了分区之后，选择t，然后选择8e，之后可以将新的分区修改为linux LVM，之后我们可以再次用以下命令查看到磁盘当前情况# fdisk -l重启虚拟机格式化新建分区# reboot，然后将新添加的分区添加到已有的组实现扩容，首先查看卷组名# vgdisplay初始化刚刚的分区# pvcreate /dev/sda3将初始化过的分区加入到虚拟卷组名# vgextend 虚拟卷组名 新增的分区# vgextend centos /dev/sda3再次查看卷组情况# vgdisplay这里可以看到，有30G的空间是空闲的，# df -h查看当前磁盘情况并记下需要扩展的文件系统名，我这里因为要扩展根目录，所以我记下的是/dev/mapper/centos-root扩容已有的卷组容量（这里有个细节，就是不能全扩展满，比如空闲空间是30G，然后这里的话30G不能全扩展上，这里我扩展的是29G）# lvextend -L +需要扩展的容量 需要扩展的文件系统名 # lvextend -L +29G /dev/mapper/centos-root然后我们用命令查看当前卷组# pvdisplay这里可以看到，卷组已经扩容了，以上只是卷的扩容，然后我们需要将文件系统扩容# resize2fs 文件系统名# resize2fs /dev/mapper/centos-root这个是网上很多参考资料的用法，但是在这里报错了解决办法是，首先查看文件系统的格式# cat /etc/fstab | grep centos-root这里可以看到，文件系统是xfs，所以需要xfs的命令来扩展磁盘空间# xfs_growfs 文件系统名# xfs_growfs /dev/mapper/centos-root之后我们再次用命令查看磁盘状态# df -h，可以看到，现在已经扩容成功了！"
  },
  
  {
    "title": "Ant打包时报内存溢出",
    "url": "/posts/ant-dabao-bao-neicunyichu/",
    "categories": "Knowledge, Ant",
    "tags": "Ant",
    "date": "2023-02-26 13:47:00 +0800",
    





    
    "snippet": "报错信息Ant编译任务报错Java Heap Space。解决方法      修改Ant命令脚本    找到Ant的安装目录，进入bin目录，根据不同的环境，修改对应的脚本。Linux下面打开ant脚本，在ant_exec_args=之前加一行代码export ANT_OPTS=-Xmx1024m；Windows下面打开ant.bat， 在@echo off之后加一行代码set ANT_OP...",
    "content": "报错信息Ant编译任务报错Java Heap Space。解决方法      修改Ant命令脚本    找到Ant的安装目录，进入bin目录，根据不同的环境，修改对应的脚本。Linux下面打开ant脚本，在ant_exec_args=之前加一行代码export ANT_OPTS=-Xmx1024m；Windows下面打开ant.bat， 在@echo off之后加一行代码set ANT_OPTS=-Xmx1024m。        更改Ant的javac指令参数    新增以下参数fork=\"true\" memoryMaximumSize=\"1024m\"。注意fork=\"true\"必须与memoryMaxinumSize配套使用。fork=\"true\"是指单独起一个Java进程才处理编译任务。  "
  },
  
  {
    "title": "CentOS安装Oracle",
    "url": "/posts/centos-anzhuang-oracle/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2023-02-26 01:47:00 +0800",
    





    
    "snippet": "一、Oracle安装1.1 Oracle 11g版本选择建议下载11.2.0.4版本，11.2.0.1版本有一些BUG会影响安装。CentOS7安装11.2.0.1遇到的坑：  操作系统内核参数semmni明明设置正确，先决条件检查以然会提示参数不正确。  一些程序包，已经安装过了，先决条件检查以然会提示没有安装。  安装到68%会报错：makefile '/home/oracle/app/...",
    "content": "一、Oracle安装1.1 Oracle 11g版本选择建议下载11.2.0.4版本，11.2.0.1版本有一些BUG会影响安装。CentOS7安装11.2.0.1遇到的坑：  操作系统内核参数semmni明明设置正确，先决条件检查以然会提示参数不正确。  一些程序包，已经安装过了，先决条件检查以然会提示没有安装。  安装到68%会报错：makefile '/home/oracle/app/oracle/product/11.2.0/dbhome_1/ctx/lib/ins_ctx.mk'的目标'install'时出错。另外，11.2.0.4版本普通用户在官网是下载不到的，可以从网盘找资源。1.2 安装和配置VNC安装VNC图形化的操作环境即可进行VNC远程或者直接本地图形化操作，比静默安装更直观。root执行以下命令，直接整体复制粘贴到终端就行。#图形界面必备`X Window System`yum -y groupinstall \"X Window System\"#安装epel源yum -y install epel-release#安装VNC+图形需要的软件yum -y install tigervnc-server openbox xfce4-terminal tint2 cjkuni-ukai-fonts network-manager-applet#自动修改/etc/xdg/openbox/autostart配置文件echo 'if which dbus-launch &gt;/dev/null &amp;&amp; test -z \"$DBUS_SESSION_BUS_ADDRESS\"; then' &gt; /etc/xdg/openbox/autostartecho '       eval `dbus-launch --sh-syntax --exit-with-session`' &gt;&gt; /etc/xdg/openbox/autostartecho 'fi' &gt;&gt; /etc/xdg/openbox/autostartecho 'tint2 &amp;' &gt;&gt; /etc/xdg/openbox/autostartecho 'nm-applet  &amp;' &gt;&gt; /etc/xdg/openbox/autostartecho 'xfce4-terminal &amp;' &gt;&gt; /etc/xdg/openbox/autostartecho ' ' &gt;&gt; /etc/xdg/openbox/autostart#防火墙放行VNC端口firewall-cmd --add-port=5901/tcpfirewall-cmd --add-port=5901/tcp --permanent1.3 创建用户为了安全起见，不建议使用root做为vnc用户。单独创建一个用户比较安全。既然安装Oracle，这里用户名我使用oracle。root执行以下命令，直接整体复制粘贴到终端就行。#创建database用户组groupadd database#创建oracle用户并放入database组中useradd oracle -g database#设置oracle密码passwd oracle #密码我设置的是database@20211.4 开启VNC服务切换到oracle用户。su oracle#首次运行，生成~/.vnc/xstartup等配置文件vncserver :1 -geometry 1920x1080#我这里设置的密码是vnc@2021 oracle用户执行以下命令，直接整体复制粘贴到终端就行。#配置VNC默认启动openboxecho \"openbox-session &amp;\" &gt; ~/.vnc/xstartup# 停止服务vncserver -kill :1#重新开启vnc服务vncserver :1 -geometry 1920x10801.5 客户端连接VNC实现远程控制使用VNC客户端连接，我用的是VNC Viewer ，我的地址如下：172.16.184.5:5901然后输入上面设置的连接密码就可以了。我这里设置的密码是vnc@2021。如果你连接的时候发现没有界面，是黑屏的，只有一个鼠标，那么可以重启一下VNC服务试试。切换到oracle用户su oracle命令：vncserver -kill :1vncserver :1 -geometry 1024x7681.6 安装中文字体解决中文乱码问题默认情况下，因CentOS中缺少中易宋体18030所以会导致中文显示成□□□□□的问题。增加所需字体就行了。下载字体：https://m.rkxy.com.cn/down.php?id=71266 ，root执行以下命令：#新建文件夹mkdir -p /usr/share/fonts/zh_CN/TrueType#zysong.ttf上传到/usr/share/fonts/zh_CN/TrueType目录并赋权chmod 75 /usr/share/fonts/zh_CN/TrueType/zysong.ttf字体安装完成，这样安装Oracle就不会中文乱码了。如果不想用中文界面安装，安装前运行以下命令，临时使用英文环境。LANG=en_US1.7 上传并解压安装包上传安装包到CentOS7服务器。只需要*1of7.zip,*2of7.zip两个压缩包即可。我上传到/home/oracle/目录了。上传以后，文件路径和名称如下：[oracle@localhost ~]$ pwd/home/oracle[oracle@localhost ~]$ lsp13390677_112040_Linux-x86-64_1of7.zip  p13390677_112040_Linux-x86-64_2of7.zip如果没有unzip工具，安装unzip用于文件解压，root执行以下命令：yum install unziporacle用户登录vnc，执行下面命令，解压出database，已备安装使用：#解压第1个zipunzip p13390677_112040_Linux-x86-64_1of7.zip#解压第2个zipunzip p13390677_112040_Linux-x86-64_2of7.zip文件如下：[oracle@localhost ~]$ lsdatabase  p13390677_112040_Linux-x86-64_1of7.zip  p13390677_112040_Linux-x86-64_2of7.zip1.8 安装Oracle安装程序依赖程序包root用户执行以下命令su root：yum -y install binutils compat-libcap1  compat-libstdc++-33 compat-libstdc++-33*.i686 elfutils-libelf-devel gcc gcc-c++ glibc*.i686 glibc glibc-devel glibc-devel*.i686 ksh libgcc*.i686 libgcc libstdc++ libstdc++*.i686 libstdc++-devel libstdc++-devel*.i686 libaio libaio*.i686 libaio-devel libaio-devel*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686 libXp1.9 开始安装Oracleoracle用户登录vnc远程桌面，进入~/database/目录。#进入安装目录cd ~/database/#运行安装程序./runInstaller配置安全更新，根据需要设置，我这里就不设置了。下载软件更新，根据个人需要选择，我这里选择跳过软件更新（S）。网络安装选项，选择创建和配置数据库（C）。桌面类or服务器类，描述中已经说的很清楚了，根据自己需要选择。这里我选择的是服务器类（S）。安装类型，我选默认的，单实例数据库安装（S）根据实际需要选择。典型安装，默认典型安装（T）即可。典型安装配置，主要设置一下密码，其他默认即可。这里密码要在大写字母+小写字母+数字组合。比如：我设置的是Database123。创建产品清单，默认即可。执行先决条件检查，这一步要稍花一些时间处理。每个人的显示可能略有不同。比如：物理内存的检测，我这个1G内存就会提示小于预期。处理方法：  根据提示信息做处理即可，比如：内存小了，加大内存。  执行修补并再次检查（F）可以自动修复  以上都解决不了，百度一下基本都是有解决办法的。没解决之前我的显示如下：执行修补并再次检查（F），方法上面描述的很清楚。root权限执行：/tmp/CVU_11.2.0.4.0_oracle/runfixup.sh执行完后，点击上面对话框中的确定（O）这里发现大部分都修复了。如下：剩下的警告尽量解决，如果自己知道影响不大直接点右上角☐全部忽略即可。比如：我的虚拟机内存，比预期值差30MB左右，影响不大直接忽略也可以。解决方法也很简单，加大内存即可。  解决缺失包：pdksh-5.2.14警告这个警告，我猜测直接忽略就行了。因为本机已经安装了ksh-20120801-142.el7.x86_64。yum search pdksh中搜索没的搜索到它。只能手动安装了。#如果没有wget就安装一下 yum install wget#下载安装包wget  http://vault.centos.org/5.11/os/x86_64/CentOS/pdksh-5.2.14-37.el5_8.1.x86_64.rpm执行安装操作。rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm执行结果如下，与已经安装的冲突了，安装失败了。rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm 警告：pdksh-5.2.14-37.el5_8.1.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥ID e8562897: NOKEY错误：依赖检测失败：    pdksh 与 (已安裝) ksh-20120801-142.el7.x86_64 冲突卸载冲突。rpm -e ksh-20120801-142.el7.x86_64再次安装。rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm全过程如下：[root@localhost ~]# rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm 警告：pdksh-5.2.14-37.el5_8.1.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥ID e8562897: NOKEY错误：依赖检测失败：    pdksh 与 (已安裝) ksh-20120801-142.el7.x86_64 冲突[root@localhost ~]# rpm -e ksh-20120801-142.el7.x86_64[root@localhost ~]# rpm -ivh pdksh-5.2.14-37.el5_8.1.x86_64.rpm警告：pdksh-5.2.14-37.el5_8.1.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥ID e8562897: NOKEY准备中...                          ################################# [100%]正在升级/安装...1:pdksh-5.2.14-37.el5_8.1          ################################# [100%]重新检测，发现警告消失了。  Swap分区设置如果Oracle安装文件检查发现Swap空间不足。大小一般设置为内存的1.5倍。root权限查询当时Swap分区设置情况。swapon -s结果如下：[root@localhost ~]# swapon -m文件名         类型       大小   已用   权限/dev/dm-1   partition  2097148   0      -2或者使用free工具来查看内存和Swap情况。free -m结果如下单位（MB）：[root@localhost ~]# free -m        total   used     free   shared  buff/cache   availableMem:    1475     439     171     13         865         877Swap:   2047      0      2047创建Swap文件，接下来我们将在文件系统上创建Swap文件。我们要在根目录/下创建一个名叫swapfile的文件，当然你也可以选择你喜欢的文件名。该文件分配的空间将等于我们需要的Swap空间。一般为内存的1.5倍以上就好了。也可以根据安装程序的提示来。root执行以下命令，创建swap分区。#创建swap文件 bs=2300的设置的值一般为内存的1.5倍以上 dd if=/dev/zero of=/var/swap bs=2500 count=1000000#需要更改swap文件的权限，确保只有root才可读chmod 600 /var/swap#告知系统将该文件用于swapmkswap /var/swap#开始使用该swapswapon /var/swap#使Swap文件永久生效,/etc/fstab加入配置echo \"/var/swap   swap    swap    sw  0   0\" &gt;&gt; /etc/fstab如果上面创建后发现大小创建错误了。如何重置呢？swapoff -a rm /var/swap上面命令就可以删除了，然后重新创建合适的swap文件就行了。经过我们的不断努力，所有警告都消失了。概要，这里显示了安装配置的概要部分，检查一下是否正确。没问题就开始安装。安装产品，上面折腾了这么久终于迎来了真正的安装操作了。进度70% ins_emagent.mk错误弹框。编辑/home/oracle/app/oracle/product/11.2.0/dbhome_1/sysman/lib/ins_emagent.mk约176行，可以搜索$(MK_EMAGENT_NMECTL)关键字快速找到。修改后如下：#===========================#  emdctl#===========================$(SYSMANBIN)emdctl:\t$(MK_EMAGENT_NMECTL) -lnnz11#===========================#  nmocat#===========================修改完成后，点击重试（R）。复制数据库文件，上面的问题解决后，安装一会儿就会出现如下的界面。耐心等待即可。数据库创建完成，经过一段时间的等待，终于弹出如下界面。执行配置脚本。据上图提示，切换root用户执行上面两个脚本就可以了。执行结果如下：[root@localhost ~]# /home/oracle/app/oraInventory/orainstRoot.sh 更改权限/home/oracle/app/oraInventory.添加组的读取和写入权限。删除全局的读取, 写入和执行权限。更改组名/home/oracle/app/oraInventory 到 database.脚本的执行已完成。[root@localhost ~]# /home/oracle/app/oracle/product/11.2.0/dbhome_1/root.sh Performing root user operation for Oracle 11g The following environment variables are set as:    ORACLE_OWNER= oracle    ORACLE_HOME=  /home/oracle/app/oracle/product/11.2.0/dbhome_1Enter the full pathname of the local bin directory: [/usr/local/bin]:    Copying dbhome to /usr/local/bin ...   Copying oraenv to /usr/local/bin ...   Copying coraenv to /usr/local/bin ...Creating /etc/oratab file...Entries will be added to the /etc/oratab file as needed byDatabase Configuration Assistant when a database is createdFinished running generic part of root script.Now product-specific root actions will be performed.Finished product-specific root actions.[root@localhost ~]# 执行完成这两个脚本，点击确定。Oracle Database的安装已成功。点击关闭即可。1.10 防火墙放行1521# 默认端口是1521，防火墙放行1521端口firewall-cmd --zone=public --add-port=1521/tcp --permanentfirewall-cmd --reload1.11 配置环境变量su oracle切换到oracle用户操作。编辑配置文件。vi ~/.bash_profile文件末尾加入以下内容，ORACLE_HOME中换成你实际安装的路径。export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_1/export ORACLE_SID=orclexport PATH=$PATH:$ORACLE_HOME/bin使用配置文件立即生效。source ~/.bash_profile1.12 启动Oraclesu oraclesqlplus /nologSQL&gt; connect /as sysdbaSQL&gt; startup1.13 sys用户登录[oracle@localhost ~]$ sqlplus /nologSQL*Plus: Release 11.2.0.4.0 Production on Tue Feb 2 02:59:38 2021Copyright (c) 1982, 2013, Oracle.  All rights reserved.SQL&gt; connect as sysdbaEnter user-name: sysEnter password: Connected.SQL&gt; select 1 from dual;\t 1----------\t 1SQL&gt; 没有问题，说明本地连接Oracle成功。1.14 启动监听lsnrctl start1.15 PLSQL连接测试使用其他机器连接我们刚安装好的Oracle进行连接测试。修改配置文件C:\\app\\itkey\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora（路径根据实际情况来）CentOS7ORCL =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.184.5)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = orcl)    )  )二、Oracle创建数据库我们很多操作都是可以通过命令行的形式来完成，但是由于不支持图形模式，在一些需要图形界面的时候就很麻烦。本次设置可以在SecureCRT中直接使用netca\\dbca命令，通过xmanager的passive来显示图形界面。设置display变量，设置的IP为安装xmanager的客户端IP, 例如本地ip为：192.168.1.2[root@test ~]# export DISPLAY=192.168.1.2:0.0其次，我们要在客户端启动Xmanager - Passive程序，最后，我们就可以在SecureCRT工具中直接使用命令来启动图形化界面了。以oracle用户登录系统，打开终端输入dbca，点击下一步点击创建数据库，下一步默认即可，下一步在全局数据库输入你要定义的名称，例如：myoracl，数据库实例名(SID)默认与全局数据库名相同，下一步不勾选配置Enterprise Manager，下一步数据库身份证明，可以为不同的账户分别设置不同的管理口令，也可以为所有账户设置同一口令，单击下一步数据库文件所在位置，默认存储类型：文件系统，存储位置：使用模版中的数据库文件位置，也可以自己指定存储路径，单击下一步恢复配置，指定快速恢复区，默认即可，有需要的可以配置，下一步内存、调整大小、字符集、连接模式可以根据自己的需要设置，下一步数据库存储，控制文件、数据文件、重做日志文件位置设置，单击下一步，创建选项，创建数据库，生成脚本，单击完成，开始创建数据库点击退出即完成数据库创建三、Oracle创建表空间并授权用户-- 登录sys用户sqlplus / as sysdba-- 查询用户表空间文件的路径，然后在此目录下创建新的表空间select name from v$datafile; -- 创建表空间，永久性表空间：一般保存表、视图、过程和索引等的数据create tablespace TESTSERVICESPACE datafile '/home/oracle/app/oracle/oradata/orcl/TESTSERVICESPACE.dbf' size 1024m autoextend on next 100m maxsize unlimited;-- 查询用户临时表空间文件的路径，然后在此目录下创建新的临时表空间select name from v$tempfile;-- 创建临时表空间，临时性表空间：只用于保存系统中短期活动的数据，如计算的中间结果等create temporary tablespace TESTSERVICESPACE_TEMP tempfile '/home/oracle/app/oracle/oradata/orcl/TESTSERVICESPACE_TEMP.dbf' size 200m autoextend on next 40m maxsize unlimited;-- 创建用户、密码并关联表空间和临时表空间create user orauser identified by \"1qaz!QAZ\" default tablespace TESTSERVICESPACE temporary tablespace TESTSERVICESPACE_TEMP;-- 授权，初始建立的用户没有任何权限，不能执行任何数据库操作，因此必须为用户设置权限或者角色grant connect,resource to orauser;-- 授予远程登录权限grant create session to orauser;-- 给表空间配额ALTER USER orauser QUOTA 100M ON TESTSERVICESPACE;-- 表空间配额（三选一即可）-- 您可以给用户，例如username在xxxx表空间中的无限配额ALTER USER orauser QUOTA UNLIMITED ON TESTSERVICESPACE;-- 您还可以定义允许用户在表空间上分配的空间最大值ALTER USER orauser QUOTA 100M ON TESTSERVICESPACE;-- 您还可以授予用户UNLIMITED TABLESPACE系统权限-- 这意味着他对数据库中的任何表空间都有无限的配额GRANT UNLIMITED TABLESPACE TO orauser;四、Oracle的重启4.1 重启监听  以Oracle身份登录数据库：su - oralce  进入监听器控制台：lsnrctl  关闭监听：stop  启动监听：start  查看监听状态：status  退出监听器控制台：exit4.2 重启数据库  以Oracle身份登录数据库：su - oralce  进入sqlplus控制台：sqlplus /nolog  以系统管理员登录：connect / as sysdba  关闭数据库：shutdown immediate          Normal：需要等待所有的用户断开连接      Immediate：等待用户完成当前的语句，并不允许新用户连接      Transactional：等待用户完成当前的事务，并不允许新用户连接      Abort：不做任何等待，直接关闭数据库        启动数据库：startup  退出Sqlplus控制台：exit4.3 重启实例  以Oracle身份登录数据库：su - oralce  查看当前实例：echo $ORACLE_SID  切换需要启动的数据库实例：export ORACLE_SID=ORCL  进入sqlplus控制台：sqlplus /nolog  以系统管理员登录：connect / as sysdba  关闭实例：shutdown abort  启动实例：startup  退出Sqlplus控制台：exit五、一些问题5.1 sqlplus / as sysdba：未找到命令      报错原因    shell环境变量未配置（使用shell远程登录）        解决方法    切换登录用户环境su - oracle，为什么普通切换su oracle仍登录不了，su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell，而后者连用户和Shell环境一起切换了。只有切换了Shell环境才不会出现PATH环境变量错误。          su oracle登录：切换到Oracle身份后用户的home目录和PATH仍然是原先用户的home目录和PATH。      su - oracle登录：相当于重新登陆，此时用户的home目录和PATH等信息会发生改变。        参考：https://github.com/lxyoucan/CentOS7Oracle11gInstallHelper"
  },
  
  {
    "title": "ifconfig命令无法使用",
    "url": "/posts/ifconfig-mingling-wufa-shiyong/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2023-02-24 01:47:00 +0800",
    





    
    "snippet": "修改网络配置，末尾的ifcfg-ens33可根据实际情况更改，有的可能为ifcfg-eth0 或者其他，可先切换到上级目录查看vi /etc/sysconfig/network-scripts/ifcfg-ens33将ONBOOT=no改为ONBOOT=yes，代表系统启动时，网卡也随之启动...DEVICE=ens33ONBOOT=yes...重启网络服务service network r...",
    "content": "修改网络配置，末尾的ifcfg-ens33可根据实际情况更改，有的可能为ifcfg-eth0 或者其他，可先切换到上级目录查看vi /etc/sysconfig/network-scripts/ifcfg-ens33将ONBOOT=no改为ONBOOT=yes，代表系统启动时，网卡也随之启动...DEVICE=ens33ONBOOT=yes...重启网络服务service network restart查询相关软件包yum provides ifconfig安装 net-tools，中间有几步需要手动确认的地方，输入y即可。yum install net-tools"
  },
  
  {
    "title": "WebLogic部署项目",
    "url": "/posts/weblogic-bushu-xiangmu/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2023-01-30 13:47:00 +0800",
    





    
    "snippet": "一种是通过网页部署，另一种是通过目录部署，类似于Tomcat的部署。网页部署登陆之后点击部署 -&gt; 安装选中项目的根路径(G:\\自己的struts项目的适配\\weblogic下调好的项目\\Struts是一个完整的项目，是项目的根路径)点击下一步输入项目的项目名称点击完成即可完成部署，查看项目概述最后查看部署成功的项目浏览器访问进行测试至此，第一种部署方式成功，我门到缓存目录查看发现目录...",
    "content": "一种是通过网页部署，另一种是通过目录部署，类似于Tomcat的部署。网页部署登陆之后点击部署 -&gt; 安装选中项目的根路径(G:\\自己的struts项目的适配\\weblogic下调好的项目\\Struts是一个完整的项目，是项目的根路径)点击下一步输入项目的项目名称点击完成即可完成部署，查看项目概述最后查看部署成功的项目浏览器访问进行测试至此，第一种部署方式成功，我门到缓存目录查看发现目录已经发布到缓存目录目录部署通过将war或者解压后的目录拷贝到%base%\\user_projects\\domains\\base_domain\\autodeploy目录，此目录相当于Tomcat的webapps目录登陆网页查看部署信息访问进行测试通过war包部署将项目打成war包，将war包扔到%base%\\user_projects\\domains\\base_domain\\autodeploy目录下查看部署信息访问测试Weblogic部署项目为默认项目(去除项目名称 = 只能用目录部署)有时候我门希望访问项目不带项目名称，类似于Tomcat的默认项目。我们可以增加一个weblogic.xml目录在WEB-INF目录下，与web.xml同级目录weblogic.xml内容如下&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE weblogic-web-app PUBLIC \"-//BEA Systems, Inc.//DTD Web Application 8.1//EN\"     \"http://www.bea.com/servers/wls810/dtd/weblogic810-web-jar.dtd\"&gt; &lt;weblogic-web-app&gt;  &lt;jsp-descriptor&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;GBK&lt;/param-value&gt;      &lt;/jsp-param&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;pageCheckSeconds&lt;/param-name&gt;        &lt;param-value&gt;-1&lt;/param-value&gt;      &lt;/jsp-param&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;compilerSupportsEncoding&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;      &lt;/jsp-param&gt;      &lt;jsp-param&gt;        &lt;param-name&gt;verbose&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;      &lt;/jsp-param&gt;    &lt;/jsp-descriptor&gt;    &lt;container-descriptor&gt;  　　　　&lt;prefer-web-inf-classes&gt;true&lt;/prefer-web-inf-classes&gt;  &lt;/container-descriptor&gt;   &lt;context-root&gt;/&lt;/context-root&gt; &lt;/weblogic-web-app&gt;&lt;prefer-web-inf-classes&gt;true&lt;/prefer-web-inf-classes&gt;是设置Weblogic优先加载WEB-INF/lib目录的lib。&lt;context-root&gt;/&lt;/context-root&gt;是设置项目的名称，/自然就是默认的项目了。"
  },
  
  {
    "title": "WebLogic目录介绍",
    "url": "/posts/weblogic-mulu-jieshao/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2023-01-29 13:47:00 +0800",
    





    
    "snippet": "日志目录每个Domain(域)都有自己的日志目录，一般启动日志是AdmiServer.log，存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\logs。项目发布目录每个域也都有自己的项目发布目录。存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\Adm...",
    "content": "日志目录每个Domain(域)都有自己的日志目录，一般启动日志是AdmiServer.log，存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\logs。项目发布目录每个域也都有自己的项目发布目录。存放位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_user。JSP编译之后的目录我们需要知道Weblogic编译JSP依赖自己的lib库，所以在编译之后的class文件头部引入自己的lib，而Tomcat也依赖于自己的lib。该目录存放的是JSP编译之后的目录，位置在%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_user\\Struts\\km2umq\\jsp_servlet文件夹下面。而且JSP不会一次性全部编译，是我们第一次访问哪个JSP编译哪个JSP(JSP的延迟编译特性确实给性能带来了不大不小的影响，第一次访问超慢的那种状况给人的感觉非常不好)，而且项目的根目录的JSP编译之后的package是默认的，然后每个目录对应一个package。根目录下的JSP。编译之后的位置%base%\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_user\\Struts\\km2umq\\jsp_servlet\\。目录下的JSP，一个目录相当于一个package。编译之后的位置。存放lib的目录存放一些公共项目使用的lib，存放位置在%base%\\user_projects\\domains\\base_domain\\lib。Weblogic自带的lib类似于Tomcat的lib目录，是Weblogic自己启动所需要的包，一般也是造成冲突包的存放位置在%base%\\wlserver\\modules。缓存目录有时候缓存造成发布问题，所以每次除了清掉缓存目录，还要清掉logs目录和项目tmp目录，也就是每次启动项目都清掉下面三个目录，每次启动都会重新生成下面三个目录。Weblogic位数查看在Weblogic安装目录下wlserver\\server\\native\\win。Weblogic启动Weblogic启动的程序是在%base%\\user_projects\\domains\\base_domain\\startWebLogic.cmd (其内部调用了%base%\\user_projects\\domains\\base_domain\\bin目录下的startWebLogic.cmd)，双击之后启动即可，启动可以访问登陆页面。Weblogic调整JVM参数　JDK7的参数设置-Xms1024m -Xmx1024m -XX:PermSize=512m -XX:MaxPermSize=512mJDK8的参数设置-Xms1024m -Xmx1024m -XX:MetaspaceSize=512m -XX:MaxMetaspaceSize=512mWeblogic12.2.1.3大概在%base%\\user_projects\\domains\\base_domain\\bin\\setDomainEnv.cmd202行左右，Weblogic12.1.3在170行。例如下面是Weblogic12.2.1.3在JDK8环境中配置。重新启动，使用jps+jmap查看JVM参数。控制台查看参数"
  },
  
  {
    "title": "WebLogic基本概念",
    "url": "/posts/weblogic-jiben-gainian/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2023-01-29 13:47:00 +0800",
    





    
    "snippet": "  Domain: 域是个逻辑概念，用来组织管理一系列的应用服务器实例，也就是下面要解释的server。域是WebLogic应用服务器中最大的概念，WebLogic应用服务器启动的时候就是以某个域来启动的，它有一个中心配置文件叫config.xml。  Cluster: 族也是一个逻辑概念，用来分组用途相同的服务器实例，一个域中可以有多个族。  Machine: 机器是物理上的概念，代表一台...",
    "content": "  Domain: 域是个逻辑概念，用来组织管理一系列的应用服务器实例，也就是下面要解释的server。域是WebLogic应用服务器中最大的概念，WebLogic应用服务器启动的时候就是以某个域来启动的，它有一个中心配置文件叫config.xml。  Cluster: 族也是一个逻辑概念，用来分组用途相同的服务器实例，一个域中可以有多个族。  Machine: 机器是物理上的概念，代表一台运行WebLogic应用服务器的实在的机器，包括其IP地址等信息。一个域中可以包括多台机器。  Server: 服务器，也就是一个应用服务器的实例，用来部署和运行各种J2EE应用程序，也可以来配置各种服务程序。它是WebLogic应用服务器的基本服务单元。一个WebLogic域中一般有一个管理服务器和多个被管理服务器。  Administrative Server: 管理服务器是用来管理配置域的中心点，一般来说，管理服务器上是不部署应用程序的，而是用来统一管理、配置、监控被管理服务器以及部署应用程序到被管理服务器上。一个域中有一台管理服务器。  Managed Server: 被管理服务器是用来部署运行各种应用程序的。一个域中有一台或多台被管理服务器。  Node Manager: 节点管理器是一个单独运行的后台程序，一般运行在被管理服务器的机器上，用来提供远程启动和停止服务器（Server）的功能。"
  },
  
  {
    "title": "云计算的三种服务模式：IaaS，PaaS和SaaS",
    "url": "/posts/paas-iaas-saas/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2023-01-29 13:47:00 +0800",
    





    
    "snippet": "2008年，云计算的概念由Google率先提出，短时间内其核心理念在全球范围内迅速传播并发展。2010年在国内形成趋势，各大IT互联网商业巨头将目光聚焦在云计算，至目前，云计算在中国已经慢慢开始成熟起来。云计算指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户，因此任何一个在互联网上提供服务的公司，都可以...",
    "content": "2008年，云计算的概念由Google率先提出，短时间内其核心理念在全球范围内迅速传播并发展。2010年在国内形成趋势，各大IT互联网商业巨头将目光聚焦在云计算，至目前，云计算在中国已经慢慢开始成熟起来。云计算指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户，因此任何一个在互联网上提供服务的公司，都可以称之为云计算公司。然而，并不是所有的云计算公司的服务模式都是一样的，虽然云计算的服务模式在不断变化，在业界根据公司的提供的服务方式，划分为三类：  SaaS（Software as a Service – 软件即服务）  PaaS（Platform as a Service – 平台即服务）  IaaS（Infrastructure as a Service – 基础架构即服务）Iaas（基础设施即服务）IaaS是基础设施即服务。英文全称是Infrastructure as a server。基本属于偏底层，指把IT基础设施作为一种服务通过网络对外提供。在这种服务模型中，用户不用自己构建一个数据中心，而是通过租用的方式来使用基础设施服务，包括服务器、存储和网络等。例如我们可直接购买腾讯云云服务器来使用，而不用自己构建机房、网络、储存等设备。在使用模式上，IaaS与传统的主机托管有相似之处，但是在服务的灵活性、扩展性和成本等方面IaaS具有很强的优势。PaaS（平台即服务）PaaS是平台即服务，英文全称是Platform as a Server。意思就是云端把客户所需的软件的平台作出租。相当于就是云端已经给大家搭建好了平台。一般来说，在用户使用的时候，云端已经搭建好了操作系统、数据库、中间件，运行库等等。用户只需要在这个搭建好的平台上下载、安装并使用自己需要的软件就可以了。腾讯云也是提供PaaS服务的平台。相对IaaS来说，PaaS的自由度和灵活度比较低，不太适合专业性比较高的IT技术从业人员。相当于范围被限定，在特定的范围做一些事情。SaaS（软件即服务）SaaS是软件即服务。英文全称是Software as a Server。到了这个层次，云端已经把操作系统、中间件、数据库、运行库、软件应用都部署好了。大多数SaaS应用程序直接通过浏览器运行，不需要客户端安装。总结对于用户而言，他们之间的关系是独立的，因为他们面向的用户群体不同，如果从技术角度而言，他们也并不是简单的继承关系，SaaS基于PaaS，而PaaS基于IaaS，现在的技术和平台多元化，PaaS可直接构建物理机上。再简单的举个例子，方便更直观的了解三个模式，假如你要开发一个基于小程序商城系统。  第一种方案是：买服务器，买数据库、买域名、开发小程序商城，那这种模式就是IaaS模式  第二种方案是：小程序提供云开发服务，免去了服务器、存储、域名等，我只开发程序即可，这种模式就是PaaS模式。  第三种方案是：微信提供商城程序，你只需开通即可，这种模式就是SaaS模式。  参考：浅谈云计算的三种服务模式：IaaS，PaaS和SaaS"
  },
  
  {
    "title": "跨域问题",
    "url": "/posts/kuayu-wenti/",
    "categories": "Knowledge, Nginx",
    "tags": "Nginx",
    "date": "2022-12-13 13:47:00 +0800",
    





    
    "snippet": "一、跨域问题产生的原因浏览器的同源策略。二、没有同源策略限制的两大危险场景浏览器是从两个方面去做同源策略的，一是针对接口的请求，二是针对DOM的查询。试想一下没有这样的限制上述两种动作有什么危险。2.1、没有同源策略限制的接口请求Cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字...",
    "content": "一、跨域问题产生的原因浏览器的同源策略。二、没有同源策略限制的两大危险场景浏览器是从两个方面去做同源策略的，一是针对接口的请求，二是针对DOM的查询。试想一下没有这样的限制上述两种动作有什么危险。2.1、没有同源策略限制的接口请求Cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将Cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景：你准备去清空你的购物车，于是打开了买买买网站www.maimaimai.com，然后登录成功，你在看有什么东西买的过程中，你的朋友发给你一个链接www.nidongde.com，你饶有兴致地浏览着www.nidongde.com，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向www.maimaimai.com发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！这就是传说中的CSRF攻击。2.2、没有同源策略限制的DOM查询有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？// HTML&lt;iframe name=\"yinhang\" src=\"www.yinhang.com\"&gt;&lt;/iframe&gt;// JS// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Domconst iframe = window.frames['yinhang']const node = iframe.document.getElementById('你输入账号密码的Input')console.log('拿到了这个${node}，还拿不到刚刚输入的账号密码吗')三、同源策略限制下接口请求的正确打开方式3.1、JSONP在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以实现跨域通信。JSONP全称json with padding，填充式的JSON。3.1.1、JSONP的原理  首先是利用script标签的src属性来实现跨域。  通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。  由于使用script标签的src属性，因此只支持GET方法。3.1.2、支持跨域的标签&lt;img src=\"\"&gt; // 图片&lt;link href=\"\"&gt; // CSS&lt;script src=\"\"&gt; // 程序3.1.3、JQuery中的JSONPJQuery中的$.ajax()函数，除了可以发起真正的Ajax数据请求之外，还可以发起JSONP数据请求：$.ajax({    url: 'http://www.liulongbin.top:3006/api/jsonp?name=zs&amp;age=20',    dataType: 'jsonp',    success: function (res) {        console.log(res);    }})默认情况下，使用JQuery发起JSONP请求，会自动携带一个callback=jQueryxxx的参数，jQueryxxx是随机生成的一个回调函数的名称。在JQuery中如果想要自定义JQuery的回调函数名称及JSONP的参数，可通过以下两个参数来指定：$.ajax({    url: 'http://www.liulongbin.top:3006/api/jsonp?name=zs&amp;age=20',    dataType: 'jsonp',    jsonp: 'callback', // 自定义参数的名称  一般让它默认为callback不会做修改    jsonpCallback: 'abc',   // 自定义回调函数的名称    success: function (res) {        console.log(res);    }})JQuery中JSONP的实现过程：JQuery中的JSONP也是通过script标签的src属性来实现跨域数据访问的，只不过，JQuery采用的是动态创建和移除script标签的方式，来发起JSONP数据请求。在发起JSONP请求的时候，动态向&lt;header&gt;中append一个script标签；在JSONP请求成功以后，动态地移除刚刚append进去的script标签。3.2、空iframe加form3.3、CORSCORS是一个W3C标准，全称是跨域资源共享（Cross-origin resource sharing）。看名字就知道这是处理跨域问题的标准做法。浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。只要同时满足以下两大条件，就属于简单请求。  请求方法是以下三种方法之一          HEAD      GET      POST        HTTP的头信息不超出以下几种字段          Accept      Accept-Language      Content-Language      Last-Event-ID      Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain      3.4、代理Nginx配置：server{      # 监听9099端口    listen 9099;    # 域名是localhost    server_name localhost;    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871     location ^~ /api {        proxy_pass http: //localhost:9871;    }   }Nginx转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的API，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下Nginx，如果兼容性没问题（IE 10或者以上），CROS才是更通用的做法吧。"
  },
  
  {
    "title": "Vue打包时url-loader处理CSS中的图片资源遇到的问题",
    "url": "/posts/url-loader-chuli-tupian-ziyuan-wenti/",
    "categories": "Knowledge, Vue",
    "tags": "Vue",
    "date": "2022-12-05 13:47:00 +0800",
    





    
    "snippet": "处理CSS中的图片资源时，我们常用的两种loader是file-loader和url-loader，两者的主要差异在于：url-loader可以设置图片大小限制，当图片超过限制时，其表现行为等同于file-loader，而当图片不超过限制时，则会将图片以base64的形式打包进CSS文件，以减少请求次数。本文主要想说的是我们在使用file-loader或url-loader时经常出现的图片地...",
    "content": "处理CSS中的图片资源时，我们常用的两种loader是file-loader和url-loader，两者的主要差异在于：url-loader可以设置图片大小限制，当图片超过限制时，其表现行为等同于file-loader，而当图片不超过限制时，则会将图片以base64的形式打包进CSS文件，以减少请求次数。本文主要想说的是我们在使用file-loader或url-loader时经常出现的图片地址错误导致图片引用不到的情况，及相应解决办法。工程目录index页面目录-index  -1.jpg  -index.html  -index.js  -index.scsswebpack配置文件中，关于图片的处理{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: 'img/[name].[hash:7].[ext]'    }},index.js文件import './index.scss'index.html文件&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"pic\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;index.scss文件.pic{  width:100px;  height:100px;  background: url('./1.jpg');  background-size: 100px 100px;}打包和分析当我们执行npm run build后查看dist中的情况如下：-dist  -css    -index.min.css  -img    -1.d1efbb3.jpg  -js    -index.html我们通过服务打开index.html会发现页面中并没有图片，并且报错：Failed to load resource:the server responded with a status 1.d1efbb3.jpg of 404 (Not found)这时我们当然是要去看看打包后的CSS文件中的图片路径了：.pic {    width: 100px;    height: 100px;    background: url(img/1.d1efbb3.jpg);    background-size: 100px 100px}/*# sourceMappingURL=index.min.css.map?v=7b7c89f8*/background:url(img/1.d1efbb3.jpg);index.min.css文件竟然去自己的同级目录找img文件夹，当然找不到了，img文件夹位于index.min.css上层，如果是background:url(../img/1.d1efbb3.jpg);就对了。然后我们尝试去修改webpack的配置文件，以达到我们的预期：{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: '../img/[name].[hash:7].[ext]'    }},然后再npm run build，index.min.css内的background的图片地址的确变成了我们想要的：.pic {    width: 100px;    height: 100px;    background: url(../img/1.d1efbb3.jpg);    background-size: 100px 100px}/*# sourceMappingURL=index.min.css.map?v=eef74865*/但是img竟然被打包到了dist文件夹的外面，不再位于dist内了：-dist  -css    -index.min.css  -js    -index.html-img  -1.d1efbb3.jpg看来我们修改配置文件的方法是不对的。分析其中的原因：打包的时候webpack会把scss文件中的background url替换成我们webpack配置文件中的 options的name属性中设置的内容，同时把scss文件中的background url中的图片文件复制到 webpack配置文件中的options的name属性所指向路径下，关键就在这里了。webpack配置文件中的options的name属性所指向路径是相对路径，那么这个路径到底是相对于谁呢？仔细观察会发现它是相对于dist文件夹的，也就是webpack的出口路径。举个例子：{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: 'img/[name].[hash:7].[ext]'    }},上面的配置就会把图片复制到dist/img/1.jpg，然后将index.min.css的background属性改为background:url('img/1.png')，该路径也是相对路径，但是它不相对于dist，而是相对于dist/css，因为我的CSS文件并没有被输出到dist的直接路径下，而是输出到了dist/css下，所以CSS文件就会去dist/css/img/1.png去拿图片，但是图片却位于dist/img/1.png，这就最终导致了CSS文件找不到图片。配置文件复制图片是相对于webpack出口路径的，CSS文件引用图片是相对于CSS文件所在路径的，如果这两个路径相同，也就是webpack出口路径 = CSS文件所在路径，那么很幸运，你的图片是可以找到的。但是一般情况下是不同的，我们习惯于将出口路径定为dist/然后将CSS文件输出到dist/css/，最终导致了引用不到图片的结果。至此原因分析完毕。解决方法在配置项内加入publicPath属性，设置为部署时的绝对路径。比如你的页面会通过如下url方式让用户访问，所有前端文件都放置于http://localhost:63342/url-loader-test/dist/，那么pubilcPath的值就应该是/url-loader-test/dist/，也就是你的部署接口地址。{    test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,    loader: 'url-loader',    options: {        limit: 10000,        name: 'img/[name].[hash:7].[ext]'，        publicPath: \"/url-loader-test/dist/\"         // 该地址不是唯一的，根据你的代码实际路由地址进行修改    }},这样做的原因是，webpack打包时，还会将图片复制到dist/img/1.png，但是他会把CSS文件中的background url改写为publicPath + name，本例中最后生成的index.min.css 如下：.pic {    width: 100px;    height: 100px;    background: url(/url-loader-test/dist/img/1.d1efbb3.jpg);    background-size: 100px 100px}/*# sourceMappingURL=index.min.css.map?v=eef74865*/这时CSS文件中的url地址就变成了一个绝对路由。总结如果我们希望在页面引入图片（包括img的src和background的url）。当我们基于webpack进行开发时，引入图片会遇到一些问题。其中一个就是引用路径的问题。拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。另外，如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况：1.文件大小小于limit参数，url-loader将会把文件转为DataURL；2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。因此我们只需要安装url-loader即可。url-loaderloader中的参数上面提到url-loader的参数和file-loader的参数，那么loader的参数是个什么概念呢？loader的参数用来自定义loader处理文件时的工作特性。下面以url-loader为例，介绍一下webpack的loader中的参数。首先看下面的例子：module.exports = {    // 入口文件路径，__dirname是根目录    entry: __dirname + '/src/main.js',    // 打包生成文件    output: {        path: __dirname + '/output',        filename: 'main.js'    },     module: {        rules: [            {                test: /\\.css$/,                use: ['style-loader', 'css-loader']            },            {                test: /\\.jpeg$/,                use: [                    {                        loader: 'url-loader',                        options: {                            limit: '1024'                        }                    },                ]            }        ]    }}其中，url-loader配置中的options属性表示的就是url-loader的参数，还有一种等价的写法：{    test: /\\.jpeg$/,    use: 'url-loader?limit=1024'}如果有多个参数，就用&amp;连接起来。和http请求中的参数类似。正如前面介绍的，limit这个参数就是告诉url-loader，在文件小于多少个字节时，将文件编码并返回DataURL。url-loader的参数此外url-loader还有一些用于file-loader的参数。我们知道，file-loader的作用是将文件复制到其他目录。file-loader提供了一系列参数允许我们自定义诸如输出文件、文件名规则、发布路径等特性的参数。下面介绍一下这些参数。先看下配置好的代码：module.exports = {    // 入口文件路径，__dirname是根目录    entry: __dirname + '/src/main.js',    // 打包生成文件    output: {        path: __dirname + '/output',        filename: 'main.js'    },     module: {        rules: [            {                test: /\\.css$/,                use: ['style-loader', 'css-loader']            },            {                test: /\\.jpeg$/,                use: 'url-loader?limit=1024&amp;name=[path][name].[ext]&amp;                outputPath=img/&amp;publicPath=output/',            }        ]    }}这里涉及到了4个参数：limit、name、outputPath、publicPath。其中limit已经说明过。file-loader相关的是name、outputPath和publicPath。下面解释一下这3个参数：  name表示输出的文件名规则，如果不添加这个参数，输出的就是默认值：文件哈希。加上[path]表示输出文件的相对路径与当前文件相对路径相同，加上[name].[ext]则表示输出文件的名字和扩展名与当前相同。加上[path]这个参数后，打包后文件中引用文件的路径也会加上这个相对路径。  outputPath表示输出文件路径前缀。图片经过url-loader打包都会打包到指定的输出文件夹下。但是我们可以指定图片在输出文件夹下的路径。比如outputPath=img/，图片被打包时，就会在输出文件夹下新建（如果没有）一个名为img的文件夹，把图片放到里面。  publicPath表示打包文件中引用文件的路径前缀，如果你的图片存放在CDN上，那么你上线时可以加上这个参数，值为CDN地址，这样就可以让项目上线后的资源引用路径指向CDN了。安装url-loadernpm install --save-dev url-loader推荐文档file-loader: https://github.com/webpack-contrib/file-loader  url-loader: http://www.cnblogs.com/ghost-xyx/p/5812902.htmldemohttps://github.com/KIDFUCKER/webpack-demo.git  参考：url-loader处理css中的图片资源遇到的问题"
  },
  
  {
    "title": "ECharts各个配置项详细说明总结",
    "url": "/posts/echarts-gepeizhixiang-shuoming/",
    "categories": "Knowledge, ECharts",
    "tags": "ECharts",
    "date": "2022-12-03 13:47:00 +0800",
    





    
    "snippet": "1、图表标题title: {    x: 'left',              // 水平安放位置，默认为左对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：     ...",
    "content": "1、图表标题title: {    x: 'left',              // 水平安放位置，默认为左对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    // textAlign: null      // 水平对齐方式，默认根据x设置自动调整    backgroundColor: 'rgba(0,0,0,0)',    borderColor: '#ccc',    // 标题边框颜色    borderWidth: 0,         // 标题边框线宽，单位px，默认为0（无边框）    padding: 5,             // 标题内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 主副标题纵向间隔，单位px，默认为10    textStyle: {        fontSize: 18,        fontWeight: 'bolder',        color: '#333'       // 主标题文字颜色    },    subtextStyle: {        color: '#aaa'       // 副标题文字颜色    }},2、图例legend: {    orient: 'horizontal',   // 布局方式，默认为水平布局，可选为：                            // 'horizontal' ¦ 'vertical'    x: 'center',            // 水平安放位置，默认为全图居中，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    backgroundColor: 'rgba(0,0,0,0)',    borderColor: '#ccc',    // 图例边框颜色    borderWidth: 0,         // 图例边框线宽，单位px，默认为0（无边框）    padding: 5,             // 图例内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 各个item之间的间隔，单位px，默认为10，                            // 横向布局时为水平间隔，纵向布局时为纵向间隔    itemWidth: 20,          // 图例图形宽度    itemHeight: 14,         // 图例图形高度    textStyle: {        color: '#333'       // 图例文字颜色    }},3、值域dataRange: {    orient: 'vertical',     // 布局方式，默认为垂直布局，可选为：                            // 'horizontal' ¦ 'vertical'    x: 'left',              // 水平安放位置，默认为全图左对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'bottom',            // 垂直安放位置，默认为全图底部，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    backgroundColor: 'rgba(0,0,0,0)',    borderColor: '#ccc',    // 值域边框颜色    borderWidth: 0,         // 值域边框线宽，单位px，默认为0（无边框）    padding: 5,             // 值域内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 各个item之间的间隔，单位px，默认为10，                            // 横向布局时为水平间隔，纵向布局时为纵向间隔    itemWidth: 20,          // 值域图形宽度，线性渐变水平布局宽度为该值 * 10    itemHeight: 14,         // 值域图形高度，线性渐变垂直布局高度为该值 * 10    splitNumber: 5,         // 分割段数，默认为5，为0时为线性渐变    color: ['#1e90ff','#f0ffff'], // 颜色     // text:['高','低'],    // 文本，默认为数值文本    textStyle: {        color: '#333'       // 值域文字颜色    }}, toolbox: {    orient: 'horizontal',   // 布局方式，默认为水平布局，可选为：                            // 'horizontal' ¦ 'vertical'    x: 'right',             // 水平安放位置，默认为全图右对齐，可选为：                            // 'center' ¦ 'left' ¦ 'right' ¦ {number}（x坐标，单位px）    y: 'top',               // 垂直安放位置，默认为全图顶端，可选为：                            // 'top' ¦ 'bottom' ¦ 'center' ¦ {number}（y坐标，单位px）    color : ['#1e90ff','#22bb22','#4b0082','#d2691e'],    backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色    borderColor: '#ccc',    // 工具箱边框颜色    borderWidth: 0,         // 工具箱边框线宽，单位px，默认为0（无边框）    padding: 5,             // 工具箱内边距，单位px，默认各方向内边距为5，                            // 接受数组分别设定上右下左边距，同css    itemGap: 10,            // 各个item之间的间隔，单位px，默认为10，                            // 横向布局时为水平间隔，纵向布局时为纵向间隔    itemSize: 16,           // 工具箱图形宽度    featureImageIcon : {},  // 自定义图片icon    featureTitle : {        mark : '辅助线开关',        markUndo : '删除辅助线',        markClear : '清空辅助线',        dataZoom : '区域缩放',        dataZoomReset : '区域缩放后退',        dataView : '数据视图',        lineChart : '折线图切换',        barChart : '柱形图切换',        restore : '还原',        saveAsImage : '保存为图片'    }},4、提示框tooltip: {    trigger: 'item',           // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'    showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms    hideDelay: 100,            // 隐藏延迟，单位ms    transitionDuration : 0.4,  // 动画变换时间，单位s    backgroundColor: 'rgba(0,0,0,0.7)',  // 提示背景颜色，默认为透明度为0.7的黑色    borderColor: '#333',       // 提示边框颜色    borderRadius: 4,           // 提示边框圆角，单位px，默认为4    borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）    padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，                               // 接受数组分别设定上右下左边距，同css    axisPointer : {            // 坐标轴指示器，坐标轴触发有效        type : 'line',         // 默认为直线，可选为：'line' | 'shadow'        lineStyle : {          // 直线指示器样式设置            color: '#48b',            width: 2,            type: 'solid'        },        shadowStyle : {                    // 阴影指示器样式设置            width: 'auto',                 // 阴影大小            color: 'rgba(150,150,150,0.3)' // 阴影颜色        }    },    textStyle: {        color: '#fff'    }},5、区域缩放控制器dataZoom: {    orient: 'horizontal',   // 布局方式，默认为水平布局，可选为：                            // 'horizontal' ¦ 'vertical'    // x: {number},         // 水平安放位置，默认为根据grid参数适配，可选为：                            // {number}（x坐标，单位px）    // y: {number},         // 垂直安放位置，默认为根据grid参数适配，可选为：                            // {number}（y坐标，单位px）    // width: {number},     // 指定宽度，横向布局时默认为根据grid参数适配    // height: {number},    // 指定高度，纵向布局时默认为根据grid参数适配    backgroundColor: 'rgba(0,0,0,0)',       // 背景颜色    dataBackgroundColor: '#eee',            // 数据背景颜色    fillerColor: 'rgba(144,197,237,0.2)',   // 填充颜色    handleColor: 'rgba(70,130,180,0.8)'     // 手柄颜色},6、网格grid: {    x: 80,    y: 60,    x2: 80,    y2: 60,    // width: {totalWidth} - x - x2,    // height: {totalHeight} - y - y2,    backgroundColor: 'rgba(0,0,0,0)',    borderWidth: 1,    borderColor: '#ccc'},7、类目轴categoryAxis: {    position: 'bottom',    // 位置    nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'    boundaryGap: true,     // 类目起始和结束两端空白策略    axisLine: {            // 坐标轴线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle控制线条样式            color: '#48b',            width: 2,            type: 'solid'        }    },    axisTick: {            // 坐标轴小标记        show: true,        // 属性show控制显示与否，默认不显示        interval: 'auto',        // onGap: null,        inside : false,    // 控制小标记是否在grid里         length :5,         // 属性length控制线长        lineStyle: {       // 属性lineStyle控制线条样式            color: '#333',            width: 1        }    },    axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel        show: true,        interval: 'auto',        rotate: 0,        margin: 8,        // formatter: null,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    splitLine: {           // 分隔线        show: true,        // 默认显示，属性show控制显示与否        // onGap: null,        lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式            color: ['#ccc'],            width: 1,            type: 'solid'        }    },    splitArea: {           // 分隔区域        show: false,       // 默认不显示，属性show控制显示与否        // onGap: null,        areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']        }    }},8、数值型坐标轴默认参数valueAxis: {    position: 'left',      // 位置    nameLocation: 'end',   // 坐标轴名字位置，支持'start' | 'end'    nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式    boundaryGap: [0, 0],   // 数值起始和结束两端空白策略    splitNumber: 5,        // 分割段数，默认为5    axisLine: {            // 坐标轴线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle控制线条样式            color: '#48b',            width: 2,            type: 'solid'        }    },    axisTick: {            // 坐标轴小标记        show: false,       // 属性show控制显示与否，默认不显示        inside : false,    // 控制小标记是否在grid里         length :5,         // 属性length控制线长        lineStyle: {       // 属性lineStyle控制线条样式            color: '#333',            width: 1        }    },    axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel        show: true,        rotate: 0,        margin: 8,        // formatter: null,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    splitLine: {           // 分隔线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式            color: ['#ccc'],            width: 1,            type: 'solid'        }    },    splitArea: {           // 分隔区域        show: false,       // 默认不显示，属性show控制显示与否        areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']        }    }},polar : {    center : ['50%', '50%'],// 默认全局居中    radius : '75%',    startAngle : 90,    splitNumber : 5,    name : {        show: true,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    axisLine: {            // 坐标轴线        show: true,        // 默认显示，属性show控制显示与否        lineStyle: {       // 属性lineStyle控制线条样式            color: '#ccc',            width: 1,            type: 'solid'        }    },    axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel        show: false,        textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE            color: '#333'        }    },    splitArea : {        show : true,        areaStyle : {            color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']        }    },    splitLine : {        show : true,        lineStyle : {            width : 1,            color : '#ccc'        }    }},9、柱形图默认参数bar: {    barMinHeight: 0,          // 最小高度改为0    // barWidth: null,        // 默认自适应    barGap: '30%',            // 柱间距离，默认为柱形宽度的30%，可设固定值    barCategoryGap : '20%',   // 类目间柱形距离，默认为类目间距的20%，可设固定值    itemStyle: {        normal: {            // color: '各异',            barBorderColor: '#fff',    // 柱条边线            barBorderRadius: 0,        // 柱条边线圆角，单位px，默认为0            barBorderWidth: 1,         // 柱条边线线宽，单位px，默认为1            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE            }        },        emphasis: {            // color: '各异',            barBorderColor: 'rgba(0,0,0,0)',   // 柱条边线            barBorderRadius: 0,                // 柱条边线圆角，单位px，默认为0            barBorderWidth: 1,                 // 柱条边线线宽，单位px，默认为1            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        }    }},10、折线图默认参数line: {    itemStyle: {        normal: {            // color: 各异,            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            lineStyle: {                width: 2,                type: 'solid',                shadowColor : 'rgba(0,0,0,0)', // 默认透明                shadowBlur: 5,                shadowOffsetX: 3,                shadowOffsetY: 3            }        },        emphasis: {            // color: 各异,            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        }    },    // smooth : false,    // symbol: null,         // 拐点图形类型    symbolSize: 2,           // 拐点图形大小    // symbolRotate : null,  // 拐点图形旋转控制    showAllSymbol: false     // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）},11、K线图默认参数k: {    // barWidth : null            // 默认自适应    // barMaxWidth : null         // 默认自适应     itemStyle: {        normal: {            color: '#fff',        // 阳线填充颜色            color0: '#00aa11',    // 阴线填充颜色            lineStyle: {                width: 1,                color: '#ff3200', // 阳线边框颜色                color0: '#00aa11' // 阴线边框颜色            }        },        emphasis: {            // color: 各异,            // color0: 各异        }    }},12、散点图默认参数scatter: {    // symbol: null,        // 图形类型    symbolSize: 4,          // 图形大小，半宽（半径）参数，当图形为                            // 方向或菱形则总宽度为symbolSize * 2    //symbolRotate : null,  // 图形旋转控制    large: false,           // 大规模散点图    largeThreshold: 2000,   // 大规模阀值，large为true且数据                            // 量&gt;largeThreshold才启用大规模模式    itemStyle: {        normal: {            // color: 各异,            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        },        emphasis: {            // color: '各异'            label: {                show: false                // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为                // 'inside'|'left'|'right'|'top'|'bottom'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            }        }    }},13、雷达图默认参数radar : {    itemStyle: {        normal: {            // color: 各异,            label: {                show: false            },            lineStyle: {                width: 2,                type: 'solid'            }        },        emphasis: {            // color: 各异,            label: {                show: false            }        }    },    // symbol: null,         // 拐点图形类型    symbolSize: 2            // 可计算特性参数，空数据拖拽提示图形大小    // symbolRotate : null,  // 图形旋转控制},14、饼图默认参数pie: {    center : ['50%', '50%'],    // 默认全局居中    radius : [0, '75%'],    clockWise : false,          // 默认逆时针    startAngle: 90,    minAngle: 0,                // 最小角度改为0    selectedOffset: 10,         // 选中是扇区偏移量    itemStyle: {        normal: {            // color: 各异,            borderColor: '#fff',            borderWidth: 1,            label: {                show: true,                position: 'outer'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            labelLine: {                show: true,                length: 20,                lineStyle: {                    // color: 各异,                    width: 1,                    type: 'solid'                }            }        },        emphasis: {            // color: 各异,            borderColor: 'rgba(0,0,0,0)',            borderWidth: 1,            label: {                show: false                // position: 'outer'                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            labelLine: {                show: false,                length: 20,                lineStyle: {                    // color: 各异,                    width: 1,                    type: 'solid'                }            }        }    }},map: {    mapType: 'china',   // 各省的mapType暂时都用中文    mapLocation: {        x : 'center',        y : 'center'        // width    // 自适应        // height   // 自适应    },    showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效    itemStyle: {        normal: {            // color: 各异,            borderColor: '#fff',            borderWidth: 1,            areaStyle: {                color: '#ccc'      // rgba(135,206,250,0.8)            },            label: {                show: false,                textStyle: {                    color: 'rgba(139,69,19,1)'                }            }        },        emphasis: {                // 也是选中样式            // color: 各异,            borderColor: 'rgba(0,0,0,0)',            borderWidth: 1,            areaStyle: {                color: 'rgba(255,215,0,0.8)'            },            label: {                show: false,                textStyle: {                    color: 'rgba(139,69,19,1)'                }            }        }    }},force : {    // 数据map到圆的半径的最小值和最大值    minRadius : 10,    maxRadius : 20,    density : 1.0,    attractiveness : 1.0,    // 初始化的随机大小位置    initSize : 300,    // 向心力因子，越大向心力越大    centripetal : 1,    // 冷却因子    coolDown : 0.99,    // 分类里如果有样式会覆盖节点默认样式    itemStyle: {        normal: {            // color: 各异,            label: {                show: false                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            nodeStyle : {                brushType : 'both',                color : '#f08c2e',                strokeColor : '#5182ab'            },            linkStyle : {                strokeColor : '#5182ab'            }        },        emphasis: {            // color: 各异,            label: {                show: false                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            nodeStyle : {},            linkStyle : {}        }    }},chord : {    radius : ['65%', '75%'],    center : ['50%', '50%'],    padding : 2,    sort : 'none',    // can be 'none', 'ascending', 'descending'    sortSub : 'none', // can be 'none', 'ascending', 'descending'    startAngle : 90,    clockWise : false,    showScale : false,    showScaleText : false,    itemStyle : {        normal : {            label : {                show : true                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE            },            lineStyle : {                width : 0,                color : '#000'            },            chordStyle : {                lineStyle : {                    width : 1,                    color : '#666'                }            }        },        emphasis : {            lineStyle : {                width : 0,                color : '#000'            },            chordStyle : {                lineStyle : {                    width : 2,                    color : '#333'                }            }        }    }},island: {    r: 15,    calculateStep: 0.1      // 滚轮可计算步长 0.1 = 10%}, markPoint : {    symbol: 'pin',          // 标注类型    symbolSize: 10,         // 标注大小，半宽（半径）参数，当图形为方向                            // 或菱形则总宽度为symbolSize * 2    // symbolRotate : null, // 标注旋转控制    itemStyle: {        normal: {            // color: 各异，            // borderColor: 各异,      // 标注边线颜色，优先于color             borderWidth: 2,            // 标注边线线宽，单位px，默认为1            label: {                show: true,                position: 'inside'     // 可选为'left'|'right'|'top'|'bottom'                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE            }        },        emphasis: {            // color: 各异            label: {                show: true                // position: 'inside'  // 'left'|'right'|'top'|'bottom'                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE            }        }    }},markLine : {    // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string    symbol: ['circle', 'arrow'],      // 标线起始和结束的symbol大小，半宽（半径）参数，当图    // 形为方向或菱形则总宽度为symbolSize * 2    symbolSize: [2, 4],    // 标线起始和结束的symbol旋转控制    // symbolRotate : null,    itemStyle: {        normal: {            // color: 各异,           // 标线主色，线色，symbol主色            // borderColor: 随color,  // 标线symbol边框颜色，优先于color             borderWidth: 2,           // 标线symbol边框线宽，单位px，默认为2            label: {                show: false,                // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'                position: 'inside',                  textStyle: {          // 默认使用全局文本样式，详见TEXTSTYLE                    color: '#333'                }            },            lineStyle: {                // color: 随borderColor,       // 主色，线色，优先级高于borderColor和color                // width: 随borderWidth,       // 优先于borderWidth                type: 'solid',                shadowColor : 'rgba(0,0,0,0)', // 默认透明                shadowBlur: 5,                shadowOffsetX: 3,                shadowOffsetY: 3            }        },        emphasis: {            // color: 各异            label: {                show: false                // position: 'inside' // 'left'|'right'|'top'|'bottom'                // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE            },            lineStyle : {}        }    }},textStyle: {    decoration: 'none',    fontFamily: 'Arial, Verdana, sans-serif',    fontFamily2: '微软雅黑',    // IE8- 字体模糊并且不支持不同字体混排，额外指定一份    fontSize: 12,    fontStyle: 'normal',    fontWeight: 'normal'},15、默认标志图形类型列表symbolList : [    'circle', 'rectangle', 'triangle', 'diamond',    'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'],16、可计算特性配置，孤岛，提示颜色calculable: false,                        // 默认关闭可计算特性calculableColor: 'rgba(255,165,0,0.6)',   // 拖拽提示边框颜色calculableHolderColor: '#ccc',            // 可计算占位提示颜色nameConnector: ' &amp; ',valueConnector: ' : ',animation: true,animationThreshold: 2500,                 // 动画元素阀值，产生的图形原素超过2500不出动画addDataAnimation: true,                   // 动态数据接口是否开启动画效果animationDuration: 2000,animationEasing: 'ExponentialOut'         // BounceOut  参考：echarts——各个配置项详细说明总结"
  },
  
  {
    "title": "MySQL分页查询优化",
    "url": "/posts/mysql-fenye-chaxun-youhua/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2022-12-03 10:47:00 +0800",
    





    
    "snippet": "MySQL一般使用LIMIT实现分页，基本语句为：SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引。举例来说，如果实际SQL类似下面语句，那么在category_id，id两列上建立复合索引比较好：SELECT * FROM articles WHERE c...",
    "content": "MySQL一般使用LIMIT实现分页，基本语句为：SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引。举例来说，如果实际SQL类似下面语句，那么在category_id，id两列上建立复合索引比较好：SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10;随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似下面这种：SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 10;可以看出，越往后分页，LIMIT语句的偏移量就会越大，速度也会明显变慢。此时，我们可以通过子查询的方式来提高分页效率：SELECT * FROM articles WHERE id &gt;=(SELECT id FROM articles  WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) AND category_id = 123 ORDER BY id LIMIT 10;还可以通过JOIN方式来实现分页查询：SELECT * FROM articles AS t1 JOIN (SELECT id FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) AS t2 WHERE t1.id &gt;= t2.id AND t1.category_id = 123 ORDER BY t1.id LIMIT 10;为什么会这样呢？因为子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。  参考：MySQL的分页查询SQL语句"
  },
  
  {
    "title": "SpringMVC",
    "url": "/posts/springmvc/",
    "categories": "Knowledge, SpringMVC",
    "tags": "SpringMVC",
    "date": "2022-12-02 13:47:00 +0800",
    





    
    "snippet": "SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。什么是SpringMVCSpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model、View、Controller分离，将Web层进行职责解耦，把复杂的Web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组...",
    "content": "SpringMVC以DispatcherServlet为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了MVC模式。什么是SpringMVCSpringMVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model、View、Controller分离，将Web层进行职责解耦，把复杂的Web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。SpringMVC运行流程及九大组件SpringMVC的运行流程  用户发送请求至前端控制器DispatcherServlet  DispatcherServlet收到请求调用HandlerMapping处理器映射器  处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet  DispatcherServlet通过HandlerAdapter处理器适配器调用处理器执行处理器(Controller，也叫后端控制器)  Controller执行完成返回ModelAndView  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet  DispatcherServlet将ModelAndView传给ViewReslover视图解析器  ViewReslover解析后返回具体View  DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。  DispatcherServlet响应用户。从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度SpringMVC的优点  可以支持各种视图技术，而不仅仅局限于JSP  与Spring框架集成(如IoC容器、AOP等)  清晰的角色分配：前端控制器(DispatcherServlet)，请求到处理器映射(HandlerMapping)，处理器适配器(HandlerAdapter)，视图解析器(ViewResolver)。SpringMVC的主要组件  前端控制器DispatcherServlet(不需要程序员开发) 作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet就减少了其它组件之间的耦合度。  处理器映射器HandlerMapping(不需要程序员开发) 作用：根据请求的URL来查找Handler  处理器适配器HandlerAdapter 注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。  处理器Handler(需要程序员开发)  视图解析器ViewResolver(不需要程序员开发) 作用：进行视图的解析，根据视图逻辑名解析成真正的视图(Vew)  视图View(需要程序员开发JSP) View是一个接口， 它的实现类支持不同的视图类型(JSP，Freemarker，PDF等等)SpringMVC和Struts2的区别有哪些  SpringMVC的入口是一个Servlet即前端控制器(DispatchServlet)，而Struts2入口是一个Filter过虑器(StrutsPrepareAndExecuteFilter)。  SpringMVC是基于方法开发(一个url对应一个方法)，请求参数传递到方法地形参，可以设计为单例或多例(建议单例)，Struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。  Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，SpringMVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。JSP视图解析器默认使用JSTL。"
  },
  
  {
    "title": "JDK和JRE",
    "url": "/posts/jdk-he-jre/",
    "categories": "Knowledge, JDK",
    "tags": "JDBC, JDK",
    "date": "2022-12-02 13:47:00 +0800",
    





    
    "snippet": "JDK是整个Java的核心，包括了Java运行环境JRE、Java开发工具和Java基础类库。利用JDK（调用JAVA API）开发了属于我们自己的Java程序后，通过JDK中的编译程序（javac）将我们的Java文件编译成Java字节码，在JRE上运行这些Java字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。",
    "content": "JDK是整个Java的核心，包括了Java运行环境JRE、Java开发工具和Java基础类库。利用JDK（调用JAVA API）开发了属于我们自己的Java程序后，通过JDK中的编译程序（javac）将我们的Java文件编译成Java字节码，在JRE上运行这些Java字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。"
  },
  
  {
    "title": "Git无法提交和更新",
    "url": "/posts/git-wufa-tiijaohegengxin/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2022-12-01 13:47:00 +0800",
    





    
    "snippet": "依次执行以下命令就可以正常push和pullgit config --global --unset http.proxy git config --global --unset https.proxy",
    "content": "依次执行以下命令就可以正常push和pullgit config --global --unset http.proxy git config --global --unset https.proxy"
  },
  
  {
    "title": "JS中获取alert代码的位置",
    "url": "/posts/js-zhong-huoqu-alert-weizhi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2022-12-01 10:47:00 +0800",
    





    
    "snippet": "找到弹窗出现的页面，在浏览器控制台输入：var oalert = window.alertwindow.alert = (...args) =&gt; { oalert(...args); console.error(new Error('someone alerted'))}然后复现弹窗，即可在控制台看到alert代码的位置。",
    "content": "找到弹窗出现的页面，在浏览器控制台输入：var oalert = window.alertwindow.alert = (...args) =&gt; { oalert(...args); console.error(new Error('someone alerted'))}然后复现弹窗，即可在控制台看到alert代码的位置。"
  },
  
  {
    "title": "JS发送POST JSON格式请求",
    "url": "/posts/js-fasong-postjson-geshi-qingqiu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2022-12-01 10:47:00 +0800",
    





    
    "snippet": "var xhr = new XMLHttpRequest();var sendData = {name:\"abc\"};xhr.open(\"POST\", \"/service/hello\", true);xhr.setRequestHeader('content-type', 'application/json');// 将用户输入值序列化成字符串xhr.send(JSON.stringify(...",
    "content": "var xhr = new XMLHttpRequest();var sendData = {name:\"abc\"};xhr.open(\"POST\", \"/service/hello\", true);xhr.setRequestHeader('content-type', 'application/json');// 将用户输入值序列化成字符串xhr.send(JSON.stringify(sendData));// 回调xhr.onreadystatechange = function() {    if (xhr.readyState == 4) {        // 根据服务器的响应内容格式处理响应结果        if(xhr.getResponseHeader('content-type') === 'application/json') {            var result = JSON.parse(xhr.responseText);\t            // 根据返回结果判断验证码是否正确            if(result.code === -1) {                alert('验证码错误');            }        }    } else {        console.log(xhr.responseText);    }}  参考：js 发送post json格式请求"
  },
  
  {
    "title": "收藏夹",
    "url": "/posts/shuqian-shoucangjia/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2022-11-24 13:47:00 +0800",
    





    
    "snippet": "                                    Knowledge                                                                    技术博客                                            纯洁的微笑                        友人C    ...",
    "content": "                                    Knowledge                                                                    技术博客                                            纯洁的微笑                        友人C                        靳闯博客                                                                                            知识汇总                                            数据库/运维/大数据/架构知识汇总                        JQL                        Spring框架入门教程                        保贝说保\t\t\t\t\t\t帆软信创产品\t\t\t\t\t\t山川软件信创产品                                                                                            教程                                            Bootstrap中文网                        Spring Cloud中文网                        Knife4j - swagger-bootstrap-ui                        人工智能教程                        菜鸟教程                        Python教程                        数据结构和算法动态可视化平台                        易百教程                                                                                            Resource                                                                    媒体资源                                            极简壁纸                        必应壁纸                        Awesome Wallpapers                        急速收录网 - 网址查询                        WebStack.cc - 设计师网址导航                        Pexels - 免费素材图片                        Stock Up - 免费素材图片                        沙沙野 - 免费素材图片                        Unsplash - 免费素材图片                        Pixabay - 免费素材图片                        StockSnap - 免费素材图片                        HiFiNi - 音乐磁场                        樱花动漫                        搜狗搜索 - 微信公众号搜索                                                                                            软件资源                                            9553下载                        绿盒下载站                        Bitbucket下载                        Atlassian全家桶以及插件破解详细教程                        为知笔记服务端Docker镜像使用说明                                                                                            WIN系统资源                                            Microsoft官网                        DLL下载站                        MSDN                        字体天下                                                                                            插件资源                                            Greasy Fork - 油猴脚本                        Atlassian插件市场                        Gitbook常用插件                                                                                            文档资源                                            iSlide                                                                                            书籍资源                                            Jiumo Search 鸠摩搜索                                                                                        Develop                                                                    API文档                                            uTools插件开发文档                        程序员手册大全                        JIRA-7.6.1 - API接口文档                        JIRA-5.1.3 - API接口文档                        Arthas-3.6.7 - 开发文档                        易源接口 - 互联网API入口                        微信开放文档                        Apache ECharts\t\t\t\t\t\t华为GaussDB语法                                                                                            图标                                            图标下载                        阿里巴巴矢量图标库                        Icon Ninja                        Free vector icons                        iconfinder                        Dribbble                        Free Icons                        Free Logo Maker - Namecheap                                                                                            仓库                                            Git                        JQuery                        Python                        RPM仓库 - Linux软件                        pkgs.org - Linux和Unix软件                        Maven仓库                        Maven仓库 - 阿里云                        Ruby                        Font Awesome - v4                        Font Awesome - v5                        Font Awesome - v6                        Tomcat历史版本                                                                                            源码                                            站长素材                        懒人之家                                                                                            Git项目                                            mall项目 - 电商系统                        MM-Wiki - 轻量级的企业知识分享与团队协同软件                        GitHub开源的10个优秀后台管理面板                        25个国内顶级技术开发团队Github                                                                                        Tools                                                                    媒体工具                                            XDOC文档预览云服务                        图片剪裁                        在线抠图                        Chrome Bookmarks Separator - 虚拟分隔符                        Palettes - 调色板                        Material Palette - 调色板                        Color Hunt - 调色板                        Simone Ferrari - 网页配色方案                        135编辑器 - 微信公众号编辑器                                                                                            网盘搜索                                            云铺子                        懒盘搜索                        56网盘搜索                        盘131                                                                                            数据生成工具                                            在线身份证号码生成器                        中国省市区编码对照表2020版                        Cron表达式生成器                        JVM配置工具                        经纬度查询 - 坐标拾取系统                        时间日期间隔计算器                        云际云短信 - 模拟接码                        草料二维码生成器\t\t\t\t\t\t临时邮箱                                                                                            格式转换工具                                            时间戳转换工具                        在线代码格式化                        奇客PDF转Word                        PDF to DOC                        在线ico图标转换                        WEBP转JPG                        WEBP转JPG                        M4A转MP3                                                                                            开发工具                                            JS Bin                        Spring Initializr                        Sunny-Ngrok内网穿透服务                        微信公众平台                        微信公众平台接口调试工具                        Java命名/p8z                        SVG编辑器                        Hoppscotch - 在线Postman                                                                                            工具集合                                            脚本之家在线工具                        JSON在线工具                        JSON在线                        PDF24 Tools                        WORTHSEE音频编辑工具箱\t\t\t\t\t\ttoolfk工具箱                                                                                        Gov                                                                    中国                                            政府 - 中国政府网 - 中央人民政府门户网站                        教育 - NTCE - 中国教育考试网                        继续教育 - 中国电子学会电子信息人才能力提升工程                         继续教育 - 现代专技继续教育网                        继续教育 - 终身教育平台                        税务 - 自然人电子税务局                        社保 - 国家社会保险公共服务平台                        医保 - 国家医保服务平台                                                                                            北京                                            继续教育 - 北京继续教育                        继续教育 - 北京市职业技能提升行动管理平台                        社保 - 北京市人力资源和社会保障局                        车辆 - 北京市小客车指标调控管理信息系统                                                                                            河北                                            就业 - 河北人才网                        政府 - 张家口市人民政府                        社保 - 张家口人力资源和社会保障局                        医保 - 张家口市医疗保障局                        教育 - 张家口教师招聘考试网                        教育 - 河北省教育考试院                        教育 - 名校网 - 全国各省市学校大全                        教育 - 河北公务员考试网                                                                                        My                            云设计                滴答清单                随手记                Lemon                QQ邮箱                微信读书                                                    Work                            EDS                EHR                企业管理平台                                "
  },
  
  {
    "title": "Log4j漏洞修复",
    "url": "/posts/log4j-loudong-xiufu/",
    "categories": "Knowledge, Log4j",
    "tags": "Log4j",
    "date": "2022-09-28 13:47:00 +0800",
    





    
    "snippet": "升级官方版本（推荐）目前Apache官方已发布最新版升级包，Java7版本升级至log4j-2.12.4版本，Java8及以上版本升级至log4j-2.17.0版本，升级包中移除了对lookup功能的支持，默认禁用了JNDI方法。移除Log4j包中JndiLookup类（可能存在未知影响）移除log4j-core包中JndiLookup类文件，并重启服务，具体方法如下：  Linux系统zi...",
    "content": "升级官方版本（推荐）目前Apache官方已发布最新版升级包，Java7版本升级至log4j-2.12.4版本，Java8及以上版本升级至log4j-2.17.0版本，升级包中移除了对lookup功能的支持，默认禁用了JNDI方法。移除Log4j包中JndiLookup类（可能存在未知影响）移除log4j-core包中JndiLookup类文件，并重启服务，具体方法如下：  Linux系统zip -q -d log4j-core-*.jar org/apache/logging/log4j/core/lookup/JndiLookup.class  Windows系统jar包解压缩，删除org/apache/logging/log4j/core/lookup/路径下JndiLookup.class文件。修改Log4j配置（需评估是否影响业务）通过更改Log4j配置达到缓解作用，具体更改配置如下：  JVM启动参数添加-Dlog4j2.formatMsgNoLookups=True  在应用classpath下添加log4j2.component.properties配置文件，文件内容为log4j2.formatMsgNoLookups=true需注意该方法的两项措施在log4j-2.10.0以下版本无效，可采取第二种修复方式。"
  },
  
  {
    "title": "Eclipse更换工作空间的步骤",
    "url": "/posts/eclipse-genghuan-gongzuokongjian-buzhou/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-28 01:47:00 +0800",
    





    
    "snippet": "一、指定新工作空间位置二、设置编码设置工作空间编码UTF-8设置JSP编码三、指定JDK位置四、配置Tomcat五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件指定maven插件指定maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入.abcdefghijklmnopqrstuvwxyz十二、校验的删...",
    "content": "一、指定新工作空间位置二、设置编码设置工作空间编码UTF-8设置JSP编码三、指定JDK位置四、配置Tomcat五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件指定maven插件指定maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入.abcdefghijklmnopqrstuvwxyz十二、校验的删除十三、Debug十四、修改背景颜色Window -&gt; preference -&gt; general -&gt; editors -&gt; test editors -&gt; background color -&gt; 色调85、饱和度120、亮度208"
  },
  
  {
    "title": "Spring Boot切换多环境配置文件",
    "url": "/posts/springboot-qiehuan-duohuanjing-peizhiwenjian/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2022-09-23 13:47:00 +0800",
    





    
    "snippet": "在项目开发的过程中，我们难免会遇到开发、测试、生产等环境的切换，而各个环境的配置肯定是不同的。传统的办法是在项目打包的时候修改配置文件。但人为做的事情难免产生意外。Spring Boot为我们提供了一种多环境配置文件同时存在，而运行打包时仅运行所选的配置文件的方式。spring.profiles.activespring:  profiles:    # active: yaya    ac...",
    "content": "在项目开发的过程中，我们难免会遇到开发、测试、生产等环境的切换，而各个环境的配置肯定是不同的。传统的办法是在项目打包的时候修改配置文件。但人为做的事情难免产生意外。Spring Boot为我们提供了一种多环境配置文件同时存在，而运行打包时仅运行所选的配置文件的方式。spring.profiles.activespring:  profiles:    # active: yaya    active: keats指定激活哪个文件，值是application-{profileName}.yml中的profileName，用于区分不同的运行环境。如果application.yml和被激活的yml中同时配置了一个相同的键，被激活的yml中的值会覆盖application.yml中的值。spring.profiles.includespring:  profiles:    include: yayaDB, yayaRedis指定包含(合并)多个yml的内容一起启动。这样有助于同环境下yml文件的分类管理。像上面include值是多个的情况，除了使用,分隔的输入方式外，还可以使用换行- profileName的方式，这是yml 的一种语法。spring:  profiles:    include:      - yayaDB      - yayaRedis按照以上的yml配置之后，就可以通过注释与放开不同的active，来实现环境的切换了。  参考：SpringProfile轻松切换多环境配置文件"
  },
  
  {
    "title": "DBCP、C3P0、Proxool、BoneCP方式创建数据源连接",
    "url": "/posts/sizhong-peizhi-shujuyuan-de-fangshi/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2022-09-23 13:47:00 +0800",
    





    
    "snippet": "Apache DBCP以这种方式创建数据源必须先准备两个jar文件：commons-dbcp.jar和commons-pool.jar，将这两个jar包放到WEB-INF/lib目录下。以这种方式创建的数据源就不再是javax.sql.DataSource了，而是org.apache.commons.dbcp.BasicDataSource。而且不再需要配置任何文件就可以直接使用。// 创建...",
    "content": "Apache DBCP以这种方式创建数据源必须先准备两个jar文件：commons-dbcp.jar和commons-pool.jar，将这两个jar包放到WEB-INF/lib目录下。以这种方式创建的数据源就不再是javax.sql.DataSource了，而是org.apache.commons.dbcp.BasicDataSource。而且不再需要配置任何文件就可以直接使用。// 创建BasicDataSource对象BasicDataSource ds = new BasicDataSource();ds.setDriverClassName(\"com.mysql.jdbc.Driver\");ds.setUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUsername(\"[用户名]\");ds.setPassword(\"[密码]\");//指定数据库连接池中初始化连接数的个数ds.setInitialSize(50);//指定最大的连接数: 同一时刻可以同时向数据库申请的连接数ds.setMaxActive(100);//指定最大连接数: 在数据库连接池中保存的最大的空闲连接的数量ds.setMaxIdle(30);//指定最小连接数：在数据库连接池中保存的最小的空闲连接的数量ds.setMinIdle(5);//指定等待时间：等待数据库连接池中给分配的连接，等待时间，超过之后会报异常ds.setMaxWait(10000);//毫秒单位// 关闭数据源连接ds.close();C3P0使用C3P0方式创建数据源应该首先准备一个jar文件：c3p0-0.9.1.2.jar，将其放到WEB-INF/lib目录下，就可以在项目中使用C3P0创建数据源了，C3P0创建的数据源对象也不是DataSource对象，而是ComboPooledDataSource。// 创建ComboPooledDataSource对象ComboPooledDataSource ds = new ComboPooledDataSource();ds.setDriverClass(\"com.mysql.jdbc.Driver\");ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUser(\"[用户名]\");ds.setPassword(\"[密码]\");ds.setInitialPoolSize(50);ds.setMaxPoolSize(100);ds.setMaxIdleTime(10000);Proxool采用该方式创建数据源需要准备的jar包：proxool-01.9.0RC3.jar，将其放到WEB-INF/lib目录下，之后就可以项目中创建ProxoolDataSource对象。// 创建ProxoolDataSource对象ProxoolDataSource ds = new ProxoolDataSource();ds.setDriver(\"com.mysql.jdbc.Driver\");ds.setDriverUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUser(\"[用户名]\");ds.setPassword(\"[密码]\");BoneCPBoneCP是一个快速高效，开源免费的Java数据库接池。创作者称，BoneCP在性能上会完全超越所有主流的Java连接池。它可以帮你管理数据连 接，让你的应用程序能更快速地访问数据库。比C3P0/DBCP连接池快25倍。这个数据库连接池采用Google Collection作为内部的集合类框架，而且现在的版本已经很稳定。要使用BoneCP，必须用到的jar文件有：bonecp-0.6.5.jargoogle-collections-1.0.jarslf4j-api-1.5.11.jarslf4j-log4j12-1.5.11.jarlog4j-1.2.15.jar将这些jar包放到WEB-INF/lib目录下，就可以在程序中创建BoneCPDataSource对象。// 创建BoneCPDataSource对象BoneCPDataSource ds = new BoneCPDataSource();ds.setDriverClass(\"com.mysql.jdbc.Driver\");ds.setJdbcUrl(\"jdbc:mysql://localhost:3306/[实例名]\");ds.setUsername(\"[用户名]\");ds.setPassword(\"[密码]\");ds.setAcquireIncrement(1);ds.setAcquireRetryDelay(10000);ds.setIdleConnectionTestPeriod(100);ds.setMinConnectionsPerPartition(2);ds.setMaxConnectionsPerPartition(20);ds.setPartitionCount(2);"
  },
  
  {
    "title": "如何在Word中打出带勾的方框",
    "url": "/posts/word-ruhe-dachu-daigoudekuang/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2022-09-23 08:47:00 +0800",
    





    
    "snippet": "在Word文档中输入数字2611，然后按下键盘上的快捷键ALT + X，此时，这几个数字就会转换成方框内打钩符号。",
    "content": "在Word文档中输入数字2611，然后按下键盘上的快捷键ALT + X，此时，这几个数字就会转换成方框内打钩符号。"
  },
  
  {
    "title": "Linux配置防火墙",
    "url": "/posts/linux-peizhi-fanghuoqiang/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2022-09-23 01:47:00 +0800",
    





    
    "snippet": "CentOS6用service iptables status查看，CentOS7系统iptables叫firewalld，使用systemctl status firewalld查看。# 查看防火墙状态systemctl status firewalld# 如果不是显示active状态，需要打开防火墙systemctl start firewalld# 查看所有已开放的临时端口（默认为空）...",
    "content": "CentOS6用service iptables status查看，CentOS7系统iptables叫firewalld，使用systemctl status firewalld查看。# 查看防火墙状态systemctl status firewalld# 如果不是显示active状态，需要打开防火墙systemctl start firewalld# 查看所有已开放的临时端口（默认为空）firewall-cmd --list-ports# 查看所有永久开放的端口（默认为空）firewall-cmd --list-ports --permanent# 添加临时开放端口firewall-cmd --add-port=223/tcp# 添加永久开放的端口firewall-cmd --add-port=223/tcp --permanent# 关闭临时端口firewall-cmd --remove-port=80/tcp# 关闭永久端口firewll-cmd --remove-port=80/tcp --permanent# 配置结束后需要输入重载命令并重启防火墙以生效配置firewall-cmd --reloadsystemctl restart firewalld"
  },
  
  {
    "title": "Eclipse如何显示行号",
    "url": "/posts/eclipse-ruhe-xianshi-hanghao/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-23 01:47:00 +0800",
    





    
    "snippet": "一、快捷键法打开一个代码页面，直接输入快捷键CTRL + F10，就会调出一个菜单，勾选show line numbers即可显示行号。二、右侧边栏法打开一个代码页面，右键点击其侧边栏，如图所示的位置，就会显示一个菜单，勾选show line numbers即可显示行号。三、通用设置法在Eclipse菜单栏选择Window -&gt; Prenference，在打开的左侧设置窗口，依次展开W...",
    "content": "一、快捷键法打开一个代码页面，直接输入快捷键CTRL + F10，就会调出一个菜单，勾选show line numbers即可显示行号。二、右侧边栏法打开一个代码页面，右键点击其侧边栏，如图所示的位置，就会显示一个菜单，勾选show line numbers即可显示行号。三、通用设置法在Eclipse菜单栏选择Window -&gt; Prenference，在打开的左侧设置窗口，依次展开Window -&gt; Preferences -&gt; Gerenal -&gt; Editors -&gt; Text Editors，然后勾选右侧的show line numbers即可显示行号。"
  },
  
  {
    "title": "Windows10彻底关闭自动更新",
    "url": "/posts/chedi-guanbi-windows-gengxin/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2022-09-09 13:47:00 +0800",
    





    
    "snippet": "一、禁用Windows Update服务  打开运行对话框，输入services.msc，点击确定打开服务。  找到Windows Update这一项，双击打开。  点击停止，把启动类型选为禁用，最后点击应用。  接下再切换到恢复选项，将默认的重新启动服务改为无操作，然后点击应用。二、在组策略里关闭Win10自动更新相关服务  打开运行对话框，输入gpedit.msc，点击确定打开组策略编辑...",
    "content": "一、禁用Windows Update服务  打开运行对话框，输入services.msc，点击确定打开服务。  找到Windows Update这一项，双击打开。  点击停止，把启动类型选为禁用，最后点击应用。  接下再切换到恢复选项，将默认的重新启动服务改为无操作，然后点击应用。二、在组策略里关闭Win10自动更新相关服务  打开运行对话框，输入gpedit.msc，点击确定打开组策略编辑器。  在组策略编辑器中，依次展开计算机配置 -&gt; 管理模板 -&gt; Windows组件 -&gt; Windows更新。  然后在右侧配置自动更新设置中，将其设置为已禁用并点击下方的应用。  之后还需要再找到删除使用所有Windows更新功能的访问权限，选择已启用，完成设置后，点击应用。三、禁用任务计划里边的Win10自动更新  打开运行对话框，输入taskschd.msc，点击确定打开任务计划程序。  在任务计划程序的设置界面，依次展开任务计划程序库 -&gt; Microsoft -&gt; Windows -&gt; WindowsUpdate，把里面的项目都设置为禁用就可以了。四、在注册表中关闭Win10自动更新  打开运行对话框，输入regedit，点击确定打开注册表。  在注册表设置中，找到并定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UsoSvc，然后在右侧找到Start键。  点击修改，把Start值改为十六进制，值改为4，然后点击确定保存数据。  继续在右侧找到FailureActions键，右键点击修改该键的二进制数据，将0010、0018行的左起第5个数值由原来的01改为00，完成后，点击下方的确定即可。至此彻底关闭win10自动更新的操作步骤就全部完成了。"
  },
  
  {
    "title": "vi/vim下如何搜索字符串",
    "url": "/posts/linux-vi-xia-ruhe-sousuo-zifu/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2022-09-09 01:47:00 +0800",
    





    
    "snippet": "  命令模式下，输入/字符串，比如搜索user，输入/user，按下回车之后，可以看到vim已经把光标移动到该字符处和高亮了匹配的字符串  查看下一个匹配，按下n（小写n）  跳转到上一个匹配，按下N（大写N）",
    "content": "  命令模式下，输入/字符串，比如搜索user，输入/user，按下回车之后，可以看到vim已经把光标移动到该字符处和高亮了匹配的字符串  查看下一个匹配，按下n（小写n）  跳转到上一个匹配，按下N（大写N）"
  },
  
  {
    "title": "Eclipse中将Java项目转换成Web项目的方法",
    "url": "/posts/eclipse-zhong-jiangxiangmu-zhuanwei-webxiangmu-de-fangfa/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-09 01:47:00 +0800",
    





    
    "snippet": "用Eclipse开发项目的时候，把一个Web项目导入到Eclipse里会变成一个Java工程，将无法在Tomcat中进行部署运行，所以要转为Web项目。      找到.project文件，找到里面的&lt;natures&gt;标签，查看是否有下面的代码，没有则复制进去，如果Properties配置中有Project Facets选项则忽略此步骤。     &lt;nature&gt;or...",
    "content": "用Eclipse开发项目的时候，把一个Web项目导入到Eclipse里会变成一个Java工程，将无法在Tomcat中进行部署运行，所以要转为Web项目。      找到.project文件，找到里面的&lt;natures&gt;标签，查看是否有下面的代码，没有则复制进去，如果Properties配置中有Project Facets选项则忽略此步骤。     &lt;nature&gt;org.eclipse.wst.common.project.facet.core.nature&lt;/nature&gt; &lt;nature&gt;org.eclipse.wst.common.modulecore.ModuleCoreNature&lt;/nature&gt; &lt;nature&gt;org.eclipse.jem.workbench.JavaEMFNature&lt;/nature&gt;        Java项目中只有下面一句     &lt;nature&gt;org.eclipse.jdt.core.javanature&lt;/nature&gt;        刷新导入的项目。      在项目上点击右键，进入Properties配置，点击Project Facets，再点击Convert to faceted form进入属性设置。            勾选Dynamic Web Module和Java，选择相应的版本，并点击下方出现的Further configuration available。            配置Modify Faceted Project，此处是设置web.xml文件的路径，我们输入src/main/webapp，Generate web.xml deployment descriptor自动生成web.xml文件，可选可不选。        点击OK--&gt;Apply应用设置，Java项目即转换为了Web项目。注：如果忘记点击Further configuration available，即忘记修改WebContent为webapp，可以点击Deployment Assembly选项，然后将WebContent删除，将webapp添加进去。该选项的功能：部署项目时，设置文件发布的路径以及jar包发布的路径。"
  },
  
  {
    "title": "Eclipse已经导入jar包，但还是出现ClassNotFound异常",
    "url": "/posts/eclipse-yiijng-daoru-jarbao-danhaishi-xianshi-classnotfound/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2022-09-09 01:47:00 +0800",
    





    
    "snippet": "问题描述最近在部署一个Web项目，jar包在lib目录下新建了子目录放置，在Java类中直接通过import能导入使用，并且单独运行一个Java类的main方法可以正常运行，但是在运行Web项目时却会报ClassNotFound的错误。问题原因对于普通的Java类，编译jar包时，就直接在导入的包中查找就可以了，但是对于Web项目，由于它们是借助了Tomcat或者其他的容器发布，基于Tomc...",
    "content": "问题描述最近在部署一个Web项目，jar包在lib目录下新建了子目录放置，在Java类中直接通过import能导入使用，并且单独运行一个Java类的main方法可以正常运行，但是在运行Web项目时却会报ClassNotFound的错误。问题原因对于普通的Java类，编译jar包时，就直接在导入的包中查找就可以了，但是对于Web项目，由于它们是借助了Tomcat或者其他的容器发布，基于Tomcat本身，它会在Web项目中的WEB-INF下的lib中进行编译jar包，而之前导入的jar包却不在这里，所以，就会报错。解决办法把需要的jar包拷贝进入WEB-INF下的lib就可以了。"
  },
  
  {
    "title": "Maven使用阿里云镜像下载jar包失败",
    "url": "/posts/aliyun-jingxiang-xiazai-jar-shibai/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2022-08-08 13:47:00 +0800",
    





    
    "snippet": "将旧版阿里云映像&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/...",
    "content": "将旧版阿里云映像&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;替换成新版映像地址&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;"
  },
  
  {
    "title": "Spring Boot使用PageHelper",
    "url": "/posts/springboot-shiyong-pagehelper/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "      引入依赖      &lt;dependency&gt;      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;      &lt;version&gt;4.1.0&lt;/version&gt;  &lt;/dep...",
    "content": "      引入依赖      &lt;dependency&gt;      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;      &lt;version&gt;4.1.0&lt;/version&gt;  &lt;/dependency&gt;            在application.yml中做如下配置      # 分页配置  pagehelper:      helper-dialect: mysql      reasonable: true      support-methods-arguments: true      params: count=countSql            在代码中使用      PageHelper.startPage(pageNum, pageSize); // 表示从pageNum页开始，每页pageSize条数据  List&lt;Tools&gt; list = toolsMapper.findAll();  PageInfo&lt;Tools&gt; pageInfo = new PageInfo&lt;Tools&gt;(list);  return ServerResponse.createBySuccess(\"查询成功\",pageInfo);      "
  },
  
  {
    "title": "Python下载yaml模块报错",
    "url": "/posts/xiazai-yaml-baocuo/",
    "categories": "Knowledge, Python",
    "tags": "Python",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "报错信息cmd安装yaml，网上大部分写的都是pip install yaml，可是，执行完报错Could not find a version that satisfies the requirement yaml No matching distribution found for yaml.，但是执行pip install pyyaml就可以成功。报错原因python3.X只能使用pi...",
    "content": "报错信息cmd安装yaml，网上大部分写的都是pip install yaml，可是，执行完报错Could not find a version that satisfies the requirement yaml No matching distribution found for yaml.，但是执行pip install pyyaml就可以成功。报错原因python3.X只能使用pip install pyyaml来安装。"
  },
  
  {
    "title": "MyBatis报错，无效的列索引",
    "url": "/posts/mybatis-baocuo-wuxiao-de-liesuoyin/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "报错信息nested exception is org.apache.ibatis.type.TypeException: Could not set parameters for mapping: ParameterMapping{property= ‘groupid’,mode=IN, javaType=class java.lang.Object, jdbcType=null,nume...",
    "content": "报错信息nested exception is org.apache.ibatis.type.TypeException: Could not set parameters for mapping: ParameterMapping{property= ‘groupid’,mode=IN, javaType=class java.lang.Object, jdbcType=null,numericScale=null, resultMapld=‘null’, jdbcTypeName-=‘nl’,expression= 'null}. Cause: org.apache.ibatis.type.TypeException: Errorsetting non null for parameter #3 with JdbcType null. Try setting adifferent JdbcType for this parameter or a different configurationproperty. Cause: org.apache.ibatis.type.TypeException: Error setting nonnull for parameter #3 with JdbcType null . Try setting a differentJdbcType for this parameter or a different configuration property. Cause:java.sql.SQL Exception:无效的列索引报错原因使用了/*… */注释解决方法SQL本身没有问题，换一种注释方式即可  参考：SQL报错：无效的列索引"
  },
  
  {
    "title": "金融监管、监管科技以及银行业监管报送概述",
    "url": "/posts/jinrongjianguan-jianguankeji-yinhangyejianguan/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2022-07-21 13:47:00 +0800",
    





    
    "snippet": "上周金融科技前沿课程的主题是《监管科技》，韩海燕老师从金融监管引入，介绍了我国的金融监管体系，接着进入监管科技的详细讲解。我觉得最主要的是弄清楚监管科技的定义，以及在实际的银行业应用场景中具体的运作流程是怎么样的。韩老师讲的很全面，将ABCD等金融科技手段在监管系统中是如何运作的讲的很清楚，收获颇丰，但是比较少涉及到监管的对象和内容，仍没有很清楚监管机构是要监管什么东西？监管机构要求银行金融...",
    "content": "上周金融科技前沿课程的主题是《监管科技》，韩海燕老师从金融监管引入，介绍了我国的金融监管体系，接着进入监管科技的详细讲解。我觉得最主要的是弄清楚监管科技的定义，以及在实际的银行业应用场景中具体的运作流程是怎么样的。韩老师讲的很全面，将ABCD等金融科技手段在监管系统中是如何运作的讲的很清楚，收获颇丰，但是比较少涉及到监管的对象和内容，仍没有很清楚监管机构是要监管什么东西？监管机构要求银行金融业机构报送的资料有哪些？这些报送要求的目的分别是什么？所以这篇文章分为三个部分，一是介绍金融监管，二是介绍监科技，三是对银行业监管报送进行概述。文章目录      一、金融监管              1.1 什么是金融监管        1.2 金融监管的作用和意义        1.3 我国的金融监管体系              二、监管科技              2.1 什么是监管科技        2.2 监管科技的发展概况        2.3 监管科技的技术支撑                      2.3.1 云计算            2.3.2 大数据            2.3.3 人工智能            2.3.4 区块链            2.3.5 API                          2.4 监管科技的主要应用场景及案例                      2.4.1 反洗钱领域应用            2.4.2 地方金融监管应用            2.4.3 用户身份识别            2.4.4 市场交易行为监测            2.4.5 支付行为监测和风险防控                                三、银行业监管报送              3.1 理财与资金信托报送        3.2 反假币报送        3.3 个人银行账户申报        3.4 1104报表        3.5 人行大集中        3.6 EAST（监管数据标准化规范）        3.7 客户风险报送        3.8 对外金融资产负债及交易统计        3.9 征信报送        3.10 反洗钱报送        3.11 人行存贷款标准化报送        3.12 支付统计报送        3.13 金融基础数据报送            一、金融监管1.1 什么是金融监管金融监管是指政府通过特定的机构（如中央银行）对金融交易行为主体进行的某种限制或规定。顾名思义，监是监督，管是管理。  谁来监管 ：政府，并且是通过特定的机构（如中央银行）。  监管谁 ：监管的对象也在逐步扩大，从银行、非银行金融机构 –&gt; 准金融机构（如集体投资机构、贷款协会、 银行附属公司） –&gt; 整个金融体系。  监管啥 ：监管的主要内容包括对对证券业、保险业、信托业、商业银行的监管；对金融机构设立、资产负债业务的监管；对会计结算、外汇外债的监管等等，总之，监管的内容很多，其中，对商业银行的监管是监管的重点。  用什么方式进行监管：公告监管、准则监管、实体监管。（这里涉及一个“四结合的监管方法”，意思是外部监管与内部自律相结合、全面监管与重点监管相结合…）1.2 金融监管的作用和意义  减少金融风险。促进金融和经济健康发展，社会稳定。  保证公平。保障存款人和投资者的利益。同时有监督，避免暗箱操作，贪污腐败。  帮助金融机构不倒闭，不然像金融危机一样会危害整个社会。  宏观调控，进行货币政策，财政政策等的一种方式。（存款准备金）1.3 我国的金融监管体系一委一行两会一局二、监管科技2.1 什么是监管科技什么是监管科技简单地说，监管科技是为了应对金融科技创新发展中不断暴露出的风险与问题而采取的监管解决方案。监管科技分为两个方面  金融监管机构使用的“监管科技”（科技+监管，SupTech）  金融机构使用的“合规科技”（科技+合规，CompTech）监管科技参与主体这个过程涉及到金融监管机构（第一部分介绍过）、金融机构、金融科技公司/专业的监管科技公司。监管科技与金融科技的关系这两者具有交叉李生的关系，是同类信息技术在不同需求场景下的应用。比如，当科技应用于金融创新发展之时，称之为金融科技，但这可能引发金融风险与侵害消费者权益，而当科技应用于有效防范金融风险与保护消费者权益时，称为监管科技。监管科技的作用与意义简单来说，“科技+监管”能够有效应对“科技+金融”的风险。2.2 监管科技的发展概况国内外学者将监管科技的演变划分为三个阶段。当前，全球监管科技正处于从2.0到3.0时代的关键时期。  1.0: 2000年左右，金融机构引入新技术来监视和分析特定法规或流程的风险。  2.0：从2008年全球金融危机后大概十年间，实现了监管合规义务和技术的结合。  3.0：从“了解您的客户”到 “了解您的数据”的转变。当前，我国各级金融监管机构都十分重视以大数据、云计算、区块链、人工智能为代表的新兴信息科技研发，并已在很多重要领域实现了监管科技的落地应用。2.3 监管科技的技术支撑  这一节主要对云计算、大数据、人工智能、区块链、API技术做一个概述。都是很基础的概念知识。2.3.1 云计算基本原理云计算的商业运用至今己超过十年，是金融科技和监管科技各项技术应用中成熟度最高的。目前广为接受的是美国国家标准与技术研究院（NIST）给予的定义：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问，进人可配置的计算资源共享池。按照服务类型，可以分为  基础设施即服务（IaaS）：是指用户可以通过网络直接获取虚拟机或者其他资源等服务，比如比如我现在写文章的个人网站就是基于阿里云服务器搭建的，这里的阿里云其实就是IaaS。  平台即服务（PaaS）：是服务商可以给用户提供一个开发平台以及相应的配套服务。  软件即服务 （SaaS）：提供的是应用程序，用户直接使用。发展现状随着云计算产业的发展，中国已经成为全球最大的半导体市场，也成为增长最快的云计算市场之一。在监管科技领域的应用与实践云计算作为基础设施，可为监管科技提供良好的运营平台、开发平台。2.3.2 大数据基本原理大数据我们都比较熟悉了。泛指超出传统常规数据库软件工具能力范围的需要新处理模式的海量、多样化的数据集合和信息资产，包括传统结构化数据、半结构化数据和非结构化数据。大数据技术是伴随数据处理周期发展的一系列技术合集，包括数据采集、数据预处理、数据存储、数据挖掘和数据可视化等。其战略意义不在于庞大信息数据本身，而是要通过加工实现数据的“增值”，有助于促进统筹监管、实时监管和监管决策。在监管科技领域的应用与实践大数据在监管科技领域应用广泛，已落地多个应用场景。从业务流程看，大数据在监管科技领域的应用可分为数据收集和数据分析两大方面；从应用场景看，大数据可应用于用户身份识别、市场交易监控、合规数据报送、法律法规跟踪、风险数据融合分析、金融机构压力测试、信息系统安全等多个领域。2.3.3 人工智能基本原理人工智能是计算机科学的一个分支，全称是Artificial Intelligence，简称AI。它是一门结合了自然科学、社会科学、技 术科学的新兴交叉学科。本质是对人的思维进行模拟，从运算智能到感知智能最后到认知智能。主流技术包括计算机视觉、语音识别、机器学习、自然语言处理、知识图谱、任务规划、联邦学习等在监管科技领域的应用与实践当前人工智能技术突破、应用广泛。当前，AI已落地多个监管领域场景应用。  用户身份识别：OCR识别、人脸识别  可疑交易监测：机器学习、知识图谱  数据安全：联邦学习  欺诈用户识别：知识图谱  舆情监控：机器学习、自然语言处理  合规监管：机器学习、自然语言处理2.3.4 区块链基本原理区块链也称分布式账本（Distributrd Ledger），是由包含交易信息的区块从后向前有序链接起来的数据结构。区块链已经讲了很多，这里不再赘述了。  主要特征： 分布协作、难以篡改、强制执行、扩展性高。  主流技术：区块链技术是点对点传输、分布式数据存储、加密技术、共识机制、智能合约等多项技术要素的组合。发展现状区块链技术潜在的应用价值巨大，国内外政府组织、金融机构和科技公司均在不同程度上关注并开展区块链技术的研究 和应用。目前，主要体现在如下三个方面：  建应用，在具体的应用场景中应用区块链：国际标准化组织（ISO）设立了区块链和分布式记账技术委员会（ISO/TC 307）；国内金融领域，中国人民银行发布了《金融分布式账本技术安全规范》（JR/T0184-2020）等。  搭平台，发展区块链技术并对外相关服务：在公益、政务民生、电子存证、供应链协同、资产管理、证券交易等，区块链场景应用不断丰富。  定标准，制定区块链行业标准：国内外多个大型科技公司，通过底层区块链架设和基础设施搭建，对外提供数据上链服务，包括BaaS（Blockchain as a Service）平台、电子存证云服务等。在监管科技领域的应用与实践区块链技术在金融监管领域发挥重要作用，为降低合规成本、提高监管效率创造了条件，是监管科技重要的技术手段之一。在监管科技领域主要应用于关键信息存证、信息流转与共享，并已在多个应用场景实践，如反洗钱、票据交易、证券交易、 风险监测、合同存证、中小企业融资等。随着技术的发展，区块链与监管科技的契合度必然会越来越高，在未来的金融发展和金融监管方面，在注重区块 链技术突破的同时，一方面会探索更多的应用场景，另一方面也会更重视树立标准标杆、制定国际标准，并建立 完善的适合区块链发展的法律法规体系。2.3.5 API基本原理API全称是Application Programming Interface，即应用程序编程接口。其本质是一些预先定义好的函数，主要目的 是提供应用程序与开发人员以访问一组例程的能力 ，而使其无需访问源码或理解内部工作机制的细节 。主要包含内部 API、企业定制API、开放API（OpenAPI）三大类。在监管科技领域的应用与实践API已应用于监管科技领域的诸多场景，如支付API监控、开放银行的OpenAPI等，有效提升金融服务效能 同时，监管侧也强化对银行开放服务的合规管理，国内外监管机构均纷纷发布API相关规范文件，作为API开放的指导政策。API其实现在的应用场景也很多，比如前段时间我需要使用到天眼查的大样本数据，天眼查就提供了API可以供调用数据，但是太贵了…我只能通过爬虫解决问题。未来这种通过API接口提供服务会越来越多。2.4 监管科技的主要应用场景及案例  这一节主要简单概述了监管科技在反洗钱领域、地方金融监管、用户身份识别、市场交易行为监测、支付行为监测和风险防控五个方面的应用场景。案例引用自《中国监管科技发展报告（2020）》。此部分只涉及基本介绍，具体实现仍需探索。2.4.1 反洗钱领域应用应用背景及痛点分析反洗钱监管工作面临的痛点和问题主要集中如下两方面：  监管机构侧，面对报告机构上报的海量可疑交易报告和大额交易报告等业务数据，处理效率亟待提升。(据统计，2018年中国反洗钱中心共接收报告机构报送的 大额交易9.19亿份，可疑交易报告160.20万份。)  被监管机构侧，面临海量数据存储与计算难 、可疑交易识别难、传统交易监控系统易产生误报 、数据质量 管控难、缺少可视化工具等问题应用案例：基于Hadoop分布式架构大数据平台的反洗钱报送系统架构从日益增长的海量交易数据中高效甄别出可疑的洗钱实体、可疑洗钱实体的团伙关系、对客户进行风险评级，并通过可视化的交互方式，高效进行案宗核查。基于Hadoop分布式架构的大数据平台，在分层架构的基础 上，计算规则模型，解决数据计算和存储问题，保障报送时 效性；同时引入机器学习、深度学习等AI技术，提升可疑交易识别准确度，具有以下的特点：  海量数据存储与计算  按主题分类汇总数据，灵活构建用户画像  基于分布式架构，准实时监测和快速查询  机器学习和深度学习的应用2.4.2 地方金融监管应用应用背景及痛点分析近几年金融业态不断丰富，金融创新激增，金融乱象也随之屡有发生。相对大型持牌金融机构，地方金融经营主题普遍存在风险防范意识和风险管理能力较弱的情况，业务活动的风险系数整体偏高，给地方金融监督管理局的监管工作带来巨大挑战，主要体现在如下几点：  监管数量庞大，信息不对称：位于地方市区一级的地方金融机构，少则几千家多则数万家，靠传统现场检查基本难以覆盖。  专业人员的匮乏：监管对象复杂程度高，监管事项多，专业人员不足。  缺少技术手段支撑。应用案例：全国首创基于区块链的网贷风险处置应用——网络投票决策平台近年来网贷机构风险显露，监管部门及时引导网贷机构良性退出，其中，退出方案需通过网络投票方式表决，而普通的投票系统无法满足要求。某银行在市地方金融监督管理局的指导下，建设网络投票决策平台，运用区块链技术解决网贷机构清退流程中的互不信任问题，运用人脸识别技术解决身份验证问题，运用智能语音机器人解决公告送达问题。应用案例：智慧信访处理平台2018年7月，P2P风险集中爆发，某金融局信访量急剧增加。另一方面， 重复上报同一问题也引发大量重复性工作，传统人工回复耗时久、效率较低，信访工作人员回复时效压力激增。某银行在该金融局的指导下，运用AI等前沿科技，建设智慧信访处理平台，运用自然语言处理技术，自动检索出信访问题中的关键字，智能匹配最优答复内容，解 了人工操作需耗费大量时间的问题，大幅提升信访回复效率。上线首月，回复效率提升1倍，每周办结数上升30%，平均处理时间节省80%。2.4.3 用户身份识别应用背景及痛点分析近几年来，随着互联网高速发展，越来越多的金融服务和交易在线上进行，技术的发展带来了便利，但也给了不法分子伪造、隐藏身份的机会。不法分子盗用账号、盗用银行卡的行为日益猖獗 ，并随着灰黑产线上网络的扩张，泄露的账号、银行卡信息得以快速传播，被更多不法分子利用，极大损害消费者的权益。如何准确、有效地识别用户身份？是当下金融机构和监管部门急需解决的问题。应用案例：KYC充分利用人脸识别、图像OCR识别等技术，有效识别客户身份，提升识别和核验的准确性、有效性。2.4.4 市场交易行为监测应用背景及痛点分析科技进步促进了金融创新，互联网高速发展便利了市场交易线上化，但也滋生了大量新型金融欺诈犯罪，身份伪冒、信贷诈骗、薅羊毛、电信诈骗等欺诈案件层出不穷，欺诈风险已成为市场交易行为风险识别的重要内容。同时，监管机构为防止金融风险的发生，对金融机构也提出更高的合规要求，给金融机构的市场交易行为监测监督工作带来巨大挑战，集中体现在如下三个方面：  海量交易数据处理难：庞大客户群产生的海量交易数据，且数据来源分散、数据格式多样，超出了传统监管手段的处理能力  欺诈手段变化多，风险识别难：欺诈黑色产业链逐年增长，黑产规模庞大，互相助攻，欺诈手段不断变化，传统反欺诈技术手段难以识别风险  传统人工处理成本高、效率低、风险大：传统人工识别误判率较高、人工复核运营成本高、监控策略人为泄露损失风险大。应用案例：基于深度学习的反欺诈实时交易监测从制度标准、防控能力等方面建立面向客户的覆盖多产品、全渠道、全流程的企业级反欺诈平台。基于神经网络交易欺诈评分模型，结合大数据挖掘能力，进行交易的实时评分决策。应用案例：基于知识图谱的反欺诈黑产挖掘  黑产信息采集：充分利用内外部数据资源，采集与识别行业反欺诈黑产联盟数据，如：举报数据、公安数据等。  知识图谱黑产挖掘：基于知识图谱，挖掘潜在黑产网络路径。  知识图谱可视化辅助风险识别：通过可视化技术，直观展示黑产关联路径，辅助风险识别决策。2.4.5 支付行为监测和风险防控应用背景及痛点分析近几年，随着科技日新月异发展，我国第三方支付开启飞速发展，线上线下支付应用场景日益丰富，移动支付市场规模随之不断扩大。科技创新带来便利的同时，也带来了新的风险隐患，加大了金融机构和监管部门的风险防控和监管难度。集中体现在如下三个方面：  支付用户身份识别难，线上支付、移动支付过程中，身份伪冒风险大；  欺诈、洗钱等异常支付行为难识别；  客户信息、支付交易信息等存在泄露风险。应用案例：智能可疑交易监控科技基于“案例特征化、特征指标化、指标模型化”的推动方式，建立“立体监控+生态联防”的可疑交易风险防控体系，贯穿于事 前、事中和事后全流程环节。三、银行业监管报送  这部分主要回答这个问题：监管机构要求银行金融业机构报送的资料有哪些？这些报送要求的目的分别是什么？前面已经讲过，金融监管机构采用现场检查与非现场监管相结合的监管方式，其中又以非现场监管为主要形式。而非现场监管的主要手段即银行业各类监管数据的报送，当前，银行业的监管报送主要包括：            报送信息      监管部门                  理财与资金信托报送      人民银行              反假币报送      人民银行              个人银行账户申报      人民银行              1104 报表      银保监              人行大集中      人民银行              EAST报送      银保监              客户风险报送      银保监              对外金融资产负债及交易统计      国家外汇管理局              征信报送      人民银行              反洗钱报送      人民银行              人行存贷款标准化报送      人民银行              风险信息及特约商户信息报送      中国支付清算协会              理财信息报送      银保监              支付统计报送      人民银行              非居民金融账户涉税报送      人民银行              金融基础数据报送      人民银行              区域特色报表      各区域人行、银保监 区域化报表      3.1 理财与资金信托报送【主要业务概述】报送信息包括理财及资金信托产品的资产池及产品信息、产品募集信息、股票及其他股权资产中资金信托、理财产品投资明细信息等资产负债信息。可分为  日常：填报产品（资产池）成立信息和终止信息。  月末：填报产品的资金募集、资产池的资产负债信息。【报送目的】  全面、准确监测货币供应量与金融机构信贷规模  综合评估金融机构理财业务、资金信托业务的发展对现行货币政策传导机制的影响  参考资料：理财、资金信托专项统计制度3.2 反假币报送【主要业务概述】根据《中国人民银行货币鉴别及假币收缴、鉴定管理办法》（中国人民银行令〔2019〕第3号）第五章第三十一条：金融机构应当按照中国人民银行有关规定，对现金机具、人员培训、冠字号码以及假币收缴鉴定业务等进行数据管理，并将相关数据报送中国人民银行或其分支机构。【报送目的】规范货币鉴别及假币收缴、鉴定行为，保护货币持有人的合法权益3.3 个人银行账户申报【主要业务概述】根据《人民币银行结算账户管理系统业务处理办法》（银办发［2007］74号）第二十八条：银行应对存款人的开户申请书填写的事项和证明文件的真实性、完整性、合规性进行认真审查。开户申请书填写的事项齐全，符合开立基本存款账户、临时存款账户和预算单位专用存款账户条件的，银行应将存款人的开户申请书、相关的证明文件和银行审核意见等开户资料报送中国人民银行当地分支行，经其核准后办理开户手续；符合开立一般存款账户、其他专用存款账户和个人银行结算账户条件的，银行应办理开户手续，并于开户之日起5个工作日内向中国人民银行当地分支行备案。【报送目的】规范人民币银行结算账户的开立和使用，维护经济金融秩序稳定3.4 1104报表【主要业务概述】1104报表是指“1104工程”指定的报表，而“1104工程”又是指2003年11月4日银监会召开的“银行业金融机构监管信息系统建设”主席办公会和监管信息系统建设领导小组会议上决定启动的银行业金融机构监督信息系统这一重大举措。 这是我国银行业监管方式的一次革命。根据银保监《关于做好2022年银行业非现场监管报表填报工作的通知》，要求各金融机构报送的主要报表，包括资产负债，表外业务、流动性风险、贷款质量、投向行业和地区、重点客户等。2022年新增了四大类全新报表：  《G05个人存贷款情况统计表》：目前只报送贷款情況，由此可见，我国网络借货行业引发监管关注，国家正在不断加大对网络借货的监管力度。  《G27主要负债项目明细表》  《G53_VI域存货款情况表》：该表统计县域地区的存贷款业务，是为了继续做好原金融精准扶贫贷款存量统计、信贷支持脱贫地区、统计脱贫人口情況  《S68 绿色融资情况表》：要推进绿色融资【报送目的】帮助监管人员更加准确地识别银行机构的风险和抵御风险的能力，以帮助监管人员更加全面地对风险进行评价和预警。  参考资料：2022年度1104报表填报“浅析”3.5 人行大集中【主要业务概述】人民银行金融统计数据大集中自动化报送系统（简称PBOC Report），是基于现代计算机网络技术应用基础上，由人行总行设置金融统计数据服务器，建立的一个全国统一的金融统计数据库。人行针对各银行存贷款、中间业务、网点人员、互联网金融等汇总报表统计，贷款类报表较多，从行业、期限、业务种类分别进行统计。人行大集中报表主要包括常规报表和临时报表。  常规报表根据报送频度又分为日报、月报、季报和年报，月报根据报送日期先后分为月报一批和月报二批，共报送37张报表  临时报表主要是人行或者其他国家机关出于宏观经济调控等的需要，由人行营管部调统处发布通知，组织填报的报表【报送目的】通过采集和处理所有金融机构上报的金融统计数据，生成金融机构县级以上各层次的金融统计报表和数据，并实现对金融统计数据的统一管理、统一维护与共享。有很强的监管意义。比如公安部在16个城市试点基础上，在全国推广机动车检验标志电子化，为机动车所有人、驾驶人以及相关行业和管理部门提供电子证照服务。  参考资料: 一文读懂【人行大集中+金标】之【概念定义、报送内容、校验规则、监管意义】3.6 EAST（监管数据标准化规范）【主要业务概述】EAST系统全称Examination and Analysis Technology，是银监会在2008年开发的具有自主知识产权的检查分析系统，旨在顺应大数据发展趋势需求，并帮助监管部门提高检查效能。系统包含银行标准化数据提取、现场检查项目管理、数据模型生成工具、数据模型发布与管理等功能模块。2019年9月29日，中国银行保险监督管理委员会办公厅（以下简称“银保监会”）颁布关于印发《银行业金融机构监管数据标准化规范》（2019年版）的通知（以下简称“EAST 4.0”）。EAST作为1104之后的又一重量级监管报送系统，与1104报送汇总数据的维度明显不同。EAST报送的是数据明细，涵盖十个监管主题域、66张数据表、1852个数据项，包括客户、账户、交易、机构、合同、中间业务等所有明细数据，但这些明细又与1104报表有着严密的校验关系，EAST报送是将各银行千差万别的数据结构映射成统一的标准监管格式数据，以实现标准监管数据的采集和处理。EAST的报送明细数据量非常大。【报送目的】EAST报送将中小银行千差万别的数据结构映射成统一的标准监管格式数据，以实现标准监管数据的采集和处理统一的监管数据更利于机构之间的比对，有利于银行业风险的整体把控。3.7 客户风险报送【主要业务概述】银监会决定从2013年起实行新版客户风险统计制度，对各政策性银行、国有商业银行、股份制商业银行、邮储银行（目前邮储银行已经并入国有银行）进行客户信息汇总统计。客户风险数据报送包括对公及同业客户授信和表内外业务统计表、集团客户、供应链融资基本信息统计表、单一法人客户基本信息统计表、对公客户担保情况统计表、个人贷款违约情况统计表、个人违约贷款担保情况统计表相关客户风险信息，共计6张大表，18张子表。【报送目的】实现对主要银行业金融机构表内外信用风险的全面监测，重点加强集团客户授信风险监测能力，逐步完善前瞻性的风险识别信息3.8 对外金融资产负债及交易统计【主要业务概述】主要采集中国居民（包括境内机构和个人）与非中国居民之间各项国际收支交易的流量以及对外金融资产负债的存量数据。对外金融资产负债及交易申报业务大体归为两个部分：  国际收支交易：即中国居民与非中国居民之间的各项交易，包括货物买卖、服务贸易、股息利息收支、无偿捐赠以及赔偿，直接投资、证券投资、金融衍生产品以及存贷款等其他投资交易。  对外金融资产、负债：指中国居民对非中国居民拥有的金融资产，包括对外直接投资、证券投资、金融衍生产品投资、存款、发放贷款及各类应收款等；对外负债指中国居民对非中国居民承担的负债，包括吸收直接投资、发行有价证券、金融衍生产品投资、吸收存款、接受贷款及各类应付款等。【报送目的】进一步完善对外金融资产负债及交易统计3.9 征信报送【主要业务概述】目前正处于一代征信到二代征信的过渡阶段。2018年6月，中国人民银行征信中心发布了《人民银行征信系统数据采集规范（二代试行）》系统列标准，对个人征信、企业征信、征信查询等采集要求做了整体变更，对于银行的监管也愈发严格。二代征信分企业征信和个人征信：  个人征信报送基本信息、借贷信息、担保信息三大类报表  企业征信报送基本信息、借贷交易信息、担保交易信息、抵质押物信息、财务报表信息五大类报表【报送目的】  与现阶段的征信系统相比，二代征信系统采集业务范围更广、数据项更多  重新制定通用数据采集标准，全面支持商业银行新兴信贷业务数据采集  提供更方便、更规范的征信信息服务  建立更健全的数据质量管控体系及合规管理体系3.10 反洗钱报送【主要业务概述】反洗钱报送主要报送大额交易和可疑交易，  大额交易：指个人之间人民币5万，美元1万以上的交易，个人和单位之间50万以上人民币，或5万美元以上交易，单位客户之间200万人民币或20万美元之间的交易。  可疑交易：要求金融机构发现或者有合理理由怀疑客户、客户的资金或者其他资产、客户的交易或者试图进行的交易与洗钱、恐怖融资等犯罪活动相关的，不论所涉资金金额或者资产价值大小，应当提交可疑交易报告。【报送目的】规范金融机构大额交易和可疑交易报告行为3.11 人行存贷款标准化报送【主要业务概述】为了加强对金融机构存、贷款业务的及时监测和管理，人民银行在《存款统计分类及编码（试行）》、《贷款统计分类及编码（试行）》的基础上，拟定了《存款数据元（试行）》、《贷款数据元（试行）》，采用抽样统计的方法，建立《标准化存贷款综合抽样统计监测制度（试行）》，简称“金标”。包括存款余额、贷款余额、贷款发生额三张报文，部分银行根据自身业务属性，划分出活期存款余额、非活期存款余额、贷款余额、贷款发生额四类报文。【报送目的】逐月报送存贷款数据，以便及时、准确、系统地反映金融机构存款和贷款的结构、风险、利率水平等相关信息。3.12 支付统计报送【主要业务概述】支付信息统计分析(Statistical analysis of payment information)简称PISA，自2015年起，支付业务数据通过支付信息统计分析系统报送，取消支付业务报表手工报送方式。根据中国人民银行关于发布〈支付业务统计指标〉行业标准的通知。报送内容包括：支付环境统计指标、支付服务组织统计指标、人民币银行结算账户类统计指标、支付工具统计指标、支付系统统计指标、其它支付指标等。共计31张报表，1张年报，6张季报，24张月报。【报送目的】支付体系运行中形成的支付信息，是一国经济金融活动的原始记录，蕴含着社会资金运动的规律，是宏观经济运行的“晴雨表”，相对其他数据而言，具有准确性、实时性、客观性特点，有利于完善支付体系监督管理，促进支付研究和领导决策3.13 金融基础数据报送【主要业务概述】为了全面落实和实现国务院办公厅下发《关于全面推进金融业综合统计工作的意见》中的综合统计工作的总体目标，中国人民银行调查统计司于2020年6月12日下发了《关于建立金融基础数据统计制度的通知（试行）》。金融基础数据报送涵盖贷款、存款、债券、股权投资和特定目的载体投资等四方面，涉及交易对手管理、业务存量管理、合同管理、风险控制等各方面，统计内容细、要素多、数据量庞大。【报送目的】通过准确及时的全量逐笔明细采集，逐步实现金融业综合统计工作全覆盖，对高效赋能金融数据生产力、维护国家金融稳定具有重要意义，是打造国家金融基础数据库的重要组成部分。免责声明：监管报送是非常专业的领域，笔者仅根据所学知识整理资料，资料来源包括银保监会、人民银行、外管局、人行征信中心的监管发文、行业研究报告、公司研究报告、网络文章等，不做任何商业用途，旨在督促自己进步的同时，逐渐将知识沉淀下来。  参考：【金融科技前沿】【长文】金融监管、监管科技以及银行业监管报送概述"
  },
  
  {
    "title": "MySQL安全模式",
    "url": "/posts/mysql-anquan-moshi/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2022-07-21 10:47:00 +0800",
    





    
    "snippet": "MySQL安全模式要求不能对非主键的条件查询做update和delete操作报错信息update activity set type = 1 where title = 'aa' Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses ...",
    "content": "MySQL安全模式要求不能对非主键的条件查询做update和delete操作报错信息update activity set type = 1 where title = 'aa' Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Editor and reconnect. 0.000 sec解决方法查看安全模式开关状态show variables like 'SQL_SAFE_UPDATES';关闭安全模式SET SQL_SAFE_UPDATES = 0;  参考：MySQL安全模式"
  },
  
  {
    "title": "解决无法复制代码的问题",
    "url": "/posts/jiejue-wufa-fuzhi-daima-wenti/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2022-07-21 08:47:00 +0800",
    





    
    "snippet": "$(\"#content_views pre\").css(\"user-select\", \"text\");$(\"#content_views pre code\").css(\"user-select\", \"text\");",
    "content": "$(\"#content_views pre\").css(\"user-select\", \"text\");$(\"#content_views pre code\").css(\"user-select\", \"text\");"
  },
  
  {
    "title": "时间",
    "url": "/posts/jinianri/",
    "categories": "Index, Learning",
    "tags": "TODO",
    "date": "2022-07-12 13:47:00 +0800",
    





    
    "snippet": "            \t    ",
    "content": "            \t    "
  },
  
  {
    "title": "如何给Tomcat指定JDK和JRE",
    "url": "/posts/ruhe-gei-tomcat-zhiding-jdk/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "在Tomcat安装目录下的bin目录下找到setclasspath.sh，在最开始添加以下代码export JAVA_HOME=\"/home/jdk-1.8\"export JRE_HOME=\"/home/jdk-1.8/jre\"",
    "content": "在Tomcat安装目录下的bin目录下找到setclasspath.sh，在最开始添加以下代码export JAVA_HOME=\"/home/jdk-1.8\"export JRE_HOME=\"/home/jdk-1.8/jre\""
  },
  
  {
    "title": "Spring Boot配置Redis哨兵模式连接",
    "url": "/posts/springboot-peizhi-redis-shaobing-moshi-zhixing-lianjie/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "spring:    redis:        database: 0        # host: 127.0.0.1 # 哨兵模式无效youxiao        port: 6379        password: root # 哨兵模式有效        # 连接超时时长（毫秒）        pingInterval: 100000        timeout: 100000...",
    "content": "spring:    redis:        database: 0        # host: 127.0.0.1 # 哨兵模式无效youxiao        port: 6379        password: root # 哨兵模式有效        # 连接超时时长（毫秒）        pingInterval: 100000        timeout: 100000        sentinel:            master: mymaster            # 哨兵节点列表            nodes: 192.168.1.1:6371,192.168.1.1:6372,192.168.1.1:6373        jedis:            pool:                 # 连接池最大连接数（使用0表示没有限制）                max-active: 100                # 连接池最大阻塞等待时间（使用-1表示没有限制），超时报异常                max-wait: -1                # 连接池种的最大空闲连接（使用0表示没有限制）                max-idle: 10                # 连接池中的最小空闲连接（使用0表示没有限制）                min-idle: 5"
  },
  
  {
    "title": "Redis哨兵模式执行select 0命令报错： (error) ERR unknown command select, with args beginning with：0",
    "url": "/posts/redis-shaobing-moshi-zhixing-select0-baocuo/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "报错信息Redis哨兵模式执行select 0命令报错。(error) ERR unknown command select, with args beginning with: 0解决办法三个node节点为：10.12.168.68:6395,10.12.168.69:6395,10.12.168.70:6396redis-cli -h 10.12.168.68 -p 6395 -a 12...",
    "content": "报错信息Redis哨兵模式执行select 0命令报错。(error) ERR unknown command select, with args beginning with: 0解决办法三个node节点为：10.12.168.68:6395,10.12.168.69:6395,10.12.168.70:6396redis-cli -h 10.12.168.68 -p 6395 -a 1234   # 通，但是执行 select 0 报错redis-cli -h 10.12.168.69 -p 6395 -a 1234   # 通，但是执行 select 0 报错redis-cli -h 10.12.168.70 -p 6396 -a 1234   # 通，但是执行 select 0 报错虽然不能执行select 0，但是可以执行info，找到主节点信息，然后连接主节点再进行操作即可。产生原因因为哨兵的nodes不是主节点，也不是从节点，也就是说不是数据节点，而是监控节点，主要为了当主节点挂掉之后，选举新的主节点。所以在该nodes节点是无法运行select、keys等命令的。  参考：redis哨兵模式执行select 0命令报错： (error) ERR unknown command select, with args beginning with: 0"
  },
  
  {
    "title": "Maven连接私服如何配置",
    "url": "/posts/maven-lianjie-sifu-de-peizhi/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2022-06-09 13:47:00 +0800",
    





    
    "snippet": "Maven的setting.xml文件配置，该配置中使用了一个id为nexusProfile的profile，这个profile包含了相关的仓库配置，同时配置中又使用了activeProfile元素将这个profile激活，这样当执行Maven构件的时候，激活的profile会将仓库配置应用到项目中去。&lt;profiles&gt;    &lt;profile&gt;        &l...",
    "content": "Maven的setting.xml文件配置，该配置中使用了一个id为nexusProfile的profile，这个profile包含了相关的仓库配置，同时配置中又使用了activeProfile元素将这个profile激活，这样当执行Maven构件的时候，激活的profile会将仓库配置应用到项目中去。&lt;profiles&gt;    &lt;profile&gt;        &lt;!-- profile的id --&gt;        &lt;id&gt;nexusProfile&lt;/id&gt;        &lt;repositories&gt;            &lt;repository&gt;                &lt;!-- 仓库id，repositories可以配置多个仓库，保证id不重复 --&gt;                &lt;id&gt;nexus&lt;/id&gt;                &lt;!-- 仓库地址，即Nexus仓库组的地址 --&gt;                &lt;url&gt;http://nexus.m2plat.cn/repository/maven-public/&lt;/url&gt;                &lt;!-- 是否下载releases构件 --&gt;                &lt;releases&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                &lt;/releases&gt;                &lt;!-- 是否下载snapshots构件 --&gt;                &lt;snapshots&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                &lt;/snapshots&gt;            &lt;/repository&gt;        &lt;/repositories&gt;        &lt;pluginRepositories&gt;            &lt;!-- 插件仓库，Maven的运行依赖插件，也需要从私服下载插件 --&gt;            &lt;pluginRepository&gt;                &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt;                &lt;id&gt;nexus&lt;/id&gt;                &lt;url&gt;http://nexus.m2plat.cn/repository/maven-public/&lt;/url&gt;                &lt;releases&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                &lt;/releases&gt;                                &lt;snapshots&gt;                    &lt;enabled&gt;true&lt;/enabled&gt;                    &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;                    &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;                &lt;/snapshots&gt;            &lt;/pluginRepository&gt;        &lt;/pluginRepositories&gt;    &lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt;    &lt;activeProfile&gt;nexusProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt;配置镜像让Maven只使用私服，配置后本机所有的Maven项目都会从Nexus私服下载构件：&lt;!-- Maven对全部仓库的访问全部拦截到私服的public仓库中去 --&gt;&lt;!-- 如果私服关闭，那么就不能访问中央工厂了--&gt;&lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;nexus&lt;/id&gt;        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;        &lt;name&gt;Local Repository&lt;/name&gt;        &lt;url&gt;http://127.0.0.1:8081/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;&lt;/mirrors&gt;配置Maven部署构件到Nexus：&lt;!-- 项目部署到私服配置 --&gt;&lt;distributionManagement&gt; &lt;!-- 远程部署管理信息 --&gt;    &lt;repository&gt; &lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt;        &lt;id&gt;releases&lt;/id&gt;        &lt;name&gt;Nexus Release Repository&lt;/name&gt;        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/releases/&lt;/url&gt;    &lt;/repository&gt;    &lt;snapshotRepository&gt; &lt;!-- 如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt;        &lt;id&gt;snapshots&lt;/id&gt;        &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt;        &lt;url&gt;http://127.0.0.1:8081/nexus/content/repositories/snapshots/&lt;/url&gt;    &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;  Nexus仓库对匿名用户是只读的，所以为了能够部署构件，还需要在setting.xml文件中配置认证信息：&lt;!--私服的验证信息--&gt;&lt;servers&gt;    &lt;server&gt;        &lt;id&gt;releases&lt;/id&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;admin123&lt;/password&gt;    &lt;/server&gt;    &lt;server&gt;        &lt;id&gt;snapshots&lt;/id&gt;        &lt;username&gt;admin&lt;/username&gt;        &lt;password&gt;admin123&lt;/password&gt;    &lt;/server&gt;&lt;/servers&gt;配置好以后，就可以通过Maven的deploy命令，将项目的jar包部署到Nexus上，供其他项目组模块使用。大大加快了项目组的开发效率。  参考：为什么要用远程仓库（私服）maven 私服的使用及settings.xml的配置"
  },
  
  {
    "title": "JQuery格式化时间",
    "url": "/posts/jquery-geshihua-shijian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2022-04-19 13:47:00 +0800",
    





    
    "snippet": "$(function(){    alert(getDateString(new Date(\"2022-04-19\")));});function getDateString(time) {    var datetime = new Date();    datetime.setTime(time);    var year = datetime.getFullYear();    var...",
    "content": "$(function(){    alert(getDateString(new Date(\"2022-04-19\")));});function getDateString(time) {    var datetime = new Date();    datetime.setTime(time);    var year = datetime.getFullYear();    var month = datetime.getMonth() + 1 &lt; 10 ? \"0\"                 + (datetime.getMonth() + 1) : datetime.getMonth() + 1;    var date = datetime.getDate() &lt; 10 ? \"0\"                 + datetime.getDate() : datetime.getDate();    var hour = datetime.getHours() &lt; 10 ? \"0\"                 + datetime.getHours() : datetime.getHours();    var minute = datetime.getMinutes() &lt; 10 ? \"0\"                 + datetime.getMinutes() : datetime.getMinutes();    var second = datetime.getSeconds() &lt; 10 ? \"0\"                 + datetime.getSeconds() : datetime.getSeconds();    return year + \"-\" + month + \"-\" + date + \" \" + hour + \":\" + minute + \":\" + second;}"
  },
  
  {
    "title": "Kali拿取路由器pin码",
    "url": "/posts/kali-qu-luyouqi-pinma/",
    "categories": "Knowledge, SECURITY",
    "tags": "SECURITY",
    "date": "2022-04-10 13:47:00 +0800",
    





    
    "snippet": "网卡监听模式airmon-ng start wlan0　　扫描wash -i wlan0mon跑pin            网卡          物理地址         信道reaver -i wlan0mon -b 00:5A:13:40:AA:F8 -c 11 -vv -K 0通过pin获得wifi密码            网卡          物理地址           p...",
    "content": "网卡监听模式airmon-ng start wlan0　　扫描wash -i wlan0mon跑pin            网卡          物理地址         信道reaver -i wlan0mon -b 00:5A:13:40:AA:F8 -c 11 -vv -K 0通过pin获得wifi密码            网卡          物理地址           pin码reaver -i wlan0mon -b 78:A1:06:B6:2A:42 -p 92975934  参考：kali拿取路由器pin码"
  },
  
  {
    "title": "Kali暴力破解wifi密码",
    "url": "/posts/kali-pojie-wifi/",
    "categories": "Knowledge, SECURITY",
    "tags": "SECURITY",
    "date": "2022-04-09 13:47:00 +0800",
    





    
    "snippet": "查看本机网卡名称ifconfig  eth0有线网卡  wlan0无线网卡虚拟机无法访问网卡，所以需要使用外接的USB无线网卡。查看是否支持监听模式airmon-ng如果该命令没有任何输出则表示没有可以支持监听模式的网卡。开启无线网卡的监听模式airmon-ng start wlan0如果airmon-ng显示的是wifi0，就把wlan0改为wifi0，这时候再输入ifconfig，会发现...",
    "content": "查看本机网卡名称ifconfig  eth0有线网卡  wlan0无线网卡虚拟机无法访问网卡，所以需要使用外接的USB无线网卡。查看是否支持监听模式airmon-ng如果该命令没有任何输出则表示没有可以支持监听模式的网卡。开启无线网卡的监听模式airmon-ng start wlan0如果airmon-ng显示的是wifi0，就把wlan0改为wifi0，这时候再输入ifconfig，会发现wlan0变为了wlan0mon，这表明网卡监听模式已开启。搜索附近的WiFiairodump-ng wlan0mon使用airodump-ng命令列出无线网卡扫描到的WiFi热点详细信息，包括信号强度，加密类型，信道等，BSSID为MAC地址，PWR为信号强度（越小信号越强），CH为信道，#DATA为数据量，越大使用的人就越多。这里我们记下要破解WiFi的BSSID和信道。当搜索到我们想要破解的WiFi热点时可以Ctrl+C停止搜索。抓取握手包使用网卡的监听模式抓取周围的无线网络数据包，其中我们需要用到的数据包是包含了WiFi密码的握手包，当有新用户连接WiFi时会发送握手包。airodump-ng -c 10 --bssid D4:EE:07:12:57:80 -w ~/ wlan0mon  -c指定信道  -bssid指定目标路由器的BSSID  -w指定抓取数据包保存的目录强制连接到wifi的设备重连路由器现在我们使用aireplay-ng命令给连接到wifi的设备发送一个反认证包，使设备强制断开连接，随后它会自动再次连接wifi，这个自动连接过程会进行三次握手，会发送TCP包（里面包含加密的密码数据）。不难看出，airplay-ng生效的前提是WiFi热点中必须至少已经接入一个设备。由于刚刚打开的终端一直在执行抓包工作，所以我们重新打开一个终端，输入命令。aireplay-ng -0 5 -a D4:EE:07:12:57:80 -c AC:CF:85:B6:81 wlan0mon  -a指定目标路由器的BSSID  -c指定要攻击设备的MAC地址  -0为用deauth洪水攻击WiFi设备的次数，-0 0为无限，-0 5则攻击5次结束无线网卡的监听模式此时返回前一个终端，当窗口右上角出现WPA handshake时说明抓包成功，这个时候使用Ctrl+C命令停止抓包，同时结束无线网卡的监听模式。airmon-ng stop wlan0mon解压字典文件Kali本身就有字典文件，我们把它解压出来。gzip -d /usr/share/wordlists/rockyou.txt.gz暴力破解上面已经成功抓取到了握手包，现在要做的工作就是将握手包的密码和字典文件中的密码进行匹配。aircrack-ng -w /usr/share/wordlist/rockyou.txt ~/*.cap  -w字典路径 握手包路径生成字典文件如果Kali自带的字典文件不够用，可以通过crunch自己制作字典。crunch 10 10 012 xy &gt; /root/12345.txt   10 10表示制作一个10位数的密码  012 xy表示密码中包含数字012、xy这些元素  /root/12345.txt表示密码文本储存的路径以及名字"
  },
  
  {
    "title": "如何去除有道云笔记广告",
    "url": "/posts/ruhe-quchu-youdaoyun-de-guanggao/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2022-04-06 08:47:00 +0800",
    





    
    "snippet": "一、适用于6.0之前版本你只需要找到有道云笔记的安装路径*\\Youdao\\YoudaoNote\\theme\\build.xml，把下面的代码删掉&lt;PanelAd type=\"adpanel\" css=\"public\" ass=\"mainform panelclient PanelAd\"&gt;         &lt;panelTopLine type=\"panel\" css=\"AdP...",
    "content": "一、适用于6.0之前版本你只需要找到有道云笔记的安装路径*\\Youdao\\YoudaoNote\\theme\\build.xml，把下面的代码删掉&lt;PanelAd type=\"adpanel\" css=\"public\" ass=\"mainform panelclient PanelAd\"&gt;         &lt;panelTopLine type=\"panel\" css=\"AdPanel\" Dockstyle=\"top\"                        Bounds=\"0,0,0,1\"/&gt;         &lt;AdPhoto type=\"photo\" css=\"Ad AdPhoto\" ass=\"common fill\"/&gt;         &lt;AdText type=\"label\" css=\"AdText\" AnchorStyle=\"topleft\"                  Bounds=\"20,135,25,10\" Margin=\"0,0,0,0\"/&gt;&lt;/PanelAd&gt;之后保存，重启有道云笔记，就可以了。二、6.0及以后版本找到有道云笔记的安装路径*\\Youdao\\YoudaoNote\\theme\\build.xml，找到PanelAd标签&lt;PanelAd type=\"adpanel\" css=\"public\" ass=\"mainform PanelAd\"&gt;    &lt;panelTopLine type=\"panel\" css=\"AdPanel\" Dockstyle=\"top\" Bounds=\"0,0,0,1\"/&gt;    &lt;MiddlePhotoPanel type=\"panel\" css=\"public\" DockStyle=\"top\"                       Bounds=\"0,0,250,160\" Margin=\"0,13,0,13\"&gt;        &lt;AdPhoto type=\"photo\" css=\"Ad AdPhoto\" AnchorStyle=\"center\"                  AutoZoom=\"ZoomEqual\" Bounds=\"0,0,200,130\"&gt;            &lt;AdClose type=\"button\" css=\"adclear\" AnchorStyle=\"topright\"                      Bounds=\"-1,1,24,24\" /&gt;            &lt;AdText type=\"label\" css=\"AdText\" AnchorStyle=\"bottomleft\"                      Bounds=\"6,-6,25,10\"/&gt;        &lt;/AdPhoto&gt;    &lt;/MiddlePhotoPanel&gt;&lt;/PanelAd&gt;删除ass属性里面的panelclient这个值，我上面的截图是删除之后的。然后找到AdWraperMid这个标签，大概在466行，修改bounds属性值为0，0，0，0。&lt;!-- 底部广告--&gt;&lt;AdWraperMid type=\"panel\" css=\"public\" dockstyle=\"bottom\"              visible=\"false\" bounds=\"0,0,0,0\"&gt;    &lt;PanelAdMid type=\"control\" control=\"PanelAd\"&gt;    &lt;/PanelAdMid&gt;    &lt;LeftShadow type=\"control\" control=\"MidPanelLeftShadow\"/&gt;&lt;/AdWraperMid&gt;之后保存，重启有道云笔记，就可以了。  参考：如何去除有道云笔记广告（windows）"
  },
  
  {
    "title": "如何查看和修改Redis密码",
    "url": "/posts/ruhe-chakan-he-xiugai-redis-mima/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-03-24 13:47:00 +0800",
    





    
    "snippet": "打开redis.windows.conf文件，默认是没有requirepass root这句话的，因为默认密码是”“，加上这句话意思就是密码修改为root。",
    "content": "打开redis.windows.conf文件，默认是没有requirepass root这句话的，因为默认密码是”“，加上这句话意思就是密码修改为root。"
  },
  
  {
    "title": "Redis启动报错：The Windows version of Redis allocates a memory ...",
    "url": "/posts/redis-qidong-baocuo/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2022-03-24 13:47:00 +0800",
    





    
    "snippet": "报错信息The Windows version of Redis allocates a memory mapped heap for sharing with the forked process used for persistence operations. In order to share this memory, Windows allocates from the system...",
    "content": "报错信息The Windows version of Redis allocates a memory mapped heap for sharing with the forked process used for persistence operations. In order to share this memory, Windows allocates from the system paging file a portion equal to the size of the Redis heap. At this time there is insufficient contiguous free space available in the system paging file for this operation (Windows error 0x5AF). To work around this you may either increase the size of the system paging file, or decrease the size of the Redis heap with the --maxheap flag.Sometimes a reboot will defragment the system paging file sufficiently for this operation to complete successfully.Please see the documentation included with the binary distributions for more details on the --maxheap flag.Redis can not continue. Exiting.产生原因系统内存不足解决办法可以通过添加启动参数解决redis-server.exe  redis.windows.conf  --maxheap 1gbmaxheap参数可以带单位也可以不带单位，不带单位默认为字节"
  },
  
  {
    "title": "JSESSIONID什么时候生成并传递到前端的",
    "url": "/posts/jsessionid-shenme-shihou-shengcheng/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2022-03-03 13:47:00 +0800",
    





    
    "snippet": "如果客户端请求的cookie中不包含JSESSIONID，服务端调用request.getSession()时就会生成并传递给客户端，此次响应头会包含设置cookie的信息。如果客户端请求的cookie中包含JSESSIONID，服务端调用request.getSession()时就会根据JSESSIONID进行查找对象，如果能查到就返回，否则就跟没传递JSESSIONID一样。如果是彻底动...",
    "content": "如果客户端请求的cookie中不包含JSESSIONID，服务端调用request.getSession()时就会生成并传递给客户端，此次响应头会包含设置cookie的信息。如果客户端请求的cookie中包含JSESSIONID，服务端调用request.getSession()时就会根据JSESSIONID进行查找对象，如果能查到就返回，否则就跟没传递JSESSIONID一样。如果是彻底动静分离的时候session怎么标识？彻底的动静分离，对session并无影响，无论是直接浏览器url请求还是Ajax请求都会在客户端cookie生成sessionid；如果要通过缓存进行自行管理session也是可以的。  参考：jsessionid什么时候生成并传递到前端的？"
  },
  
  {
    "title": "Vue怎么将表单的值传给后台",
    "url": "/posts/ruhe-jiang-vueform-de-zhi-chuandao-houtai/",
    "categories": "Knowledge, Vue",
    "tags": "Vue",
    "date": "2022-02-22 13:47:00 +0800",
    





    
    "snippet": "...let form = null;form = this.questionForm;const params = form;const res = this.saveSubject(params);...",
    "content": "...let form = null;form = this.questionForm;const params = form;const res = this.saveSubject(params);..."
  },
  
  {
    "title": "Error Code：1175. You are using safe update mode and you tried to update a table without a WHERE tha",
    "url": "/posts/error-code-1175/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2022-02-22 10:47:00 +0800",
    





    
    "snippet": "MySQL在执行删除、更新语句时报这种错误，是因为在MySQL处于safe-updates模式中，如果where后跟的条件不是主键id，那么就会提示这种错误。解决方式有两种。  SET SQL_SAFE_UPDATES = 0;执行该命令更改MySQL数据库模式。  在where判断条件中跟上主键id，例如：delete from firstmysqldatabase.user where ...",
    "content": "MySQL在执行删除、更新语句时报这种错误，是因为在MySQL处于safe-updates模式中，如果where后跟的条件不是主键id，那么就会提示这种错误。解决方式有两种。  SET SQL_SAFE_UPDATES = 0;执行该命令更改MySQL数据库模式。  在where判断条件中跟上主键id，例如：delete from firstmysqldatabase.user where UserName='zhangsan' and ID&gt;=0;  参考：Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE tha"
  },
  
  {
    "title": "Java去掉JSON数据中值为null的属性字段",
    "url": "/posts/qudiao-json-hong-wei-null-de-yuansu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2022-02-18 01:47:00 +0800",
    





    
    "snippet": "@JsonInclude(JsonInclude.Include.NON_NULL) 此方法集成于Springboot2.0中，此方法的配置意在实体类与JSON互转的时候属性值为null的不参与序列化。使用时用注解的方式：放在标记类@JsonInclude(JsonInclude.Include.NON_NULL) public class HandlePayResponse {    pr...",
    "content": "@JsonInclude(JsonInclude.Include.NON_NULL) 此方法集成于Springboot2.0中，此方法的配置意在实体类与JSON互转的时候属性值为null的不参与序列化。使用时用注解的方式：放在标记类@JsonInclude(JsonInclude.Include.NON_NULL) public class HandlePayResponse {    private String platform_order_id;    private String order_id;    ...}属性public class HandlePayResponse {    ...    @JsonInclude(JsonInclude.Include.NON_NULL)     private String remark1;    private String remark2;    ...}配置文件中添加全局配置jackson.default-property-inclusion:non_null不过这配置要慎用，不然你项目中所有的实体类转为JSON需要显示时，值为null的都不会显示。使用前效果：{\"platform_order_id\":\"20191025112603731\",\"order_id\":\"12345\",\"merchant_id\":\"1\",\"sign\":\"3b8944f68fd2a3ef54dc349cba207e457435bd653375d10043adec832d9db14c\",\"sign_type\":\"SHA256\",\"total_amount\":\"1\",\"remark1\":null,\"remark2\":null,\"qrUrl\":\"https://qr.chinaums.com/bills/qrCode.do?id=30471910253040324116767159\",\"code\":\"SUCCESS\",\"errorMassage\":null}使用后效果：{\"platform_order_id\":\"20191025104352324\",\"order_id\":\"12345\",\"merchant_id\":\"1\",\"sign\":\"388db8c52c86b4843f676340fb12c10ee1ca2674eeb4057dd0cb58d00adc0e17\",\"sign_type\":\"SHA256\",\"total_amount\":\"1\",\"qrUrl\":\"https://qr.chinaums.com/bills/qrCode.do?id=30471910256385241102482750\",\"code\":\"SUCCESS\"}  参考：Java取掉json数据中值为null的属性字段"
  },
  
  {
    "title": "前端到后端400错误（The server cannot or will not process the request due to...）",
    "url": "/posts/qianduan-dao-houtai-400-cuowu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2022-01-21 01:47:00 +0800",
    





    
    "snippet": "错误信息The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request ...",
    "content": "错误信息The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).错误原因      第一种情况    前端提交的内容在后端一般都用String类型来接收，用Date类型接收会报错。        第二种情况    在提交表单的时候，填写的数据类型与Controller层的接收类型不一致导致400错误，可以检查一下代码，看看是不是请求参数错误，表单传过去的数据无法与pojo对象匹配。        第三种情况    Controller代码方法中使用了@RequestParam注解，但是在jsp中没有对应的@RequestParam注解name属性参数值，而且@RequestParam注解的required属性默认为true，也就是说，JSP中参数值必须对应@RequestParam注解的name属性值。  "
  },
  
  {
    "title": "表单中name相同的元素在后台如何获取",
    "url": "/posts/biaodan-zhong-name-xiangtong-ruhe-zaihoutai-huoqu-shuju/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2022-01-21 01:47:00 +0800",
    





    
    "snippet": "name相同的多个元素只需要在后台用String[] param = request.getParameterValues(\"param\")就可以了。",
    "content": "name相同的多个元素只需要在后台用String[] param = request.getParameterValues(\"param\")就可以了。"
  },
  
  {
    "title": "在静态方法中调用Spring注入的类",
    "url": "/posts/zaijingtaifangfa-zhong-diaoyong-spring-zhuru-de-lei/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-12-24 01:47:00 +0800",
    





    
    "snippet": "@Componentpublic class FileUtil {    @Autowired    FileConfig fileConfig;    @Autowired    private static FileConfig staticFileConfig;    @PostConstruct    public void init() {        staticFileCon...",
    "content": "@Componentpublic class FileUtil {    @Autowired    FileConfig fileConfig;    @Autowired    private static FileConfig staticFileConfig;    @PostConstruct    public void init() {        staticFileConfig = fileConfig;    }    public static void test() {        // getPath()是FileConfig中的方法        String path = staticFileConfig.getPath();    }}@PostConstruct注解被用来修饰一个非静态的void()方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。该注解的方法在整个Bean初始化中的执行顺序：Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)  参考：在静态方法中调用Spring注入的类的方法"
  },
  
  {
    "title": "图片转BASE64",
    "url": "/posts/tupian-zhuan-base64/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-12-24 01:47:00 +0800",
    





    
    "snippet": "public static String getImageStr(File file, String fileType)             throws IOException {    String fileContentBase64 = null;    String base64Str = \"data:\" + fileType + \";base64,\";    String co...",
    "content": "public static String getImageStr(File file, String fileType)             throws IOException {    String fileContentBase64 = null;    String base64Str = \"data:\" + fileType + \";base64,\";    String content = null;    //将图片文件转化为字节数组字符串，并对其进行Base64编码处理    InputStream in = null;    byte[] data = null;    //读取图片字节数组    try {        in = new FileInputStream(file);        data = new byte[in.available()];        in.read(data);        in.close();        //对字节数组Base64编码        if (data == null || data.length == 0) {            return null;        }        content = Base64.encodeBytes(data);        if (content == null || \"\".equals(content)) {            return null;        }        fileContentBase64 = base64Str + content;    } catch (IOException e) {        e.printStackTrace();    } finally {        if (in != null) {            in.close();        }    }    return fileContentBase64;}public static void main(String[] args) throws IOException {    String base64_str = getImageStr(new File(\"D:\\\\test.jpg\"), \"jpg\");}"
  },
  
  {
    "title": "Java工具类把URL转换成二维码",
    "url": "/posts/java-zhong-url-zhuan-erweima/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-12-24 01:47:00 +0800",
    





    
    "snippet": "&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;import java.awt.image.Bu...",
    "content": "&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;import java.util.Map;import javax.imageio.ImageIO;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.common.BitMatrix;public class CodeUtil {    private static final int BLACK = 0xFF000000;    private static final int WHITE = 0xFFFFFFFF;    public static String createQrCode(String url, String path, String fileName) {        try {            Map&lt;EncodeHintType, String&gt; hints = new HashMap&lt;&gt;();            hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\");            BitMatrix bitMatrix = new MultiFormatWriter().encode(url,                 BarcodeFormat.QR_CODE, 400, 400, hints);            File file = new File(path, fileName);            if (file.exists()                 || ((file.getParentFile().exists()                 || file.getParentFile().mkdirs()) &amp;&amp; file.createNewFile())) {                writeToFile(bitMatrix, \"jpg\", file);                return file.toString();            }        } catch (Exception e) {            e.printStackTrace();        }        return null;    }     static void writeToFile(BitMatrix matrix, String format, File file)                 throws IOException {        BufferedImage image = toBufferedImage(matrix);        if (!ImageIO.write(image, format, file)) {            throw new IOException(\"Could not write an image of format \"                 + format + \" to \" + file);        }    }     static void writeToStream(BitMatrix matrix, String format, OutputStream stream)                 throws IOException {        BufferedImage image = toBufferedImage(matrix);        if (!ImageIO.write(image, format, stream)) {            throw new IOException(\"Could not write an image of format \" + format);        }    }     private static BufferedImage toBufferedImage(BitMatrix matrix) {        int width = matrix.getWidth();        int height = matrix.getHeight();        BufferedImage image = new BufferedImage(width, height,             BufferedImage.TYPE_INT_RGB);        for (int x = 0; x &lt; width; x++) {            for (int y = 0; y &lt; height; y++) {                image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE);            }        }        return image;    }    public static void main(String[] args) {        createQrCode(\"www.baidu.com\",\"D:\\\\\",\"code.jpg\");    }}  参考：把url链接转换成二维码的工具类"
  },
  
  {
    "title": "Windows10下当前目录右键添加CMD快捷方式",
    "url": "/posts/win10-xia-dangqian-mulu-youjian-tianjia-cmd-kuaijiefangshi/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2021-12-23 13:47:00 +0800",
    





    
    "snippet": "Win10下Shift + 右键不能打开CMD，只能打开PowerShell。首先，在桌面新建一个文本文档。Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here]@=\"在此处打开命令行\"\"Icon\"=\"cmd.exe\"[HKEY_...",
    "content": "Win10下Shift + 右键不能打开CMD，只能打开PowerShell。首先，在桌面新建一个文本文档。Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here]@=\"在此处打开命令行\"\"Icon\"=\"cmd.exe\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\"\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt]@=\"在此处打开命令行\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\" \\\"cd %1\\\"\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here]@=\"在此处打开命令行\"\"Icon\"=\"cmd.exe\"[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\"\"然后将上面内容粘贴到该文本文档中，保存并将该文本文档以.reg结尾即可，名字可以随意取。（PS：@=”此处打开命令行”  该引号内文字可以随意修改成你想要显示的文字）。最后，双击注册一下就可以了，结果右键菜单中就有了。  参考：win10下当前目录右键添加CMD快捷方式"
  },
  
  {
    "title": "PowerDesigner中，修改了某个字段的name，其code也跟着修改",
    "url": "/posts/powerdesigner-zhong-xiugai-mouge-ziduan-de-name-code-yegenzhe-xiugai/",
    "categories": "Knowledge, PowerDesigner",
    "tags": "PowerDesigner",
    "date": "2021-12-13 13:47:00 +0800",
    





    
    "snippet": "  选择Tools -&gt; GeneralOptions…菜单，出现General Options对话框。  从Category中选择Dialog项。  取消右边“Name to Code mirroring”复选框。  参考：PowerDesigner中，修改了某个字段的name，其code也跟着修改",
    "content": "  选择Tools -&gt; GeneralOptions…菜单，出现General Options对话框。  从Category中选择Dialog项。  取消右边“Name to Code mirroring”复选框。  参考：PowerDesigner中，修改了某个字段的name，其code也跟着修改"
  },
  
  {
    "title": "PowerDesigner中name和comment的互相转换",
    "url": "/posts/powerdesigner-zhong-namehecomment-xianghu-zhuanhuan/",
    "categories": "Knowledge, PowerDesigner",
    "tags": "PowerDesigner",
    "date": "2021-12-13 13:47:00 +0800",
    





    
    "snippet": "在【Tools】-【Execute Commands】-【Edit/Run Script】下。输入下面你要选择的语句即可，也可以保存起来，以便下次使用，后缀为.vbs。需要注意的问题是：运行语句时必须在Module模式下，如果是导出报表时执行会出现错误提示。name转到comment注释字段'如果comment为空，则填入name；如果不为空，则保留不变，这样可以避免已有的注释丢失。Opti...",
    "content": "在【Tools】-【Execute Commands】-【Edit/Run Script】下。输入下面你要选择的语句即可，也可以保存起来，以便下次使用，后缀为.vbs。需要注意的问题是：运行语句时必须在Module模式下，如果是导出报表时执行会出现错误提示。name转到comment注释字段'如果comment为空，则填入name；如果不为空，则保留不变，这样可以避免已有的注释丢失。Option ExplicitValidationMode = TrueInteractiveMode = im_BatchDim mdl 'the current model'get the current active model Set mdl = ActiveModelIf (mdl Is Nothing) Then  MsgBox \"There is no current Model \"ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then  MsgBox \"The current model is not an Physical Data model. \"Else  ProcessFolder mdlEnd If' This routine copy name into comment for each table, each column and each view ' of the current folder Private Sub ProcessFolder(folder)  Dim Tab 'running   table    For Each Tab In folder.tables    If Not tab.isShortcut Then    '如果有表的注释，则不改变它.如果没有表注释.则把name添加到注释里面    If Trim(tab.comment) = \"\" Then     tab.comment = tab.name    End If    Dim col ' running column      For Each col In tab.columns    '如果col的comment为空，则填入name，如果已有注释，则不添加;这样可以避免已有注释丢失    If Trim(col.comment) = \"\" Then     col.comment = col.name    End If  NextEnd IfNextDim view 'running view  For Each view In folder.ViewsIf Not view.isShortcut And Trim(view.comment) = \"\"  Then  view.comment = view.nameEnd IfNext'go into the sub-packages  Dim f 'running folder  For Each f In folder.PackagesIf Not f.IsShortcut Then  ProcessFolder fEnd IfNextEnd Subcomment注释字段转到nameOption ExplicitValidationMode = TrueInteractiveMode = im_BatchDim mdl 'the current model  'get the current active model  Set mdl = ActiveModelIf (mdl Is Nothing) Then  MsgBox \"There is no current Model \"ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then  MsgBox \"The current model is not an Physical Data model. \"Else  ProcessFolder mdlEnd IfPrivate Sub ProcessFolder(folder)  On Error Resume Next  Dim Tab 'running table    For Each Tab In folder.tables    If Not tab.isShortcut Then    tab.name = tab.comment    Dim col 'running column      For Each col In tab.columns      If col.comment = \"\" Then      Else        col.name = col.comment      End If    Next    End If  Next    Dim view 'running view    For Each view In folder.Views    If Not view.isShortcut Then    view.name = view.comment    End If  Next    'go into the sub-packages    Dim f 'running folder    For Each f In folder.Packages    If Not f.IsShortcut Then    ProcessFolder f    End If  NextEnd Sub  参考：PowerDesigner中NAME和COMMENT的互相转换，需要执行语句"
  },
  
  {
    "title": "PowerDesigner 16.5逆向工程，从远程Oracle 11g数据库导出PDM",
    "url": "/posts/powerdesigner-cong-yuancheng-oracle-daochu-pdm/",
    "categories": "Knowledge, PowerDesigner",
    "tags": "PowerDesigner",
    "date": "2021-12-13 13:47:00 +0800",
    





    
    "snippet": "本文使用工具：  Oracle 11g  PowerDesigner 16.5第一步首先打开PowerDesigner，点击新建模型输入模型名称并选择数据库Oracle第二步选中当前模型，然后在菜单栏database -&gt; configure Connections在弹出窗口，点击Add Data Source按钮选择系统数据源选择Oracle Database Client Driv...",
    "content": "本文使用工具：  Oracle 11g  PowerDesigner 16.5第一步首先打开PowerDesigner，点击新建模型输入模型名称并选择数据库Oracle第二步选中当前模型，然后在菜单栏database -&gt; configure Connections在弹出窗口，点击Add Data Source按钮选择系统数据源选择Oracle Database Client Driver点击完成输入Data Source Name，选择TNS Service Name，输入UserID，点击Test Connection按钮参数说明：  Data Source Name：为数据源命名  Description：添加描述，可不填写  TNS Service Name：TNS服务名，若没有配置，可直接填写&lt;IP&gt;:&lt;端口号&gt;/&lt;实例名&gt;，如：127.0.0.1:1521/orcl  User ID：用户名输入Oracle数据库的用户名和密码，点击OK弹出Connection Successful提示然后回到Configure Data Connections界面，会看到增加了一个名为Oracle 11g的Data Source第三步在菜单上选择Database -&gt; Update Model From Database选择Using a data source，然后点击右侧的按钮从下拉列表框中选择刚才添加的Data Source ：Oracle 11g，然后输入Oracle登录的用户名和密码点击Connect，连接数据库，然后会显示数据库中所有的表选择要导出为模型的表，然后点击OK，执行导出操作  参考：powerdesigner16.5逆向工程，从远程oracle11g数据库导出PDM"
  },
  
  {
    "title": "Git使用规范",
    "url": "/posts/git-shiyong-guifan/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-12-08 13:47:00 +0800",
    





    
    "snippet": "Git分支命名规范Git分支分为集成分支、功能分支和修复分支，分别命名为develop、feature和hotfix，均为单数。不可使用features、future、hotfixes、hotfixs等错误名称。  master（主分支，永远是可用的稳定版本，不能直接在该分支上开发）  develop（开发主分支，所有新功能以这个分支来创建自己的开发分支，该分支只做只合并操作，不能直接在该分...",
    "content": "Git分支命名规范Git分支分为集成分支、功能分支和修复分支，分别命名为develop、feature和hotfix，均为单数。不可使用features、future、hotfixes、hotfixs等错误名称。  master（主分支，永远是可用的稳定版本，不能直接在该分支上开发）  develop（开发主分支，所有新功能以这个分支来创建自己的开发分支，该分支只做只合并操作，不能直接在该分支上开发）  feature-xxx（功能开发分支，在develop上创建分支，以自己开发功能模块命名，功能测试正常后合并到develop分支）  feature-xxx-fix（功能bug修复分支，feature分支合并之后发现bug，在develop上创建分支修复，之后合并回develop分支。PS:feature分支在申请合并之后，未合并之前还是可以提交代码的，所以feature在合并之前还可以在原分支上继续修复bug）  hotfix-xxx（紧急bug修改分支，在master分支上创建，修复完成后合并到master）注意事项：  一个分支尽量开发一个功能模块，不要多个功能模块在一个分支上开发。  feature分支在申请合并之前，最好是先pull一下develop主分支下来，看一下有没有冲突，如果有就先解决冲突后再申请合并。Git提交记录规范每个git commit记录都需要按照固定格式，具体格式为：  第一行：作者: 功能模块名称（或 功能模块ID）  第二行：提交描述，中英文皆可  参考：git 分支命名规范"
  },
  
  {
    "title": "如何在Excel中锁定行和列",
    "url": "/posts/excel-duoding-hanghelie/",
    "categories": "Knowledge, Excel",
    "tags": "Excel",
    "date": "2021-12-08 13:47:00 +0800",
    





    
    "snippet": "首先确定要锁定的行和列（图片中蓝色框住的部分），然后选定行和列所交接的单元格（图片中用红色框住的部分）然后选定菜单栏窗口—&gt;冻结窗口（如图）  参考：如何在excel中锁定行和列",
    "content": "首先确定要锁定的行和列（图片中蓝色框住的部分），然后选定行和列所交接的单元格（图片中用红色框住的部分）然后选定菜单栏窗口—&gt;冻结窗口（如图）  参考：如何在excel中锁定行和列"
  },
  
  {
    "title": "Jira修改默认时间格式",
    "url": "/posts/jira-xiugai-moren-shijian-geshi/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-10-11 08:47:00 +0800",
    





    
    "snippet": "日期显示格式我们希望看到2017-10-10、2017-10-05 01:34这样的格式，可以如下设置：管理-系统-外观，找到日期时间格式设置，如下图：修改保存后再次查看，会发现样式已修改：提示时间  服务端进入Jira的安装目录，默认为/opt/atlassian/jira/atlassian-jira/WEB-INF/classes文件夹  找到jpm.xml文件  找到对应的参数(ke...",
    "content": "日期显示格式我们希望看到2017-10-10、2017-10-05 01:34这样的格式，可以如下设置：管理-系统-外观，找到日期时间格式设置，如下图：修改保存后再次查看，会发现样式已修改：提示时间  服务端进入Jira的安装目录，默认为/opt/atlassian/jira/atlassian-jira/WEB-INF/classes文件夹  找到jpm.xml文件  找到对应的参数(key)jira.lf.date.relativize  将对应的值default-value改为false  重新启动Jira进入Jira中查看，发现已修改：表单填写格式调整我们在创建问题时，如果有字段为填写时间或日期的，会发现填写表单的时候发现日期时间字段信息依然是系统原有的格式，如下图：如果也需要调整为我们习惯的格式，可以通过以下步骤进行调整：管理-系统-一般配置-高级设置，修改以下项：  参考：Jira篇:Jira修改默认时间格式"
  },
  
  {
    "title": "Oracle 当前时间加一天、一分钟......",
    "url": "/posts/oracle-shijian-jisuan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-10-11 01:47:00 +0800",
    





    
    "snippet": "sysdate+1 -- 加1天sysdate+1/24 -- 加1小时sysdate+1/(24*60) -- 加1分钟sysdate+1/(24*60*60) -- 加1秒钟-- 加法 select add_months(sysdate, 12) from dual; -- 加1年 select add_months(sysdate, 1) from dual; -- 加1月 selec...",
    "content": "sysdate+1 -- 加1天sysdate+1/24 -- 加1小时sysdate+1/(24*60) -- 加1分钟sysdate+1/(24*60*60) -- 加1秒钟-- 加法 select add_months(sysdate, 12) from dual; -- 加1年 select add_months(sysdate, 1) from dual; -- 加1月 select to_char(sysdate+7, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1星期 select to_char(sysdate+1, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1天 select to_char(sysdate+1/24, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1小时 select to_char(sysdate+1/24/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1分钟 select to_char(sysdate+1/24/60/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 加1秒 -- 减法 select add_months(sysdate, -12) from dual; -- 减1年 select add_months(sysdate, -1) from dual; -- 减1月 select to_char(sysdate-7, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1星期 select to_char(sysdate-1, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1天 select to_char(sysdate-1/24, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1小时 select to_char(sysdate-1/24/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1分钟 select to_char(sysdate-1/24/60/60, 'yyyy-mm-dd HH24:MI:SS') from dual; -- 减1秒  参考：Oracle 当前日期加一天、一分钟……"
  },
  
  {
    "title": "Oracle 如何查看版本信息",
    "url": "/posts/oracle-ruhe-chakan-banben/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-10-11 01:47:00 +0800",
    





    
    "snippet": "首先打开PLSQL并登录Oracle，新建一个SQL窗口输入select * from v$version，执行查询即可。",
    "content": "首先打开PLSQL并登录Oracle，新建一个SQL窗口输入select * from v$version，执行查询即可。"
  },
  
  {
    "title": "将时间转化为天小时分秒字符串",
    "url": "/posts/jiang-shijian-zhuanwei-hanzishifenmiao/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-10-11 01:47:00 +0800",
    





    
    "snippet": "public String formatSeconds(String secondsStr) {    Long seconds = new BigDecimal(secondsStr).longValue();    String timeStr = seconds + \"秒\";    if (seconds &gt; 60) {        long second = seconds ...",
    "content": "public String formatSeconds(String secondsStr) {    Long seconds = new BigDecimal(secondsStr).longValue();    String timeStr = seconds + \"秒\";    if (seconds &gt; 60) {        long second = seconds % 60;        long min = seconds / 60;        if (second == 0) {            timeStr = min + \"分钟\";        } else {            timeStr = min + \"分钟\" + second + \"秒\";        }        if (min &gt; 60) {            min = (seconds / 60) % 60;            long hour = (seconds / 60) / 60;            if (second == 0) {                if (min == 0) {                    timeStr = hour + \"小时\";                } else {                    timeStr = hour + \"小时\" + min + \"分钟\";                }            } else {                timeStr = hour + \"小时\" + min + \"分钟\" + second + \"秒\";            }            if (hour &gt; 24) {                hour = ((seconds / 60) / 60) % 24;                long day = (((seconds / 60) / 60) / 24);                timeStr = day + \"天\" + hour + \"小时\" + min + \"分钟\" + second + \"秒\";                if (second == 0) {                    if (min == 0) {                        if (hour == 0) {                            timeStr = day + \"天\";                        } else {                            timeStr = day + \"天\" + hour + \"小时\";                        }                    } else {                        timeStr = day + \"天\" + hour + \"小时\" + min + \"分钟\";                    }                } else {                    timeStr = day + \"天\" + hour + \"小时\" + min + \"分钟\" + second + \"秒\";                }            }        }    }    return timeStr;}"
  },
  
  {
    "title": "MySQL如何重置密码",
    "url": "/posts/mysql-ruhe-zhongzhi-mima/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-09-15 10:47:00 +0800",
    





    
    "snippet": "      修改my.ini文件    在my.ini文件的[mysqld]栏下添加skip-grant-tables，如下：     [mysql] # 设置MySQL客户端默认字符集 default-character-set=utf8  [mysqld] skip-grant-tables # 设置3306端口 port = 3306  # 设置MySQL的安装目录 basedir=D...",
    "content": "      修改my.ini文件    在my.ini文件的[mysqld]栏下添加skip-grant-tables，如下：     [mysql] # 设置MySQL客户端默认字符集 default-character-set=utf8  [mysqld] skip-grant-tables # 设置3306端口 port = 3306  # 设置MySQL的安装目录 basedir=D:\\MySQL\\mysql-5.7.27-winx64\\bin # 设置MySQL数据库的数据的存放目录 datadir=D:\\MySQL\\mysql-5.7.27-winx64\\data # 允许最大连接数 max_connections=200 # 设置MySQL服务端默认字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB             启动MySQL服务。     net start mysql        执行命令mysqld --skip-grant-tables，绕过权限启动MySQL。      重置账户密码。    进入MySQL安装目录cd D:\\MySQL\\mysql-5.7.27-winx64\\bin，执行命令mysql跳过权限验证连接数据库，update mysql.user set authentication_string=\"\" where user=\"root\";重置 root 用户的密码。        刷新权限表、设置新密码    设置新密码的语句：update user set password=password('新密码') where user='root' and host='localhost';，如：     mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec) mysql&gt; use mysql;  mysql&gt; update user set password=password('root')       &gt; where user='root' and host='localhost'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec)        参考：Windows MySQL重置root密码"
  },
  
  {
    "title": "Jira not show Rich text editor Jira不显示富文本编辑框解决方案",
    "url": "/posts/jira-buxianshi-fuwenbenkuang-de-jiejue-fangan/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-09-15 10:47:00 +0800",
    





    
    "snippet": "首先，后台系统界面，左侧进入Rich text editor，启用Enable rich text editor for users开关。然后，进入顶部的Issue标签，进入左侧的Field Configurations：进入Default Field Configuration后的Configure，定位需要启用富文本编辑框的字段，如Comment，点后面的Renderers：切换到Wik...",
    "content": "首先，后台系统界面，左侧进入Rich text editor，启用Enable rich text editor for users开关。然后，进入顶部的Issue标签，进入左侧的Field Configurations：进入Default Field Configuration后的Configure，定位需要启用富文本编辑框的字段，如Comment，点后面的Renderers：切换到Wiki style renderer：   参考：Jira not show Rich text editor Jira 不显示富文本编辑框解决方案"
  },
  
  {
    "title": "JS如何从后台返回的Map中取数据",
    "url": "/posts/js-ruhe-conghoutai-fanhuide-map-zhong-qushuju/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-09-15 10:47:00 +0800",
    





    
    "snippet": "&lt;script&gt;    var a = '{\"1\":\"100\"}';    b = 1;    var json = JSON.parse(a);     console.log(json[b]);&lt;/script&gt;",
    "content": "&lt;script&gt;    var a = '{\"1\":\"100\"}';    b = 1;    var json = JSON.parse(a);     console.log(json[b]);&lt;/script&gt;"
  },
  
  {
    "title": "Hibernate实体类注解配置",
    "url": "/posts/Hibernate-shitilei_shujie-peizhi/",
    "categories": "Knowledge, Hibernate",
    "tags": "Hibernate",
    "date": "2021-08-12 13:23:00 +0800",
    





    
    "snippet": "一、类级别注解1、@Entity(name=”EntityName”)必须，name为可选，对应数据库中一的个表。2、@Table(name=””, catalog=””, schema=””)可选，通常和@Entity配合使用，只能标注在实体的class定义处，表示实体对应的数据库表的信息。  name：可选，表示表的名称，默认表名和实体名称一致，只有在不一致的情况下才需要指定表名。  c...",
    "content": "一、类级别注解1、@Entity(name=”EntityName”)必须，name为可选，对应数据库中一的个表。2、@Table(name=””, catalog=””, schema=””)可选，通常和@Entity配合使用，只能标注在实体的class定义处，表示实体对应的数据库表的信息。  name：可选，表示表的名称，默认表名和实体名称一致，只有在不一致的情况下才需要指定表名。  catalog：可选，表示Catalog名称，默认为Catalog(“”)。  schema：可选，表示Schema名称，默认为Schema(“”)。二、属性级别注解1、@id必须，定义映射到数据库表的主键的属性，一个实体只能有一个属性被映射为主键，置于getXxxx()前。2、@GeneratedValue(strategy=GenerationType, generator=””)可选，strategy：表示主键生成策略，有AUTO，INDENTITY，SEQUENCE和TABLE4种，分别表示让ORM框架自动选择，根据数据库的Identity字段自动生成（主要是自动增长类型的主键，适用于SQL Server，MySQL，DB2，MS等数据库中，Oracle不适用），根据数据库表的Sequence字段生成（Oracle，DB2使用该种），使用一个特定的数据库表格来保存主键，默认为AUTO。  generator：表示主键生成器的名称，这个属性通常和ORM框架相关，例如，Hibernate可以指定uuid、native等主键生成方式。示例：@Id@GeneratedValues(strategy=StrategyType.INDETITY)public int getId() {    return id;}3、@Basic(fetch=FetchType, optional=true)可选，@Basic表示一个简单的属性到数据库表的字段的映射，对于没有任何标注的getXxxx()方法，默认即为@Basic。  fetch：表示该属性的读取策略，有EAGER和LAZY两种，分别表示主支抓取和延迟加载，默认为EAGER。  optional：表示该属性是否允许为null，默认为true。示例：@Basic(optional=false)public String getAddress() {    return address;}4、@Column可选，@Column描述了数据库表中该字段的详细定义，这对于根据JPA注解生成数据库表结构的工具非常有作用。  name：表示数据库表中该字段的名称，默认情形属性名称一致。  nullable：表示该字段是否允许为null，默认为true。  unique：表示该字段是否是唯一标识，默认为false。  length：表示该字段的大小，仅对String类型的字段有效。  insertable：表示在ORM框架执行插入操作时，该字段是否应出现INSETRT语句中，默认为true。  updateable：表示在ORM框架执行更新操作时，该字段是否应该出现在UPDATE语句中，默认为true，对于一经创建就不可以更改的字段，该属性非常有用，如对于birthday字段。  columnDefinition：表示该字段在数据库中的实际类型，通常ORM框架可以根据属性类型自动判断数据库中字段的类型，但是对于Date类型仍无法确定数据库中字段类型究竟是DATE，TIME还是TIMESTAMP，此外，String的默认映射类型为VARCHAR，如果要将String类型映射到特定数据库的BLOB或TEXT字段类型，该属性非常有用。示例：@Column(name=\"BIRTH\", nullable=\"false\", columnDefinition=\"DATE\")public String getBithday() {    return birthday;}5、@Temporal可选，用于定义映射到数据库的时间精度。@Temporal(TemporalType=DATE)       // 日期@Temporal(TemporalType=TIME)       // 时间@Temporal(TemporalType=TIMESTAMP)  // 两者兼具6、@Transient可选，@Transient表示该属性并非一个到数据库表的字段的映射，ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient，否则，ORM框架默认其注解为@Basic。示例：// 根据birth计算出age属性@Transientpublic int getAge() {    return getYear(new Date()) - getYear(birth);}三、映射继承关系1、@Inheritance(strategy)定义所选择的策略，这个注解需要在每个类层次结构(class hierarchy)最顶端的实体类上使用。strategy继承类所选策略，InheritanceType.TABLE_PER_CLASS，InheritanceType.SINGLE_TABLE，InheritanceType.JOINED。2、@MappedSuperclass可选，将超类的JPA注解传递给子类，使子类能够继承超类的JPA注解。标注为@MappedSuperclass的类将不是一个完整的实体类，他将不会映射到数据库表，但是他的属性都将映射到其子类的数据库字段中。标注为@MappedSuperclass的类不能再标注@Entity或@Table注解，也无需实现序列化接口。示例：@MappedSuperclasspublic class Employee() {    ....} @Entity@Table(name=\"engineer\")public class Engineer extends Employee {     .....} @Entity@Table(name=\"manager\")public class Manager extends Employee {     .....}3、@Embedded可选，@Embedded将几个字段组合成一个类，并作为整个Entity的一个属性。例如User包括id，name，city，street，zip属性。我们希望city，street，zip属性映射为Address对象，这样，User对象将具有id，name和address这三个属性。Address对象必须定义为@Embededable。示例：@Embeddablepublic class Address {city, street, zip} @Entity@Table(name=\"user\")public class User {    @Embedded    @AttributeOverrides( {@AttributeOverride(name=\"firstName\",         column=@Column(name=\"first_name\")), ...})    public Address getAddress() {        ..........    }}   四、映射实体bean的关联关系1、共有属性  fetch  配置加载方式Fetch.EAGER -  及时加载，多对一默认是Fetch.EAGERFetch.LAZY - 延迟加载，一对多默认是Fetch.LAZY  cascade  设置级联方式CascadeType.PERSIST - 保存CascadeType.REMOVE - 删除CascadeType.MERGE - 修改CascadeType.REFRESH - 刷新CascadeType.ALL - 全部  targetEntity配置集合属性类型，如：@OneToMany(targetEntity=Book.class)2、@JoinColumn可选，@JoinColumn和@Column类似，这里描述的不是一个简单字段，而是一个关联字段（通常是外键），例如，描述一个@ManyToOne的字段。  name：该字段的名称。由于@JoinColumn描述的是一个关联字段，如ManyToOne，则默认的名称由其关联的实体决定。例如，实体Order有一个user属性来关联实体User，则Order的user属性为一个外键，其默认的名称为实体User的名称+下划线+实体User的主键名称。3、@ManyToOne(fetch=FetchType, cascade=CascadeType)可选，表示一个多对一的映射，该注解标注的属性通常是数据库表的外键。  optional：是否允许该字段为null，该属性应该根据数据库表的外键约束来确定，默认为true。  fetch：表示抓取策略，默认为FetchType.EAGER。  cascade：表示默认的级联操作策略，可以指定为ALL，PERSIST，MERGE，REFRESH和REMOVE中的若干组合，默认为无级联操作。  targetEntity：表示该属性关联的实体类型，该属性通常不必指定，ORM框架根据属性类型自动判断targetEntity。示例：// 订单Order和用户User是一个ManyToOne的关系，@JoinColumn定义外键列名// 在Order类中定义@ManyToOne()@JoinColumn(name=\"userid\")public User getUser() {    return user;}4、@OneToMany(fetch=FetchType, cascade=CascadeType)可选，描述一个一对多的关联，该属性应该为集体类型，在数据库中并没有实际字段。默认会使用连接表做一对多关联，添加@JoinColumn(name=”xxx_id”) 后，就会使用外键关联，而不使用连接表了。  fetch：表示抓取策略，默认为FetchType.LAZY，因为关联的多个对象通常不必从数据库预先读取到内存。  cascade：表示级联操作策略，对于OneToMany类型的关联非常重要，通常该实体更新或删除时，其关联的实体也应当被更新或删除。例如：实体User和Order是OneToMany的关系，则实体User被删除时，其关联的实体Order也应该被全部删除。示例：// 用户User和订单Order是一个OneToMany的关系，@JoinColumn(name=\"对方的数据库表外键列名\") // 在User类中定义@OneToMany(mappyedBy=\"user\")@JoinColumn(name=\"userid\")public &lt;Set&gt;Order getOrders() {    return orders;}5、@OneToOne(fetch=FetchType, cascade=CascadeType)可选，描述一个一对一的关联。  fetch：表示抓取策略，默认为FetchType.LAZY。  cascade：表示级联操作策略。          主表类A与从表类B的主键值相对应。        // 主表：@OneToOne(cascade=CascadeType.ALL)@PrimaryKeyJoinColumnpublic B getB(){    Return b;}// 从表：无              主表A中有一个从表属性是B类型的b        // 主表：@OneToOne(cascade=CascadeType.ALL)@JoinColumn(name=\"主表外键\")   //这里指定的是数据库中的外键字段。public B getB(){    return b;}// 从表：无              主表A中有一个从表属性是B类型的b，同时，从表B中有一个主表属性是A类型的a        // 主表：@OneToOne(cascade=CascadeType.ALL)@JoinColumn(name=\"主表外键\")   //这里指定的是数据库中的外键字段。public B getB(){    return b;}// 从表：@OneToOne(mappedBy=\"主表类中的从表属性\")public 主表类 get主表类(){    return 主表对象}        注意：@JoinColumn是可选的。默认值是从表变量名+”_“+从表的主键（注意，这里加的是主键。而不是主键对应的变量）。示例：    @OneToOne(fetch=FetchType.LAZY)public Blog getBlog() {    return blog;}      6、@ManyToMany可选，描述一个多对多的关联.多对多关联上是两个一对多关联，但是在ManyToMany描述中，中间表是由ORM框架自动处理。  targetEntity：表示多对多关联的另一个实体类的全名，例如：package.Book.class。  mappedBy：表示多对多关联的另一个实体类的对应集合属性名称。  fetch：表示抓取策略。  cascade：表示级联操作策略。示例：Teacher实体表示教师，Student实体表示学生，为了描述教师和学生关系，可以在Teacher和Student之间建立ManyToMany关联。public class Student{    private Set&lt;Teacher&gt; teachers = new HashSet&lt;Teacher&gt;();    @ManyToMany    @JoinTable(name=\"teacher_student\", joinColumns={@JoinColumn(name=\"sid\")},         inverseJoinColumns={@JoinColumn(name=\"tid\")})    public Set&lt;Teacher&gt; getTeachers() {        return teachers;    }}public class Teacher{    private Set&lt;Student&gt; students = new HashSet&lt;Student&gt;();    @ManyToMany(mappedBy=\"teachers\")    public Set&lt;Student&gt; getStudents() {        return students;    }}7、@JoinTable通过表关联的方式来映射一对多或者多对多的关系时，要使用@JoinTable这个标记。无注解属性的默认值。  如果属性为单一类型，则映射为@Basic。  如果属性对应的类型定义了@Embeddable注解，则映射为@Embedded。  如果属性对应的类型实现了Serializable， 则属性被映射为@Basic并在一个列中保存该对象的serialized版本。  如果该属性的类型为java.sql.Clob 或 java.sql.Blob，则作为@Lob并映射到适当的LobType。"
  },
  
  {
    "title": "Hibernate概述",
    "url": "/posts/Hibernate-gaishu/",
    "categories": "Knowledge, Hibernate",
    "tags": "Hibernate",
    "date": "2021-08-12 13:23:00 +0800",
    





    
    "snippet": "知识点  Hibernate概述数据持久化、ORM概念及原理、Hibernate编程步骤  Hibernate基础实体映射、ID生成器、Hibernate数据类型，Hibernate对象生命周期  关联映射一对一、一对多、多对多  高级映射组合映射、继承映射、值集合映射  事务管理事务传播性、事务隔离级别、事务控制  高级查询Criteria、HQL一、对象持久化1、持久（Persisten...",
    "content": "知识点  Hibernate概述数据持久化、ORM概念及原理、Hibernate编程步骤  Hibernate基础实体映射、ID生成器、Hibernate数据类型，Hibernate对象生命周期  关联映射一对一、一对多、多对多  高级映射组合映射、继承映射、值集合映射  事务管理事务传播性、事务隔离级别、事务控制  高级查询Criteria、HQL一、对象持久化1、持久（Persistence）  数据保存到可掉电设备中。  企业级应用中，即把内存中（瞬时）的数据保存到磁盘中加以“固化”。2、对象持久化技术  Java对象序列化和反序列化：数据查询困难，效率低  通过XML保存对象：复杂的xml操作，用于应用或公司间进行数据传输  JDBC：关系型数据库（RDBMS）,SQL(DDL, DML)：低水平的数据操作  对象关系映射(ORM)二、JDBC的缺点1、JDBC编程步骤  注册驱动  建立到数据库的连接  创建statement  执行SQL语句  处理ResultSet  关闭JDBC对象缺点：重复的编程步骤2、JDBC数据封装JDBC数据封装过程缺点：编程人员大部分精力花费在对ResultSet数据封装。三、ORM1、概念Object Relational Mapping（对象关系映射），通过使用描述对象和数据库之间映射的元数据，将Java程序中的对象自动持久化到关系数据库中。2、ORM包括四个部分  一个对持久类对象进行CRUD操作的API  一个语言或API用来规定与类和类属性相关的查询  一个规定元数据映射的工具  一种技术可以让ORM的实现同事务对象一起进行dirty checking, lazy association fetching以及其他的优化功能3、为什么采用ORM模式  提高生产率（Productivity）  可维护性（Maintainability）  更好的性能（Performance）  厂商独立性（Vendor independence）4、ORM主流框架  Hibernate：开源、性能、稳定性  TopLink：Oracle商业商业产品  Ibatis、MyBatis：开源、开放性  Apache OJB：开源、性能、稳定性、支持各种标准规范四、Hibernate简介Hibernate强大功能，按照Java基础语义（关联、继承、多态、组合及Java集合框架）的持久层开发，面对对象查询语言（HQL）。1、Hibernate 环境配置库文件包  antlr.jar — HQL转换工具  asm.jar, asm-attrs.jar — generate and transform classes  cglib.jar — 实现PO字节码的动态生成  dom4j.jar — 读写xml  hibernate3.jar — 核心包  jta.jar — JAVA 事务处理接口  commons-collections.jar — Apache Commons包中的一个，开发的集合类  commons-logging.jar — Apache Commons包中的一个，日志功能  ojdbc14.jar — oracle驱动包  c3p0.jar — 数据库连接池  ejb3-persistence.jar, hibernate-annotations.jar — 注解基础包  hibernate-entitymanager.jar — JPA支持包  javassit.jar — 代码生成包  jboss-archive-browsing.jar — support JPA entity manager2、Hibernate应用组成  DDL（可选） — sql  POJO（plain object java obiect） —  持久化类          Id      需映射属性的get/set方法      空参构造方法        Hibernate配置文件 — hibernate.cfg.xml or hibernate.properties  创建对象-关系映射 — .hbm.xml or 注解  通过Hibernate API访问数据库的代码3、Hibernate项目结构4、Hibernate开发步骤—API应用步骤  创建Hibernate配置，读取Hibernate配置文件及信息  用读取的配置信息生成SessionFactory对象  从SessionFactory对象获取一个Session对象  用Session对象生成事务  通过Session对象的方法进行操作  提交或回滚事务  释放session and session factory资源5、Hibernate核心API  Session是数据连接与事务管理 间的中间接口，它是非线程安全的，所以一个线程只创建一个Session对象。save()/beginTrasaction()/close()/delete()/get()/load()/persist()/saveOrUpdate()/update()  SessionFactory负责创建Session对象， SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。可以通过Configuration对象创建SessionFactory对象。openSession()/close()  Configuration配置hibernate，启动hibernate 时读取cfg.xml ，创建SessionFactory对象。config()  Transaction数据库事务接口, 可选接口，将应用代码从底层的事务实现中抽象出来，可能会是：JDBC事务、JTA用户事务commit()/rollback()  Query查询接口，query实例包装了HQL查询语句。list()/setXXX()  Criteria查询接口，用于创建和执行条件查询，更面向对象。list()/add()/createCriteria()6、Hibernate对象生命周期对象生命周期：一个对象从被创建开始，到不再使用，被垃圾回收期回收为止。一个持久化类的实例可能处于三种不同状态中的某一种。 这三种状态的定义则与所谓的持久化上下文(persistence context)有关:  瞬时状态 (Transient)  持久状态(Persistent)  脱管状态(Detached)Hibernate的Session对象就是这个所谓的持久化上下文  瞬时对象由new操作符创建，且尚未与Hibernate Session 关联的对象被认定为瞬时(Transient)的瞬时(Transient)对象不会被持久化到数据库中，也不会被赋予持久化标识(identifier)如果瞬时(Transient)对象在程序中没有被引用，它会被垃圾回收器(garbage collector)销毁使用Hibernate Session可以将其变为持久(Persistent)状态  持久对象持久(Persistent)的实例在数据库中有对应的记录，并拥有一个持久化标识(identifier)Hibernate会检测到处于持久(Persistent)状态的对象的任何改动，在当前操作单元(unit of work)执行完毕时将对象数据(state)与数据库同步(synchronize) 在默认情况下，Hibernate会在UPDATE中包含所有的列如果只更新那些被修改的列，可以通过修改配置dynamic-update=\"true\"来实现  脱管对象实例曾经与某个持久化上下文发生过关联，不过那个上下文被关闭了， 或者这个实例是被序列化(serialize)到另外的进程。 它拥有持久化标识，并且在数据库中存在一个对应的行 脱管(Detached)对象不在持久化管理之内，但对脱管对象的引用依然有效，对象可继续被修改Detached状态的对象可以再次与某个Session实例相关联而成为Persistent对象7、Hibernate对象状态转换"
  },
  
  {
    "title": "Hibernate笔记",
    "url": "/posts/Hibernate-biji/",
    "categories": "Knowledge, Hibernate",
    "tags": "Hibernate",
    "date": "2021-08-12 13:23:00 +0800",
    





    
    "snippet": "一、JavaProject配置过程（TestHibernate）1、加入Hibernate支持，即拷贝Hibernate支持jar包；创建hiberante.cfg.xml文件。（注解配置方式）&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC    \"-//Hiber...",
    "content": "一、JavaProject配置过程（TestHibernate）1、加入Hibernate支持，即拷贝Hibernate支持jar包；创建hiberante.cfg.xml文件。（注解配置方式）&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC    \"-//Hibernate/Hibernate Configuration DTD//EN\"    \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!-- 数据库连接 --&gt;        &lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;        &lt;property name=\"connection.url\"&gt;jdbc:mysql://localhost:3306/bbs_db&lt;/property&gt;        &lt;property name=\"connection.username\"&gt;root&lt;/property&gt;        &lt;property name=\"connection.password\"&gt;root&lt;/property&gt;               &lt;!-- 方言dialect --&gt;        &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;               &lt;!-- 是否显示sql语句 --&gt;        &lt;property name=\"show_sql\"&gt;true&lt;/property&gt;               &lt;!-- 数据库更新方式 --&gt;        &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt;               &lt;!-- 实体关系映射 --&gt;        &lt;mapping class=\"com.bbs.bean.User\"/&gt;           &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;2、创建持久化类Admin、User等，并通过注解配置“实体关系映射”。（重点）  涉及多个知识点，如：@Many To One映射关系，@One To Many等。（重点）  @GeneratedValue主键生成策略，常用strategy = GenerationType.AUTO（重点）  fetch=FetchType.LAZY懒加载设置及级联配置cascade设置。（重点）（此处为系统设计部分，初级工程师先关注具体使用。）package com.bbs.bean; import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table; // 用户注册实体类，对应t_user表@Entity@Table(name = \"t_user\")public class User {    private int userid;    private String username;    private String password;    private String sex;    private String hobbys;    private String birthday;    private String city;    private String email;    private String qq;    private String createtime;    @Id    @GeneratedValue(strategy = GenerationType.AUTO)    public int getUserid() {      return userid;    }    @Column(name = \"username\")    public String getUsername() {      return username;    }    @Column(name = \"password\")    public String getPassword() {      return password;    }    @Column(name = \"sex\")    public String getSex() {      return sex;    }    @Column(name = \"hobbys\")    public String getHobbys() {      return hobbys;    }    @Column(name = \"birthday\")    public String getBirthday() {      return birthday;    }    @Column(name = \"city\")    public String getCity() {      return city;    }    @Column(name = \"email\")    public String getEmail() {      return email;    }    @Column(name = \"qq\")    public String getQq() {      return qq;    }    @Column(name = \"createtime\")    public String getCreatetime() {      return createtime;    }    public void setUserid(int userid) {      this.userid = userid;    }    public void setUsername(String username) {      this.username = username;    }    public void setPassword(String password) {      this.password = password;    }    public void setSex(String sex) {      this.sex = sex;    }    public void setHobbys(String hobbys) {      this.hobbys = hobbys;    }    public void setBirthday(String birthday) {      this.birthday = birthday;    }    public void setCity(String city) {      this.city = city;    }    public void setEmail(String email) {      this.email = email;    }    public void setQq(String qq) {      this.qq = qq;    }    public void setCreatetime(String createtime) {      this.createtime = createtime;    } }3、JavaProject工程项目下，需要通过工厂类，获取session对象：（代码片段）package com.bbs.util; import org.hibernate.SessionFactory;import org.hibernate.cfg.AnnotationConfiguration;import org.hibernate.cfg.Configuration; /** * 自定义工厂类 单例模式 * Hibernate五大核心接口 * configuration接口、 * sessionFactory接口、 * session接口、 * Transaction接口、 * query接口 */public class MySessionFactory {    /**      * 1.设置私有的构造函数      * 2.定义一个静态变量      * 3.定义一段静态代码块      * 4.定义一个方法用于获取单例模式对象      * 5.单例模式分为饿汉模式和懒汉模式两种      */    private static SessionFactory sessionFactory;    static {        // 使用configuration接口获取hibernate配置文件 /hibernate.cfg.xml\"        // 第一种读取注解，第二种关系映射配置文件形式        Configuration configuration = new AnnotationConfiguration();        configuration.configure(\"hibernate.cfg.xml\");        // 获取工厂类        if (sessionFactory == null) {            sessionFactory = configuration.buildSessionFactory();        }    }    // 单例模式下具有一个私有的构造函数    private MySessionFactory() {    }    // 该方法用于获取工厂类    public static SessionFactory getSessionFactory() {        return sessionFactory;    }}4、调用HibernateAPI五大接口，SessionFactory、Session、Transaction，完成对象持久化过程，即保存操作。SessionFactory factory = MySessionFactory.getSessionFactory();Session session = factory.openSession();// 开启事务session.beginTransaction();Admin admin = new Admin();admin.setAdminname(\"zhangsan\");admin.setAdminpassword(\"123456\");// 临时状态（瞬时状态）Transientsession.save(admin);// 提交事务 session.getTransaction().commit(); session.close();及Query接口，HQL语句执行。Session session = factory.openSession();Query q = session.createQuery(\"from Admin e where e.adminid=:id\");q.setInteger(\"id\", 1);session.close();package com.bbs.test; import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import com.bbs.bean.User;import com.bbs.util.MySessionFactory; public class TestOpenSession {    public static void main(String[] args) {        SessionFactory factory = MySessionFactory.getSessionFactory();        Session session = factory.openSession();        // 开启事务        session.beginTransaction();        // 临时对象        User user = new User();        user.setCreatetime(\"1995-15-15\");        user.setPassword(\"123\");        user.setSex(\"1\");        user.setUsername(\"zhong\");        // 临时状态        // 持久化过程就是一个数据保存的过程        session.save(user);        // 提交事务        session.getTransaction().commit();        session.close();                //执行HQL语句        Session session1 = factory.openSession();        Query q = session1.createQuery(\"from User u where u.userid=:id\");        q.setInteger(\"id\", 8);        User user1 = (User) session1.get(User.class, 8);        System.out.println(\"1.\" + ((User)(q.list().get(0))).getUsername());        System.out.println(\"2.\" + user1.getUsername());        session1.close();    }}二、真实项目使用情况（TestHibernate1）对以上项目架构做分析，其中factory.openSession()的使用，在实际项目中，每次访问都产生一个session，假如连续使用多次，则获得的session不是同一个对象，并且使用完需要调用close方法关闭session(每次都需要关闭；增加服务器负担)，所以，我们通常使用factory.getCurrentSession，从字面上可以看得出来，是获取当前上下文一个session对象，当第一次使用此方法时，会自动产生一个session对象，并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，简单而言，getCurrentSession就是，如果有已经使用的，用旧的，如果没有，建新的。getCurrentSession是在事务提交时自动调用close方法。实际项目中，我们选择使用getCurrentSession，并且此方法的使用，必须开启事务。使用SessionFactory.getCurrentSession()需要在hibernate.cfg.xml中如下配置：      如果采用jdbc独立引用程序配置如下    &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;            如果采用了JTA事务配置如下    &lt;property name=\"hibernate.current_session_context_class\"&gt;jta&lt;/property&gt;      具体使用步骤，如下：      需要上下文配置（即在hibernate.cfg.xml）中，需要配置     &lt;property name=\"current_session_context_class\"&gt;thread&lt;/property&gt;            代码如下     // 必须加入事务，线程安全 Session session = factory.getCurrentSession(); // 开启事务 session.beginTransaction(); Message e = (Message) session.get(Message.calss, 39); // 提交 自动close session.getTransaction().commit();        小提示：事务的处理，可以通过动态代理简化代码量，并可统一管理。  在实际项目中，我们还需要考虑数据库访问时效性。需要使用“JDBC连接池”。我们选择C3P0，具体配置如下，同时导入C3P0的jar包支持：&lt;!-- 连接池Jdbc connection pool C3P0 --&gt;&lt;property name=\"connection.pool_size\"&gt;1&lt;/property&gt;三、WebProject配置过程（TestSH1.1&amp;TestSH1.2）Hibernate的使用我们在JavaProject中已经充分展示了；在WebProject项目中，使用Hibernate的方式和Java项目中没有太多区别。我们在实际项目中，是通过Spring整合Hibernate的方式集成使用；总体来说写的代码绝对比单独用Hibernate然后在DAO类里写的代码要少；使用Spring整合Hibernate，配置较多。使用getCurrentSession，所有的操作都必须开启事务，所以需要我们注意，使用Spring框架的声明式事务，不再需要自动创建sessionFactory和session，不再需要手动控制事务的开启和关闭。（重点）具体实现步骤如下：  在Spirng配置文件中，装配一个org.springframework.orm.hibernate3.LocalSessionFactoryBean类。          方法一、配置数据源，读取配置文件，获取连接信息；设置hibernate配置信息。         &lt;bean id=\"dataSource\" destory-method=\"close\"      class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;     &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;     &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;     &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;     &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\"      class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\"&gt;     &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;     &lt;property name=\"annotatedClasses\"&gt;         &lt;list&gt;             &lt;value&gt;com.hp.model.User&lt;/value&gt;             &lt;value&gt;com.hp.model.Log&lt;/value&gt;         &lt;/list&gt;     &lt;/property&gt;     &lt;property name=\"hibernateProperties\"&gt;         &lt;props&gt;             &lt;prop key=\"hibernate.dialect\"&gt;               org.hibernate.dialect.OracleDialect             &lt;prop&gt;             &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;         &lt;/props&gt;     &lt;/property&gt; &lt;/bean&gt;        或者hibernate3版本的AnnotationSessionFactoryBean     &lt;bean id=\"sessionFactory\"   class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\"&gt;     &lt;property name=\"dataSource\"&gt;         &lt;ref bean=\"dataSource\"/&gt;     &lt;/property&gt;     &lt;property name=\"hibernateProperties\"&gt;         &lt;props&gt;             &lt;prop key=\"hibernate.dialect\"&gt;                 org.hibernate.dialect.MySQLDialect             &lt;/prop&gt;             &lt;!-- 加入事务，就不需要此处配置 --&gt;             &lt;prop key=\"hibernate.current_session_context_class\"&gt;thread&lt;/prop&gt;             &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;         &lt;/props&gt;     &lt;/property&gt;     &lt;property name=\"packagesToScan\"&gt;         &lt;list&gt;             &lt;value&gt;com.bbs.bean&lt;/value&gt;         &lt;/list&gt;     &lt;/property&gt; &lt;/bean&gt;            方法二、可以通过configLocation属性，加载hibernate.cfg.xml文件。    &lt;bean id=\"sessionFactory\"     class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt;    &lt;property name=\"configLocation\" value=\"file:src/hibernate.cfg.xml\"&gt;    &lt;/property&gt;&lt;/bean&gt;            2. 在spring环境下，新建一个操作类TestSpringDao，需要继承HibernateDaoSupport。        public void test1() {    Session session = this.getSessionFactory().getCurrentSession();    session.beginTransaction();    Message e = (Message) session.get(Message.class, 35);    session.getTransaction().commit();}            在spring配置文件中，装配一个bean，必须注入属性sessioniFactory值。     &lt;bean id=\"testDao1\" class=\"com.bbs.test.TestSpringDao\"&gt;     &lt;property name=\"sessionFactory\"&gt;         &lt;ref bean=\"sessionFactory\"/&gt;     &lt;/property&gt; &lt;/bean&gt;            单元测试，此时可以获取Message对象，才成功。     ApplicationContext ac =      new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 如何获取类的实例 TestSpringDao dao1 = (TestSpringDao) ac.getBean(\"testDao1\"); dao1.test1();      四、实际项目使用（TestSH2）在Spring整合Hibernate框架中，方法中需要开启事务，以及提交事务。这部分代码基本都是模板化的，那么，我们如何在编写过程中把这部分代码省略，或者让系统自动为我们添加。这时，我们考虑到动态代理模式及SpringAOP。我们在实际项目中是如何做的？demo演示如下，在实际项目中我们选择Spring3.0及Hibernate3.0，我们选择注解的形式：      首先从配置文件开始：     &lt;!-- apache下的BasicDataSource，数据库连接池 --&gt; &lt;bean id=\"dataSource\" destory-method=\"close\"      class=\"org.apache.commons.dbcp.BasicDataSource\"&gt;     &lt;property name=\"driverClassName\"&gt;         &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;     &lt;/property&gt;     &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;     &lt;property name=\"username\" value=\"root\"/&gt;     &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\"   class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\"&gt;     &lt;property name=\"dataSource\"&gt;         &lt;ref bean=\"dataSource\"/&gt;     &lt;/property&gt;     &lt;property name=\"hibernateProperties\"&gt;         &lt;props&gt;             &lt;prop key=\"hibernate.dialect\"&gt;                 org.hibernate.dialect.MySQLDialect             &lt;/prop&gt;             &lt;!-- 加入事务，就不需要此处配置 --&gt;             &lt;prop key=\"hibernate.current_session_context_class\"&gt;thread&lt;/prop&gt;             &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt;         &lt;/props&gt;     &lt;/property&gt;     &lt;property name=\"packagesToScan\"&gt;         &lt;list&gt;             &lt;value&gt;com.bbs.bean&lt;/value&gt;         &lt;/list&gt;     &lt;/property &lt;/bean&gt;            设计dao层具体实现：    按照MVC的设计思想，我们创建UserDao层，com.bbs.dao.impl，创建类UserDaoImpl，继承HibernateDaoSupport，这个类是Spring框架提供的，我们使用其中的getHibernateTemplate方法(其中还有一个getSession方法，不常用)，getHibernateTemplate方法提供非常多的常用方法来完成基本的操作。而getSession方法是没有经过Spring包装的，Spring会把最原始的Session给你，在使用完之后必须自己调用相应的close方法，而且也不会对声明式事务进行相应的管理，一旦没有及时关闭连接，就会导致数据库连接池的连接数溢出；getHibernateTemplate()方法是经过Spring封装的，例如添加相应的声明式事务管理，由Spring管理相应的连接。    在实际的使用过程中发现的确getHibernateTemplate()比getSession()方法要好很多，但是有些方法在getHibernateTemplate()并没有提供，这时我们用HibernateCallback回调的方法操作数据库（比如对原生sql语句的执行）。    继承HibernateDaoSupport是可以的，但这种方式还是不太好，还是用到了继承，也就是没有降低所谓的耦合度。解决方案：                  Spring为我们提供了一个hibernateTemplate，你只需在配置文件中配置一个bean，并传入一个sessionFactory。        &lt;bean id=\"hibernateTemplate\"     class=\"com.springframework.orm.hibernate3.HibernateTemplate\"&gt;    &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt;&lt;/bean&gt;                            然后在使用dao的时候注入该hibernateTemplate的bean即可。通过注解实现，因此@Component相当于&lt;bean id=\"\" class=\"\"/&gt;        @Componentpublic class UserDaoImpl implements UserDao {    @Autowired    private HibernateTemplate hibernateTemplate;    public HibernateTemplate getHibernateTemplate() {        return hibernateTemplate;    }    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {        this.hibernateTemplate = hibernateTemplate;    }}                            在方法中直接使用hibernateTemplate提供的get、load、find等方法。              事务管理，Spring提供的事务管理可以分为两类：编程式、声明式，编程式，其实就是在代码里面来控制，像Hibernate操作数据一样，开启事务，提交事务，这种方式有一定的局限性，所以我们一般是用声明式来配置我们的事务。在Spring和Hibernate整合架构中，声明式事务配置，包括以下三项：          事务管理类，我们选择DataSourceTransactionManager或HibernateTransactionManager；      以及声明式事务隔离级别及传播特性，我们通过advice通知拦截；（其中包括五部分，重点，难点）传播行为隔离级别  isolation=”default”        &lt;tx:method name=\"add\" propagation=\"REQUIRED\"     isolation=\"default\" read-only=\"false\"/&gt;                只读  read-only=”false”事务超时 timeout=”-1”        &lt;tx:method name=\"add\" timeout=\"-1\"&gt;                回滚规则 rollback-for=””  /  no-rollback-for=””        &lt;tx:method name=\"update\" no-rollback-for=\"\"&gt;                    以及哪些类和方法参与事务，我们通过SpringAOP实现。        经过以上配置，我们可以实现特定的业务，执行不同的事务策略。程序员只需要关心业务代码实现即可，极大的减轻了程序员额外代码。当然，事务切入点，我们是在sevice层去配置。        Spring配置中定义扫描器，把这些类，纳入Spring容器管理中。     &lt;!-- 扫描注解类 --&gt; &lt;context:component-scan base-package=\"com.bbs\"/&gt;            至此，我们的整合工作就基本完成了。我们可以通过一个单元测试，验证一下：     ApplicationContext ac =          new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 如何获取类的实例 UserDao dao1 = (UserDao) ac.getBean(\"userDaoImpl\"); User user = dao1.findUserById(9); System.out.println(user.getUsername());            业务层service改造，及注解实现：          @Service用于标注业务层组件，即service层类      @Controller用于标注控制层组件（如spingMVC中的控制类）      @Repository用于标注数据访问组件，即dao层类              @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。         @Service public class UserService implements IuserService {   @Autowired   private IUserDao userDao;   public IUserDao getUserDao() {     return userDao;   }   public void setUserDao(IUserDao userDao) {     this.userDao = userDao;   } }                          控制层改造及实现，及代码片段：使用@controller注解     @Controller public class LoginServlet {   @Autowired   IUserService userService;   public IUserService getUserService() {     return userService;   }   public void setUserService(IUserService userService) {     this.userService = uerService;   }   @RequestMapping(value=\"login\", method=RequestMethod.POST) }      五、BBS论坛项目，升级为SpringMVC3.0 + Hibernate3.0 + Mysql5.1 + DBCP数据源项目，升级项目名SH_BBSV4.0具体实现步骤，参考以为配置。六、Hibernate二级缓存  一级缓存及Session缓存，是事务级别的，由Hibernate去管理，一般不去干涉。  二级缓存是sessionFactroy缓存，我们可以根据业务访问及修改频次去设置缓存级别，及设置缓存文字。"
  },
  
  {
    "title": "Java静态代理与动态代理",
    "url": "/posts/jingtaidiali-he-dongtaidaili/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-08-12 01:47:00 +0800",
    





    
    "snippet": "代理概念为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。从图中可以看出，代理接口（Subject）、代理类（ProxySubject）、委托类（RealSubject）形成一个“品”字结构。根据代理类的生成时间不同可以...",
    "content": "代理概念为某个对象提供一个代理，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。从图中可以看出，代理接口（Subject）、代理类（ProxySubject）、委托类（RealSubject）形成一个“品”字结构。根据代理类的生成时间不同可以将代理分为静态代理和动态代理两种。下面以一个模拟需求说明静态代理和动态代理：委托类要处理一项耗时较长的任务，客户类需要打印出执行任务消耗的时间。解决这个问题需要记录任务执行前时间和任务执行后时间，两个时间差就是任务执行消耗的时间。静态代理由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。代理接口// 代理接口，处理给定名字的任务。 public interface Subject {      // 执行给定名字的任务，taskName 任务名     public void dealTask(String taskName);   } 委托类，具体处理业务// 真正执行任务的类，实现了代理接口。 public class RealSubject implements Subject {      // 执行给定名字的任务。这里打印出任务名    // 并休眠500ms模拟任务执行了很长时间     @Override      public void dealTask(String taskName) {          System.out.println(\"正在执行任务：\" + taskName);          try {             Thread.sleep(500);          } catch (InterruptedException e) {             e.printStackTrace();          }      }  }  静态代理类// 代理类，实现了代理接口。  public class ProxySubject implements Subject {          // 代理类持有一个委托类的对象引用      private Subject delegate;         public ProxySubject(Subject delegate) {          this.delegate = delegate;      }        // 将请求分派给委托类执行    // 记录任务执行前后的时间，时间差即为任务的处理时间     @Override      public void dealTask(String taskName) {          long stime = System.currentTimeMillis();           // 将请求分派给委托类处理          delegate.dealTask(taskName);          long ftime = System.currentTimeMillis();           System.out.println(\"执行任务耗时\" + (ftime - stime) + \"毫秒\");      } } 生成静态代理类工厂public class SubjectStaticFactory {     // 客户类调用此工厂方法获得代理对象。      // 对客户类来说，其并不知道返回的是代理类对象还是委托类对象。      public static Subject getInstance() {           return new ProxySubject(new RealSubject());      }  }  客户类public class Client1 {      public static void main(String[] args) {          Subject proxy = SubjectStaticFactory.getInstance();          proxy.dealTask(\"DBQueryTask\");      }     }  静态代理的优缺点  优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。  缺点：          代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。      如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。      动态代理动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。先看看与动态代理紧密关联的Java API。      java.lang.reflect.Proxy    这是Java动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。      // Proxy类的静态方法   // 方法 1: 该方法用于获取指定代理对象所关联的调用处理器    static InvocationHandler getInvocationHandler(Object proxy)         // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象    static Class getProxyClass(ClassLoader loader, Class[] interfaces)         // 方法 3：该方法用于判断指定类对象是否是一个动态代理类    static boolean isProxyClass(Class cl)         // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例    static Object newProxyInstance(ClassLoader loader,           Class[] interfaces, InvocationHandler h)               java.lang.reflect.InvocationHandler    这是调用处理器接口，它自定义了一个invoke方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。每次生成动态代理类对象时都要指定一个对应的调用处理器对象。      // InvocationHandler的核心方法   // 该方法负责集中处理动态代理类上的所有方法调用。  // 第一个参数既是代理类实例，第二个参数是被调用的方法对象    // 第三个方法是调用参数。  // 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行    Object invoke(Object proxy, Method method, Object[] args)              java.lang.ClassLoader    这是类装载器类，负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由JVM在运行时动态生成的而非预存在于任何一个.class文件中。每次生成动态代理类对象时都需要指定一个类装载器对象。  动态代理实现步骤具体步骤是：  实现InvocationHandler接口创建自己的调用处理器  给Proxy类提供ClassLoader和代理接口类型数组创建动态代理类  以调用处理器类型为参数，利用反射机制得到动态代理类的构造函数  以调用处理器对象为参数，利用动态代理类的构造函数创建动态代理类对象// 分步骤实现动态代理 // InvocationHandlerImpl 实现了InvocationHandler接口// 并能实现方法调用从代理类到委托类的分派转发  // 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用  InvocationHandler handler = new InvocationHandlerImpl(..);     // 通过Proxy为包括Interface接口在内的一组接口动态创建代理类的类对象  Class clazz = Proxy.getProxyClass(        classLoader, new Class[] { Interface.class, ... });     // 通过反射从生成的类对象获得构造函数对象  Constructor constructor = clazz.getConstructor(        new Class[] { InvocationHandler.class });     // 通过构造函数对象创建动态代理类实例  Interface Proxy = (Interface)constructor.newInstance(        new Object[] { handler });   Proxy类的静态方法newProxyInstance对上面具体步骤的后三步做了封装，简化了动态代理对象的获取过程。// 简化后的动态代理实现 // InvocationHandlerImpl实现了InvocationHandler接口// 并能实现方法调用从代理类到委托类的分派转发  InvocationHandler handler = new InvocationHandlerImpl(..);     // 通过Proxy直接创建动态代理类实例  Interface proxy = (Interface)Proxy.newProxyInstance( classLoader,       new Class[] { Interface.class },  handler );   动态代理实现示例创建自己的调用处理器//  动态代理类对应的调用处理程序类  public class SubjectInvocationHandler implements InvocationHandler {         // 代理类持有一个委托类的对象引用      private Object delegate;      public SubjectInvocationHandler(Object delegate) {          this.delegate = delegate;      }         @Override      public Object invoke(Object proxy, Method method, Object[] args)             throws Throwable {          long stime = System.currentTimeMillis();           // 利用反射机制将请求分派给委托类处理        // Method的invoke返回Object对象作为方法执行结果。          // 因为示例程序没有返回值，所以这里忽略了返回值处理          method.invoke(delegate, args);          long ftime = System.currentTimeMillis();           System.out.println(\"执行任务耗时\"+(ftime - stime)+\"毫秒\");          return null;      }  }   生成动态代理对象的工厂工厂方法列出了如何生成动态代理类对象的步骤// 生成动态代理对象的工厂public class DynProxyFactory {      //客户类调用此工厂方法获得代理对象。      //对客户类来说，其并不知道返回的是代理类对象还是委托类对象。      public static Subject getInstance(){           Subject delegate = new RealSubject();          InvocationHandler handler = new SubjectInvocationHandler(delegate);          Subject proxy = null;          proxy = (Subject)Proxy.newProxyInstance(              delegate.getClass().getClassLoader(),               delegate.getClass().getInterfaces(),               handler);          return proxy;      }  }  动态代理客户类public class Client {      public static void main(String[] args) {          Subject proxy = DynProxyFactory.getInstance();          proxy.dealTask(\"DBQueryTask\");      }   }  动态代理机制特点首先是动态生成的代理类本身的一些特点。  包：如果所代理的接口都是public的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非public的接口（因为接口不能被定义为protect或 private，所以除public之外就是默认的package访问级别），那么它将被定义在该接口所在包（假设代理了com.ibm.developerworks包中的某非public接口A，那么新生成的代理类所在的包就是com.ibm.developerworks），这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问；  类修饰符：该代理类具有final和public修饰符，意味着它可以被所有的类访问，但是不能被再度继承；  类名：格式是“$ProxyN”，其中N是一个逐一递增的阿拉伯数字，代表Proxy类第N次生成的动态代理类，值得注意的一点是，并不是每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。      类继承关系：该类的继承关系如图：        由图可见，Proxy类是它的父类，这个规则适用于所有由Proxy创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。  接下来让我们了解一下代理类实例的一些特点。每个实例都会关联一个调用处理器对象，可以通过Proxy提供的静态方法getInvocationHandler去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的invoke方法执行，此外，值得注意的是，代理类的根类java.lang.Object中有三个方法也同样会被分派到调用处理器的invoke方法执行，它们是hashCode，equals和toString，可能的原因有：  一是因为这些方法为public且非final类型，能够被代理类覆盖；  二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口（或继承于该接口的某子接口）的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。接着来了解一下被代理的一组接口有哪些特点。首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过65535，这是JVM设定的限制。最后再来了解一下异常处理方面的特点。从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于Throwable接口，但事实是否如此呢？答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛Throwable异常。那么如果在invoke方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Java动态代理类已经为我们设计好了解决方法：它将会抛出UndeclaredThrowableException异常。这个异常是一个RuntimeException类型，所以不会引起编译错误。通过该异常的getCause方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。总结一个典型的动态代理创建对象过程可分为以下四个步骤：  通过实现InvocationHandler接口创建自己的调用处理器IvocationHandler handler = new InvocationHandlerImpl(...);  通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});  通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});  通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法Object result = method.invoke(proxied,args)动态代理的优缺点  优点：动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。在本示例中看不出来，因为invoke方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似Spring AOP那样配置外围业务。      缺点： 诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在 Java中本质上就行不通。    有很多条理由，人们可以否定对class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。  "
  },
  
  {
    "title": "Struts2中通配的使用",
    "url": "/posts/struts2-zhongde-tongpei/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 13:47:00 +0800",
    





    
    "snippet": "在struts.xml文件（配置PersonAction的配置文件）中修改成如下：第一个*的意思是调用的类，第二个*的意思是所用的类中的方法，花括号内的数字就是所用的第几个*。例如请求地址：http://localhost:8080/Struts2MVCDemo/Person_liming?name=liming，代表调用PersonAction类中的lingming()方法。",
    "content": "在struts.xml文件（配置PersonAction的配置文件）中修改成如下：第一个*的意思是调用的类，第二个*的意思是所用的类中的方法，花括号内的数字就是所用的第几个*。例如请求地址：http://localhost:8080/Struts2MVCDemo/Person_liming?name=liming，代表调用PersonAction类中的lingming()方法。"
  },
  
  {
    "title": "MVC",
    "url": "/posts/mvc/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 13:47:00 +0800",
    





    
    "snippet": "MVC的优点  多个视图可以共享一个模型，提高代码重用性。  三个模块相互独立，改变其中一个不会影响其他两个，降低了模块之间的耦合度，提高了模块的可拓展性。  控制器提高了程序的灵活性和可配置性，把不同的模型和不同的视图结合到一起。  在使用MVC进行Web项目开发时，系统分工很明确。系统分工  美工、网页设计人员 — view  Java开发人员 — controller  数据库开发人员...",
    "content": "MVC的优点  多个视图可以共享一个模型，提高代码重用性。  三个模块相互独立，改变其中一个不会影响其他两个，降低了模块之间的耦合度，提高了模块的可拓展性。  控制器提高了程序的灵活性和可配置性，把不同的模型和不同的视图结合到一起。  在使用MVC进行Web项目开发时，系统分工很明确。系统分工  美工、网页设计人员 — view  Java开发人员 — controller  数据库开发人员、高级开发人员、领域专家 — model核心部分"
  },
  
  {
    "title": "关于Struts2",
    "url": "/posts/guanyu-struts2/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 13:47:00 +0800",
    





    
    "snippet": "Struts2实现的MVC模式核心控制器：Filter拦截器。将Servlet解耦，可以用单元测试来对Action控制层进行测试。Struts2执行流程  定义FilterDispatcher，一般出现的过滤器最后。  FilterDispatcher将请求转发给ActionMapper，ActionMapper负责识别当前请求是否需要Struts2做出处理，如果需要处理的话，ActionM...",
    "content": "Struts2实现的MVC模式核心控制器：Filter拦截器。将Servlet解耦，可以用单元测试来对Action控制层进行测试。Struts2执行流程  定义FilterDispatcher，一般出现的过滤器最后。  FilterDispatcher将请求转发给ActionMapper，ActionMapper负责识别当前请求是否需要Struts2做出处理，如果需要处理的话，ActionMapper告诉FilterDispatcher需要处理这个请求，FilterDispatcher就建立ActionProxy对象，ActionProxy对象代理Action的运行及处理过程。  ActionProxy在创建时不知运行哪个Action，只知道url请求，会从ConfigurationManager中询问要调取哪个Action（struts.xml定义）。  ActionProxy取得Action对象同时获取相关拦截器以及可能使用的Result结果信息，着手建立ActionInvocation对象，ActionInvocation对象描述了Action运行的整个过程，并且调用相关的拦截器（Action调用之前部分），ActionInvocation做了一个很重要的工作，把Request请求的参数封装到ActionContext对象里，具体是封装到ActionContext中的值栈（ValueStack）。  调用Action类，执行Action中默认的execute方法（可以自定义），返回一个结果Result，然后选择在struts.xml中配置的页面。  按照相反次序执行拦截器链。  ActionInvocation对象执行完获得HttpServletResponse对象，然后以与过滤器配置定义相反的顺序执行过滤器向用户展示响应的结果。必须的jar包struts-core.xxx.jarxwork-core.xxx.jar。"
  },
  
  {
    "title": "StrutsMVCDemo6 - Struts2中的重定向（2.2.3）",
    "url": "/posts/struts2-zhongde-chongdingxiang/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 06:47:00 +0800",
    





    
    "snippet": "PersonAction.javapublic String execute() {     return \"p1_p2\";}  struts.xml&lt;!-- 公共配置包 --&gt;&lt;package name=\"default\" namespace=\"\" extends=\"struts-default\"&gt;    &lt;interceptors&gt;        &l...",
    "content": "PersonAction.javapublic String execute() {     return \"p1_p2\";}  struts.xml&lt;!-- 公共配置包 --&gt;&lt;package name=\"default\" namespace=\"\" extends=\"struts-default\"&gt;    &lt;interceptors&gt;        &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;        &lt;interceptor-stack name=\"myStack\"&gt;            &lt;!-- 19个拦截器 其中一个是自定义的 --&gt;            &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;            &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;        &lt;/interceptor-stack&gt;    &lt;/interceptors&gt;          &lt;default-interceptor-ref name=\"myStack\"&gt;&lt;/default-interceptor-ref&gt;            &lt;!-- 重定向 --&gt;    &lt;global-results&gt;        &lt;result name=\"index\" type=\"redirect\"&gt;/index.jsp&lt;/result&gt;        &lt;result name=\"p1_p2\" type=\"redirectAction\"&gt;p2&lt;/result&gt;    &lt;/global-results&gt;&lt;/package&gt;  运行结果"
  },
  
  {
    "title": "StrutsMVCDemo5 - Struts2拦截器的使用（2.2.3）",
    "url": "/posts/struts2-lanjieqi-de-shiyong/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 05:47:00 +0800",
    





    
    "snippet": "目录结构LogInterceptor.javapackage com.bbs.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;// 日志拦截器public class LogInterceptor impleme...",
    "content": "目录结构LogInterceptor.javapackage com.bbs.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;// 日志拦截器public class LogInterceptor implements Interceptor {    private static final long serialVersionUID = 1L;    public void destroy() {    }    public void init() {    }    public String intercept(ActionInvocation invocation) throws Exception {    // ActionInvocation实例，直接调用invoke方法，把当前拦截器执行过程交给    // 下一个拦截器，或者调用action的方法    System.out.println(\"执行了logInterceptor拦截器。。。上部分 \");    String rs = invocation.invoke();    System.out.println(\"执行了logInterceptor拦截器。。。下部分 \");    return rs;    }}struts.xml&lt;package name=\"animal\" namespace=\"/animal\" extends=\"person\"&gt;    &lt;interceptors&gt;        &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;    &lt;/interceptors&gt;            &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\" method=\"login\"&gt;        &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;    &lt;/action&gt;        &lt;action name=\"a2\" class=\"com.bbs.action.AnimalAction\" method=\"admin\"&gt;        &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;运行结果  经过测试，如果没有设置Struts核心拦截器，用户请求数据无法获取。  配置核心拦截器或拦截器栈。  其他的action或package不受影响，自定义的拦截器配置只对本action或包生效。解决方法需要配置核心拦截器或拦截器栈，如果自定义拦截器位于Struts核心拦截器前面，并且直接return视图名，可能会不经过核心拦截器，造成某些业务无法正常执行。&lt;interceptors&gt;    &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;&lt;/interceptors&gt;&lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\" method=\"login\"&gt;    &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;    &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;    &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;    &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;&lt;/action&gt;升级配置&lt;interceptors&gt;    &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;    &lt;interceptor-stack name=\"myStack\"&gt;        &lt;!-- 19个拦截器 其中一个是自定义的 --&gt;        &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;        &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;    &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;default-interceptor-ref name=\"myStack\"&gt;&lt;/default-interceptor-ref&gt;&lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\" method=\"login\"&gt;    &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;    &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;&lt;/action&gt;再次升级配置配置一个公共配置包，其他包中继承该公共配置包。&lt;!-- 公共配置包 --&gt;&lt;package name=\"default\" namespace=\"\" extends=\"struts-default\"&gt;    &lt;interceptors&gt;        &lt;interceptor name=\"myLog\" class=\"com.bbs.interceptor.LogInterceptor\"/&gt;        &lt;interceptor-stack name=\"myStack\"&gt;            &lt;interceptor-ref name=\"defaultStack\"&gt;&lt;/interceptor-ref&gt;            &lt;interceptor-ref name=\"myLog\"&gt;&lt;/interceptor-ref&gt;        &lt;/interceptor-stack&gt;    &lt;/interceptors&gt;        &lt;default-interceptor-ref name=\"myStack\"&gt;&lt;/default-interceptor-ref&gt;&lt;/package&gt;  日志拦截器LogInterceptor.javapackage com.bbs.interceptor; import java.lang.reflect.Method;import javax.management.DescriptorKey;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor; // 日志拦截器public class LogInterceptor implements Interceptor {    private static final long serialVersionUID = 1L;    public void destroy() {      }    public void init() {       }    public String intercept(ActionInvocation invocation) throws Exception {        // ActionInvocation实例，直接调用invoke方法，把当前拦截器执行过程交给        // 下一个拦截器，或者调用action的方法        System.out.println(\"执行了logInterceptor拦截器。。。上部分 \");        String rs = invocation.invoke();        // 获取已经执行的action，以及执行的具体方法，        // 并且获取注解标记(注解中有针对相关操作的说明)        Object action = invocation.getAction();        String method = invocation.getProxy().getMethod();        // 通过反射，method是String类型，获取具体对象        Method m = action.getClass().getMethod(method, null);                DescriptorKey dk = m.getAnnotation(DescriptorKey.class);                String value = \"\";        if (dk != null) {            value = dk.value();        }        System.out.println(\"执行了：\" + value + \"操作\");                System.out.println(\"执行了logInterceptor拦截器。。。下部分 \");        return rs;   } }AnimalAction.java@DescriptorKey(\"执行了admin方法\")public String admin() {    System.out.println(admin);    return SUCCESS;}运行结果"
  },
  
  {
    "title": "StrutsMVCDemo4 - Struts2传递对象的方式（2.2.3）",
    "url": "/posts/struts2-chuandi-duixiang-de-fangshi/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 04:47:00 +0800",
    





    
    "snippet": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocati...",
    "content": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;    &lt;!-- 开发阶段，struts配置修改，重新加载 --&gt;    &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\"&gt;&lt;/constant&gt;        &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello2\" class=\"com.bbs.action.PersonAction\" method=\"zhangxueyou\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello3\" class=\"com.bbs.action.PersonAction\" method=\"liming\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;    &lt;include file=\"struts*.xml\"&gt;&lt;/include&gt;&lt;/struts&gt;struts1.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;package name=\"animal\" namespace=\"\" extends=\"person\"&gt;        &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;            &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;action name=\"a2\" class=\"com.bbs.action.AnimalAction\" method=\"admin\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;            &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action;// struts2 Action层public class PersonAction {    private String name;        // 视图从值栈中获取name    public String getName() {        System.out.println(\"调用getName方法\");        return name;    }        public void setName(String name) {        System.out.println(\"调用setName方法，在actionContext中记录值栈信息\");        this.name = name;    }        // 默认执行    public String execute() {        // 返回result结果,视图名字        return \"success\";    }        public String zhangxueyou() {        if (true) {            return \"success\";        } else {            return \"error\";        }    }        public String liming() {        System.out.println(\"获取页面参数：\" + name);        if (name == null || name.equals(\"\")) {            return \"error\";        }        return \"success\";    }    }Admin.javapackage com.bbs.action;/** * 管理员实体类，对应t_admin表  * @author Administrator * */public class Admin {    private int adminid;    private String adminname;    private String adminpassword;    public int getAdminid() {        return adminid;    }    public void setAdminid(int adminid) {        this.adminid = adminid;    }    public String getAdminname() {        return adminname;    }    public void setAdminname(String adminname) {        this.adminname = adminname;    }    public String getAdminpassword() {        return adminpassword;    }    public void setAdminpassword(String adminpassword) {        this.adminpassword = adminpassword;    }    public String toString() {       return \"adminid=\" + adminid + \", adminname=\"        + adminname + \", adminpassword=\" + adminpassword;    }}AnimalAction.javapackage com.bbs.action;import com.opensymphony.xwork2.ActionSupport;/** * action 模型，处理animal方法 * ActionSupport类不仅实现了action接口。还实现了： * validateable      提供校验功能 * validationAware   提供校验功能 * textprovider      提供国际化支持 * localprovider     提供国际化支持 * serializable      序列化接口 * 所以，更多情况下，我们需要继承ActionSupport类 * @author Administrator */public class AnimalAction extends ActionSupport {    private static final long serialVersionUID = 1L;    private String name;    private String pwd;    private Admin admin;        public String getName() {        return name;    }    public String getPwd() {        return pwd;    }    public void setName(String name) {        this.name = name;    }    public void setPwd(String pwd) {        this.pwd = pwd;    }    public String login() {        if (name.trim().equals(\"mayi\") &amp;&amp; pwd.trim().equals(\"123\")) {            return SUCCESS;        } else {            return ERROR;        }    }        public void validate() {        // 验证        if (name == null || pwd == null) {            addFieldError(name, \"不能为空！\");        }    }    public String admin() {        System.out.println(admin);        return SUCCESS;    }    }success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;%@  taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;    &lt;title&gt;Success页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    success    获取值栈属性值：${name }&lt;br/&gt;    id : ${admin.adminid }&lt;br/&gt;    username : ${admin.adminname }&lt;br/&gt;    password : ${admin.adminpassword }&lt;br/&gt;    &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;请求地址http://localhost:8080/Struts2MVCDemo/a2?name=mayi&amp;pwd=123&amp;admin.adminname=zhong&amp;admin.adminid=456&amp;admin.adminpassword=789运行结果控制台浏览器"
  },
  
  {
    "title": "StrutsMVCDemo3 - Struts2后台验证（2.2.3）",
    "url": "/posts/struts2-houtai-yanzheng/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 03:47:00 +0800",
    





    
    "snippet": "Struts2提供的后台效验流程  拦截器调用指定的方法validate()方法；  判断保存错误的Map集合是否为空，为null，才执行action的execute()方法；  如果不为null, 说明验证有错误，不放行。数据效验原理public synchronized void addFieldError(String fieldName, String errorMessage) {...",
    "content": "Struts2提供的后台效验流程  拦截器调用指定的方法validate()方法；  判断保存错误的Map集合是否为空，为null，才执行action的execute()方法；  如果不为null, 说明验证有错误，不放行。数据效验原理public synchronized void addFieldError(String fieldName, String errorMessage) {    // 保存所有的错误信息的map集合    // 同一个key，可以对应多个值    final Map&gt; errors = internalGetFieldErrors();    // 先根据当前错误的key，去错误的map集合中查找，看是否已经存在！    List thisFieldErrors = errors.get(fieldName);    // 当前错误的key，在map集合不存在    if (thisFieldErrors == null) {        thisFieldErrors = new ArrayList();        errors.put(fieldName, thisFieldErrors);    }    // 设置错误信息！    thisFieldErrors.add(errorMessage);}错误处理配置错误视图标记input对应的JSP页面，出现错误跳转到index.jsp，合理显示错误信息。&lt;package name=\"animal\" namespace=\"\" extends=\"person\"&gt;    &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\"&gt;        &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;    &lt;!-- 开发阶段，struts配置修改，重新加载 --&gt;    &lt;constant name=\"struts.configuration.xml.reload\" value=\"true\"&gt;&lt;/constant&gt;        &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello2\" class=\"com.bbs.action.PersonAction\" method=\"zhangxueyou\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello3\" class=\"com.bbs.action.PersonAction\" method=\"liming\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;    &lt;include file=\"struts*.xml\"&gt;&lt;/include&gt;&lt;/struts&gt;struts1.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;package name=\"animal\" namespace=\"\" extends=\"person\"&gt;        &lt;action name=\"a1\" class=\"com.bbs.action.AnimalAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;            &lt;result name=\"input\"&gt;/index.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action;// struts2 Action层public class PersonAction {    private String name;        // 视图从值栈中获取name    public String getName() {        System.out.println(\"调用getName方法\");        return name;    }        public void setName(String name) {        System.out.println(\"调用setName方法，在actionContext中记录值栈信息\");        this.name = name;    }        // 默认执行    public String execute() {        // 返回result结果,视图名字        return \"success\";    }        public String zhangxueyou() {        if (true) {            return \"success\";        } else {            return \"error\";        }    }        public String liming() {        System.out.println(\"获取页面参数：\" + name);        if (name == null || name.equals(\"\")) {            return \"error\";        }        return \"success\";    }    }AnimalAction.javapackage com.bbs.action;import com.opensymphony.xwork2.ActionSupport;/** * action 模型，处理animal方法 * ActionSupport类不仅实现了action接口。还实现了： * validateable      提供校验功能 * validationAware   提供校验功能 * textprovider      提供国际化支持 * localprovider     提供国际化支持 * serializable      序列化接口 * 所以，更多情况下，我们需要继承ActionSupport类 * @author Administrator */public class AnimalAction extends ActionSupport {    private static final long serialVersionUID = 1L;    private String name;    private String pwd;        public String getName() {        return name;    }    public String getPwd() {        return pwd;    }    public void setName(String name) {        this.name = name;    }    public void setPwd(String pwd) {        this.pwd = pwd;    }    public String login() {        if (name.trim().equals(\"mayi\") &amp;&amp; pwd.trim().equals(\"123\")) {            return \"success\";        } else {            return \"error\";        }    }        public void validate() {        // 验证        if (name == null || pwd == null) {            addFieldError(name, \"不能为空！\");        }    }    }success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;%@  taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;    &lt;title&gt;Success页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    success获取值栈属性值：${name }    &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "StrutsMVCDemo2 - 获取Struts2值栈中的值（2.2.3）",
    "url": "/posts/huoqu-struts2-zhizhan-zhongde-zhi/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 02:47:00 +0800",
    





    
    "snippet": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocati...",
    "content": "目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;        &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello2\" class=\"com.bbs.action.PersonAction\" method=\"zhangxueyou\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;                &lt;action name=\"hello3\" class=\"com.bbs.action.PersonAction\" method=\"liming\"&gt;            &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;result name=\"error\"&gt;/WEB-INF/error.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action;// struts2 Action层public class PersonAction {    private String name;        // 视图从值栈中获取name    public String getName() {        System.out.println(\"调用getName方法\");        return name;    }        public void setName(String name) {        System.out.println(\"调用setName方法，在actionContext中记录值栈信息\");        this.name = name;    }        // 默认执行    public String execute() {        // 返回result结果,视图名字        return \"success\";    }        public String zhangxueyou() {        if (true) {            return \"success\";        } else {            return \"error\";        }    }        public String liming() {        System.out.println(\"获取页面参数：\" + name);        if (name == null || name.equals(\"\")) {            return \"error\";        }        return \"success\";    }    }success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;%@  taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;    &lt;title&gt;Success页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    success获取值栈属性值：${name }    &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "StrutsMVCDemo - Struts2配置步骤（2.2.3）",
    "url": "/posts/struts2-peizhi-buzhou/",
    "categories": "Knowledge, Struts2",
    "tags": "Struts2",
    "date": "2021-08-09 01:47:00 +0800",
    





    
    "snippet": "步骤  导入jar包，核心包struts2-core.xxx.jar、xwork-core.xxx.jar。      在Web项目上，支持Struts2特性：在web.xml中定义一个filter。这个filter就是FilterDispatcher类的具体实现类：StrutsPrepareAndExecuteFilter     &lt;filter&gt;     &lt;filter...",
    "content": "步骤  导入jar包，核心包struts2-core.xxx.jar、xwork-core.xxx.jar。      在Web项目上，支持Struts2特性：在web.xml中定义一个filter。这个filter就是FilterDispatcher类的具体实现类：StrutsPrepareAndExecuteFilter     &lt;filter&gt;     &lt;filter-name&gt;struts2&lt;/filter-name&gt;     &lt;filter-class&gt;         org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter     &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt;     &lt;filter-name&gt;struts2&lt;/filter-name&gt;     &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;        创建视图层，我们使用JSP技术，创建了三个不同的页面。  创建Action模型类，PersonAction类。  创建配置文件struts.xml文件，名字默认“struts.xml”。  过滤器会读取“struts.xml”。      struts.xml文件中，继承struts-default。     &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;        相当于我们有了Struts2提供的默认的拦截器或拦截器栈配置。例如：          处理乱码      封装请求数据      国际化      ServletContext      ServletConfig      Session      Request        配置action，对应url和action类；以及返回的result视图。  启动Tomcat。目录结构web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xmlns=\"http://java.sun.com/xml/ns/javaee\"          xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                     http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"          id=\"WebApp_ID\" version=\"2.5\"&gt;    &lt;display-name&gt;Struts2MVCDemo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;            org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter        &lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;struts.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC    \"-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN\"    \"http://struts.apache.org/dtds/struts-2.1.7.dtd\"&gt;&lt;struts&gt;    &lt;!-- 不需要默认Spring容器管理Struts --&gt;    &lt;constant name=\"struts.objectFactory\"               value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;        &lt;!-- hello1请求               必须要指定name属性;              namespace命名空间             package就是要区分请求包名    --&gt;    &lt;package name=\"person\" namespace=\"/person\" extends=\"struts-default\"&gt;            &lt;action name=\"hello1\" class=\"com.bbs.action.PersonAction\"&gt;                    &lt;result name=\"success\"&gt;/WEB-INF/success.jsp&lt;/result&gt;            &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;PersonAction.javapackage com.bbs.action; // struts2 Action层public class PersonAction {             // 默认执行       public String execute() {              // 返回result结果，视图名字              return \"success\";       }      }index.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Index页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;index    &lt;a href=\"http://localhost:8080/Struts2MVCDemo/person/hello1\"&gt;        请求链接-------PersonAction中的方法    &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;success.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Success页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;error.jsp&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"    pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"     \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;title&gt;Error页面&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        success    &lt;/body&gt;&lt;/html&gt;异常由于我们使用的是独立的Struts2的jar包，所以关闭使用Spring的管理即可解决以上异常。正常的项目中是不需要关闭的。&lt;!-- 不需要默认Spring容器管理struts --&gt;&lt;constant name=\"struts.objectFactory\"           value=\"com.opensymphony.xwork2.ObjectFactory\"&gt;&lt;/constant&gt;"
  },
  
  {
    "title": "Topic，Topic分片和Queue",
    "url": "/posts/topic-topicfenpian-queue/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "Queue是RocketMQ中的另一个重要概念。在对该概念进行分析介绍前，我们先来看一张图：为了简化分析过程，在这张图中没有包含Slave Broker。Broker1，Broker2和Broker3都是Master Broker。如果各Master Broker有Slave Broker，Slave Broker中的结构和其对应的Master Broker完全相同。从本质上来说，Rocke...",
    "content": "Queue是RocketMQ中的另一个重要概念。在对该概念进行分析介绍前，我们先来看一张图：为了简化分析过程，在这张图中没有包含Slave Broker。Broker1，Broker2和Broker3都是Master Broker。如果各Master Broker有Slave Broker，Slave Broker中的结构和其对应的Master Broker完全相同。从本质上来说，RocketMQ中的Queue是数据分片的产物。为了更好地理解Queue的定义，我们还需要引入一个新的概念：Topic分片。在分布式数据库和分布式缓存领域，分片概念已经有了清晰的定义。同理，对于RocketMQ，一个Topic可以分布在各个Broker上，我们可以把一个Topic分布在一个Broker上的子集定义为一个Topic分片。对应上图，TopicA有3个Topic分片，分布在Broker1，Broker2和Broker3上，TopicB有2个Topic分片，分布在Broker1和Broker2上，TopicC有2个Topic分片，分布在Broker2和Broker3上。将Topic分片再切分为若干等分，其中的一份就是一个Queue。每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定。我们知道，数据分片的主要目的是突破单点的资源（网络带宽，CPU，内存或文件存储）限制从而实现水平扩展。RocketMQ在进行Topic分片以后，已经达到水平扩展的目的了，为什么还需要进一步切分为Queue呢。解答这个问题还需要从负载均衡说起。以消息消费为例，借用RocketMQ官方文档中的Consumer负载均衡示意图来说明：如图所示，TOPIC_A在一个Broker上的Topic分片有5个Queue，一个ConsumerGroup内有2个Consumer按照集群消费的方式消费消息，按照平均分配策略进行负载均衡得到的结果是：第一个Consumer消费3个Queue，第二个Consumer消费2个Queue。如果增加Consumer，每个Consumer分配到的Queue会相应减少。RocketMQ的负载均衡策略规定：Consumer数量应该小于等于Queue数量，如果Consumer超过Queue数量，那么多余的Consumer将不能消费消息。在一个ConsumerGroup内，Queue和Consumer之间的对应关系是一对多的关系：一个Queue最多只能分配给一个Consumer，一个Cosumer可以分配得到多个Queue。这样的分配规则，每个Queue只有一个消费者，可以避免消费过程中的多线程处理和资源锁定，有效提高各Consumer消费的并行度和处理效率。由此，我们可以给出Queue的定义：Queue是Topic在一个Broker上的分片等分为指定份数后的其中一份，是负载均衡过程中资源分配的基本单元。"
  },
  
  {
    "title": "Spring集成RocketMQ",
    "url": "/posts/spring-jicheng-rocketmq/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "Maven依赖fastjson-1.2.44.jarnetty-all-4.1.19.Final.jarrocketmq-client-4.2.0.jarrocketmq-common-4.2.0.jarrocketmq-remoting-4.2.0.jarslf4j-api-1.7.25.jarslf4j-nop-1.7.25.jar&lt;!-- RocketMQ --&gt;&lt;d...",
    "content": "Maven依赖fastjson-1.2.44.jarnetty-all-4.1.19.Final.jarrocketmq-client-4.2.0.jarrocketmq-common-4.2.0.jarrocketmq-remoting-4.2.0.jarslf4j-api-1.7.25.jarslf4j-nop-1.7.25.jar&lt;!-- RocketMQ --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-common&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-remoting&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.19.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.44&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;RocketMQ配置文件spring-rokectmq.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;bean id=\"rocketmqProduct\"         class=\"org.apache.rocketmq.client.producer.DefaultMQProducer\"         init-method=\"start\"        destroy-method=\"shutdown\"&gt;        &lt;property name=\"producerGroup\" value=\"concurrent_producer\"/&gt;        &lt;property name=\"namesrvAddr\" value=\"192.168.0.103:9876\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"consumerSpringListener\"         class=\"com.ju.biz.mq.rokectmq.quickstartspring.ConsumerSpringListener\" /&gt;    &lt;bean id=\"rocketmqConsumer\"         class=\"org.apache.rocketmq.client.consumer.DefaultMQPushConsumer\"         init-method=\"start\" destroy-method=\"shutdown\"&gt;        &lt;property name=\"consumerGroup\" value=\"concurrent_consumer\"/&gt;        &lt;property name=\"namesrvAddr\" value=\"192.168.0.103:9876\"/&gt;        &lt;property name=\"messageListener\" ref=\"consumerSpringListener\"/&gt;        &lt;property name=\"subscription\"&gt;            &lt;map&gt;                &lt;entry key=\"TopicTest\"&gt;                &lt;value&gt;*&lt;/value&gt;                &lt;/entry&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;生产者ProducerSpring.javaApplicationContext context =             new ClassPathXmlApplicationContext(\"/spring/spring-rokectmq.xml\"); DefaultMQProducer producer = (DefaultMQProducer) context.getBean(\"rocketmqProduct\");try {    Message msg = new Message(\"TopicTest\", \"TagA\",                     (\"Hello RocketMQ\").getBytes(RemotingHelper.DEFAULT_CHARSET));    SendResult sendResult = producer.send(msg);} catch (Exception e) {    e.printStackTrace();    Thread.sleep(1000);}消费者ConsumerSpringListener.javapublic class ConsumerSpringListener implements MessageListenerConcurrently {      @Override     public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,                 ConsumeConcurrentlyContext context) {         System.out.printf(\"%s Receive New Messages: %s %n\",                     Thread.currentThread().getName(), msgs);         return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;     } }"
  },
  
  {
    "title": "如何搭建RocketMQ集群 - 双主集群部署",
    "url": "/posts/ruhe-dajian-rocketmq-jiqun/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "服务器环境            IP      角色      模式                  192.168.2.222      nameServer1,brokerServer1      Master1              192.168.2.223      nameServer2,brokerServer2      Master2      修改配置文件两台机器...",
    "content": "服务器环境            IP      角色      模式                  192.168.2.222      nameServer1,brokerServer1      Master1              192.168.2.223      nameServer2,brokerServer2      Master2      修改配置文件两台机器执行相同的操作，并注意，brokerName的值跟配置文件一致vi /usr/local/rocketmq/conf/2m-noslave/broker-a.propertiesvi /usr/local/rocketmq/conf/2m-noslave/broker-b.properties这里把常用的参数配置基本都列了出来，具体意思在注释里#所属集群名字 brokerClusterName=rocketmq-cluster #broker名字，注意此处不同的配置文件填写的不一样 brokerName=broker-a|broker-b #0 表示 Master，&gt;0 表示 Slave brokerId=0 #nameServer地址，分号分割 namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876 # 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数 defaultTopicQueueNums=4 # 是否允许 Broker 自动创建Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true # 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭 autoCreateSubscriptionGroup=true # Broker 对外服务的监听端口 listenPort=10911 # 删除文件时间点，默认凌晨 4点 deleteWhen=04 #文件保留时间，默认 48 小时 fileReservedTime=120 #commitLog每个文件的大小默认1G mapedFileSizeCommitLog=1073741824 #ConsumeQueue每个文件默认存30W条，根据业务情况调整 mapedFileSizeConsumeQueue=300000 #destroyMapedFileIntervalForcibly=120000 #redeleteHangedFileInterval=120000 #检测物理文件磁盘空间 diskMaxUsedSpaceRatio=88 #存储路径 storePathRootDir= /usr/local/rocketmq/store #commitLog 存储路径 storePathCommitLog= /usr/local/rocketmq/store /commitlog #消费队列存储路径存储路径 storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue #消息索引存储路径 storePathIndex=/usr/local/rocketmq/store/index #checkpoint 文件存储路径 storeCheckpoint=/usr/local/rocketmq/store/checkpoint #abort 文件存储路径 abortFile=/usr/local/rocketmq/store/abort #限制的消息大小，默认4MmaxMessageSize=65536 #flushCommitLogLeastPages=4 #flushConsumeQueueLeastPages=2 #flushCommitLogThoroughInterval=10000 #flushConsumeQueueThoroughInterval=60000 #Broker 的角色 #- ASYNC_MASTER 异步复制Master #- SYNC_MASTER 同步双写Master #- SLAVE brokerRole=ASYNC_MASTER #刷盘方式 #- ASYNC_FLUSH 异步刷盘 #- SYNC_FLUSH 同步刷盘 flushDiskType=ASYNC_FLUSH #checkTransactionMessageEnable=false #发消息线程池数量 #sendMessageThreadPoolNums=128 #拉消息线程池数量 #pullMessageThreadPoolNums=128启动要先启动NameServer，再启Broker，两台机器执行相同的操作。启动BrokerServer（节点1用的是a.properties，节点2用的是b.properties）数据清理首先停一下服务cd /usr/local/rocketmq/binsh mqshutdown brokersh mqshutdown namesrv然后清一下store，但别忘记重新建一下rm -rf /usr/local/rocketmq/storemkdir /usr/local/rocketmq/storemkdir /usr/local/rocketmq/store/commitlogmkdir /usr/local/rocketmq/store/consumequeuemkdir /usr/local/rocketmq/store/indexBroker重启对客户端的影响Broker重启可能会导致正在发往这台机器的的消息发送失败，RocketMQ提供了一种优雅关闭Broker的方法，通过执行以下命令会清除Broker的写权限，过40s后，所有客户端都会更新Broker路由信息，此时再关闭Broker就不会发生发送消息失败的情况，因为所有消息都发往了其他Broker。sh mqadmin wipeWritePerm -b brokerName -n namesrvAddr"
  },
  
  {
    "title": "RocketMQ术语",
    "url": "/posts/rocketmq-shuyu/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "Producer消息生产者，生产者的作用就是将消息发送到MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到MQ。Producer Group生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。Consumer消息消费者，简单来说，消费MQ上的消息的应用程序就是...",
    "content": "Producer消息生产者，生产者的作用就是将消息发送到MQ，生产者本身既可以产生消息，如读取文本信息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到MQ。Producer Group生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。Consumer消息消费者，简单来说，消费MQ上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等取决于业务需要。Consumer Group消费者组，和生产者类似，消费同一类消息的多个Consumer实例组成一个消费者组。TopicTopic是一种消息的逻辑分类，比如说你有订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单Topic存放订单相关的消息，一个是库存Topic存储库存相关的消息。MessageMessage是消息的载体。一个Message必须指定Topic，相当于寄信的地址。Message还有一个可选的Tag设置，以便消费端可以基于Tag进行过滤消息。也可以添加额外的键值对，例如你需要一个业务Key来查找Broker上的消息，方便在开发过程中诊断问题。Tag标签可以被认为是对Topic进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。BrokerBroker是RocketMQ系统的主要角色，其实就是前面一直说的MQ。Broker接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。通过提供轻量级的Topic和Queue机制来处理消息存储,同时支持推（push）和拉（pull）模式以及主从结构的容错机制。NameServerNameServer为Producer和Consumer提供路由信息。提供轻量级的服务发现和路由。每个NameServer记录完整的路由信息，提供等效的读写服务，并支持快速存储扩展。由这张图可以看到有四个集群，分别是NameServer集群、Broker集群、Producer集群和Consumer集群：简单说明一下图中箭头含义，从Broker开始，Broker Master1和Broker Slave1是主从结构，它们之间会进行数据同步，即Date Sync。同时每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer中。Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Broker发送心跳。Producer只能将消息发送到Broker master，但是Consumer则不一样，它同时和提供Topic服务的Master和Slave建立长连接，既可以从Broker Master订阅消息，也可以从Broker Slave订阅消息。RocketMQ集群部署模式单Master模式也就是只有一个Master节点，称不上是集群，一旦这个Master节点宕机，那么整个服务就不可用，适合个人学习使用。多Master模式多个Master节点组成集群，单个Master节点宕机或者重启对应用没有影响。  优点：所有模式中性能最高。  缺点：单个Master节点宕机期间，未被消费的消息在节点恢复之前不可用，消息的实时性就受到影响。  注意：使用同步刷盘可以保证消息不丢失，同时Topic相对应的queue应该分布在集群中各个节点，而不是只在某各节点上，否则，该节点宕机会对订阅该Topic的应用造成影响。多Master多Slave异步复制模式在多Master模式的基础上，每个Master节点都有至少一个对应的Slave。Master节点可读可写，但是Slave只能读不能写，类似于MySQL的主备模式。  优点：在Master宕机时，消费者可以从Slave读取消息，消息的实时性不会受影响，性能几乎和多Master一样。  缺点：使用异步复制的同步方式有可能会有消息丢失的问题。多Master多Slave同步双写模式同多Master多Slave异步复制模式类似，区别在于Master和Slave之间的数据同步方式。  优点：同步双写的同步模式能保证数据不丢失。  缺点：发送单个消息RT会略长，性能相比异步复制低10%左右。  刷盘策略：同步刷盘和异步刷盘（指的是节点自身数据是同步还是异步存储）。  同步方式：同步双写和异步复制（指的一组Master和Slave之间数据的同步）。  注意：要保证数据可靠，需采用同步刷盘和同步双写的方式，但性能会较其他方式低。"
  },
  
  {
    "title": "RocketMQ实际部署",
    "url": "/posts/rocketmq-shiji-bushu/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "      上传安装包        解压RocketMQ压缩包        在安装目录下创建存储路径      mkdir -p data/store/{commitlog,consumequeue,index}            进入conf目录下修改日志配置文件      mkdir -p /home/weblogic/apache-rocketmq/logs  sed -i '...",
    "content": "      上传安装包        解压RocketMQ压缩包        在安装目录下创建存储路径      mkdir -p data/store/{commitlog,consumequeue,index}            进入conf目录下修改日志配置文件      mkdir -p /home/weblogic/apache-rocketmq/logs  sed -i 's#${user.home}#/home/apache-rocketmq#g' *.xml            修改RocketMQ的配置文件，以下为主要参数      # nameServer地址，分号分割  namesrvAddr = 9.23.28.145:9876  # Broker 对外服务的监听端口  listenPort = 10911            修改启动脚本，指定JDK        启动mqnamesrv      nohup sh mqnamesrv &amp;            启动Broker      nohup sh mqbroker -c /home/weblogic/apache-rocketmq/conf/broker.conf &gt;/dev/null 2&gt;&amp;1 &amp;        自动创建Topic      nohup sh mqbroker -c /home/weblogic/apache-rocketmq/conf/broker.conf autoCreateTopicEnable=true &gt;/dev/null 2&gt;&amp;1 &amp;            安装RocketMQ-Console    修改配置文件rocketmq-console的配置      server.port = 8099  rocketmq.config.namesrvAddr = 9.23.28.145:9876            启动控制台      nohup /home/weblogic/apache-rocketmq/jdk/jdk1.8/bin/java -jar rocketmq-console-ng-1.0.0.jar  &amp;             需要开放的端口    8080、9876、10911        访问控制台    http://localhost:8099/rocketmq-console        物理部署      "
  },
  
  {
    "title": "RocketMQ如何在控制台查看死信队列",
    "url": "/posts/rocketmq-ruhe-zai-kongzhitai-chakan-sixinduilie/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "RocketMQ的ACK机制其中涉及到了消息消费重试，当重试次数达到默认的16次后（可以通过配置文件修改）如果对应的消息还没被成功消费的话，该消息就会投递到DLQ死信队列。不过，在使用控制台查询死信消息队列的时候会报错org.apache.rocketmq.client.exception.MQClientException: Can not find Message Queue for t...",
    "content": "RocketMQ的ACK机制其中涉及到了消息消费重试，当重试次数达到默认的16次后（可以通过配置文件修改）如果对应的消息还没被成功消费的话，该消息就会投递到DLQ死信队列。不过，在使用控制台查询死信消息队列的时候会报错org.apache.rocketmq.client.exception.MQClientException: Can not find Message Queue for this topic, %DLQ%consumer1 See http://rocketmq.apache.org/docs/faq/ for further details.，具体如下图：对应服务器进入相关的目录下/usr/local/rocketmq/store/consumequeue，发现确实是存在%DLQ%consumer1。我们通过RocketMQ的管理命令（先进入/usr/local/rocketmq/bin）sh mqadmin topicList -n 192.168.140.129:9876;192.168.140.128:9876查看所有的Topic，发现也确实能够找到。sh mqadmin topicRoute -n 192.168.140.129:9876 -t %DLQ%consumer1查看该Topic信息，发现perm为2。修改Topic的perm为6（两台机器都要执行），在128机器上执行如下命令：sh mqadmin updateTopic -b 192.168.159.129:10911 -n 192.168.159.129:9876 -t %DLQ%consumer1 -p 6129机器上执行如下命令：sh mqadmin updateTopic -b 192.168.159.128:10911 -n 192.168.159.128:9876 -t %DLQ%consumer1 -p 6查看控制台死信队列。"
  },
  
  {
    "title": "RocketMQ配置项",
    "url": "/posts/rocketmq-peizhixiang/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "客户端的公共配置类：ClientConfig            参数名      默认值      说明                  NamesrvAddr             NameServer地址列表，多个NameServer地址用分号隔开              clientIP      本机IP      客户端本机IP地址，某些机器会发生无法识别客户端IP地址情...",
    "content": "客户端的公共配置类：ClientConfig            参数名      默认值      说明                  NamesrvAddr             NameServer地址列表，多个NameServer地址用分号隔开              clientIP      本机IP      客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定              instanceName      DEFAULT      客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）              clientCallbackExecutorThreads      4      通信层异步回调线程数              pollNameServerInteval      30000      轮训NameServer间隔时间，单位毫秒              heartbeatBrokerInterval      30000      向Broker发送心跳间隔时间，单位毫秒              persistConsumerOffsetInterval      5000      持久化Consumer消费进度间隔时间，单位毫秒      Producer配置            参数名      默认值      说明                  producerGroup      DEFAULT_PRODUCER      Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。              createTopicKey      TBW102      在发送消息时，自动创建服务器不存在的Topic，需要指定Key              defaultTopicQueueNums      4      在发送消息时，自动创建服务器不存在的Topic，默认创建的队列数              sendMsgTimeout      10000      发送消息超时时间，单位毫秒              compressMsgBodyOverHowmuch      4096      消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节              retryAnotherBrokerWhenNotStoreOK      FALSE      如果发送消息返回sendResult，但是sendStatus!=SEND_OK，是否重试发送              maxMessageSize      131072      客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）              transactionCheckListener             事物消息回查监听器，如果发送事务消息，必须设置              checkThreadPoolMinSize      1      Broker回查Producer事务状态时，线程池大小              checkThreadPoolMaxSize      1      Broker回查Producer事务状态时，线程池大小              checkRequestHoldMax      2000      Broker回查Producer事务状态时，Producer本地缓冲请求队列大小      PushConsumer配置            参数名      默认值      说明                  consumerGroup      DEFAULT_CONSUMER      Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组              messageModel      CLUSTERING      消息模型，支持以下两种：1.集群消费；2.广播消费              consumeFromWhere      CONSUME_FROM_LAST_OFFSET      Consumer启动后，默认从什么位置开始消费              allocateMessageQueueStrategy      AllocateMessageQueueAveragely      Rebalance算法实现策略              Subscription      {}      订阅关系              messageListener             消息监听器              offsetStore             消费进度存储              consumeThreadMin      10      消费线程池数量              consumeThreadMax      20      消费线程池数量              consumeConcurrentlyMaxSpan      2000      单队列并行消费允许的最大跨度      PullConsumer配置            参数名      默认值      说明                  consumerGroup             Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组              brokerSuspendMaxTimeMillis      20000      长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒              consumerPullTimeoutMillis      10000      非长轮询，拉消息超时时间，单位毫秒              consumerTimeoutMillisWhenSuspend      30000      长轮询，Consumer拉消息请求Broker挂起超过指定时间，客户端认为超时，单位毫秒              messageModel      BROADCASTING      消息模型，支持以下两种：1.集群消费；2.广播模式              messageQueueListener             监听队列变化              offsetStore             消费进度存储              registerTopics             注册的Topic集合              allocateMessageQueueStrategy             Rebalance算法实现策略      Broker配置查看Broker默认配置sh mqbroker -m            参数名\t       默认值       说明                  consumerGroup             Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组              listenPort      10911      Broker对外服务的监听端口              namesrvAddr      Null      NameServer地址              brokerIP1      本机IP      本机IP地址，默认系统自动识别，但是某些多网卡机器会存在识别错误的情况，这种情况下可以人工配置              brokerName             本机主机名              brokerClusterName      DefaultCluster      Broker所属哪个集群              brokerId      0      BrokerId，必须是大等于0的整数，0表示Master，&gt;0表示Slave，一个Master可以挂多个Slave，Master和Slave通过BrokerName来配对              storePathCommitLog      $HOME/store/commitlog      commitLog存储路径              storePathConsumeQueue      $HOME/store/consumequeue      消费队列存储路径              storePathIndex      $HOME/store/index      消息索引存储队列              deleteWhen      4      删除时间时间点，默认凌晨4点              fileReservedTime      48      文件保留时间，默认48小时              maxTransferBytesOnMessageInMemory      262144      单次pull消息（内存）传输的最大字节数              maxTransferCountOnMessageInMemory      32      单次pull消息（内存）传输的最大条数              maxTransferBytesOnMessageInMemory      65535      单次pull消息（磁盘）传输的最大字节数              maxTransferCountOnMessageInDisk      8      单次pull消息（磁盘）传输的最大条数              messageIndexEnable      TRUE      是否开启消息索引功能              messageIndexSafe      FALSE      是否提供安全的消息索引机制，索引保证不丢              brokerRole      ASYNC_MASTER      Broker的角色-ASYNC_MASTER异步复制Master-SYNC_MASTER同步双写Master-SLAVE              flushDiskType      ASYNC_FLUSH      刷盘方式-ASYNC_FLUSH异步刷盘-SYNC_FLUSH同步刷盘              cleanFileForciblyEnable      TRUE      磁盘满，且无过期文件情况下TRUE表示强制删除文件，优先保证服务可用FALSE标记服务不可用，文件不删除      "
  },
  
  {
    "title": "关于RocketMQ",
    "url": "/posts/guanyu-rocketmq/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "RocketMQ队列的长度RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会...",
    "content": "RocketMQ队列的长度RocketMQ没有内存Buffer概念，RocketMQ的队列都是持久化磁盘，数据定期清除。RocketMQ同其他MQ有非常显著的区别，RocketMQ的内存Buffer抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除。RocketMQ的消息优先级RocketMQ并不遵循任何规范，但参考了各种规范的设计思想。考虑到持久化的消息按照优先级排序开销大，RocketMQ没有特意支持消息优先级。在Message的API中的确没有提供和Priority(优先级)有关的方法。两种变通的处理思路供参考：  使用消息队列来表示不同的优先级：单独配置一个优先级高的队列，和一个普通优先级的队列，将不同优先级发送到不同队列即可；  使用t来表示不同的优先级：每个优先级可以用不同的Topic表示，发消息时，指定不同的Topic来表示优先级。RocketMQ提供2级消息分类，方便使用者灵活控制TopicTopic表示消息的第一级类型，比如一个电商系统的消息可以分为：交易消息、物流消息……一条消息必须有一个Topic。TagTag表示消息的第二级类型，比如交易消息又可以分为：交易创建消息，交易完成消息…..一条消息可以没有Tag。订阅指定Topic下Tags分别等于TagA或TagC或TagDconsumer.subscribe(\"TopicTest1\", \"TagA || TagC || TagD\");设置为广播消费模式consumer.setMessageModel(MessageModel.BROADCASTING);消费者的消费位置ConsumeFromWhere consumeFromWhere   CONSUME_FROM_LAST_OFFSET：第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费   CONSUME_FROM_FIRST_OFFSET：第一次启动从队列初始位置消费，后续再启动接着上次消费的进度开始消费   CONSUME_FROM_TIMESTAMP：第一次启动从指定时间点位置消费，后续再启动接着上次消费的进度开始消费 以上所说的第一次启动是指从来没有消费过的消费者，如果该消费者消费过，那么会在Broker端记录该消费者的消费位置，如果该消费者挂了再启动，那么自动从上次消费的进度开始。如何拿到消费者的处理结果绝大部分队列用于削峰和解耦，也有用于处理分布式事务。削峰是用于当应用处理不过来过大的并发请求时，将请求存于队列中，用单个或多个消费者来处理请求。这时候想要拿到请求怎么办呢？  每个消费者处理完成请求，再发送消息到消息队列中，生产者再实现消费者来消费这些处理结果信息；  将处理结果存于缓存等高性能组件中，通过轮询的方式获取任务处理结果，消息结果可以用推送的方式告知(移动端),也可以让请求方每个几秒轮询一次处理结果。队列重新消费的间隔每次重新消费间隔：10s,30s,1m,2m,3m默认消息重发次数为16次。"
  },
  
  {
    "title": "CentOS7安装RocketMQ",
    "url": "/posts/centos-anzhuang-rocketmq/",
    "categories": "Knowledge, RocketMQ",
    "tags": "RocketMQ",
    "date": "2021-07-14 13:47:00 +0800",
    





    
    "snippet": "      上传安装包    JDK1.8 (注意一定要使用1.8以上版本，1.7版本不能识别RocketMQ中的metaspace特性，该特性由1.8最新提出) 。  RocketMQ压缩包，下载选择binary版。        解压RocketMQ压缩包        修改配置文件    在conf文件中可以看到以下文件夹，对应rocketmq的不同部署模式：      2m-2s-a...",
    "content": "      上传安装包    JDK1.8 (注意一定要使用1.8以上版本，1.7版本不能识别RocketMQ中的metaspace特性，该特性由1.8最新提出) 。  RocketMQ压缩包，下载选择binary版。        解压RocketMQ压缩包        修改配置文件    在conf文件中可以看到以下文件夹，对应rocketmq的不同部署模式：      2m-2s-async  两主两从异步 异步数据的配置文件夹   2m-2s-sync   两主两从同步 同步数据的配置文件夹   2m-noslave   两主无从的配置文件           vi ../conf/broker.conf  brokerIP1 = 192.168.x.x         显示指定为本机外网IP，不要用localhost和127.0.0.1，因为远程主机会根据brokerIP1指定的地址去访问Broker        在安装目录下创建存储路径      mkdir -p data/store/{commitlog,consumequeue,index}            进入conf目录下修改日志配置文件      mkdir -p /home/apache-rocketmq/logs  sed -i 's#${user.home}#/home/apache-rocketmq#g' *.xml            修改JVM参数    vi修改runserver.sh和runbroker.sh的JVM参数如下（根据虚拟机内存大小设置，超出内存大小可能会报错）：      JAVA_OPT=\"${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn256m -XX:PermSize=128m -XX:MaxPermSize=320m\"            启动mqnamesrv      nohup sh mqnamesrv &amp;            启动broker      nohup sh mqbroker -c /home/apache-rocketmq/conf/broker.conf autoCreateTopicEnable=true &gt;/dev/null 2&gt;&amp;1 &amp;            使用jps命令检查是否启动成功      [root@localhost bin]# jps  1155 NamesrvStartup  1212 BrokerStartup  3197 Jps            安装RocketMQ-Console    GitHub下载链接：https://github.com/apache/rocketmq-externals，修改配置文件rocketmq-console/src/main/resources/application.properties       server.port = 8080  rocketmq.config.namesrvAddr = NameServer的IP:9876        编译RocketMQ-Console得到rocketmq-console-ng-1.0.0.jar      mvn clean package -Dmaven.test.skip=true            启动控制台    可以直接用jar包来启动，这个jar是用源码编译好的      nohup java -jar rocketmq-console-ng-1.0.0.jar &amp;             需要开放的端口    8080、9876、10911        访问控制台    http://localhost:8080/rocketmq-console  "
  },
  
  {
    "title": "删除下载未完整的依赖文件",
    "url": "/posts/shanchu-xiazai-weiwanzheng-de-yilai/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-07-14 03:47:00 +0800",
    





    
    "snippet": "set REPOSITORY_PATH=E:\\repositoryrem 正在搜索...for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do ( del /s /q %%i)rem 搜索完毕pause记得路径修改为你自己所在依赖包的位置，然后把.txt文件后缀改为.bat ，双击运行即可跳出窗口去...",
    "content": "set REPOSITORY_PATH=E:\\repositoryrem 正在搜索...for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do ( del /s /q %%i)rem 搜索完毕pause记得路径修改为你自己所在依赖包的位置，然后把.txt文件后缀改为.bat ，双击运行即可跳出窗口去自动删除。"
  },
  
  {
    "title": "IntelliJ IDEA Maven菜单模块为灰色",
    "url": "/posts/maven-candan-mokuai-wei-huise/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-07-14 03:23:00 +0800",
    





    
    "snippet": "Idea用maven搭建聚合项目时，出现了如下的问题：即Maven工具栏中的某一个模块是灰色的，同时导致了新的问题：在pom文件中引入jar包，但是在Java代码里，找不到这个类。然后我看了一下Dependencies目录，jar是下载好的。jar包是下载好的，但是引用类文件的地方还是有红色报错：提示要Add library to classpath。解决办法：Preferences -&g...",
    "content": "Idea用maven搭建聚合项目时，出现了如下的问题：即Maven工具栏中的某一个模块是灰色的，同时导致了新的问题：在pom文件中引入jar包，但是在Java代码里，找不到这个类。然后我看了一下Dependencies目录，jar是下载好的。jar包是下载好的，但是引用类文件的地方还是有红色报错：提示要Add library to classpath。解决办法：Preferences -&gt; build -&gt; maven -&gt; ignore files，找到对应的Maven模块，取消勾选。Maven中的灰色模块变为了黑色，同时引用的类文件也不再报错。可能出现这种问题的原因：新建模块（module）时，已经新建了一个模块，但是由于种种原因，你将该模块删除了，又新建了一个同名的模块，这时父项目的pom文件中不报错了，但是重新新建的模块已经被加入了Maven的ignoreFiles中，所以这时需要手动去取消勾选。  参考：idea maven菜单模块为灰色"
  },
  
  {
    "title": "IntelliJ IDEA离线使用Maven仓库的方法",
    "url": "/posts/lixian-shiyong-maven-cangku-de-fangfa/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-07-14 03:23:00 +0800",
    





    
    "snippet": "首先将相关的Maven依赖在外网的环境中下载好，然后将整个repository打包后拷贝到内网的机器上并解压。然后将外网的settings文件也拷贝到内网使用，或者也可以将内网 settings 文件中的镜像配置部分改成和外网一样。&lt;mirrors&gt; &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirror...",
    "content": "首先将相关的Maven依赖在外网的环境中下载好，然后将整个repository打包后拷贝到内网的机器上并解压。然后将外网的settings文件也拷贝到内网使用，或者也可以将内网 settings 文件中的镜像配置部分改成和外网一样。&lt;mirrors&gt; &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;这么做的原因是确保镜像id和repository里依赖的配置是一致的。我们随便打开一个本地仓库的依赖，会有个_remote.repositories 文件。打开后会发现.pom和.jar文件会后面会有对应镜像id，如果与settings文件里不匹配的话，那么编译时仍然会去远程仓库获取。最后打开IDEA的Maven设置，配置好本地仓库地址和settings文件地址，并勾选上Work offline（离线模式），这样就完成Maven的离线配置了。  参考：Intellij IDEA - 离线使用本地Maven仓库的方法（没有外网，且不搭建私服）"
  },
  
  {
    "title": "Spring MVC",
    "url": "/posts/spring-mvc/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "现在主流的Web MVC框架除了Struts这个主力外，其次就是Spring MVC了，因此这也是作为一名程序员需要掌握的主流框架，框架选择多了，应对多变的需求和业务时，可实行的方案自然就多了。不过要想灵活运用Spring MVC来应对大多数的Web开发，就必须要掌握它的配置及原理。web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;...",
    "content": "现在主流的Web MVC框架除了Struts这个主力外，其次就是Spring MVC了，因此这也是作为一名程序员需要掌握的主流框架，框架选择多了，应对多变的需求和业务时，可实行的方案自然就多了。不过要想灵活运用Spring MVC来应对大多数的Web开发，就必须要掌握它的配置及原理。web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xmlns=\"http://java.sun.com/xml/ns/javaee\"         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee                             http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"         id=\"WebApp_ID\"         version=\"2.5\"&gt;  &lt;display-name&gt;TestSpring&lt;/display-name&gt;    &lt;!-- Spring servlet --&gt;  &lt;servlet&gt;      &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;      &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;      &lt;/init-param&gt;      &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;      &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;!-- Spring Listener --&gt;  &lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;  &lt;/listener&gt;    &lt;!-- applicationContext.xml load --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;&lt;/web-app&gt; applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans    xsi:schemaLocation=\"http://www.springframework.org/schema/beans                 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd                 http://www.springframework.org/schema/context                 http://www.springframework.org/schema/context/spring-context-3.0.xsd                 http://www.springframework.org/schema/aop                 http://www.springframework.org/schema/aop/spring-aop-3.0.xsd                 http://www.springframework.org/schema/tx                 http://www.springframework.org/schema/tx/spring-tx-3.0.xsd                 http://www.springframework.org/schema/mvc                 http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd \"    xmlns:tx=\"http://www.springframework.org/schema/tx\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"    xmlns:context=\"http://www.springframework.org/schema/context\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns=\"http://www.springframework.org/schema/beans\"    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"&gt;        &lt;!-- Spring bean --&gt;    &lt;bean id=\"user\" class=\"com.bbs.bean.User\"&gt;&lt;/bean&gt;    &lt;bean id=\"db1\" class=\"com.bbs.util.DBConnection\"&gt;&lt;/bean&gt;    &lt;bean id=\"userDao\" class=\"com.bbs.dao.UserDao\"&gt;        &lt;property name=\"db\"&gt;&lt;ref bean=\"db1\"/&gt;&lt;/property&gt;    &lt;/bean&gt;        &lt;!-- Spring SimpleUrlHandlerMapping --&gt;    &lt;bean id=\"urlMap\"         class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt;        &lt;property name=\"mappings\"&gt;            &lt;props&gt;                &lt;prop key=\"test.do\"&gt;test&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;        &lt;bean id=\"test\" class=\"com.bbs.servlet.TestServletBean\"&gt;        &lt;property name=\"userDao\"&gt;            &lt;ref bean=\"userDao\"/&gt;        &lt;/property&gt;        &lt;property name=\"user\"&gt;            &lt;ref bean=\"user\"/&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;  TestServletBean.javapackage com.bbs.servlet;import java.io.PrintWriter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import com.bbs.bean.User;import com.bbs.dao.UserDao;public class TestServletBean implements Controller {    private User user;    private UserDao userDao;    public User getUser() {        return user;    }    public UserDao getUserDao() {        return userDao;    }    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    public void setUser(User user) {        this.user = user;    }        public TestServletBean() {            }        public ModelAndView handleRequest(HttpServletRequest request,             HttpServletResponse response) throws Exception {        try {            user = userDao.find(8);        } catch (Exception e) {            e.printStackTrace();        }        PrintWriter out = response.getWriter();        out.print(user.getUsername());        out.close();        return null;    }    }AOP配置头&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:aop=\"http://www.springframework.org/schema/aop\"\txmlns:tx=\"http://www.springframework.org/schema/tx\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans-3.0.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context-3.0.xsd        http://www.springframework.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop-3.0.xsd        http://www.springframework.org/schema/tx         http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt; MVC配置头&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xsi:schemaLocation=\"http://www.springframework.org/schema/beans         http://www.s`pringframework.org/schema/beans/spring-beans-3.0.xsd         http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context-3.0.xsd          http://www.springframework.org/schema/mvc         http://www.springfr`amework.org/schema/mvc/spring-mvc-3.0.xsd\"     xmlns:context=\"http://www.springframework.org/schema/context\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"     xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:mvc=\"http://www.springframework.org/schema/mvc\"&gt;Spring Bean配置头&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN//EN\" \t\"http://www.springframework.org/dtd/spring-beans.dtd\"&gt;"
  },
  
  {
    "title": "Spring IOC",
    "url": "/posts/spring-ioc/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "IOC理论的背景我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到...",
    "content": "IOC理论的背景我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。齿轮组中齿轮之间的啮合关系，与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。什么是控制反转(IOC)IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦，如下图：大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统：我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。IOC的别名：依赖注入(DI)2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了Spring我们就只需要告诉Spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，Spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由Spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，Spring就是通过反射来实现注入的。我们举一个生活中的例子，来帮助理解依赖注入的过程。大家对USB接口和USB设备应该都很熟悉吧，USB为我们使用电脑提供了很大的方便，现在有很多的外部设备都支持USB接口。现在，我们利用电脑主机和USB接口来实现一个任务：从外部USB设备读取一个文件。电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。通过这个例子，依赖注入的思路已经非常清楚：当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。我们把依赖注入应用到软件系统中，再来描述一下这个过程：对象A依赖于对象B，当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。IOC为我们带来了什么好处我们还是从USB的例子说起，使用USB外部设备比使用内置硬盘，到底带来什么好处？第一、USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。所以，无论两者中的任何一方出现什么的问题，都不会影响另一方的运行。这种特性体现在软件工程中，就是可维护性比较好，非常便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。第二、USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。这种特性体现在软件开发过程中，好处可是太大了。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。所以，在一个大中型项目中，团队成员分工明确、责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将得到大幅度的提高。第三、同一个USB外部设备可以插接到任何支持USB的设备，可以插接到电脑主机，也可以插接到DV机，USB外部设备可以被反复利用。在软件工程中，这种特性就是可复用性好，我们可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。显然，IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现，都可以插接到支持此标准的模块中。第四、同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。以上几点好处，难道还不足以打动我们，让我们在项目开发过程中使用IOC框架吗？IOC容器的技术剖析IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。IOC容器的一些产品Sun ONE技术体系下的IOC容器有：轻量级的有Spring、Guice、Pico Container、Avalon、HiveMind；重量级的有EJB；不轻不重的有JBoss，Jdon等等。Spring框架作为Java开发中SSH(Struts、Spring、Hibernate)三剑客之一，大中小项目中都有使用，非常成熟，应用广泛，EJB在关键性的工业级项目中也被使用，比如某些电信业务。.Net技术体系下的IOC容器有：Spring.Net、Castle等等。Spring.Net是从Java的Spring移植过来的IOC容器，Castle的IOC容器就是Windsor部分。它们均是轻量级的框架，比较成熟，其中Spring.Net已经被逐渐应用于各种项目中。使用IOC框架应该注意什么使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。第一、软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。第二、由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。第三、具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。第四、IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，象WEB2.0网站就是这种情况。"
  },
  
  {
    "title": "Spring AOP",
    "url": "/posts/spring-aop/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "AOP（Aspect Oriented Programming），面向切面编程（也叫面向方面），是Spring框架中的内容，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。主要的功能有：日志记录，性能统计，安全控制，事务处...",
    "content": "AOP（Aspect Oriented Programming），面向切面编程（也叫面向方面），是Spring框架中的内容，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。主要的功能有：日志记录，性能统计，安全控制，事务处理，异常处理等等。什么是AOPAOP可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系。使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。OOP和AOPOOP专注于对象，我们利用对象的属性，行为来解决现实中的问题，而AOP则用来在使用OOP解决问题的过程中增强解决问题的能力，实现更好的模块化。AOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。AOP能做什么AOP可以从增强模块化以及降低切面与业务逻辑的耦合度来增强OOP程序。使用AOP可以为需要某些特定功能的对象集合增加功能而不必修改这些对象的类代码。也就是我们将与实际业务逻辑无关但是需要关注的部分提取出来通过AOP来动态的添加到业务逻辑代码中。即使这些Aspect的实现机制以及代码进行了修改，只需改动一处而不会影响原有业务逻辑代码。Spring中的AOP与同样实现AOP的AspectJ不同，AspectJ将附加功能加入到目标对象中进行编译，Spring中附加功能与目标对象是分开的，在runtime时动态增加到目标对象中。这通常是通过Proxy实现的（可以看看设计模式中的代理模式，Spring的AOP就是基于Proxy实现的）。也因为Spring没有将附加功能与目标对象混合后编译所以Spring的在为对象增加附加功能只能实现在method（方法）的级别。相当于只能在执行某个method前或之后增加特定功能，而无法在方法体内部截断并增加功能。Spring通过配置文件来随时对一系列特定的对象增加、修改或取消特定功能而使程序不受其影响，也就是说这一系列对象即使没有通过Spring的AOP增加应用的功能时也是可以正常运行的。可以理解为这一系列对象根本不知道自己是否通过AOP被增加了某些功能。AOP相关概念切面(Aspect)切面可以理解为我们程序中许多并无关联的对象、子程序所共同拥有的需要关注的方面，通常遍布于整个程序中，比如我们需要在许多代码逻辑中增加安全性保障的代码（大部分这些代码都是相同的），比如在执行一个方法前后要进行日志记录，比如在执行方法时要实现事务，保证操作的原子性等等。这些一个共同点就是我们程序中需要关注的但是与实际业务逻辑无关。在利用AOP以前，它分散于整个程序中并混杂在业务逻辑代码中，假如对于安全性考虑需要变更安全性相关代码，则需要改动大量原先混杂在业务逻辑中的安全性处理代码。类似这种需要考虑的方面我们叫他切面，也就是Aspect。切入点(PointCut)指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解，MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上。连接点(JointPoint)程序执行过程中明确的点，如方法的调用或特定的异常被抛出。通知(Advice)在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice：BeforeAdvice，AfterAdvice，ThrowAdvice和DynamicIntroductionAdvice。目标对象(Target)要使用方面功能的组件对象或被切入点表达式指定的对象，包含连接点的对象，也被称作被通知或被代理对象，POJO。动态代理对象(AutoProxy)Spring使用了AOP机制后，采用的是动态代理技术实现的，当采用了AOP之后，Spring通过getBean返回的对象是一个动态代理类型对象，当使用该对象的业务方法时，该对象会负责调用方面组件和目标组件的功能，如果未采用AOP，Spring通过getBean返回的是原始类型对象，因此执行的是原有目标对象的处理Spring动态代理技术采用的是以下两种:  采用JDK Proxy API实现(目标对象有接口定义)  采用Cglib.jar工具包API实现(目标对象没有接口定义)引入（Introduction）添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现IsModified接口，来简化缓存。Spring中要使用Introduction，可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口。AOP代理（AOP Proxy）AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。织入（Weaving）组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯JavaAOP框架一样，在运行时完成织入。AOP通知类型通知主要负责指定方面功能和目标方法功能的作用关系。Spring框架提供了以下5种类型通知：  前置通知&lt;aop:before&gt;：方面功能在目标方法之前调用  后置通知&lt;aop:after-returning&gt;：方面功能在目标方法之后调用，目标方法无异常执行  最终通知&lt;aop:after&gt;：方面功能在目标方法之后调用，目标方法有无异常都执行  异常通知&lt;aop:after-throwing&gt;：方面功能在目标方法抛出异常之后执行  环绕通知&lt;aop:around&gt;：方面功能在目标方法执行前和后调用AOP切入点表达式的指定切入点表达式用于指定哪些对象和方法调用方面功能，方法限定表达式：execution(修饰符? 返回类型 方法名(参数) throws 异常类型?)  示例1–匹配所有Bean对象中以add开头的方法execution(* add*(..))  示例2–匹配UserService类中所有的方法execution(* tarena.service.UserService.*(..))  示例3–匹配UserService类中有返回值的所有方法execution(!void tarena.service.UserService.*(..))  示例4–匹配所有Bean对象中修饰符为public，方法名为add的方法execution(public * add(..))  示例5–匹配tarena.service包下所有类的所有方法execution(* tarena.service.*.*(..))  示例6–匹配tarena.service包及其子包中所有类所有方法execution(* tarena.service..*.*(..))如何使用AOP可以通过配置文件或者编程的方式来使用Spring AOP。配置可以通过xml文件来进行，大概有四种方式：  配置ProxyFactoryBean，显式地设置advisors，advice，target等。  配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象。  通过&lt;aop:config&gt;来配置。  通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点。也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象，advisor等相关配置，最终通过getProxy()方法来获取代理对象。AOP使用示例applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xmlns:context=\"http://www.springframework.org/schema/context\"     xmlns:aop=\"http://www.springframework.org/schema/aop\"     xmlns:tx=\"http://www.springframework.org/schema/tx\"     xsi:schemaLocation=\"http://www.springframework.org/schema/beans              http://www.springframework.org/schema/beans/spring-beans-3.0.xsd             http://www.springframework.org/schema/context              http://www.springframework.org/schema/context/spring-context-3.0.xsd             http://www.springframework.org/schema/aop              http://www.springframework.org/schema/aop/spring-aop-3.0.xsd             http://www.springframework.org/schema/tx              http://www.springframework.org/schema/tx/spring-tx-3.0.xsd\"&gt;     &lt;!-- AspectJ框架 方面编程 --&gt;    &lt;bean id=\"join\" class=\"com.book.aspect.BuyJoin\"&gt;&lt;/bean&gt;    &lt;bean id=\"appleBuy\" class=\"com.book.AppleBuy\"&gt;&lt;/bean&gt;    &lt;aop:config&gt;        &lt;!-- 执行：正则表达式，匹配切入点             1、execution(* com.book.AppleBuy.*(..))  AppleBuy类内所有的方法            2、execution(* com.book.*.*(..))  com.book包下所有的类的方法内所有的方法            3、execution(* com..*.*(..))  book包下及子包下的所有方法        --&gt;        &lt;!-- 定义切入点（什么位置执行通知） --&gt;        &lt;aop:pointcut id=\"testpoint\"                 expression=\"execution(* com.book.AppleBuy.*buy*(..))\"/&gt;        &lt;!-- 定义切面（对切入点统一操作） --&gt;        &lt;aop:aspect ref=\"join\"&gt;            &lt;aop:around pointcut-ref=\"testpoint\" method=\"buy\"/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt; BuyJoin.javapackage com.book.aspect;import org.aspectj.lang.ProceedingJoinPoint;public class BuyJoin {    public void buy(ProceedingJoinPoint join) throws Throwable {        System.out.println(\"支付\");        // 买苹果的业务方法，需要用到连接点        join.proceed();        System.out.println(\"完成\");    }}  Test.javapublic class Test {    public static void main(String[] args) {        BeanFactory bf = new ClassPathXmlApplicationContext(\"applicationContext1.xml\");        IBuy o = (IBuy) bf.getBean(\"appleBuy\");        o.buy();        System.out.println(\"=========================\");        o.steal();    }} "
  },
  
  {
    "title": "如何手动获取Spring容器中的bean",
    "url": "/posts/ruhe-shoudong-huoqu-spring-rongqi-zhongde-bean/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "1、定义一个工具类，实现ApplicationContextAware，实现setApplicationContext()方法public class SpringContextUtils implements ApplicationContextAware {     private static ApplicationContext context;    @Override    pu...",
    "content": "1、定义一个工具类，实现ApplicationContextAware，实现setApplicationContext()方法public class SpringContextUtils implements ApplicationContextAware {     private static ApplicationContext context;    @Override    public void setApplicationContext(ApplicationContext context)            throws BeansException {        SpringContextUtils.context = context;    }    public static ApplicationContext getContext() {        return context;    }}如此一来，我们就可以通过该工具类，来获得ApplicationContext，进而使用其getBean()方法来获取我们需要的bean。2、在Spring配置文件中注册该工具类之所以我们能如此方便地使用该工具类来获取，正是因为Spring能够为我们自动地执行setApplicationContext()方法，显然，这也是因为IOC的缘故，所以必然这个工具类也是需要在Spring的配置文件中进行配置的。&lt;bean id=\"springContextUtils\" class=\"com.zker.common.util.SpringContextUtils\" /&gt;3、编写方法进行使用一切就绪，我们就可以在需要使用的地方调用该方法来获取bean了。public String ajaxRegister() throws IOException {    UserDao userDao = (UserDao) SpringContextUtils.getContext().getBean(\"userDao\");    if (userDao.findAdminByLoginName(loginName) != null            || userDao.findUserByLoginName(loginName) != null) {        message.setMsg(\"用户名已存在\");        message.setStatus(false);    } else {        message.setMsg(\"用户名可以注册\");        message.setStatus(true);    }    return \"register\";}  参考如何手动获取Spring容器中的bean？"
  },
  
  {
    "title": "转发和重定向的区别",
    "url": "/posts/zhuanfa-he-chongdingxiang/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "调用方式不一样转发是  ServletContext.getRequestDispatcher(url).forward(req,rops);，url只能使用绝对路径，因为ServletRequest具有相对路径的概念；而ServletContext对象无此概念。当使用绝对路径时，/代表的是Web项目，代表http://localhost:8080/项目名/。  request.getReq...",
    "content": "调用方式不一样转发是  ServletContext.getRequestDispatcher(url).forward(req,rops);，url只能使用绝对路径，因为ServletRequest具有相对路径的概念；而ServletContext对象无此概念。当使用绝对路径时，/代表的是Web项目，代表http://localhost:8080/项目名/。  request.getRequestDispatcher(url).forward(req,rops);，url可以使用相对路径。  &lt;jsp:forward page=\"welcome.jsp\"&gt;&lt;/jsp:forward&gt;。重定向是response.sendRedirect(url);浏览器地址栏是否发生变化转发不发生变化，重定向会发生变化。参数的传递方式不一样重定向response.sendRedirect(url)跳转到指定的URL地址，产生一个新的Request，所以要传递参数只有在URL后加参数，如：url?id=1。转发request.getRequestDispatcher(url).forward(request, response)是直接将请求转发到指定URL，所以该请求能够直接获得上一个请求的数据，也就是说采用请求转发，Request对象始终存在，不会重新创建。行为对象不一样转发是服务器的行为，重定向是客户端浏览器的行为。"
  },
  
  {
    "title": "关于Servlet",
    "url": "/posts/shenmeshi-servlet/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "什么是ServletJava Servlet是运行在Web服务器或应用服务器上的程序，它是作为来Web浏览器或其他Http客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。使用Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Servlet是一个Java编写的程序，此程序是基于Http协议的，在服务器端运行的。是按照Servle...",
    "content": "什么是ServletJava Servlet是运行在Web服务器或应用服务器上的程序，它是作为来Web浏览器或其他Http客户端的请求和HTTP服务器上的数据库或应用程序之间的中间层。使用Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。Servlet是一个Java编写的程序，此程序是基于Http协议的，在服务器端运行的。是按照Servlet规范编写的一个Java类。Java Servlet通常情况下与使用CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。Servlet怎么处理一个请求当用户发送一个请求到某个Servlet的时候，Servlet容器会创建一个ServletRequst和ServletResponse对象。在ServletRequst对象中封装了用户的请求信息，然后Servlet容器把ServletRequst和ServletResponse对象传给用户所请求的Servlet，Servlet把处理好的结果写在ServletResponse中，然后Servlet容器把响应结果传给用户。Servlet与JSP有什么区别JSP经编译后就是Servlet，也可以说JSP等于Servlet。JSP更擅长页面（表现）。Servlet更擅长逻辑编辑（最核心的区别）。在实际应用中采用Servlet来控制业务流程，而采用JSP来生成动态网页。在Struts框架中，JSP位于MVC设计模式的视图层，而Servlet位于控制层。"
  },
  
  {
    "title": "Servlet四大域中的值的获取方式",
    "url": "/posts/servlet-zhong-4dayu-zhongde-zhi-de-huoqu-fangshi/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "PageContextPageContent是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。常用方法：getAttribute(String name); // 取得page范围内的name属性 getAttribute(String name, int scope); // 取得指定范围内的name属性...",
    "content": "PageContextPageContent是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。常用方法：getAttribute(String name); // 取得page范围内的name属性 getAttribute(String name, int scope); // 取得指定范围内的name属性其中scope可以是如下4个值PageContext.PAGE_SCOPE // 对应于page范围PageContext.REQUEST_SCOPE // 对应于request范围PageContext.SESSION_SCOPE // 对应于session范围PageContext.APPLICATION_SCOPE // 对应于application范围RequestRequest是表示一个请求，只要发出一个请求就会创建一个Request，它的作用域仅在当前请求中有效。常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。常用方法：request.setAttribute();request.getAttribute();request.removeAttribute();request.getParameter();Session服务器会为每个会话创建一个Session对象，所以Session中的数据可供当前会话中所有Servlet共享会话，用户打开浏览器会话开始，直到关闭浏览器会话才会结束，一次会话期间只会创建一个Session对象。常用于Web开发中的登陆验证界面（当用户登录成功后浏览器分配其一个Session键值对）。常用方法：session.setAttribute();session.getAttribute();session.removeAttribute();获得Session对象方法：（1）在Servlet中：HttpSession session = request.getSession();（2）由于Session属于JSP九大内置对象之一，当然可以直接使用，例如：&lt;%session.serAttribute(\"name\", \"admin\")%&gt;备注：Session是服务器端对象，保存在服务器端，并且服务器可以将创建Session后产生的sessionid通过一个Cookie返回给客户端以便下次验证，Session底层依赖于Cookie。Application（ServletContext）Application属性范围值只要设置一次，则所有的网页窗口都可以取得数据，ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象。获取Application对象方法（Servlet中）：ServletContext app01 = this.getServletContext();app01.setAttribute(\"name\", \"kaixuan\"); // 设置一个值进去ServletContext app02 = this.getServletContext();app02.getAttribute(\"name\"); // 获取键值对ServletContext同属于JSP九大内置对象之一，故可以直接使用。备注：服务器只会创建一个ServletContext对象，所以app01就是app02，通过app01设置的值当然可以通过app02获取。"
  },
  
  {
    "title": "Servlet如何使用Cookie",
    "url": "/posts/servlet-ruhe-shihyong-cookie/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-13 13:47:00 +0800",
    





    
    "snippet": "/** 创建Cookie */// 键值形式创建CookieCookie cookie = new Cookie(\"temp\", tempData);// 设置Cookie的存活时间为秒cookie.setMaxAge(60 * 60 * 24);// 写入客户端硬盘response.addCookie(cookie);/** 调用Cookie */// 将目录下所有Cookie读入并存入C...",
    "content": "/** 创建Cookie */// 键值形式创建CookieCookie cookie = new Cookie(\"temp\", tempData);// 设置Cookie的存活时间为秒cookie.setMaxAge(60 * 60 * 24);// 写入客户端硬盘response.addCookie(cookie);/** 调用Cookie */// 将目录下所有Cookie读入并存入Cookies数组中Cookie cookies[] = request.getCookies();Cookie sCookie = null;if (cookies != null) {    // 循环列出所有可用的Cookie    for(int i = 0; i &lt; cookies.length; i++) {        sCookie = cookies[i];        String sname = sCookie.getName();        String name = sCookie.getValue();    }}"
  },
  
  {
    "title": "Spring核心组件",
    "url": "/posts/spring-de-hexin-zujian/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-12 13:47:00 +0800",
    





    
    "snippet": "核心容器（Spring Core）核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。应用上下文（Spring Context）Spring上下文是一个配置...",
    "content": "核心容器（Spring Core）核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。应用上下文（Spring Context）Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。面向切面编程（Spring AOP）通过配置管理特性，Spring AOP模块直接将面向方面的编程功能集成到了Spring框架中。所以，可以很容易地使Spring框架管理的任何对象支持AOP。Spring AOP模块为基于 Spring的应用程序中的对象提供了事务管理服务。通过使用Spring AOP，不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。JDBC和DAO模块（Spring DAO）JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。对象实体映射（Spring ORM）Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。Web模块（Spring Web）Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。MVC模块（Spring Web MVC）MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。"
  },
  
  {
    "title": "ContextLoaderListener的作用",
    "url": "/posts/ContextLoaderListener-de-zuoyong/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-12 13:47:00 +0800",
    





    
    "snippet": "ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。如何部署ApplicationContext的XML文件。如果在web.xml中不写任何参数配置信息，默认的路径是/WEB-I...",
    "content": "ContextLoaderListener监听器的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。如何部署ApplicationContext的XML文件。如果在web.xml中不写任何参数配置信息，默认的路径是/WEB-INF/applicationContext.xml，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml；如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数：&lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;            /WEB-INF/classes/applicationContext-*.xml         &lt;/param-value&gt;  &lt;/context-param&gt;  在&lt;param-value&gt;&lt;/param-value&gt;里指定相应的XML文件名，如果有多个XML文件，可以写在一起并以,号分隔。上面的applicationContext-*.xml采用通配符，比如这目录下有applicationContext-ibatis-base.xml,applicationContext-action.xml,applicationContext-ibatis-dao.xml等文件，都会一同被载入。由此可见applicationContext.xml的文件位置就可以有两种默认实现：  第一种：直接将之放到/WEB-INF下，之后在web.xml中声明一个Listener；      第二种：将之放到classpath下，但是此时要在web.xml中加入&lt;context-param&gt;，用它来指明你的applicationContext.xml的位置以供web容器来加载。按照Struts2整合spring的官方给出的档案，写成：      &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;          /WEB-INF/applicationContext-*.xml,classpath*:applicationContext-*.xml      &lt;/param-value&gt;   &lt;/context-param&gt;      配置示例&lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;  &lt;!-- 注册Spring提供的Servlet --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;disptcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;disptcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/testDisServlet.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;注册Spring提供的Servlet时init-param从context-param指定的applicationContext.xml文件路径读取配置信息。 "
  },
  
  {
    "title": "Spring的字符编码过滤器",
    "url": "/posts/spring-de-zifubianma-guolvqi/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-09 13:47:00 +0800",
    





    
    "snippet": "&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;     ...",
    "content": "&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;"
  },
  
  {
    "title": "WebLogic新建JNDI数据源",
    "url": "/posts/weblogic-xinjian-jndi-shujuyuan/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "新建Oracle数据源进入Weblogic管理控制台，点击左侧【域结构】→【base domain】→【服务】→【数据源】，然后点击右侧【新建】→【一般数据源】，如下图所示：填写JDBC数据源的【名称】、【JNDI名称】，选择数据库类型，如选择【Oracle】,下一步：选择Oracle数据库的驱动程序，如下图所示：这里选择【Oracle’ s Driver （Thin）for Instanc...",
    "content": "新建Oracle数据源进入Weblogic管理控制台，点击左侧【域结构】→【base domain】→【服务】→【数据源】，然后点击右侧【新建】→【一般数据源】，如下图所示：填写JDBC数据源的【名称】、【JNDI名称】，选择数据库类型，如选择【Oracle】,下一步：选择Oracle数据库的驱动程序，如下图所示：这里选择【Oracle’ s Driver （Thin）for Instance connections;Version:Any】，点击【下一步】按钮，进入下一个配置步骤：这里使用默认配置即可 ，点击【下一步】按钮，进入下一个配置步骤，如下图所示，填写数据库的连接信息：要连接的数据库，数据库的IP地址，连接数据库时使用的端口号，登录数据库时使用的用户名和密码点击【下一步】按钮，进入下一个配置步骤：如下图所示：点击【完成】，这样WebLogic就会创建一个新的JDBC数据源，如下图所示：到此，在WebLogic新建针对Oracle数据库的JNDI数据源就算是全部完成了。数据源创建之后，我们就可以在应用程序中使用数据源了。新建MySQL数据源配置步骤和针对Oracle数据库创建的JDBC数据源大部分是一样的，针对不一样的地方给出如下的截图说明：到此，在WebLogic新建针对MySQL数据库的JNDI数据源就算是全部完成了。"
  },
  
  {
    "title": "WebLogic生产模式免用户名密码启动",
    "url": "/posts/weblogic-shengchanmoshi-mianyonghuming-mima-qidong/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "在user_projects\\domains\\base_domain\\servers\\AdminServer\\security路径下创建boot.properties文件。#Tue Jun 25 16:03:48 CST 2019password=weblogicusername= weblogic123启动之后Weblogic会将该文件中的用户名和密码加密。#Tue Jun 25 16:0...",
    "content": "在user_projects\\domains\\base_domain\\servers\\AdminServer\\security路径下创建boot.properties文件。#Tue Jun 25 16:03:48 CST 2019password=weblogicusername= weblogic123启动之后Weblogic会将该文件中的用户名和密码加密。#Tue Jun 25 16:03:48 CST 2019password={AES}nJ5pDEJUQFWxKHzz4kwiVW2DFqFCnDhW/wHzsPgYt7o\\=username={AES}yjpymx0snt+AZhAxDv7PtBVkS8p4ms03YHbvsJRNjdQ\\=如果需要修改启动Weblogic的密码，只需修改该文件的内容即可。"
  },
  
  {
    "title": "WebLogic启动命令",
    "url": "/posts/weblogic-qidong-mingling/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "WebLogic启动server命令[root@lbogon roy]# nohup ./startWebLogic.sh &gt;out.log 2&gt;&amp;1 &amp; ",
    "content": "WebLogic启动server命令[root@lbogon roy]# nohup ./startWebLogic.sh &gt;out.log 2&gt;&amp;1 &amp; "
  },
  
  {
    "title": "WebLogic静默创建域",
    "url": "/posts/weblogic-jingmo-chuangjian-yu/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "进入路径cd /weblogic/oracle/middleware/wlserver/common/bin静默创建域./config.sh -mode=silent -silent_script=/home/app_admin/weblogic_ins/create_domain.rsp -logfile=/home/app_admin/weblogic/create_domain.log...",
    "content": "进入路径cd /weblogic/oracle/middleware/wlserver/common/bin静默创建域./config.sh -mode=silent -silent_script=/home/app_admin/weblogic_ins/create_domain.rsp -logfile=/home/app_admin/weblogic/create_domain.logcreate_domain.rsp文件内容read template from \"/home/app_admin/weblogic/Oracle/Middleware/wlserver/common/templates/wls/wls.jar\"; set JavaHome \"/home/app_admin/jdk1.8.0_144\"; set ServerStartMode \"prod\"; find Server \"AdminServer\" as AdminServer;set AdminServer.ListenAddress \"\";set AdminServer.ListenPort \"7001\";//set AdminServer.SSL.Enabled \"true\";//set AdminServer.SSL.ListenPort \"7002\"; //We can directly create a new managed server.create Server \"VM-YDYWJYSL01\" as BASE;//set BASE.ListenAddress \"\";//set BASE.ListenPort \"8003\";//set BASE.SSL.Enabled \"true\";//set BASE.SSL.ListenPort \"8004″; //Create Machine//create Machine \"base\" as Machinename; //use templates default weblogic userfind User \"weblogic\" as u1;set u1.password \"weblogic123\"; //create a new user//create User \"weblogic\" as u1;//set u1.password \"weblogic123\"; write domain to \"/home/app_admin/weblogic/Oracle/Middleware/user_project/domains/base_domain/\";  // The domain name will be \"demo-domain\" close template;注意  ServerStartMode，dev为开发模式，prod为生产模式  AdminServer.ListenAddress为空默认是本机IP  SSL端口7002根据实际选择打开还是关闭  Machinename是主机名"
  },
  
  {
    "title": "WebLogic静默安装",
    "url": "/posts/weblogic-jingmo-anzhuang/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "前期准备新建用户组web[root@edwcube3 ~]# groupadd web新建用户weblogic并修改用户密码# 添加用户，并用-g参数来制定 web用户组[root@edwcube3 ~]# useradd -g web weblogic # passwd命令修改密码[root@edwcube3 ~]# passwd weblogic Changing password fo...",
    "content": "前期准备新建用户组web[root@edwcube3 ~]# groupadd web新建用户weblogic并修改用户密码# 添加用户，并用-g参数来制定 web用户组[root@edwcube3 ~]# useradd -g web weblogic # passwd命令修改密码[root@edwcube3 ~]# passwd weblogic Changing password for user weblogic.New UNIX password:Retype new UNIX password:passwd: all authentication tokens updated successfully.安装JDK。可以不安装JDK，直接在响应文件中指定JDK位置。开始安装首先看命令的格式java -jar wls_121200.jar -silent -responseFile file -invPtrLoc file# -response file：响应文件# -invPtrLoc file：初始化环境文件创建响应文件wls.rsp，响应文件中的项一定要写全，否则会报参数不足等错误[ENGINE]#DO NOT CHANGE THIS.Response File Version=1.0.0.0.0[GENERIC]#The oracle home location. This can be an existing Oracle Home or a new Oracle HomeORACLE_HOME=/home/weblogic#Set this variable value to the Installation Type selected. e.g. WebLogic Server, Coherence, Complete with Examples.INSTALL_TYPE=WebLogic Server#Provide the My Oracle Support Username. If you wish to ignore Oracle Configuration Manager configuration provide empty string for user name.MYORACLESUPPORT_USERNAME=#Provide the My Oracle Support PasswordMYORACLESUPPORT_PASSWORD=&lt;SECURE VALUE&gt;#Set this to true if you wish to decline the security updates. Setting this to true and providing empty string for My Oracle Support username will ignore the Oracle Configuration Manager configurationDECLINE_SECURITY_UPDATES=true#Set this to true if My Oracle Support Password is specifiedSECURITY_UPDATES_VIA_MYORACLESUPPORT=false#Provide the Proxy HostPROXY_HOST=#Provide the Proxy PortPROXY_PORT=#Provide the Proxy UsernamePROXY_USER=#Provide the Proxy PasswordPROXY_PWD=&lt;SECURE VALUE&gt;#Type String (URL format) Indicates the OCM Repeater URL which should be of the format [scheme[Http/Https]]://[repeater host]:[repeater port]COLLECTOR_SUPPORTHUB_URL=创建初始化环境文件文件oraInst.locinventory_loc=/home/weblogic/oraInventoryinst_group=weblogic保证所需要的目录weblogic用户要用读写权限，/ghca/bea文件用户weblogic必须要有读写权限，oraInst.loc，wls.rsp，fmw_12.1.3.0.0_wls.jar文件用户weblogic必须要有读写权限。安装 wls.rsp，oraInst.loc必须指定绝对路径java -jar fmw_12.1.3.0.0_wls.jar -silent -responseFile /home/weblogic/wls.rsp -invPtrLoc /home/weblogic/oraInst.loc启动程序日志文件为/tmp/OraInstall2016-12-07_11-28-48AM/launcher2016-12-07_11-28-48AM.log。正在提取文件........Java HotSpot(TM) Server VM warning: You have loaded library /tmp/orcl3700411247043593693.tmp/Disk1/install/linux/libjni.so which might have disabled stack guard. The VM will try to fix the stack guard now.It's highly recommended that you fix the library with 'execstack -c &lt;libfile&gt;', or link it with '-z noexecstack'.启动 Oracle Universal Installer检查 CPU 速度是否大于 300 MHz。 实际为 2128.009 MHz 通过检查交换空间: 必须大于 512 MB。 实际为 8388604 MB 通过检查此平台是否需要 64 位 JVM。 实际为32 通过 (不需要 64 位)检查临时空间: 必须大于 300 MB。 实际为 3559 MB 通过准备从/tmp/OraInstall2016-12-07_11-28-48AM启动 Oracle Universal InstallerJava HotSpot(TM) Server VM warning: ignoring option MaxPermSize=512m; support was removed in 8.0 ---可忽略日志:/tmp/OraInstall2016-12-07_11-28-48AM/install2016-12-07_11-28-48AM.log版权所有 (c) 1996, 2014, Oracle 和/或其附属公司。保留所有权利。正在读取响应文件...开始检查: CertifiedVersions预期的结果: enterprise-4,enterprise-5,enterprise-6,redhat-6,redhat-4,redhat-5,SuSE-11之一实际结果: (未知操作系统版本)检查完成。此次检查的总体结果为: 未通过 &lt;&lt;&lt;&lt; 可忽略问题: 此 Oracle 软件未经当前操作系统认证。建议案: 确保在正确的平台上安装软件。警告: 检查:CertifiedVersions 失败。开始检查: CheckJDKVersion预期的结果: 1.7.0_15实际结果: 1.8.0_111检查完成。此次检查的总体结果为: 通过  CheckJDKVersion 检查: 成功。已启用此会话的验证。正在验证数据...正在复制文件...可以在以下位置找到本次安装会话的日志:/tmp/OraInstall2016-12-07_11-28-48AM/install2016-12-07_11-28-48AM.log-----------20%----------40%----------60%----------80%--------100%Oracle Fusion Middleware 12c WebLogic Server 和 Coherence 12.1.3.0.0 的 安装 已成功完成。日志已成功复制到/home/weblogic/oraInventory/logs。打印此信息，说明weblogic安装成功了。"
  },
  
  {
    "title": "WebLogic集成到Eclipse",
    "url": "/posts/weblogic-jichengdao-eclipse/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "集成Weblogic其实和集成Tomcat操作基本是一样的（不过由于可能适配包不支持最新的weblogic12所以我新装了jdk1.7和weblogic10.3.6来演示。选择接受协议后开始安装适配包，由于网络问题安装比较慢，没有东西弹出来但在Eclipse右下角会有安装进度。选择重启Eclipse，重启后再次按前边步骤进到下图界面。可以看到Weblogic已成功添加，直接点击“Apply ...",
    "content": "集成Weblogic其实和集成Tomcat操作基本是一样的（不过由于可能适配包不支持最新的weblogic12所以我新装了jdk1.7和weblogic10.3.6来演示。选择接受协议后开始安装适配包，由于网络问题安装比较慢，没有东西弹出来但在Eclipse右下角会有安装进度。选择重启Eclipse，重启后再次按前边步骤进到下图界面。可以看到Weblogic已成功添加，直接点击“Apply and Close”。但现在我们并没有指定domain目录所以下边还得指定domain。在图中标签中展出“Known Domains”，然后在其中选择我们前边创建的base_domain。可以看到检测报错The server is invalid. Error occurred reading server credential. Required file or directory 'servers/AdminServer/security/boot.properties' cannot be found.，意思是在domain目录中找不到servers/AdminServer/security/boot.properties，这是Weblogic启动需要的用户密码文件，默认没有这个文件，也没有servers/AdminServer/security目录，所以我们进入domain主目录（我这里是D:\\Oracle\\Middleware\\user_projects\\domains\\base_domain），然后创建servers/AdminServer/security目录并在该目录下创建boot.properties文件，最后用记事本打开boot.properties，在其中写入前边创建domain时指定的用户名密码并保存，比如我这里是：先点Back返回上一步再点Next返回来，就不会有报错。我们这里由于什么都没配，所以没有资源，直接点“Finish”即可。这意思是boot.properties中还是明文密码这样不安全，不管他直接选“No”即可，使用一个项目测试可以看到Weblogic可正常服务。"
  },
  
  {
    "title": "WebLogic安装和部署",
    "url": "/posts/weblogic-anzhuang-he-bushu/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "安装Weblogic双击安装文件启动安装程序，在安装首页面点击下一步按钮。创建中间件主目录，建议路径为：D:\\OracleMiddleware，点击下一步按钮。设置安全更新账户，此处跳过，点击下一步按钮。选择安装类型，此处我们选择典型，点击下一步按钮。选择产品安装目录，点击下一步按钮。设置快捷方式位置，此处我们选择“所有用户”，点击下一步按钮。安装概要确认，点击下一步按钮。进行正式安装，等待...",
    "content": "安装Weblogic双击安装文件启动安装程序，在安装首页面点击下一步按钮。创建中间件主目录，建议路径为：D:\\OracleMiddleware，点击下一步按钮。设置安全更新账户，此处跳过，点击下一步按钮。选择安装类型，此处我们选择典型，点击下一步按钮。选择产品安装目录，点击下一步按钮。设置快捷方式位置，此处我们选择“所有用户”，点击下一步按钮。安装概要确认，点击下一步按钮。进行正式安装，等待完成，此过程切勿退出。配置域安装成功后，提示弹出配置向导，此处我们选择“创建新的Weblogic域”，点击下一步按钮。设置域类型，此处我们选择“Basic…”，点击下一步按钮。指定域名和位置，此处我们以base_domain举例，域位置默认为D:\\OracleMiddleware\\user_projects\\domains目录，点击下一步按钮。配置管理员用户名和口令，此处建议管理员名称/密码为weblogic/admin，点击下一步按钮。设置开发模式，此处建议选择可用JDK内的JRocket SDK，以防止Console发布崩溃的问题出现，点击下一步按钮。进行可选配置，此处勾选“管理服务器”，点击下一步按钮。配置管理服务器，此处ListenPort可以根据自己偏好进行设置，建议初次建立时不要调整，点击下一步按钮。配置概要预览，进行二次确认后，如无问题点击创建按钮。安装完成，此处会提示域位置以及管理服务器访问地址，点击完成按钮。运行OracleMiddleware\\user_projects\\domains\\picc_domain\\bin\\startWebLogic.cmd，在浏览器输入：http://localhost:7001/console访问控制台。"
  },
  
  {
    "title": "JWT",
    "url": "/posts/jwt/",
    "categories": "Knowledge, JWT",
    "tags": "JWT",
    "date": "2021-07-07 13:47:00 +0800",
    





    
    "snippet": "什么是JWTJson web token (JWT)， 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。该Token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该Token也可直接...",
    "content": "什么是JWTJson web token (JWT)， 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。该Token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该Token也可直接被用于认证，也可被加密。JWT的组成第一部分称为头部（header)，第二部分称为载荷（payload)，第三部分是签证（signature)。      header    JWT的头部承载两部分信息：声明类型，这里是JWT；声明加密的算法，通常直接使用HMAC SHA256，完整的头部就像下面这样的JSON：      {      \"typ\": \"JWT\",      \"alg\": \"HS256\"  }        然后将头部进行BASE64加密（该加密是可以对称解密的），构成了第一部分。      eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9            playload    载荷就是存放有效信息的地方：标准中注册的声明、公共的声明、私有的声明。                  标准中注册的声明（建议但不强制使用）          iss: JWT签发者  sub: JWT所面向的用户  aud: 接收JWT的一方  exp: JWT的过期时间，这个过期时间必须要大于签发时间  nbf: 定义在什么时间之前，该JWT都是不可用的.  iat: JWT的签发时间  jti: JWT的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。                            公共的声明        公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的信息，但不建议添加敏感信息，因为该部分在客户端可解密。                    私有的声明        私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为BASE64是对称解密的，意味着该部分信息可以归类为明文信息。这个指的就是自定义的声明。这些声明跟JWT标准规定的声明区别在于：JWT规定的声明，JWT的接收方在拿到JWT之后，都知道怎么对这些标准的声明进行验证；而私有的声明不会验证，除非明确告诉接收方要对这些声明进行验证以及规则才行。              定义一个payload      {      \"sub\": \"1234567890\",      \"name\": \"John Doe\",      \"admin\": true  }        然后将其进行BASE64加密，得到Jwt的第二部分。      eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9            signature    JWT的第三部分是一个签证信息，这个签证信息由三部分组成：      header (BASE64后的)  payload (BASE64后的)  secret        这个部分需要BASE64加密后的header和BASE64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行组合加密，然后就构成了JWT的第三部分。      // javascript  var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);  var signature = HMACSHA256(encodedString, 'secret');   // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ      将这三部分用.连接成一个完整的字符串，构成了最终的JWT:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ注意：secret是保存在服务器端的，JWT的签发生成也是在服务器端的，secret就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发JWT了。JWT有什么好处  支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。  无状态(也称：服务端可扩展行): Token机制在服务端不需要存储Session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的Cookie或本地介质存储状态信息。  更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：JavaScript，HTML，图片等），而你的服务端只要提供API即可。  去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可。  更适用于移动应用: 当你的客户端是一个原生平台（iOS，Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。  CSRF: 因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。一般建议使用：1、在HTTP请求中以参数的形式加入一个服务器端产生的token，或者，2、放入http请求头中也就是一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。  性能: 一次网络往返时间（通过数据库查询Session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。  不需要为登录页面做特殊处理: 如果你使用Protractor做功能测试的时候，不再需要为登录页面做特殊处理。  基于标准化:你的API可以采用标准化的JSON Web Token (JWT)。这个标准已经存在多个后端库（.NET，Ruby，Java，Python，PHP）和多家公司的支持（如：FireBASE，Google，Microsoft）。Java中的实现在Java的实现中可以有两种方式，一种是不借助第三方jar，自己生成token，另一种的借助第三方jar，传入自己需要的负荷信息，生成token。      自己生成Token    header和poyload的组成都是JSON字符串，所以先创建头部的JSON，然后用BASE64编码org.apache.axis.encoding.Base64。然后再创建负荷的JSON，然后也同样用BASE64编码，这样就生成了两个字符串，然后用.拼接到一起就形成了现在的形式eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0。接下来对上边拼接成的字符串进行HS256的算法加密生成sign签名，这里需要自己手动去写一个类，然后提供一个静态方法供外界的调用，类的实现代码如下：     import javax.crypto.Mac;   import javax.crypto.spec.SecretKeySpec;   import org.apache.commons.codec.binary.Base64;   public class HS256 {       public static String returnSign(String message) {           String hash = \"\";           // 别人篡改数据，但是签名的密匙是在服务器存储，         // 密匙不同，生成的sign也不同。           // 所以根据sign的不同就可以知道是否篡改了数据。           String secret = \"mystar\"; // 密匙           try {               Mac sha256_HMAC = Mac.getInstance(\"HmacSHA256\");               SecretKeySpec secret_key = new SecretKeySpec(secret.getBytes(),                                       \"HmacSHA256\");               sha256_HMAC.init(secret_key);               hash = Base64.encodeBase64String(sha256_HMAC                                         .doFinal(message.getBytes()));               System.out.println(message + \"#####\" + hash);           } catch (Exception e) {               System.out.println(\"Error\");           }           return hash;       }   }          这样Token的三部分就生成了，然后当做参数传到前台，用Cookie存储就可以在同一客户端调用了。当从客户端带过来Token参数的时候，直接对头部和负荷再次调用加密算法，看生成的新的签名和之前的签名是否一致，判断数据是否被篡改。        借用第三方的jar(jjwt-0.7.0.jar)生成token      public static String createJWT(String py) {      System.out.println(\"负荷的值：\" + py);      SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;      // 此处就是服务器定义的自己的秘钥      String authJJm = PropertiesUtil.getValue(\"authJm\");      byte[] apiKeySecretBytes = DatatypeConverter.parseBase64Binary(authJm);      Key signingKey = new SecretKeySpec(apiKeySecretBytes,                                   signatureAlgorithm.getJcaName());      JwtBuilder builder = Jwts.builder()          .setHeaderParam(\"typ\", \"JWT\")          .setHeaderParam(\"alg\", \"HS256\")          .setPayload(py) // 负荷          .signWith(signatureAlgorithm, signingKey); // 部分签名，用HS256加密      return builder.compact();  }        调用这个方法会自动对header和poyload进行BASE64的编码，用的是jar包自带的io.jsonwebtoken.impl.Base64Codec，跟自己生成Token时，用的BASE64的jar不一样，自己在此列出来：      public static void main(String[] args) {          JSONObject json_header = new JSONObject();        json_header.put(\"typ\", \"JWT\"); // 类型        json_header.put(\"alg\", \"HS256\"); // 加密算法        String header = Base64Codec.BASE64URL.encode(json_header.toString()        .getBytes());        String aa = Base64Codec.BASE64URL.decodeToString(header);        System.out.println(header + \"--\" + aa);    }          接着上边createJWT()方法说，只要把自己定义的负荷JSON串当做参数传入就行，并且签名也会对应的生成，返回一个完整的Token。在测试的过程中，发现即使自己不定义Token的头部，也会自动生成header，只是里边没有typ这样的参数定义，只有HS256，这里源码里边，默认了alg的value。这样执行完，把生成的Token就当做参数传到前台，存储在Cookie里边。然后再说一下，前台带过来Token参数时候，怎么处理，看代码：      public static Claims parseJWT(String jwt) {      // 秘钥，跟生成Token时对应一致      String authJm = PropertiesUtil.getValue(\"authJm\");       if (jwt.split(\"\\\\.\").length == 3) {          String head = jwt.split(\"\\\\.\")[0]; // 头部          String payload = jwt.split(\"\\\\.\")[1]; // 负荷          // System.out.println(Base64Codec.BASE64URL.decodeToString(payload));          String sign = jwt.split(\"\\\\.\")[2]; // 签名          JwsHeader claims1 = Jwts.parser().setSigningKey(DatatypeConverter                          .parseBase64Binary(authJm))                          .parseClaimsJws(jwt).getHeader(); // 头部信息          System.out.println(\"头部：\" + claims1.toString());          Claims claims = Jwts.parser().setSigningKey(DatatypeConverter                          .parseBase64Binary(authJm))                          .parseClaimsJws(jwt).getBody(); // 负荷信息          // 传入负荷，再次调用返回签名，看是否一致          String sign_new = createJWT(JSONObject.toJSONString(claims))                                          .split(\"\\\\.\")[2];           if (sign_new.equals(sign)) {              System.out.println(\"匹配一致，数据没有篡改\");          }          return claims;      } else {          return null;      }  }        这个过程的原理跟自己生成Token判断原理一样，都是重新生成sign，只是一个是调用自己的方法，另外一个是调用第三方的方法。  Token过期时间这个相对来说不是太复杂，可以在负荷里边多带一个参数，把过期时间放进去，其实里边有一个exp标签名就是存储过期时间字段的，存储的是时间戳。// 存储long nowMillis = System.currentTimeMillis();long expMillis = nowMillis + 1000*2; // 设置Token 2秒过期// 获取Date aa = new Date(Long.parseLong(claims.get(\"aa\").toString()));可以存储一个生成Token时间和Token过期时间，然后服务器接收到的时候，可以根据当前的时间去判断。当前时间大于Token生成时间并且小于Token过期时间的情况下，继续走接下来的业务操作。  参考基于Token的WEB后台认证机制【JWT】JWT+HA256加密 Token验证JSON Web Token - 在Web应用间安全地传递信息"
  },
  
  {
    "title": "Git命令及其影响",
    "url": "/posts/git-mingling-huizong/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-07-06 13:47:00 +0800",
    





    
    "snippet": "本地仓库            行为      命令      备注                  初始化      git init      在本地的当前目录里初始化git仓库              拉取远程仓库      git clone 地址      从网络上某个地址拷贝仓库(repository)到本地              查看当前状态      git stat...",
    "content": "本地仓库            行为      命令      备注                  初始化      git init      在本地的当前目录里初始化git仓库              拉取远程仓库      git clone 地址      从网络上某个地址拷贝仓库(repository)到本地              查看当前状态      git status      查看当前仓库的状态              查看不同      git diff      查看当前状态和最新的commit之间不同的地方                     git diff 版本号1 版本号2      查看两个指定的版本之间不同的地方。这里的版本号指的是commit的hash值              添加文件      git add -A      在commit之前要先add              撤回stage的东西      git checkout – .      这里用英文句号表示撤回所有修改              提交      git commit -m “提交信息”      提交信息最好能体现更改了什么              删除未tracked      git clean -xf      删除当前目录下所有没有track过的文件。不管它是否是.gitignore文件里面指定的文件夹和文件              查看提交记录      git log      查看当前版本及之前的commit记录                     git reflog      查看HEAD的变更记录              版本回退      git reset –hard 版本号      回退到指定版本号的版本，该版本之后的修改都被删除。同时也是通过这个命令回到最新版本。需要reflog配合      远程仓库            行为      命令      备注                  设置用户名      git config –global user.name “你的用户名”                     设置邮箱      git config –global user.email “你的邮箱”                     生成ssh key      ssh-keygen -t rsa -C “你的邮箱”                     添加远程仓库      git remote add origin 你复制的地址      设置origin              上传并指定默认      git push -u origin master      指定origin为默认主机，以后push默认上传到origin上              提交到远程仓库      git push      将当前分支增加的commit提交到远程仓库              从远程仓库同步      git pull      在本地版本低于远程仓库版本的时候，获取远程仓库的commit      可以用一张图直观地看出以上主要的命令对仓库的影响。对照查看两张图：  Workspace：即工作区，逻辑上是本地计算机，还没添加到repository的状态；  Staging：即版本库中的stage，是暂存区。修改已经添加进repository，但还没有作为commit提交，类似于缓存；  Local repository：即版本库中master那个地方。到这一步才算是成功生成一个新版本；  Remote repository：则是远程仓库。用来将本地仓库上传到网络，可以用于备份、共享、合作。"
  },
  
  {
    "title": "Git本地仓库的使用",
    "url": "/posts/git-bendi-cangku-de-shiyong/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-07-06 13:47:00 +0800",
    





    
    "snippet": "新仓库初始化运行git init来初始化仓库它会创建一个隐藏的文件夹.git文件的添加和提交在这个文件夹里面创建一个today.txt的文件。这时使用git status来查看有什么变化。它告诉我有一个还未追踪的文件，并提示我可以使用git add &lt;file&gt;...把它加进去，执行git add -A，再次使用git status。状态变了，说明add成功。再看看它的提示Cha...",
    "content": "新仓库初始化运行git init来初始化仓库它会创建一个隐藏的文件夹.git文件的添加和提交在这个文件夹里面创建一个today.txt的文件。这时使用git status来查看有什么变化。它告诉我有一个还未追踪的文件，并提示我可以使用git add &lt;file&gt;...把它加进去，执行git add -A，再次使用git status。状态变了，说明add成功。再看看它的提示Changes to be committed，也就是说现在可以执行commit了。注意，只有被add到暂存区的更新才会被提交进入repo。提交前，如果对WorkSpace的文件进行修改，而没有被添加到暂存区，那么提交进repo中的只是暂存区的更新，WorkSpace修改的部分不会提交进repo中的。执行git commit -m \"提交信息\"将文件提交到repository里。提交信息用英文的双引号括起来。这时运行git log就可以看到提交的记录了，git log显示内容依次是：  此次提交对应的版本号  提交人：姓名 邮箱  提交的时间  提交版本修改的内容：就是我们commit -m \"xxx\"里的xxx文件的修改接着修改文件内容。我们用git status看看有什么变化。这和之前的提示不一样了。之前是这个。比较一下就会看到，之前的是添加新文件，当时文件还没被追踪（untracked），而这次是更改已经追踪（tracked）的文件。现在我们通过git看看文件做了哪些变化，执行git diff它默认跟最新的一个commit进行比较。红色（前面有减号-）表示删除，绿色（前面有加号+）表示添加。因此，在git看来，我们是删除了原来那一行，并添加了新的两行。这在文件内容特别多的时候效果比较明显。当然，我们也可以把WorkSpace中的状态和repo中的状态进行diff，命令如下：git diff HEAD~n，这个命令在以下情况可以使用：  你忘记改了什么，又想知道。  别人发给你新版本，你想知道更改了什么。假如我现在想撤销这些更改，执行git checkout -- .（git add之前）就行了。执行git status看看，上一个status的提示已经不见了。再来看看文件，已经复原了，那么再次进行修改。git add -Agit commit -m \"将[自己]改为[米娜桑]\"用git log看看提交（commit）记录。现在有两个提交了。版本回退现在试着将文件回退到第一个commit时的状态。从刚才的git log我们看到两行黄色部分是以commit开头的，后面接着一串字符。这一串字符是16进制的数，是一串哈希值。我们叫它版本号就行了。开始回退，执行git reset --hard 1df0573（取版本号前7位就可以了）。这里提示HEAD已经更改指向至1df0573了。此时文件内容已经回到第一个版本的状态。这里文件的修改日期被更改为现在的时间 2016\\6\\2 19:29，这是由于文件的修改日期是由Windows修改的，因为它检测到这个文件被修改了。而我们刚才从最新版本回退到现在这个版本，就像是我们手动修改了文件内容一样，事实上是由git来完成的。现在再执行git log。新版本的commit记录不见了，这就是reset --hard的力量，那怎么回到最新版呢？先执行git reflog。可以看到HEAD的变化情况。第一行表示当前HEAD所在的版本号是1df0573，而之所以在这个版本号，是由于我们执行了reset命令。看第二行，它告诉我们，这个HEAD所在的版本号是ad93b89，这个版本号是在执行commit之后形成的。此时我再用一次reset，git reset --hard ad93b89，将HEAD指向ad93b89， 同时查看log。回到第一次reset前的状态了。清除未追踪的文件现在看看如何用命令删除新加的文件。首先手动创建个文件，用来演示。用checkout是没办法删除掉它的，使用git clean -xf。这个命令的杀伤力比较大，它删除当前目录下所有没有track过的文件。不管它是否是.gitignore文件里面指定的文件夹和文件。"
  },
  
  {
    "title": "Git版本回退",
    "url": "/posts/git-banben-huitui/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-07-06 13:47:00 +0800",
    





    
    "snippet": "撤销WorkSpace中的更新使用git checkout --&lt;file&gt;...命令。注意：使用这种方法撤销更新的时候一定要慎重，因为通过这种方式撤销后，更新将没有办法再找回。当然，如果我们已经add了的话，那么checkout是没任何作用的，我们要先取消添加才可以撤回提交，使用下述指令：git reset HEAD Test.javagit checkout Test.jav...",
    "content": "撤销WorkSpace中的更新使用git checkout --&lt;file&gt;...命令。注意：使用这种方法撤销更新的时候一定要慎重，因为通过这种方式撤销后，更新将没有办法再找回。当然，如果我们已经add了的话，那么checkout是没任何作用的，我们要先取消添加才可以撤回提交，使用下述指令：git reset HEAD Test.javagit checkout Test.java撤销Stage中的更新使用git reset HEAD &lt;file&gt;...命令把暂存区的更新移出到WorkSpace中。撤销Repo中的更新撤销提交有两种方式：使用HEAD指针和使用commit id，在Git中，有一个HEAD指针指向当前分支中最新的提交。用HEAD代表当前版本，上一个版本就是HEAD^，再上一个版本就是HEAD^^依次类推，如果想回退到更早的提交，可以使用HEAD~n（也就是，HEAD^=HEAD~1，HEAD^^=HEAD~2）。git reset --hard HEAD^git reset --hard HEAD~1git reset --c2760c5512bc67a8b990c1da508d40cca623f23恢复被撤销的提交回退后，你突然后悔了，想回退回新的那个版本，可是遗憾的是，你键入git log却发现没有了最新的那个版本号，这怎么办呢，没事，Git中给你提供了这颗”后悔药”，Git记录着你输入的每一条指令，键入git reflog，你会发现，版本号就在这里，然后键入git reset --hard ad2080c。–hard和–soft前面在使用reset来撤销更新的时候，我们都是使用的--head选项，其实与之对应的还有一个--soft选项，区别如下：  –head：撤销并删除相应的更新。  –soft：撤销相应的更新，把这些更新的内容放到Stage中。删除文件在Git中，如果我们要删除一个文件，可以使用下面的命令，git rm &lt;file&gt;相比rm只是多了一步，把这次删除的更新发到Stage中。"
  },
  
  {
    "title": "Oracle DBLINK",
    "url": "/posts/oracle-dblink/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-07-06 01:47:00 +0800",
    





    
    "snippet": "Oracle在进行跨库访问时，可以通过创建DBLINK实现，首先了解下环境：在tnsnames.ora中配置两个数据库别名：orcl(用户名：wangyong 密码：1988)、orcl2(用户名：wangyong 密码：123456)，在orcl中创建DBLINK来访问orcl2赋予权限在创建DBLINK之前，我们需要判断，登陆的用户是否具备创建DBLINK的权限，所以我们执行以下的语句(...",
    "content": "Oracle在进行跨库访问时，可以通过创建DBLINK实现，首先了解下环境：在tnsnames.ora中配置两个数据库别名：orcl(用户名：wangyong 密码：1988)、orcl2(用户名：wangyong 密码：123456)，在orcl中创建DBLINK来访问orcl2赋予权限在创建DBLINK之前，我们需要判断，登陆的用户是否具备创建DBLINK的权限，所以我们执行以下的语句(用wangyong用户登陆orcl)-- 查看wangyong用户是否具备创建DBLINK权限select * from user_sys_privs where privilege like upper('%DBLINK%') AND USERNAME='WANGYONG';如果查询有返回行，则表示具备创建DBLINK权限，否则，则需要使用sys登陆orcl为WANGYONG用户赋予创建权限-- 给wangyong用户授予创建dblink的权限grant create public DBLINK to wangyong;此时，再执行上面查看是否具备权限的SQL语句，会发现有返回行，表示WANGYONG这个用户已经具备创建DBLINK的权限创建DBLINK      通过PLSQL图形化创建     填写完成后点击Apply按钮即可创建成功。        通过sqlplus中的SQL语句创建     -- 注意一点，如果密码是数字开头，用“”括起来 create public DBLINK TESTLINK2 connect to WANGYONG  identified by \"123456\" USING 'ORCL21'         -- 没有在tnsnames.ora中配置连接时使用下面的语句创建DBLINK CREATE DBLINK 'DBLINK名字' CONNECT TO '用户名' IDENTIFIED BY '密码' USING  '(DESCRIPTION =      (ADDRESS_LIST =         (ADDRESS =(PROTOCOL = TCP)(HOST = 数据库IP地址)(PORT = 1521))     )     (CONNECT_DATA =         (SERVICE_NAME = 服务名))     )';        这样，就完成了简单database简单的创建  创建同义词对于链接字符串，还可以创建同义词代替，使用起来会稍微省点事-- 创建同义词create synonym TESTSYNONYM FOR company@TESTLINK1;那么查询、插入、修改、删除中可直接用WYSYNONYM代替company@TESTLINK1即可，例如查询语句可改成如下方式-- 查询ORCL2中WANGYONG用户的表COMPANYSELECT * FROM TESTSYNONYM order by id"
  },
  
  {
    "title": "CentOS离线安装Oracle依赖",
    "url": "/posts/centos-lixian-anzhuang-oracle-yilai/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2021-07-06 01:47:00 +0800",
    





    
    "snippet": "安装离线下载插件[root@localhost honcur]# sudo yum install yum-plugin-downloadonly 这个插件可以把依赖包下载到本地。下载rpm包，保存在本地[root@localhost ~]# cd /usr/local[root@localhost local]# mkdir oralib[root@localhost local]# cd...",
    "content": "安装离线下载插件[root@localhost honcur]# sudo yum install yum-plugin-downloadonly 这个插件可以把依赖包下载到本地。下载rpm包，保存在本地[root@localhost ~]# cd /usr/local[root@localhost local]# mkdir oralib[root@localhost local]# cd oralib[root@localhost local]# yum install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers kernel-headers ksh libaio libaio-devel libgcc libgomp libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel glibc-static --downloadonly --downloaddir=. 执行命令后，进入/usr/local/oralib可以看到依赖包已经全部下载在文件夹内。安装Oracle需要的依赖包把依赖包oralib.tar放入/usr/local文件夹下，然后打开terminal# 切换到root[honcur@localhost ~]$ su root # 切换到目录[root@localhost honcur]# cd /usr/local # 解压依赖包[root@localhost local]# tar zxvf oralib.tar # 切换到oralib目录[root@localhost local]# cd oralib/ # 安装所有依赖,然后根据提示输入‘Y’，敲回车[root@localhost oralib]# yum localinstall *.rpm –nogpgcheck "
  },
  
  {
    "title": "Spring集成Quartz",
    "url": "/posts/spring-jicheng-quertz/",
    "categories": "Knowledge, Quartz",
    "tags": "Quartz",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "依赖&lt;!-- 定时任务 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;配置文件&l...",
    "content": "依赖&lt;!-- 定时任务 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;配置文件&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans                      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 需要执行的类 --&gt; &lt;bean id=\"testJob\" class=\"com.sky.test.TestImpl\" /&gt; &lt;!-- 配置job --&gt; &lt;bean id=\"testJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt;  &lt;property name=\"targetObject\" ref=\"testJob\" /&gt;  &lt;!-- 定时的方法名 --&gt;  &lt;property name=\"targetMethod\" value=\"test\" /&gt;  &lt;!-- 是否允许任务并发执行。当值为false时，表示必须等到前一个线程处理完毕后才再启一个新的线程 --&gt;  &lt;property name=\"concurrent\" value=\"false\" /&gt; &lt;/bean&gt;     &lt;!-- CronTrigger表达式触发器 --&gt; &lt;bean id=\"testJobTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt;  &lt;property name=\"jobDetail\" ref=\"testJobDetail\" /&gt;  &lt;!-- 1000ms --&gt;  &lt;property name=\"startDelay\" value=\"1000\" /&gt;  &lt;!-- 设置定时的时间 --&gt;  &lt;property name=\"cronExpression\" value=\"0 0 4 * * ?\" /&gt; &lt;/bean&gt;     &lt;!--配置调度工厂 --&gt; &lt;bean id=\"schedulerFactoryNews\" autowire=\"no\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt;  &lt;property name=\"triggers\"&gt;   &lt;list&gt;    &lt;ref bean=\"testJobTrigger\" /&gt;   &lt;/list&gt;  &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;"
  },
  
  {
    "title": "Corn表达式",
    "url": "/posts/corn-biaodashi/",
    "categories": "Knowledge, Quartz",
    "tags": "Quartz",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "一个Cron表达式有至少6个（也可能7个）有空格分隔的时间元素，按顺序依次为秒       （0~59）分       （0~59）时       （0~23）天（月） （0~31，但是你需要考虑你月的天数）月       （0~11）天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）年       （1970－2099）其中每个元素可以是一个值(如...",
    "content": "一个Cron表达式有至少6个（也可能7个）有空格分隔的时间元素，按顺序依次为秒       （0~59）分       （0~59）时       （0~23）天（月） （0~31，但是你需要考虑你月的天数）月       （0~11）天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）年       （1970－2099）其中每个元素可以是一个值(如6)一个连续区间(9-12)一个间隔时间(8-18/4)(/表示每隔4小时)一个列表(1,3,5)通配符由于“月份中的日期”和“星期中的日期”这两个元素互斥的，必须要对其中一个设置0 0 10,14,16 * * ?          每天上午10点，下午2点，4点0 0/30 9-17 * * ?           朝九晚五工作时间内每半小时0 0 12 ? * WED              表示每个星期三中午12点 0 0 12 * * ?                每天中午12点触发 0 15 10 ? * *               每天上午10:15触发 0 15 10 * * ?               每天上午10:15触发 0 15 10 * * ? *             每天上午10:15触发 0 15 10 * * ? 2005          2005年的每天上午10:15触发 0 * 14 * * ?                在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ?              在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ?           在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ?              在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED          每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI         周一至周五的上午10:15触发 0 15 10 15 * ?              每月15日上午10:15触发 0 15 10 L * ?               每月最后一日的上午10:15触发 0 15 10 ? * 6L              每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2002-2005    2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3             每月的第三个星期五上午10:15触发   有些子表达式能包含一些范围或列表。例如：子表达式（天（星期））可以为MON-FRI，MON,WED,FRI，MON-WED,SAT。  *字符代表所有可能的值，因此，*在子表达式（月）里表示每个月的含义，*在子表达式（天（星期））表示星期的每一天。  /字符用来指定数值的增量。  例如：在子表达式（分钟）里的0/15表示从第0分钟开始，每15分钟，在子表达式（分钟）里的3/20表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样。  ?字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值，当两个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为?。  L字符仅被用于天（月）和天（星期）两个子表达式，它是单词last的缩写，但是它在两个子表达式里的含义是不同的，在天（月）子表达式中，“L”表示一个月的最后一天，在天（星期）自表达式中，L表示一个星期的最后一天，也就是SAT，如果在L前有具体的内容，它就具有其他的含义了。例如：6L表示这个月的倒数第6天，FRIL表示这个月的最一个星期五。  注意：在使用L参数时，不要指定列表或范围，因为这会导致问题。"
  },
  
  {
    "title": "Oracle 创建用户并分配权限",
    "url": "/posts/oracle-chuangjian-yonghu-bing-fenpei-quanxian/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "进入CMD命令行，输入sqlplus /nolog进入Oralce控制台；输入conn / as sysdba以管理员权限登录；登录成功输入create user 用户名 identified by 密码创建用户名密码；创建成功，开始授予权限，输入：-- 连接数据库权限grant create session to 用户名-- 操作表空间权限grant unlimited tablespac...",
    "content": "进入CMD命令行，输入sqlplus /nolog进入Oralce控制台；输入conn / as sysdba以管理员权限登录；登录成功输入create user 用户名 identified by 密码创建用户名密码；创建成功，开始授予权限，输入：-- 连接数据库权限grant create session to 用户名-- 操作表空间权限grant unlimited tablespace to 用户名;-- 创建表权限grant create table to 用户名;-- 删除表权限grante drop table to 用户名;-- 插入表权限grant insert table to 用户名;-- 更新表权限grant update table to 用户名;创建完成，退出控制台，输入用户名，密码登录查询用户是否创建成功。"
  },
  
  {
    "title": "Oracle 安装",
    "url": "/posts/oracle-anzhuang/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "  下载安装包http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html以下网址来源于官方下载页网win32位操作系统http://download.oracle.com/otn/nt/oracle11g/112010/win32_11gR2_database_1of2.ziphttp:...",
    "content": "  下载安装包http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html以下网址来源于官方下载页网win32位操作系统http://download.oracle.com/otn/nt/oracle11g/112010/win32_11gR2_database_1of2.ziphttp://download.oracle.com/otn/nt/oracle11g/112010/win32_11gR2_database_2of2.zip  win64位操作系统http://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_database_1of2.ziphttp://download.oracle.com/otn/nt/oracle11g/112010/win64_11gR2_database_2of2.zip  双击安装文件，进行安装    配置更新信息，此处我们直接下一步    配置更新信息跳过的提醒，直接点击是按钮    设置安装选项，此处我们选择“创建和配置数据库”，点击下一步按钮    系统类别设置，此处我们选择“桌面类”，点击下一步按钮    设置安装信息，建议将Oracle主目录位置设置为非中文目录D:\\Oracle11g；全局数据库名默认为orcl，可根据自己需要进行修改；数据库口令为非必录项，如果录入则会设置为管理员账户的初始密码，设置完成后点击下一步按钮    如果密码过于简单，则会提示不符合规范，规范为不小于8位，且至少包含数字、小写字母、大写字母，此处我们忽略，点击是按钮    提进行先决条件检查    安装概要确认，查看无误后，点击完成按钮    进行安装，此过程时间较长    如果初始安装时，选择了创建数据库，则会创建数据库实例    设置数据库口令，如果不更改则直接点确认即可，此处建议点击口令管理进行调整    如果点击口令管理，则可设置账户锁定状态以及初始密码，填写完成后点击确定按钮    安装结束，此时会显示安装的配置信息，点击关闭按钮安装结束  "
  },
  
  {
    "title": "JDBC、数据源、JNDI、数据库连接池",
    "url": "/posts/shujuyuan-lianjiechi/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "JDBCjava database connectivity standard 是一套规范的面向应用程序的接口，通过它可以访问各类关系数据库。各个数据库会实现该接口作为驱动如jtds.jar，当然可以自己写实现。JDBC是低级API，提供访问数据库的接口，是构建高级API的基础，利用纯Java编写可以在任何操作系统任何Java环境下工作。JDBC API中定义了一些Java类分别用来表示与数...",
    "content": "JDBCjava database connectivity standard 是一套规范的面向应用程序的接口，通过它可以访问各类关系数据库。各个数据库会实现该接口作为驱动如jtds.jar，当然可以自己写实现。JDBC是低级API，提供访问数据库的接口，是构建高级API的基础，利用纯Java编写可以在任何操作系统任何Java环境下工作。JDBC API中定义了一些Java类分别用来表示与数据库的连接（connections），SQL语句（SQL statements），结果集（result sets）以及其它的数据库对象，使得Java程序能方便地与数据库交互并处理所得的结果。使用JDBC，所有Java程序（包括Java applications ，applets和servlet）都能通过SQL语句或存储在数据库中的过程（stored procedures）来存取数据库。要通过JDBC来存取某一特定的数据库，必须有相应的JDBC Driver，它往往是由生产数据库的厂家提供，是连接JDBC API与具体数据库之间的桥梁。JDBC Driver是用于特定数据库的一套实施了JDBC接口的类集。简单的说，JDBC可以做三件事：与数据库建立连接，发送SQL语句，处理结果。JDBC可以理解为ODBC的纯Java语言和面向对象的实现。JDBC传统模式开发存在的主要问题      时间和内存资源消耗巨大。    普通的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再根据JDBC代码（或配置文件）中的用户名和密码进行验证其正确性。这一过程一般会花费0.05~1s，一旦需要数据库连接的时候就必须向数据库请求一个，执行完后再断开连接。显然，如果同一个数据库在同一时间有数十人甚至上百人请求连接势必会占用大量的系统资源，严重的会导致服务器崩溃。        有内存泄漏的风险。    因为每一次数据库连接使用完后都需要断开连接，但如果程序出现异常致使连接未能及时关闭，这样就可能导致内存泄漏，最终只能以重启数据库的方法来解决；另外使用传统JDBC模式开发不能控制需要创建的连接数，系统一般会将资源大量分出给连接以防止资源不够用，如果连接数超出一定数量也会有极大的可能导致内存泄漏。  数据源数据源定义的是连接到实际数据库的一条路径而已，数据源中并无真正的数据，它仅仅记录的是你连接到哪个数据库，以及如何连接的，如ODBC数据源。也就是说数据源仅仅是数据库的连接名称，一个数据库可以有多个数据源连接。在Java语言中，DataSource对象就是一个代表数据源实体的对象。JNDIJNDI全称是java naming and directory interface（Java命名和目录接口）。简单点就是你按命名规则给一个东西命名然后你就可以通过该名字在特定环境下直接查找到该东西了。JNDI中的命名（Naming），就是将Java对象以某个名称的形式绑定（binding）到一个容器环境（Context）中，以后调用容器环境到JNDI容器环境（Context）的查找（lookup）方法又可以查找出某个名称所绑定的Java对象。这样做的好处在于在真实的项目应用中，通常是由系统程序或框架程序先将资源对象绑定到JNDI环境中，以后在该系统或框架中运行的模块程序就可以从JNDI环境中查找这些资源对象了。比如，Tomcat服务器在启动时可以创建一个连接到某种数据库系统的数据源（DataSource）对象，并将该数据源（DataSource）对象绑定到JNDI环境中，以后在这个Tomcat服务器中运行的Servlet和JSP程序就可以从JNDI环境中查询出这个数据源（DataSource）对象进行使用，而不用关心数据源（DataSource）对象是如何创建出来的，这种方式极大的增强了系统的可维护性，这样，当数据库系统的连接参数发生变更时，就只是Tomcat系统管理员一个人要关心的事情，而与所有的应用程序开发人员无关。数据库连接池为了解决由使用传统开发模式创建连接导致的一系列问题，我们可以采用数据库连接池技术。数据库连接池是负责分配、管理和释放数据库连接。使用数据库连接池是因为数据库连接是一种关键的有限的昂贵的资源。如Weblogic、Tomcat、WebSphere容器都实现了数据库连接池，但是数据库连接池是可以独立出来自己编码实现的。常见的数据库连接池有：c3p0、DBCP、BoneCP、Proxool等。数据库连接池在系统启动时初始化了一定量maxIdle=idlenum的数据库连接，即没有使用中的连接被释放的情况下，连接池中保存的最大空闲连接数。数据库连接请求如果没有超过idle的值则直接去连接池中获取；如果超过了maxIdle的值则新建一个数据库连接；但如果数据库连接池中的连接总数超过了maxActive=activenum则做如下处理：  直接抛错。  让想要借出连接的线程等待一段时间，如果等不到，再抛错。  每隔一段时间检查一次pool，直到有可用连接，否则一直等下去。  永远可以拿到（视情况需要maxActive不设置或0或负）。但当没有可以使用的数据库连接的时候，连接池将要等待一个连接被返回的最长时间（毫秒）maxWait=waitnum，超过这个时间就要抛出异常。数据源与数据库连接池关系  数据源是一种数据库对编程提供的一个接口，每个数据源对应一个数据库。  连接池只是存放数据库连接对象的一个缓冲池，需要数据连接的时候从缓冲池中取就行了。  连接池可以管理数据源。数据源与JNDI关系数据源是在JDBC 2.0中引入的一个概念。在JDBC 2.0扩展包中定义了javax.sql.DataSource接口来描述这个概念。如果用户希望建立一个数据库连接，通过查询在JNDI服务中的数据源，可以从数据源中获取相应的数据库连接。这样用户就只需要提供一个逻辑名称，而不是数据库登录的具体细节。即DataSource采用Java的JNDI技术，来获得DataSource对象的引用。"
  },
  
  {
    "title": "JNDI方式创建数据源连接",
    "url": "/posts/jndi-fangshi-chuangjian-shujuyuan/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2021-07-05 13:47:00 +0800",
    





    
    "snippet": "以JNDI方式创建数据源首先要配置数据源的相关连接信息，该配置在Tomcat安装目录下的conf/context.xml文件中&lt;Context&gt;   &lt;Resource  name=\"jdbc/NutzDemo\"               auth=\"Container\"              type=\"javax.sql.DataSource\"          ...",
    "content": "以JNDI方式创建数据源首先要配置数据源的相关连接信息，该配置在Tomcat安装目录下的conf/context.xml文件中&lt;Context&gt;   &lt;Resource  name=\"jdbc/NutzDemo\"               auth=\"Container\"              type=\"javax.sql.DataSource\"              maxActive=\"100\"               maxIdle=\"30\"              maxWait=\"10000\"              username=\"root\"               password=\"root\"              driverClassName=\"com.mysql.jdbc.Driver\"              url=\"jdbc:mysql://localhost:3306/cheng\" /&gt;&lt;/Context&gt;在项目的web.xml中引入数据源&lt;resource-ref&gt;  &lt;res-ref-name&gt;jdbc/NutzDemo&lt;/res-ref-name&gt;  &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;  &lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt;获取数据库连接以进行相应的操作// 初始化JNDI上下文，创建DataSource对象Context initContext = new InitialContext();Context context = (Context) initContext.lookup(\"java:comp/env\");DataSource dataSource = (DataSource) context.lookup(\"jdbc/NutzDemo\");Connection conn = dataSource.getConnection();PreparedStatement ps = conn.prepareStatement(\"select * from t_role\");ResultSet rs = ps.executeQuery();System.out.println(rs.next());rs.close();conn.close();或者整合到Spring，在Spring的配置文件中添加如下代码&lt;bean id=\"datasource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;  &lt;property name=\"jndiName\" value=\"java:comp/env/jdbc/NutzDemor\" /&gt; &lt;/bean&gt;"
  },
  
  {
    "title": "Linux查看文件内容的命令",
    "url": "/posts/linux-chakan-wenjian-neirong-de-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-07-05 01:47:00 +0800",
    





    
    "snippet": "catmorehead /etc/passwd    # 查看文件的前十行head -2 /etc/passwd # 查看文件的前两行tail /etc/passwd    # 查看文件的后十行tail -f /etc/passwd # 实时跟踪文件的后十行tail -2 /etc/passwd # 查看文件的后两行wc -l /etc/passwd   # 显示文件的行数nl /etc/p...",
    "content": "catmorehead /etc/passwd    # 查看文件的前十行head -2 /etc/passwd # 查看文件的前两行tail /etc/passwd    # 查看文件的后十行tail -f /etc/passwd # 实时跟踪文件的后十行tail -2 /etc/passwd # 查看文件的后两行wc -l /etc/passwd   # 显示文件的行数nl /etc/passwd      # 直接打印文件内容并且显示行号"
  },
  
  {
    "title": "Context上下文",
    "url": "/posts/shangxiawen/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2021-07-02 13:47:00 +0800",
    





    
    "snippet": "程序执行部分到达子程序，子程序要获得结果，就要用到程序之前的一些结果（包括但不限于外部变量值，外部对象等等）；APP点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。这些都是上下文的典型例子，理解成环境就可以，而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。进程中断在操作系统中是有...",
    "content": "程序执行部分到达子程序，子程序要获得结果，就要用到程序之前的一些结果（包括但不限于外部变量值，外部对象等等）；APP点击一个按钮进入一个新的界面，也要保存你是在哪个屏幕跳过来的等等信息，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。这些都是上下文的典型例子，理解成环境就可以，而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。进程中断在操作系统中是有上有下的。ServletContext是Servlet中最大的一个接口，呈现了Web应用的Servlet视图。它代表当前的web应用，所有的Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为Context域对象。这里的Context可以理解成是一种容器，而且容器里的东西是共享的。PageContext是JSP中的内置对象之一，它是javax.servlet.jsp.PageContext类的实例对象。提供了对JSP页面所有的对象及命名空间的访问，这里Context看作是一个实现访问JSP页面之间的数据共享的容器。"
  },
  
  {
    "title": "JSP九大内置对象及四大作用域",
    "url": "/posts/jsp-9daneizhiduixiang-4dazuoyongyu/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2021-07-02 13:47:00 +0800",
    





    
    "snippet": "JSP九大内置对象request     请求对象       类型javax.servlet.ServletRequest   作用域 Requestresponse    响应对象       类型javax.servlet.ServletResponse  作用域 PagepageContext 页面上下文对象  类型javax.servlet.jsp.PageContext  作用域...",
    "content": "JSP九大内置对象request     请求对象       类型javax.servlet.ServletRequest   作用域 Requestresponse    响应对象       类型javax.servlet.ServletResponse  作用域 PagepageContext 页面上下文对象  类型javax.servlet.jsp.PageContext  作用域 Pagesession     会话对象       类型javax.servlet.http.HttpSession 作用域 Sessionapplication 应用程序对象   类型javax.servlet.ServletContext    作用域 Applicationout         输出对象       类型javax.servlet.jsp.JspWriter    作用域 Pageconfig      配置对象       类型javax.servlet.ServletConfig    作用域 Pagepage        页面对象       类型javax.servlet.Object           作用域 Pageexception   例外对象       类型javax.servlet.Throwable        作用域 Pageexception对象则代表了JSP文件运行时所产生的例外对象，此对象不能在一般JSP文件中直接使用，而只能在使用了&lt;%@ page isErrorPage=\"true\"%&gt;的JSP文件中使用。JSP四大域对象JSP九大内置对象中有四大域对象，范围小到大page(PageContext,JSP有效)              指pageContext(javax.servlet.jsp.PageContext)request(一次请求)                指HttpServletRequest(javax.servlet.ServletRequest)session(一次会话)                       指HttpSession(javax.servlet.http.HttpSession)application(ServletContext,当前web应用) 指application(javax.servlet.ServletContext)Servlet三大域对象  request  session  application实验大概流程是这样的，我们访问index.jsp的时候，分别对pageContext，request，session，application四个作用域中的变量进行累加。（当然先判断这个变量是不是存在，如果变量不存在，则要把变量初始化成1）。计算完成后就从index.jsp执行forward跳转到test.jsp。在test.jsp里再进行一次累加，然后显示出这四个整数来。从显示的结果来看，我们可以直观的得出结论：  page里的变量没法从index.jsp传递到test.jsp。只要页面跳转了，它们就不见了。  request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。  session和application里的变量一直在累加，开始还看不出区别，只要关闭浏览器，再次重启浏览器访问这页，session里的变量就重新计算了。  application里的变量一直在累加，除非你重启Tomcat，否则它会一直变大。作用域规定的是变量的有效期限：  如果把变量放到pageContext里，就说明它的作用域是page，它的有效范围只在当前JSP页面里。从把变量放到PageContext开始，到JSP页面结束，你都可以使用这个变量。  如果把变量放到request里，就说明它的作用域是request，它的有效范围是当前请求周期。所谓请求周期，就是指从HTTP请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个JSP页面，在这些页面里你都可以使用这个变量。  如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。  如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他作用域中都是不会发生的，page，request，session都是完全隔离的，无论如何修改都不会影响其他人的数据。作用域的生命周期和作用范围  application(ServletContext)          生命周期：当Web应用被加载进容器时创建代表整个web应用的ServletContext对象，当服务器关闭或Web应用被移除时，ServletContext对象跟着销毁。      作用范围：整个Web应用。        request          生命周期：在service 方法调用前由服务器创建，传入service方法。整个请求结束，request生命结束。      作用范围：整个请求链（请求转发也存在）。        session          生命周期：在第一次调用 request.getSession() 方法时，服务器会检查是否已经有对应的session,如果没有就在内存中创建一个session并返回。当一段时间内session没有被使用（默认为30分钟），则服务器会销毁该session。如果服务器非正常关闭（强行关闭），没有到期的session也会跟着销毁。如果调用session提供的invalidate()，可以立即销毁session。      作用范围：一次会话。        page(PageContext)          生命周期：当对JSP请求时开始，当响应结束时销毁。      作用范围：整个JSP页面，是四大作用域中最小的一个。      "
  },
  
  {
    "title": "context-param和init-param",
    "url": "/posts/context-param-he-init-param/",
    "categories": "Knowledge, JavaWeb",
    "tags": "JavaWeb",
    "date": "2021-07-02 01:47:00 +0800",
    





    
    "snippet": "初始化参数web.xml里面可以定义两种参数  Application范围内的参数，存放在ServletContext中，在web.xml中配置如下     &lt;context-param&gt;     &lt;param-name&gt;context/param&lt;/param-name&gt;     &lt;param-value&gt;avalible during ap...",
    "content": "初始化参数web.xml里面可以定义两种参数  Application范围内的参数，存放在ServletContext中，在web.xml中配置如下     &lt;context-param&gt;     &lt;param-name&gt;context/param&lt;/param-name&gt;     &lt;param-value&gt;avalible during application&lt;/param-value&gt; &lt;/context-param&gt;        Servlet范围内的参数，只能在Servlet的init()方法中取得，在web.xml中配置如下     &lt;servlet&gt;     &lt;servlet-name&gt;MainServlet&lt;/servlet-name&gt;     &lt;servlet-class&gt;com.wes.controller.MainServlet&lt;/servlet-class&gt;     &lt;init-param&gt;        &lt;param-name&gt;param1&lt;/param-name&gt;        &lt;param-value&gt;avalible in servlet init()&lt;/param-value&gt;     &lt;/init-param&gt;     &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt;      初始化参数获取在Servlet中可以通过代码分别取用package com.wes.controller;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;public class MainServlet extends HttpServlet {    public MainServlet() {        super();    }    public void init() throws ServletException {        System.out.println(\"下面的参数是存放在ServletContext中的\");        System.out.println(getServletContext().getInitParameter(\"context/param\"));        System.out.println(\"下面的参数param1是在Servlet中存放的\");        System.out.println(this.getInitParameter(\"param1\"));    }}第一种参数在Servlet里面可以通过getServletContext().getInitParameter(\"context/param\")得到第二种参数只能在Servlet的init()方法中通过this.getInitParameter(\"param1\")得到示例&lt;servlet&gt;    &lt;description&gt;&lt;/description&gt;    &lt;display-name&gt;IOCServlet&lt;/display-name&gt;    &lt;servlet-name&gt;IOCServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.hp.servlet.IOCServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;test&lt;/param-name&gt;        &lt;param-value&gt;123&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/servlet&gt; &lt;context-param&gt;    &lt;param-name&gt;test1&lt;/param-name&gt;    &lt;param-value&gt;456&lt;/param-value&gt;&lt;/context-param&gt; PrintWriter out = response.getWriter();out.println(\"context test：\" + getServletContext().getInitParameter(\"test\"));out.println(\"context test1：\" + getServletContext().getInitParameter(\"test1\"));out.println(\"init test：\" + this.getInitParameter(\"test\"));out.println(\"init test1：\" + this.getInitParameter(\"test1\"));out.close();# 结果context test nullcontext test1 456init test 123init test1 null"
  },
  
  {
    "title": "Spring项目启动报错",
    "url": "/posts/spring-xiangmu-qidong-baocuo/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-01 13:47:00 +0800",
    





    
    "snippet": "报错信息通配符的匹配很全面, 但无法找到元素 'mvc:annotation-driven' 的声明报错原因虽然在XML文件上方声明了mvc，但没有配置此声明对应的文件信息。解决方法正确配置如下&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/200...",
    "content": "报错信息通配符的匹配很全面, 但无法找到元素 'mvc:annotation-driven' 的声明报错原因虽然在XML文件上方声明了mvc，但没有配置此声明对应的文件信息。解决方法正确配置如下&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc         http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;意思就是，mvc声明用http://www.springframework.org/schema/mvc/spring-mvc.xsd这个文件来解析。"
  },
  
  {
    "title": "ResponseBody返回4种数据格式的数据",
    "url": "/posts/ResponseBody-fanhui-sizhong-geshi-de-shuju/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-07-01 13:47:00 +0800",
    





    
    "snippet": "返回键值对或者集合前端JS请求// 返回值为Map的形式$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()}...",
    "content": "返回键值对或者集合前端JS请求// 返回值为Map的形式$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()}, // 请求参数        dataType : \"json\", // Ajax接口（请求URL）返回的数据类型        success : function(data) { // data：返回数据（JSON对象）            if(data.name == \"empty\") {                $(\".errorFont\").text(\"用户名为不能为空！\");                $(\".errorFont\").css(\"color\",\"red\");            } else if (data.name == \"exist\") {                $(\".errorFont\").text(\"用户名已注册\");                $(\".errorFont\").css(\"color\",\"green\");            } else if (data.name == \"noexist\") {                $(\".errorFont\").text(\"用户名未注册\");                $(\".errorFont\").css(\"color\",\"red\");            }        },        error : function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 验证用户是否存在，返回一个键值对的数据@RequestMapping(\"/nameProving\") @ResponseBodypublic Object nameProving(String name) {    HashMap&lt;String, String&gt; resultMap = new HashMap&lt;String, String&gt;();    if (StringUtils.isEmpty(name)) {        resultMap.put(\"name\", \"empty\");    } else {        Userss user = userService.getUserByName(name);        if(user!=null)            resultMap.put(\"name\", \"exist\");        else            resultMap.put(\"name\", \"noexist\");    }    return JSONArray.toJSONString(resultMap);}返回JSON格式的字符串前端JS请求// 返回值为String的形式，dataType:\"json\"$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving2?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()},        dataType : \"json\",        success : function(data) { // data：返回数据（JSON对象）            if(data == \"empty\") {                $(\".errorFont\").text(\"用户名为不能为空2！\");                $(\".errorFont\").css(\"color\",\"red\");            } else if(data == \"exist\") {                $(\".errorFont\").text(\"用户名已注册2\");                $(\".errorFont\").css(\"color\",\"green\");            } else if(data == \"noexist\") {                $(\".errorFont\").text(\"用户名未注册2\");                $(\".errorFont\").css(\"color\",\"red\");            }        },        error : function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员2！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 验证用户是否存在，返回一个转成JSON字符串的数据@RequestMapping(\"/nameProving2\") @ResponseBodypublic String nameProving2(String name) {    String result = \"\";    if(StringUtils.isEmpty(name)) {        result = \"empty\";    } else {        Userss user = userService.getUserByName(name);        if(user != null)            result = \"exist\";        else            result = \"noexist\";    }    return JSONArray.toJSONString(result);}返回字符串前端JS请求// 返回值为String的形式，dataType:\"text\"$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving3?t=\" + new Date().getTime(),        data : {name:$(\".name\").val()},        dataType : \"text\"        success:function(data) {            if(data == \"\\\"empty\\\"\") {                $(\".errorFont\").text(\"用户名为不能为空3！\");                $(\".errorFont\").css(\"color\",\"red\");            } else if(data == \"\\\"exist\\\"\") {                $(\".errorFont\").text(\"用户名已注册3\");                $(\".errorFont\").css(\"color\",\"green\");            } else if(data == \"\\\"noexist\\\"\") {                $(\".errorFont\").text(\"用户名未注册3\");                $(\".errorFont\").css(\"color\",\"red\");            }        },        error:function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员3！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 验证用户是否存在，返回一个字符串的数据/*** 此方法中有多个注解 * method：指定请求方式* required：表示参数是否必须，默认为必须，fslse为不是必须* @param name* @return*/@RequestMapping(value=\"/nameProving3\", method=RequestMethod.POST, params=\"name\") @ResponseBodypublic String nameProving3(@RequestParam(value=\"name\", required=false) String name) {    String result = \"\";    if(StringUtils.isEmpty(name)) {        result= \"empty\";    } else {        Userss user=userService.getUserByName(name);        if(user!=null)            result= \"exist\";        else            result= \"noexist\";    }    return result;}返回类对象的数据前端JS请求// 返回值为类对象的形式，dataType:\"json\"$(\".name\").blur(function() {    $.ajax({        type : \"Post\",        url : \"/mvc-demo/user/nameProving4?t=\"+new Date().getTime(),        data : {name:$(\".name\").val()},        dataType : \"json\",        success : function(data) {            if (data == null) {                $(\".errorFont\").text(\"用户名为空或者用户名不存在4！\");                $(\".errorFont\").css(\"color\",\"red\");            } else {                $(\".errorFont\").text(\"用户名\"+data.name+\"已注册4\");                $(\".errorFont\").css(\"color\",\"green\");            }        },        error : function(data) {            $(\".errorFont\").text(\"发生未知错误，请联系管理员2！\");            $(\".errorFont\").css(\"color\",\"red\");        }    });});后端逻辑处理// 返回一个类对象@RequestMapping(\"/nameProving4\") @ResponseBodypublic User nameProving4(String name) {    User user = userService.getUserByName(name);    if(user==null){        return null;    }    return user;}"
  },
  
  {
    "title": "web.xml的加载顺序",
    "url": "/posts/webxml-de-jiazai-shunxu/",
    "categories": "Knowledge, JavaWeb",
    "tags": "JavaWeb",
    "date": "2021-07-01 13:47:00 +0800",
    





    
    "snippet": "web.xml加载顺序首先可以肯定的是，加载顺序与它们在web.xml文件中的先后顺序无关。即不会因为filter写在listener的前面而会先加载filter。最终得出的结论是：listener -&gt; filter -&gt; servlet同时还存在着这样一种配置节：context-param，它用于向ServletContext提供键值对，即应用程序上下文信息。我们的liste...",
    "content": "web.xml加载顺序首先可以肯定的是，加载顺序与它们在web.xml文件中的先后顺序无关。即不会因为filter写在listener的前面而会先加载filter。最终得出的结论是：listener -&gt; filter -&gt; servlet同时还存在着这样一种配置节：context-param，它用于向ServletContext提供键值对，即应用程序上下文信息。我们的listener，filter等在初始化时会用到这些上下文中的信息，那么context-param配置节是不是应该写在listener配置节前呢？实际上 context-param配置节可写在任意位置，因此真正的加载顺序为：context-param -&gt; listener -&gt; filter -&gt; servlet对于某类配置节而言，与它们出现的顺序是有关的。以filter为例，web.xml中可以定义多个filter，与filter相关的一个配置节是filter-mapping，这里一定要注意，对于拥有相同filter-name的filter和filter-mapping配置节而言，filter-mapping必须出现在filter之后，否则当解析到filter-mapping时，它所对应的filter-name还未定义。web容器启动时初始化每个filter时，是按照filter配置节出现的顺序来初始化的，当请求资源匹配多个filter-mapping时，filter拦截资源是按照filter-mapping配置节出现的顺序来依次调用doFilter()方法的。servlet同filter类似，此处不再赘述。由此，可以看出，web.xml的加载顺序是：context-param -&gt; listener -&gt; filter -&gt; servlet ，而同个类型之间的实际程序调用的顺序是根据对应的mapping的顺序进行调用的。Load-on-startup元素Load-on-startup元素在web应用启动的时候指定了servlet被加载的顺序，它的值必须是一个整数。如果它的值是一个负整数或是这个元素不存在，那么容器会在该servlet被调用的时候，加载这个servlet。如果值是正整数或零，容器在配置的时候就加载并初始化这个servlet，容器必须保证值小的先被加载。如果值相等，容器可以自动选择先加载谁。在servlet的配置当中，5的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。web.xml加载过程  启动一个WEB项目的时候，WEB容器会去读取它的配置文件web.xml，读取&lt;listener&gt;和&lt;context-param&gt;两个结点。  紧急着，容器创建一个ServletContext（servlet上下文），这个web项目的所有部分都将共享这个上下文。  容器将&lt;context-param&gt;转换为键值对，并交给servletContext。  容器创建&lt;listener&gt;中的类实例，创建监听器。"
  },
  
  {
    "title": "WebLogic默认用户名和密码",
    "url": "/posts/welogic-moren-yonghuminghemima/",
    "categories": "Knowledge, WebLogic",
    "tags": "WebLogic",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "Weblogic的默认用户名和密码：weblogic/weblogic",
    "content": "Weblogic的默认用户名和密码：weblogic/weblogic"
  },
  
  {
    "title": "Oracle 常用语句",
    "url": "/posts/oracle-changyong-yuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "临时表select to_date('2004-05-07','yyyy-mm-dd') from dual修改字段长度alter table &lt;TABLENAME&gt; modify &lt;COL&gt; &lt;COLTYPE&gt;;-- 示例alter table TEST modify param1 VARCHAR2(4000);修改字段名称alter table &lt...",
    "content": "临时表select to_date('2004-05-07','yyyy-mm-dd') from dual修改字段长度alter table &lt;TABLENAME&gt; modify &lt;COL&gt; &lt;COLTYPE&gt;;-- 示例alter table TEST modify param1 VARCHAR2(4000);修改字段名称alter table &lt;TABLENAME&gt; RENAME COLUMN &lt;COL1&gt; TO &lt;COL2&gt;;查询数据库中包含USERCODE字段的表select * from user_tab_cols where column_name='USERCODE';查询所有表select table_name from user_tables;查询指定表名下的所有字段select * from user_tab_columns where Table_Name='表名';查询所有表的字段和注释select * from user_col_comments;"
  },
  
  {
    "title": "Git配置用户名和邮箱",
    "url": "/posts/git-peizhi-yonghuming-he-youxiang/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "# 设置全局用户名和邮箱git config --global user.name '张三'git config --global user.email 'zhangsan@email.com'# 查看当前配置git config --global user.namegit config --global user.email# 针对某个项目单独设置用户名和邮箱# 进入到该项目的.git目录...",
    "content": "# 设置全局用户名和邮箱git config --global user.name '张三'git config --global user.email 'zhangsan@email.com'# 查看当前配置git config --global user.namegit config --global user.email# 针对某个项目单独设置用户名和邮箱# 进入到该项目的.git目录，执行如下命令git config --local user.name '张三'git config --local user.email 'zhangsan@email.com'# 删除全局的用户和邮箱git config --global --unset user.namegit config --global --unset user.email# 删除某个项目中的用户名和邮箱# 进入到该项目的.git目录，执行如下命令git config --local --unset user.namegit config --local --unset user.email"
  },
  
  {
    "title": "Git常用命令",
    "url": "/posts/git-changyong-mingling/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "git init     # 初始化仓库git status   # 查看工作区状态git add -A   # 添加文件git commit -m \"提交信息\"  # 将文件提交到repository里git log      # 查看提交的记录git diff     # 查询更改信息git checkout -- .        # 撤销更改git reset --hard 1df0...",
    "content": "git init     # 初始化仓库git status   # 查看工作区状态git add -A   # 添加文件git commit -m \"提交信息\"  # 将文件提交到repository里git log      # 查看提交的记录git diff     # 查询更改信息git checkout -- .        # 撤销更改git reset --hard 1df0573 # 回退，取版本号前7位就可以了git clean -xf            # 删除新加的文件git checkout develop     # 切换到开发分支git checkout -b xxx        # 创建本地分支git remote update origin --prune    # 刷新远程分支列表"
  },
  
  {
    "title": "Dubbo发布和引用服务",
    "url": "/posts/dubbo-fabuheyinyong-fuwu/",
    "categories": "Knowledge, Dubbo",
    "tags": "Dubbo",
    "date": "2021-06-30 13:47:00 +0800",
    





    
    "snippet": "使用Dubbo发布服务在spring/applicationContext-dubbo.xml文件里添加如下信息&lt;!-- Dubbo服务的名称，用于计算依赖关系，名称可自定义，但不可重复--&gt; &lt;dubbo:application name=\"test\" /&gt;&lt;!-- 配置注册中心ZooKeeper地址 --&gt; &lt;dubbo:registry pro...",
    "content": "使用Dubbo发布服务在spring/applicationContext-dubbo.xml文件里添加如下信息&lt;!-- Dubbo服务的名称，用于计算依赖关系，名称可自定义，但不可重复--&gt; &lt;dubbo:application name=\"test\" /&gt;&lt;!-- 配置注册中心ZooKeeper地址 --&gt; &lt;dubbo:registry protocol=\"zookeeper\" address=\"127.0.0.1:2181\" /&gt;&lt;!-- 用Dubbo协议在20882端口暴露服务 --&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20882\" /&gt;&lt;!-- 发布接口服务 interface:发布的接口全限定名称 ref:接口的实现类                     version:版本号 timeout:设置超时时间--&gt;&lt;dubbo:service interface=\"com.test.reveal.testReveal.TestInterReveal\"             ref=\"testInterReveal\" version=\"2.0.0\" timeout=\"300000\"/&gt;使用Dubbo引用服务在spring/springmvc.xml文件里添加如下信息&lt;!-- Dubbo服务的名称，用于计算依赖关系，名称可自定义，但不可重复--&gt;&lt;dubbo:application name=\"test-item\"/&gt;&lt;!-- 配置注册中心ZooKeeper地址，该注册地址必须和服务接口注册地址相同 --&gt; &lt;dubbo:registry protocol=\"zookeeper\" address=\"127.0.0.1:2181\" /&gt;&lt;!-- 引用接口服务 --&gt;&lt;dubbo:reference interface=\"com.test.reveal.testReveal.TestInterReveal\"             id=\"testInterReveal\" check=\"false\" version=\"2.0.0\"/&gt;"
  },
  
  {
    "title": "CentOS安装JDK",
    "url": "/posts/centos-anzhuang-jdk/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2021-06-30 01:47:00 +0800",
    





    
    "snippet": "当前JDK最新版本下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html历史JDK版本下载地址：http://www.oracle.com/technetwork/java/javase/archive-139210.htmlLinux上一般会安装Open JDK，关于OpenJDK和JDK的区别：htt...",
    "content": "当前JDK最新版本下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html历史JDK版本下载地址：http://www.oracle.com/technetwork/java/javase/archive-139210.htmlLinux上一般会安装Open JDK，关于OpenJDK和JDK的区别：http://www.cnblogs.com/sxdcgaq8080/p/7487369.html卸载系统自带OpenJDK查看系统自带的OpenJDK版本信息java -version查看系统自带Java相关文件rpm -qa | grep java以上文件中，下面这几个可以删除java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64删除系统自带Java文件rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64检查是否已经删除成功java -version显示未找到命令...，代表已经删除成功了，如果还没删除，使用yum -y remove xxx命令删除解压JDKtar -zxvf jdk-8u144-linux-x64.tar.gz配置环境变量vi /etc/profile在文本的最后一行插入#java environmentexport JAVA_HOME=/usr/soft/jdk1.8.0_65export JRE_HOME=$JAVA_HOME/jreexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib退出viESCshift+qqw!刷新环境变量source /etc/profile检查是否安装成功java -version"
  },
  
  {
    "title": "ORA-00911 invalid character",
    "url": "/posts/tongshi-zhixing-duotiao-insert-yuju-baocuo/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-25 13:47:00 +0800",
    





    
    "snippet": "错误信息在PLSQL Developer中的SQL窗口执行多条insert语句时会提示错误：ORA-00911 : invalid character，检查sql提示所在的分号是英文的，没有问题。更加奇怪的是如果一条一条执行，是不会出现这个错误的，都是可以成功的，但是批量执行就会提示ORA-00911了。解决方法在SQL的开始和最后添加如下：begin  insert sql1;  inse...",
    "content": "错误信息在PLSQL Developer中的SQL窗口执行多条insert语句时会提示错误：ORA-00911 : invalid character，检查sql提示所在的分号是英文的，没有问题。更加奇怪的是如果一条一条执行，是不会出现这个错误的，都是可以成功的，但是批量执行就会提示ORA-00911了。解决方法在SQL的开始和最后添加如下：begin  insert sql1;  insert sql2;  ...end;这样就可以了。"
  },
  
  {
    "title": "Oracle 的精确函数",
    "url": "/posts/oracle-de-jinggque-hanshu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-25 13:47:00 +0800",
    





    
    "snippet": "ROUND按照指定的精度进行四舍五入select round(3.1415926, 4) from dual;------------------3.1416TRUNC按照指定的精度进行截取一个数select trunc(3.1415926, 4) from dual;------------------3.1415FLOOR对给定的数字取整数位select floor(2345.67) f...",
    "content": "ROUND按照指定的精度进行四舍五入select round(3.1415926, 4) from dual;------------------3.1416TRUNC按照指定的精度进行截取一个数select trunc(3.1415926, 4) from dual;------------------3.1415FLOOR对给定的数字取整数位select floor(2345.67) from dual;------------------2345CEIL返回大于或等于给出数字的最小整数select ceil(3.1415927) from dual;------------------4"
  },
  
  {
    "title": "Git忽略提交文件",
    "url": "/posts/git-hulue-tijiao-wenjian/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-25 13:47:00 +0800",
    





    
    "snippet": "Git可以add多个文件后再一次性提交，不过如果我们改动的文件很多的话，我们可以git add .一次添加全部，但有一些是几百年都不变一次的又或者自动生成的，比如lib，gen，bin文件夹等等，我们可以在代码仓库的根目录下创建一个名为.gitignore的文件，然后编辑里面的内容，把不需提交的文件忽略掉。/gen//bin//project.properties那么我们git add .的...",
    "content": "Git可以add多个文件后再一次性提交，不过如果我们改动的文件很多的话，我们可以git add .一次添加全部，但有一些是几百年都不变一次的又或者自动生成的，比如lib，gen，bin文件夹等等，我们可以在代码仓库的根目录下创建一个名为.gitignore的文件，然后编辑里面的内容，把不需提交的文件忽略掉。/gen//bin//project.properties那么我们git add .的时候，这里的文件就不会add。"
  },
  
  {
    "title": "CentOS安装Maven",
    "url": "/posts/centos-anzhuang-maven/",
    "categories": "Knowledge, CentOS",
    "tags": "CentOS",
    "date": "2021-06-25 01:47:00 +0800",
    





    
    "snippet": "解压Maven安装包tar -zxvf apache-maven-3.5.2-bin.tar.gz 配置maven环境变量vi /etc/profile添加环境变量# maven environmentexport MAVEN_HOME=/var/local/apache-maven-3.5.2export MAVEN_HOMEexport PATH=$PATH:$MAVEN_HOME/bi...",
    "content": "解压Maven安装包tar -zxvf apache-maven-3.5.2-bin.tar.gz 配置maven环境变量vi /etc/profile添加环境变量# maven environmentexport MAVEN_HOME=/var/local/apache-maven-3.5.2export MAVEN_HOMEexport PATH=$PATH:$MAVEN_HOME/bin刷新环境变量source /etc/profile验证结果mvn -version"
  },
  
  {
    "title": "ResponseBody响应乱码",
    "url": "/posts/ResponseBody-luanma/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "第一种解决方案是使用@RequestMapping注解的produces方法，写法如下：@RequestMapping(value = \"testPersonalValidtor.do\",produces = \"application/json;charset=utf-8\")  第二种方法是在Spring的配置文件中修改：&lt;!-- 处理@ResponseBody响应乱码 --&gt;&...",
    "content": "第一种解决方案是使用@RequestMapping注解的produces方法，写法如下：@RequestMapping(value = \"testPersonalValidtor.do\",produces = \"application/json;charset=utf-8\")  第二种方法是在Spring的配置文件中修改：&lt;!-- 处理@ResponseBody响应乱码 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt;       &lt;property name=\"messageConverters\"&gt;            &lt;list&gt;                &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt;                    &lt;property name=\"supportedMediaTypes\"&gt;                        &lt;list&gt;                            &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;                        &lt;/list&gt;                    &lt;/property&gt;                &lt;/bean&gt;            &lt;/list&gt;       &lt;/property&gt;  &lt;/bean&gt; "
  },
  
  {
    "title": "Oracle 计算时间差",
    "url": "/posts/oracle-jisuan-shijiancha/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "SELECT    param1,    param2,    param3FROM    TEST TWHERE    TO_NUMBER (        TO_DATE (            TO_CHAR (T.modifydate, 'yyyy-mm-dd hh24:mi:ss'),            'yyyy-mm-dd hh24:mi:ss'        ) -  ...",
    "content": "SELECT    param1,    param2,    param3FROM    TEST TWHERE    TO_NUMBER (        TO_DATE (            TO_CHAR (T.modifydate, 'yyyy-mm-dd hh24:mi:ss'),            'yyyy-mm-dd hh24:mi:ss'        ) -         TO_DATE (            TO_CHAR (T.createdate, 'yyyy-mm-dd hh24:mi:ss'),            'yyyy-mm-dd hh24:mi:ss'        )    ) * 86400 &gt; 2 * 24 * 60 * 60SELECT    param1,    param2,    param3FROM    TEST TWHERE    T.createdate &lt;![CDATA[&lt;]]&gt; (SYSDATE - 1/12)-- SYSDATE为Date类型，可以直接减，不用转换格式。"
  },
  
  {
    "title": "Oracle 误删数据的恢复方法",
    "url": "/posts/oracle-huifu-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "DELETE误删数据利用Oracle提供的闪回方法，如果在删除数据后还没做大量的操作（只要保证被删除数据的块没被覆写），就可以利用闪回方式直接找回删除的数据  确定删除数据的时间（在删除数据之前的时间就行，不过最好是删除数据的时间点）      用以下语句找出删除的数据     select * from TEST as of timestamp to_timestamp('删除时间', '...",
    "content": "DELETE误删数据利用Oracle提供的闪回方法，如果在删除数据后还没做大量的操作（只要保证被删除数据的块没被覆写），就可以利用闪回方式直接找回删除的数据  确定删除数据的时间（在删除数据之前的时间就行，不过最好是删除数据的时间点）      用以下语句找出删除的数据     select * from TEST as of timestamp to_timestamp('删除时间', 'yyyy-mm-dd hh24:mi:ss');            把删除的数据重新插入原表     insert into TEST (     select     *     from     TEST as of timestamp to_timestamp('删除时间', 'yyyy-mm-dd hh24:mi:ss') ); -- 注意要保证主键不重复      如果表结构没有发生改变，还可以直接使用闪回整个表的方式来恢复数据。表闪回要求用户必须要有flash any table权限-- 开启行移动功能 alter table 表名 enable row movement;-- 恢复表数据flashback table 表名 to timestamp to_timestamp('删除时间', 'yyyy-mm-dd hh24:mi:ss');-- 关闭行移动功能(千万别忘记)alter table 表名 disable row movement;DROP误删表由于Oracle在删除表时，没有直接清空表所占的块，Oracle把这些已删除的表的信息放到了一个虚拟容器“回收站”中，而只是对该表的数据块做了可以被覆写的标志，所以在块未被重新使用前还可以恢复。      查询这个“回收站”或者查询user_table视图来查找已被删除的表     select table_name,dropped from user_tables; select object_name,original_name,type,droptime from user_recyclebin;        在以上信息中，表名都是被重命名过的，字段table_name或者object_name就是删除后在回收站中的存放表名        如果还能记住表名，则可以用下面语句直接恢复     flashback table 原表名 to before drop;            如果记不住了，也可以直接使用回收站的表名进行恢复，然后再重命名，参照以下语句     flashback table \"回收站中的表名(如：Bin$DSbdfd4rdfdfdfegdfsf==$0)\" to  before drop rename to 新表名;      误删数据库Oracle的闪回功能除了以上基本功能外，还可以闪回整个数据库，使用数据库闪回功能，可以使数据库回到过去某一状态, 语法如下alter database flashback onflashback database to scn SCNNO;flashback database to timestamp to_timestamp('2007-2-12 12:00:00','yyyy-mm-dd hh24:mi:ss');总结Oracle提供以上机制保证了安全操作，但同时也代来了另外一个问题，就是空间占用，由于以上机制的运行，使用DROP一个表或者DELETE数据后，空间不会自动回收，对于一些确定不使用的表，删除时要同时回收空间，可以有以下2种方式：  采用truncate方式进行截断。（但不能进行数据恢复了）      在drop时加上purge选项drop table 表名 purge    该选项也可以通过删除recyclebin区域来永久性删除表     -- 删除表 drop table emp cascade constraints; purge table emp; -- 删除当前用户的回收站: purge recyclebin; -- 删除全体用户在回收站的数据: purge dba_recyclebin;      "
  },
  
  {
    "title": "JS声明全局变量",
    "url": "/posts/js-shengming-quanjubianliang/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "  使用var + 变量名的方式在function外部声明，即为全局变量，否则在function内部声明的是局部变量。  没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。  使用window全局对象window.test;来声明，全局对象的属性对应也是全局变量。",
    "content": "  使用var + 变量名的方式在function外部声明，即为全局变量，否则在function内部声明的是局部变量。  没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。  使用window全局对象window.test;来声明，全局对象的属性对应也是全局变量。"
  },
  
  {
    "title": "JS解析JSON",
    "url": "/posts/js-jiexi-json/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "JS是无法直接接收和使用JSON的数据，会出现undefined，所以要解析才能使用。方式一var str = '{\"rows\":[{\"ID\":0,\"登录账号\":\"admin\",\"登录时间\":\"2018-04-05\"}]}';var obj = eval(\"(\" + str + \")\");console.log(obj);var rows = obj[\"rows\"];for(var i = ...",
    "content": "JS是无法直接接收和使用JSON的数据，会出现undefined，所以要解析才能使用。方式一var str = '{\"rows\":[{\"ID\":0,\"登录账号\":\"admin\",\"登录时间\":\"2018-04-05\"}]}';var obj = eval(\"(\" + str + \")\");console.log(obj);var rows = obj[\"rows\"];for(var i = 0; i &lt; rows.length; i++){  var ri = rows[i];  for(var k in ri){    console.log(k + \": \" + ri[k]);  }}方式二var data = '{\"rows\":[{\"ID\":0,\"登录账号\":\"admin\",\"登录时间\":\"2018-04-05\"}]}';var obj = JSON.parse(data);console.log(obj);JSON.parse()和eval()的区别JSON.parse()解析JSON格式的数据会对要解析的字符串进行格式检查，如果格式不正确则不进行解析，而eval()则可以解析任何字符串，eval()是不安全的。比如下面的字符串：var str = 'alert(1000.toString())';eval(str);JSON.parse(str);用eval()可以解析，并且会弹出对话框，而用JSON.parse()则解析不了。如果恶意用户在JSON字符串中注入了向页面插入木马链接的脚本，用eval()是可以操作的，而用JSON.parse()则不必担心这个问题。注意：某些旧版浏览器不支持JSON.parse()，可以可以使用第三方库来支持https://github.com/douglascrockford/JSON-js/blob/master/json2.js。"
  },
  
  {
    "title": "JS将字符串转为日期",
    "url": "/posts/js-jiang-zifuchuan-zhuanhuanwei-riqi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "var str = \"2010-08-01\";// 转换日期格式，\"2010/08/01\"str = str.replace(/-/g, '/');// 创建日期对象var date = new Date(str);// 加一天date.setDate(date.getDate() + 1);",
    "content": "var str = \"2010-08-01\";// 转换日期格式，\"2010/08/01\"str = str.replace(/-/g, '/');// 创建日期对象var date = new Date(str);// 加一天date.setDate(date.getDate() + 1);"
  },
  
  {
    "title": "JS获取字符串在数组的位置",
    "url": "/posts/js-huoqu-zifuchuan-zai-shuzu-zhongde-weizhi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "function indexOf(arr, str){    // 如果可以的话，调用原生方法    if(arr &amp;&amp; arr.indexOf){        return arr.indexOf(str);    }         var len = arr.length;    for(var i = 0; i &lt; len; i++){        // 定...",
    "content": "function indexOf(arr, str){    // 如果可以的话，调用原生方法    if(arr &amp;&amp; arr.indexOf){        return arr.indexOf(str);    }         var len = arr.length;    for(var i = 0; i &lt; len; i++){        // 定位该元素位置        if(arr[i] == str){            return i;        }    }         // 数组中不存在该元素    return -1;}var a = '1';var arry = ['1', '2', '3', '4']var index = indexOf(arry, a);alert(index); // 弹出0"
  },
  
  {
    "title": "JS对URL转码与解码",
    "url": "/posts/js-dui-url-jinxing-bianma/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "escape和unescapeescape()函数用于JS对字符串进行编码，不常用。escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。采用unicode字符集对指定的字符串除0-255以外进行编码。所有的空格符、标点符号、特殊字符以及非ASCII字符都将被转化成%xx格式的字符编码（xx等于该字符在字符集表里面的编码的16进制数字）。比如，空格符对应的...",
    "content": "escape和unescapeescape()函数用于JS对字符串进行编码，不常用。escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。采用unicode字符集对指定的字符串除0-255以外进行编码。所有的空格符、标点符号、特殊字符以及非ASCII字符都将被转化成%xx格式的字符编码（xx等于该字符在字符集表里面的编码的16进制数字）。比如，空格符对应的编码是%20。escape不编码字符有69个* + - . / @ _ 0-9 a-z A-Z。var url = \"http://localhost:8080/pro?a=1&amp;b=张三&amp;c=aaa\";escape(url) // http%3A//localhost%3A8080/pro%3Fa%3D1%26b%3D%u5F20%u4E09%26c%3Daaa  encodeURI和decodeURIencodeURI()用于整个url编码。把URL字符串采用UTF-8编码格式转化成escape格式的字符串。encodeURI不编码字符有82个! # $ &amp; ' ( ) * + , - . / : ; = ? @ _ ~ 0-9 a-z A-Zvar url = \"http://localhost:8080/pro?a=1&amp;b=张三&amp;c=aaa\";encodeURI(url) // http://localhost:8080/pro?a=1&amp;b=%E5%BC%A0%E4%B8%89&amp;c=aaa encodeURIComponent和decodeURIComponentencodeURIComponent()用于参数的传递，参数包含特殊字符可能会造成间断。与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。因此，; / ? : @ &amp; = + $ , #这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。把URI字符串采用UTF-8编码格式转化成escape格式的字符串。var url = \"http://localhost:8080/pro?a=1&amp;b=张三&amp;c=aaa\";encodeURIComponent(url) // http%3A%2F%2Flocalhost%3A8080%2Fpro%3Fa%3D1%26b%3D%E5%BC%A0%E4%B8%89%26c%3Daaavar url = \"http://localhost:8080/pp?a=1&amp;b=\"+ paramUrl,var paramUrl = \"http://localhost:8080/aa?a=1&amp;b=2&amp;c=3\";// 应该使用encodeURIComponent()进行转码　　encodeURIComponent(paramUrl) // http://localhost:8080/pp?a=1&amp;b=http%3A%2F%2Flocalhost%3A8080%2Faa%3Fa%3D1%2..."
  },
  
  {
    "title": "JS遍历Map",
    "url": "/posts/js-bianli-map/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "console.log(map);for(var key in map){  console.log(\"属性：\" + key + \",值：\" + map[key]);}",
    "content": "console.log(map);for(var key in map){  console.log(\"属性：\" + key + \",值：\" + map[key]);}"
  },
  
  {
    "title": "Git乱码问题",
    "url": "/posts/git-luanma-wenti/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-06-24 13:47:00 +0800",
    





    
    "snippet": "git diff比较文件差异时，中文显示为乱码git diff接受的编码格式utf-8，而filename是以gb2312格式编写的，所以git diff命令就显示乱码。解决办法：在vim中将filename另存为utf-8格式。git status查看修改历史时，中文显示乱码解决方法：git config core.quotepath false",
    "content": "git diff比较文件差异时，中文显示为乱码git diff接受的编码格式utf-8，而filename是以gb2312格式编写的，所以git diff命令就显示乱码。解决办法：在vim中将filename另存为utf-8格式。git status查看修改历史时，中文显示乱码解决方法：git config core.quotepath false"
  },
  
  {
    "title": "Linux如何配置网络",
    "url": "/posts/linux-ruhe-peizhi-wangluo/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "查看CentOS的网络配置信息ifconfig -a或ip addr如果无法使用ifconfig命令，则需要安装软件yum install net-tools安装完成后即可使用ifconfig命令配置网络打开网络配置文件vi /etc/sysconfig/network-scripts/ifcfg-eth0把倒数第三行ONBOOT=no改为ONBOOT=yes，重启网络服务service n...",
    "content": "查看CentOS的网络配置信息ifconfig -a或ip addr如果无法使用ifconfig命令，则需要安装软件yum install net-tools安装完成后即可使用ifconfig命令配置网络打开网络配置文件vi /etc/sysconfig/network-scripts/ifcfg-eth0把倒数第三行ONBOOT=no改为ONBOOT=yes，重启网络服务service network restart检查网络连接ifconfig此时可以看到已经连接网络，不过，使用的是路由器分配的ip，如果需要静态ip，需要再设置一下vi /etc/sysconfig/network-scripts/ifcfg-eth0在最后面加入IPADDR=192.168.33.199(这里设置你的静态IP，注意冲突)GETAWAY=192.168.33.1(网关)、NETMASK=255.255.255.0(子网掩码)service network restartifconfig可以看到，ip已经从103变成了199"
  },
  
  {
    "title": "Linux如何开放端口",
    "url": "/posts/linux-ruhe-kaifang-duankou/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，如果要添加范围例外端口，如1000-2000语法命令如下：启用区域端口和协议组合firewall-cmd [--zone=&lt;zone&gt;] --add-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; [--timeout=&lt;s&gt;]参数解释...",
    "content": "在CentOS 7或RHEL 7或Fedora中防火墙由firewalld来管理，如果要添加范围例外端口，如1000-2000语法命令如下：启用区域端口和协议组合firewall-cmd [--zone=&lt;zone&gt;] --add-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; [--timeout=&lt;s&gt;]参数解释--zone  # 作用域--add-port=80/tcp  # 添加端口，格式为：端口/通讯协议--remove-port=80/tcp  # 移除端口，格式为：端口/通讯协议--permanent  # 永久生效，没有此参数重启后失效此举将启用端口和协议的组合。作用域&lt;zone&gt;可以通过命令firewall-cmd --get-active-zones查看，端口可以是一个单独的端口&lt;port&gt;或者是一个端口范围&lt;port&gt;-&lt;port&gt;。协议可以是tcp或udp，实际命令如下：      添加    firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=1000-2000/tcp --permanent（--permanent永久生效，没有此参数重启后失效）             重新载入    firewall-cmd --reload            查看    firewall-cmd --zone=public --query-port=80/tcp            删除    firewall-cmd --zone=public --remove-port=80/tcp --permanent            其他命令    firewall-cmd --list-ports # 查看已经开放的端口firewall-cmd --state # 查看默认防火墙状态（关闭后显示notrunning，开启后显示running）      当然你可以还原传统的管理方式      关闭firewalld防火墙    systemctl stop firewalldsystemctl mask firewalld            检查是否安装了iptables    service iptables status             安装iptables及iptables-services    yum install -y iptables yum install iptables-services            设置防火墙开机启动    systemctl enable iptablessystemctl enable iptables.service             开启防火墙服务    systemctl start iptables.service            修改/etc/sysconfig/iptables，增加如下一行    -A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT            重启防火墙使配置生效    systemctl restart iptables.service       其他命令# iptablesystemctl stop iptablessystemctl start iptablessystemctl restart iptablessystemctl reload iptables# firewalldsystemctl status firewalld  # 查看防火墙状态systemctl start firewalld  # 开启防火墙systemctl stop firewalld  # 关闭防火墙firewall-cmd --permanent --zone=public --add-port=27017/tcp --permanent  # 开启指定端口firewall-cmd --zone=public --remove-port=27017/tcp --permanent  # 关闭指定端口firewall-cmd --permanent --zone=public --add-port=27017-30000/tcp --permanent  # 开启指定范围端口firewall-cmd --permanent --zone=public --add-port=1-65535/tcp --permanent  # 开启所有端口firewall-cmd --zone=public --remove-port=27017-30000/tcp --permanent  # 关闭指定范围端口firewall-cmd --permanent --query-port=27017/tcp  # 查看端口是否开放firewall-cmd --reload  # 重启防火墙firewall-cmd --list-ports  # 查看已经开放的端口iptables -L -n  # 查看规则，这个命令是和iptables的相同的man firewall-cmd  # 查看帮助"
  },
  
  {
    "title": "Linux chmod命令",
    "url": "/posts/linux-chmod-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "在Linux中要修改一个文件夹或文件的权限要用到chmod命令，语法如下：chmod [who] [+ | - | =] [mode] 文件名各选项含义  who          u 表示“用户（user）”，即文件或目录的所有者      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户      o 表示“其他（others）用户”      a 表示“所有（al...",
    "content": "在Linux中要修改一个文件夹或文件的权限要用到chmod命令，语法如下：chmod [who] [+ | - | =] [mode] 文件名各选项含义  who          u 表示“用户（user）”，即文件或目录的所有者      g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户      o 表示“其他（others）用户”      a 表示“所有（all）用户”。它是系统默认值        操作符号          + 添加某个权限      - 取消某个权限      = 赋予给定权限并取消其他所有权限（如果有的话）        mode          r 可读      w 可写      x 可执行x只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x属性。      实例把index.html文件修改为可写可读可执行chmod 777 index.html要修改目录下所有文件属性可写可读可执行chmod 777 *.*修改所有htm文件的属性:chmod 777 *.htm修改文件夹属性的方法，把目录 /images/xiao 修改为可写可读可执行chmod 777 /images/xiao修改目录下所有的文件夹属性chmod 777 *要修改文件夹内所有的文件和文件夹及子文件夹属性为可写可读可执行chmod -R 777 /upload查看权限ls -l xxx.xxx那么就会出现相类似的信息，主要都是这些：-rw-rw-r--一共有10位数，其中： 最前面那个–代表的是类型  rw- 代表的是所有者（user）的权限  rw- 代表的是组群（group）的权限  r–- 代表的是其他人（other）的权限修改文件权限chmod o w xxx.xxx表示给其他人授予写xxx.xxx这个文件的权限chmod go - rw xxx.xxx表示删除xxx.xxx中组群和其他人的读和写的权限其他rwx也可以用数字来代替r ———— 4w ———— 2x ———— 1- ———— 0  -rw---     (600) 只有所有者才有读和写的权限  -rw-r–r–   (644) 只有所有者才有读和写的权限，组群和其他人只有读的权限  -rwx--     (700) 只有所有者才有读，写，执行的权限  -rwxr-xr-x (755) 只有所有者才有读，写，执行的权限，组群和其他人只有读和执行的权限  -rwx–x–x   (711) 只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限  -rw-rw-rw- (666) 每个人都有读写的权限  -rwxrwxrwx (777) 每个人都有读写和执行的权限"
  },
  
  {
    "title": "Eclipse更换工作空间的步骤",
    "url": "/posts/eclipse-genghuan-kongjian/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-24 01:47:00 +0800",
    





    
    "snippet": "一、指定新工作空间位置二、设置编码1. 设置工作空间编码UTF-82. 设置JSP编码三、指定JDK位置四、配置Tomcat1. Tomcat发布位置设置五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件1. 指定Maven插件2. 指定Maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入：.abcde...",
    "content": "一、指定新工作空间位置二、设置编码1. 设置工作空间编码UTF-82. 设置JSP编码三、指定JDK位置四、配置Tomcat1. Tomcat发布位置设置五、切换Java视图六、使用Package Explorer视图七、添加工作集视图八、指定Maven插件1. 指定Maven插件2. 指定Maven仓库九、查看Maven仓库索引十、字体修改十一、添加代码提示在上边红色框内输入：.abcdefghijklmnopqrstuvwxyz十二、校验删除十三、Debug十四、配置注释要在Types和Methods和Overriding methods中配置十五、properties文件乱码"
  },
  
  {
    "title": "Eclipse配置反编译工具JadClipse",
    "url": "/posts/eclipse-anzhuang-jadclipse/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-23 13:47:00 +0800",
    





    
    "snippet": "当运行引用了第三方jar包项目时，突然报出了jar包中的某个类的某一行出现异常。我们想看一下这个class文件的代码时，经常出现了如下图所示的场景：去找源码很浪费时间（除非是Maven项目，在pom.xml中引入依赖jar包会连同源文件下载下来）。在Eclipse中配置反编译工具，就可以随时查看class文件的内容了。下面就以JadClipse为例，讲述一下配置过程。      下载net....",
    "content": "当运行引用了第三方jar包项目时，突然报出了jar包中的某个类的某一行出现异常。我们想看一下这个class文件的代码时，经常出现了如下图所示的场景：去找源码很浪费时间（除非是Maven项目，在pom.xml中引入依赖jar包会连同源文件下载下来）。在Eclipse中配置反编译工具，就可以随时查看class文件的内容了。下面就以JadClipse为例，讲述一下配置过程。      下载net.sf.jadclipse_3.3.0.jar:  http://jadclipse.sourceforge.net/            将net.sf.jadclipse_3.3.0.jar(作用：如果不安装，第6步则搜不到JadClipse) 复制到Eclipse安装目录下的plugins下，如下图所示            Jad.exe下载地址为：http://www.javadecompilers.com/jad            将压缩包解压到Eclipse安装目录新建文件夹Jad（也可以自定义目录），如下图所示            进入Jad目录，在该目录下新建Jadtemp文件，用于存放jad.exe执行程序的缓存文件夹，如下图所示            在Eclipse中指定Jad.exe路径和缓存文件夹Jadtemp的路径。Eclipse中点击上方菜单Windows-&gt;Preferences，在搜索框中输入jad，如下图所示            指定class文件的默认打开方式            指定没有源代码的class文件的默认打开方式                    测试是否好使      "
  },
  
  {
    "title": "在Java中使用Lombok",
    "url": "/posts/java-zhong-shiyong-lombok/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-23 01:47:00 +0800",
    





    
    "snippet": "Lombok是一个帮助简化代码的工具，通过注解的形式例如：@Setter @Getter，可以替代代码中的getter和setter方法，虽然Eclipse自带的setter、getter代码生成也不需要我们手动的去敲写，但是使用@Setter @Getter这样的注解，能够使我们的代码看上去更加的简洁、优雅。在写之前，我遇到一个问题，在照着网上一些博文的做法，我直接将依赖加入pom文件，使...",
    "content": "Lombok是一个帮助简化代码的工具，通过注解的形式例如：@Setter @Getter，可以替代代码中的getter和setter方法，虽然Eclipse自带的setter、getter代码生成也不需要我们手动的去敲写，但是使用@Setter @Getter这样的注解，能够使我们的代码看上去更加的简洁、优雅。在写之前，我遇到一个问题，在照着网上一些博文的做法，我直接将依赖加入pom文件，使我的@Setter @Getter注解生效了，但是在我查看对象对应方法时我却找不到他的get、set方法，最后发现Lombok需要安装的，需要在eclipse.ini配置，单独的引入依赖不行。依赖：&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;将下载的lombok.jar放在与eclipse.ini同级目录下，在eclipse.ini文件中加入：-Xbootclasspath/a:lombok-1.16.8.jar -javaagent:lombok-1.16.8.jar重启项目，就发现能够正常使用了。"
  },
  
  {
    "title": "encodeURIComponent编码和后台解码",
    "url": "/posts/encodeURIComponent-bianma-he-jiema/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-23 01:47:00 +0800",
    





    
    "snippet": "方法一JavaScriptwindow.self.location = \"searchbytext.action?searchtext=\"         + encodeURIComponent(encodeURIComponent(seartext));Javasearchtext = java.net.URLDecoder.decode(searchtext, \"UTF-8\");两次编...",
    "content": "方法一JavaScriptwindow.self.location = \"searchbytext.action?searchtext=\"         + encodeURIComponent(encodeURIComponent(seartext));Javasearchtext = java.net.URLDecoder.decode(searchtext, \"UTF-8\");两次编码的原因：后台Java代码给searchtext赋值的时候，本身已经使用了一次解码，不过解码的结果依然不对。所以我们可以在页面上进行两次编码操作，这样后台自动的那次就可以抵消掉，然后使用searchtext = java.net.URLDecoder.decode(searchtext, \"UTF-8\");进行一次解码就好了。方法二另外还有一种方法是JavaScript进行一次编码，后台Java处理时换种写法就好了：JavaScriptwindow.self.location = \"searchbytext.action?searchtext=\"         + encodeURIComponent(seartext);JavaString s = new String(request.getParameter(\"searchtext\")        .getBytes(\"ISO8859-1\"), \"UTF-8\");"
  },
  
  {
    "title": "NoClassDefFoundError和ClassNotFoundException",
    "url": "/posts/NoClassDefFoundError-he-ClassNotFoundException/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-23 01:47:00 +0800",
    





    
    "snippet": "在日常Java开发中，我们经常碰到java.lang.NoClassDefFoundError这样的错误，需要花费很多时间去找错误的原因，而且我们很容易把java.lang.NoClassDefFoundError和java.lang.ClassNotfoundException这两个错误搞混，事实上这两个错误是完全不同的。NoClassDefFoundError的原因NoClassDefF...",
    "content": "在日常Java开发中，我们经常碰到java.lang.NoClassDefFoundError这样的错误，需要花费很多时间去找错误的原因，而且我们很容易把java.lang.NoClassDefFoundError和java.lang.ClassNotfoundException这两个错误搞混，事实上这两个错误是完全不同的。NoClassDefFoundError的原因NoClassDefFoundError错误的发生，是因为Java虚拟机在编译时能找到合适的类，而在运行时不能找到合适的类导致的错误。例如在运行时我们想调用某个类的方法或者访问这个类的静态成员的时候，发现这个类不可用，此时Java虚拟机就会抛出NoClassDefFoundError错误。与ClassNotFoundException的不同在于，这个错误发生只在运行时需要加载对应的类不成功，而不是编译时发生。ClassNotFoundException的原因ClassNotFoundException是在编译的时候在classpath中找不到对应的类而发生的错误。可能发生在使用反射的地方，spring容器加载类实例时也可能发生这种情况。ClassNotFoundException比NoClassDefFoundError容易解决，是因为在编译时我们就知道错误发生，并且完全是由于环境的问题导致。怎么解决NoClassDefFoundError错误根据前文，很明显NoClassDefFoundError的错误是因为在运行时类加载器在classpath下找不到需要加载的类，所以我们需要把对应的类加载到classpath中，或者检查为什么类在classpath中是不可用的，这个发生可能的原因如下：  对应的Class在Java的classpath中不可用  你可能用jar命令运行你的程序，但类并没有在jar文件的manifest文件中的classpath属性中定义  可能程序的启动脚本覆盖了原来的classpath环境变量  因为NoClassDefFoundError是java.lang.LinkageError的一个子类，所以可能由于程序依赖的原生的类库不可用而导致  检查日志文件中是否有java.lang.ExceptionInInitializerError这样的错误，NoClassDefFoundError有可能是由于静态初始化失败导致的  如果你工作在J2EE的环境，有多个不同的类加载器，也可能导致NoClassDefFoundError"
  },
  
  {
    "title": "Java中判断Map是否为空",
    "url": "/posts/java-zhong-pandaun-map-shifou-weikong/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "isEmpty()方法判断Map是否有内容（即new分配空间后是否有put键值对），若没有内容则true，否则false== null是判断Map是否为null（即是否new分配空间，和其中的键值对没关系），若没有内容则true，否则falseMap map = new HashMap&lt;String, String&gt;();System.out.println(\"判断Map是否有内...",
    "content": "isEmpty()方法判断Map是否有内容（即new分配空间后是否有put键值对），若没有内容则true，否则false== null是判断Map是否为null（即是否new分配空间，和其中的键值对没关系），若没有内容则true，否则falseMap map = new HashMap&lt;String, String&gt;();System.out.println(\"判断Map是否有内容:\" + map.isEmpty()); // trueSystem.out.println(\"判断Map是否为null:\" + map==null); // falseMap map = new HashMap&lt;String, String&gt;();map = null;System.out.println(\"判断Map是否有内容:\" + map.isEmpty()); // 报空指针异常System.out.println(\"判断Map是否为null:\" + (map == null)); // trueMap map = new HashMap&lt;String, String&gt;();map.put(null, null);System.out.println(\"判断Map是否为null:\" + (map == null)); // falseSystem.out.println(\"判断Map是否有内容:\" + map.isEmpty()); // false"
  },
  
  {
    "title": "在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义",
    "url": "/posts/baocuo-rfc-7230-rfc-3986/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "报错信息java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义  org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:504)  org.apache.coyote.http11.Htt...",
    "content": "报错信息java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义  org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:504)  org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:503)  org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)  org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:818)  org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1626)  org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)  java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)  java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)  org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)  java.lang.Thread.run(Thread.java:748)~报错原因这个错误的原因是JSP传递参数时传递了中文，而项目使用的是高版本的Tomcat，高版本的Tomcat传递参数不兼容。解决方法对传入的中文参数进行encodeURI()处理。function chenge() {    var frm = document.userFrom;    var userId = frm.userId.value;    var userName = frm.userName.value;      userName = encodeURI(userName);    var url = \"userAction.do?action=User&amp;userId=\" + userId + \"&amp;userName=\" + userName;    window.location.href = url;}"
  },
  
  {
    "title": "如何把Excel文本格式里的数字批量转成文本",
    "url": "/posts/ba-excel-wenbengeshi-lide-shuzi-piliang-zhuanhuancheng-wenben/",
    "categories": "Knowledge, Excel",
    "tags": "Excel",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "Excel中长数字会自动变成“科学计数法”，如果只需要显示成“文本”，可以用以下步骤：      首先在EXCEL表格中把要更改成为文本的数据全部选中。            然后在导航栏的“数据”栏内点击“分列”选项。            进入文本分列向导的分隔类型页面后，直接点击右下角的“下一步”。            设置分隔符号页面同上一步一样，点击右下角“下一步”。      ...",
    "content": "Excel中长数字会自动变成“科学计数法”，如果只需要显示成“文本”，可以用以下步骤：      首先在EXCEL表格中把要更改成为文本的数据全部选中。            然后在导航栏的“数据”栏内点击“分列”选项。            进入文本分列向导的分隔类型页面后，直接点击右下角的“下一步”。            设置分隔符号页面同上一步一样，点击右下角“下一步”。            在最后一个页面左侧把“文本”勾选，然后点击“完成”。            这时回到EXCEL表格内就能够查看到，所有的数字数据都已经显示为文本模式了。      "
  },
  
  {
    "title": "Eclipse中为jar包配置API",
    "url": "/posts/eclipse-zhong-wei-jarbao-peizhi-api/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "步骤  打开Perferences首选项；  定位到Installed JREs，选中你已有的要添加Java API的JRE或JDK；  单击右方的Edit，出现Edit JRE对话框，如果你是新建，出现New JRE对话框也一样。这时下方会出现一列jar包，例如X:/Program Files/Java/(jre/jdk版本)/jre/lib/rt.jar。单击rt.jar包选中，然后单击...",
    "content": "步骤  打开Perferences首选项；  定位到Installed JREs，选中你已有的要添加Java API的JRE或JDK；  单击右方的Edit，出现Edit JRE对话框，如果你是新建，出现New JRE对话框也一样。这时下方会出现一列jar包，例如X:/Program Files/Java/(jre/jdk版本)/jre/lib/rt.jar。单击rt.jar包选中，然后单击右方的Javadoc Location；  填写Java API位置，Javadoc URL方式是Java API的网络地址或本地Javadoc解压后的地址。Javadoc in archive是下载到本地的Javadoc压缩包地址，然后在Path within archive中填写API在压缩包内部的结构，一般为docs/API，也可以通过Browse更方便地导入；  试试在Eclipse中写几句代码，然后单击你要查API的类或方法名，F1一下，是不是能很快地定位到help，第一项应该就是javadoc for你选择的类或方法了。你可以在Eclipse中查看，也能快速定位到浏览器了，不用你自己查找；说明一般定位rt.jar包就可以了。不放心的话你也可以把别的包都配置下。示例Window  –&gt;  Preferences  –&gt;  Java  –&gt;  Installed JRES  –&gt;  选择右边的JDK  –&gt;  点击Edit  –&gt;   选择rt.jar栏  –&gt;  点击右边Javadoc Location  –&gt;  选择Javadoc in archive  –&gt;  Externel file  –&gt;   Archive path栏选择自己下载的API压缩包文件地址  –&gt;  Path within archive栏选择压缩包中html/zh_CN/api。"
  },
  
  {
    "title": "Eclipse报PermGen space异常",
    "url": "/posts/eclipse-bao-permgen-space-yichang/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "修改catalina.bat在Tomcat/bin目录下的catalina.batrem ----- Execute The Requested Command ----------------------下面加入JAVA_OPTS=\"-server -Xms800m -Xmx800m -XXNewSize=256M -XX:PermSize=256M -XX:MaxNewSize=512m...",
    "content": "修改catalina.bat在Tomcat/bin目录下的catalina.batrem ----- Execute The Requested Command ----------------------下面加入JAVA_OPTS=\"-server -Xms800m -Xmx800m -XXNewSize=256M -XX:PermSize=256M -XX:MaxNewSize=512m -XX:MaxPermSize=512m\" 这种方法在只使用Tomcat时管用，但使用Eclipse时不管用。修改eclipse.ini加入-vmd:/jdk6/bin/javaw.exe-vmargs-Dosgi.requiredJavaVersion=1.5 -Xms512m -Xmx1024m-XX:PermSize=256M -XX:MaxPermSize=512m修改Eclipse的Run Configurations点击Run - Run Configurations，在打开的窗口中点击Arguments选项卡，在VM arguments中内容最下边输入-Xms256m -Xmx512m -XX:MaxNewSize=256m -XX:MaxPermSize=256m保存后再次重启"
  },
  
  {
    "title": "如何让图片按比例响应式缩放、并自动裁剪",
    "url": "/posts/ruhe-rangtupian-anbili-xiangyingshi-suofang/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2021-06-22 13:47:00 +0800",
    





    
    "snippet": "响应式网站、移动端页面在DIV CSS布局中对于图片列表或图片排版时，如果想要图片按比例缩放，最简单的就是把img宽度设为100%，不设置高度，高度就会自动跟着宽度缩放，但是如果要达到的效果是，要让图片的宽高要按一定的比例显示，如1：1 、4：3 等，然而图片尺寸不是这个比例，又不想让图片拉伸变形，自动裁剪掉两边多余部分、这该如何解决呢？代码HTML部分&lt;div class=\"zoom...",
    "content": "响应式网站、移动端页面在DIV CSS布局中对于图片列表或图片排版时，如果想要图片按比例缩放，最简单的就是把img宽度设为100%，不设置高度，高度就会自动跟着宽度缩放，但是如果要达到的效果是，要让图片的宽高要按一定的比例显示，如1：1 、4：3 等，然而图片尺寸不是这个比例，又不想让图片拉伸变形，自动裁剪掉两边多余部分、这该如何解决呢？代码HTML部分&lt;div class=\"zoomImage\" style=\"background-image:url(images/test1.jpg)\"&gt;&lt;/div&gt;CSS部分.zoomImage{    width:100%;    height:0;    padding-bottom: 100%;    overflow:hidden;    background-position: center center;    background-repeat: no-repeat;    -webkit-background-size:cover;    -moz-background-size:cover;    background-size:cover;}原理剖析width:100%;height:0;padding-bottom: 100%;overflow:hidden;样式中的上面4句主要目的是为了让这个div以1：1的大小呈现，虽然高度为0，但是它的padding值为100%，这是因为在padding为百分比的时候，是根据他父层的宽度来进行计算的。在一点MDN关于padding的文档也有说到。background-position: center center;background-repeat: no-repeat;-webkit-background-size:cover;-moz-background-size:cover;background-size:cover;后面5句利用了CSS3中的background-size:cover的特性，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。对于padding为百分比的时候，我画了一张图，希望有助于大家理解：总结你所需要的比例就是width与padding-bottom的比例，用的时候，直接把.zoomImage当成img标签来用就可以了。"
  },
  
  {
    "title": "MySQL修改root密码的3种方法",
    "url": "/posts/mysql-xiugai-root-mima-de-fangfa/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-06-01 13:47:00 +0800",
    





    
    "snippet": "用set password命令 mysql&gt; set password for u&lt;sername&gt;@localhost = password('&lt;newpassword&gt;'); 用mysqladmin mysqladmin -u&lt;sername&gt; -p&lt;oldpassword&gt; password &lt;newpassword&gt; ...",
    "content": "用set password命令 mysql&gt; set password for u&lt;sername&gt;@localhost = password('&lt;newpassword&gt;'); 用mysqladmin mysqladmin -u&lt;sername&gt; -p&lt;oldpassword&gt; password &lt;newpassword&gt; 例子：mysqladmin -uroot -p123456 password 12用update直接编辑user表 mysql&gt; use mysql; mysql&gt; update user set password=password('12') where user='root' and host='localhost'; mysql&gt; flush privileges; "
  },
  
  {
    "title": "MySQL赋予用户权限",
    "url": "/posts/mysql-fuyu-yonghu-quanxian/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-06-01 13:47:00 +0800",
    





    
    "snippet": "本文实例，运行于MySQL5.0及以上版本。MySQL赋予用户权限的格式可概括为grant 权限 on 数据库对象 to 用户一、grant普通数据用户grant select on testdb.* to common_user@'%' -- 查询grant insert on testdb.* to common_user@'%' -- 插入grant update on testdb....",
    "content": "本文实例，运行于MySQL5.0及以上版本。MySQL赋予用户权限的格式可概括为grant 权限 on 数据库对象 to 用户一、grant普通数据用户grant select on testdb.* to common_user@'%' -- 查询grant insert on testdb.* to common_user@'%' -- 插入grant update on testdb.* to common_user@'%' -- 更新grant delete on testdb.* to common_user@'%' -- 删除或者，用一条MySQL命令来替代grant select, insert, update, delete on testdb.* to common_user@'%'二、grant数据库开发人员      grant创建、修改、删除MySQL数据表结构权限      grant create on testdb.* to developer@'192.168.0.%';  grant alter  on testdb.* to developer@'192.168.ssss0.%';  grant drop   on testdb.* to developer@'192.168.0.%';            grant操作MySQL外键权限      grant references on testdb.* to developer@'192.168.0.%';            grant操作MySQL临时表权限      grant create temporary tables on testdb.* to developer@'192.168.0.%';            grant操作MySQL索引权限      grant index on testdb.* to developer@'192.168.0.%';            grant操作MySQL视图、查看视图源代码权限      grant create view on testdb.* to developer@'192.168.0.%';  grant show   view on testdb.* to developer@'192.168.0.%';            grant操作MySQL存储过程、函数权限      grant create routine on testdb.* to developer@'192.168.0.%';    -- now, can show procedure status  grant alter  routine on testdb.* to developer@'192.168.0.%';    grant execute on testdb.* to developer@'192.168.0.%';      三、grant普通DBA管理某个MySQL数据库的权限grant all privileges on testdb to dba@'localhost'其中，关键字 “privileges” 可以省略。四、grant高级DBA管理MySQL中所有数据库的权限grant all on *.* to dba@'localhost'五、MySQL grant权限，分别可以作用在多个层次上      grant作用在整个MySQL服务器上     grant select on *.* to dba@localhost; -- dba可以查询MySQL中所有数据库中的表。 grant all    on *.* to dba@localhost; -- dba可以管理MySQL中的所有数据库            grant作用在单个数据库上     grant select on testdb.* to dba@localhost; -- dba可以查询testdb中的表。            grant作用在单个数据表上     grant select, insert, update, delete on testdb.orders to dba@localhost;            grant作用在表中的列上     grant select(id, se, rank) on testdb.apache_log to dba@localhost;            grant作用在存储过程、函数上     grant execute on procedure testdb.pr_add to 'dba'@'localhost' grant execute on function  testdb.fn_add to 'dba'@'localhost'      六、查看MySQL用户权限      查看当前用户（自己）权限      show grants;            查看其他 MySQL 用户权限      show grants for dba@localhost;      七、撤销已经赋予给MySQL用户的权限revoke跟grant的语法差不多，只需要把关键字“to”换成“from”即可grant  all on *.* to   dba@localhost;revoke all on *.* from dba@localhost;"
  },
  
  {
    "title": "Linux系统下MySQL表名区分大小写的问题",
    "url": "/posts/linux-xitongxia-mysql-biaoming-qufen-daxiaoxie-de-wenti/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-06-01 13:47:00 +0800",
    





    
    "snippet": "报错信息报错原因因为Linux环境下的MySQL数据库的表名默认是区分大小写的，可以查看Linux上的MySQL的配置文件/etc/my.cnf[root@centos tomcat7]# cat /etc/my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling sy...",
    "content": "报错信息报错原因因为Linux环境下的MySQL数据库的表名默认是区分大小写的，可以查看Linux上的MySQL的配置文件/etc/my.cnf[root@centos tomcat7]# cat /etc/my.cnf [mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid解决方法如果要使用数据库表名不区分大小写的话，就需要在[mysqld]下面添加一行配置，即lower_case_table_names=1[root@centos tomcat7]# vi /etc/my.cnf [mysqld]lower_case_table_names=1datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid补充lower_case_table_names参数  0：区分大小写  1：不区分大小写MySQL的大小写规则MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：  数据库名与表名是严格区分大小写的；  表的别名是严格区分大小写的；  列名与列的别名在所有的情况下均是忽略大小写的；  变量名也是严格区分大小写的；MySQL在Windows下都不区分大小写。如果想在查询时区分字段值的大小写，则：字段值需要设置BINARY属性，设置的方法有多种：  创建时设置CREATE TABLE T( A VARCHAR(10) BINARY );  使用alter修改ALTER TABLE`tablename` MODIFY COLUMN `cloname` VARCHAR(45) BINARY;  mysql tableeditor中直接勾选BINARY项。修改完配置之后，一定要重启数据库：[root@centos tomcat7]# service mysqld restartStopping mysqld:  [  OK  ]Starting mysqld:  [  OK  ]修改配置后的问题使用Navicat工具重新连接MySQL数据库，再次查询person表，这时发现不管查询SQL语句中的表名是大写还是小写都提示找不到person表了。原因是修改配置之后，会导致原来的大写的表名TEST无法识别，所以这一点要特别注意，解决办法是:  在修改配置之前一定先将所有表的表结构和表数据导出做备份；  删除原来的表；  修改配置；  将表结构和表数据导入。按照上面的步骤操作之后，再次查询person表，表名就不区分大小写了。"
  },
  
  {
    "title": "利用BeanUtils在对象间复制属性",
    "url": "/posts/java-duixiang-shuxing-de-fuzhi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "如果你有两个具有很多相同属性的JavaBean，一个很常见的情况就是Struts里的PO对象（持久对象）和对应的ActionForm，例如Teacher和TeacherForm。我们一般会在Action里从ActionForm构造一个PO对象，传统的方式是使用类似下面的语句对属性逐个赋值：// 得到TeacherFormTeacherForm teacherForm = (TeacherFo...",
    "content": "如果你有两个具有很多相同属性的JavaBean，一个很常见的情况就是Struts里的PO对象（持久对象）和对应的ActionForm，例如Teacher和TeacherForm。我们一般会在Action里从ActionForm构造一个PO对象，传统的方式是使用类似下面的语句对属性逐个赋值：// 得到TeacherFormTeacherForm teacherForm = (TeacherForm) form;// 构造Teacher对象Teacher teacher = new Teacher();// 赋值teacher.setName(teacherForm.getName());teacher.setAge(teacherForm.getAge());teacher.setGender(teacherForm.getGender());teacher.setMajor(teacherForm.getMajor());teacher.setDepartment(teacherForm.getDepartment());// 持久化Teacher对象到数据库HibernateDAO.save(teacher);而使用BeanUtils后，代码就大大改观了，如下所示：// 得到TeacherFormTeacherForm teacherForm = (TeacherForm) form;// 构造Teacher对象Teacher teacher = new Teacher();// 赋值BeanUtils.copyProperties(teacher, teacherForm);// 持久化Teacher对象到数据库HibernateDAO.save(teacher);如果Teacher和TeacherForm间存在名称不相同的属性，则BeanUtils不对这些属性进行处理，需要程序员手动处理。例如Teacher包含modifyDate属性而TeacherForm无此属性，那么在上面代码的copyProperties()后还要加上一句：teacher.setModifyDate(new Date());除BeanUtils外还有一个名为PropertyUtils的工具类，它也提供copyProperties()方法，作用与BeanUtils的同名方法十分相似，主要的区别在于后者提供类型转换功能，即发现两个JavaBean的同名属性为不同类型时，在支持的数据类型范围内进行转换，而前者不支持这个功能，但是速度会更快一些。PropertyUtils支持的转换类型如下：java.lang.BigDecimaljava.lang.BigIntegerboolean and java.lang.Booleanbyte and java.lang.Bytechar and java.lang.Characterjava.lang.Classdouble and java.lang.Doublefloat and java.lang.Floatint and java.lang.Integerlong and java.lang.Longshort and java.lang.Shortjava.lang.Stringjava.sql.Datejava.sql.Timejava.sql.Timestamp这里要注意一点，java.util.Date是不被支持的，而它的子类java.sql.Date是被支持的。因此如果对象包含时间类型的属性，且希望被转换的时候，一定要使用java.sql.Date类型。否则在转换时会提示argument mistype异常。"
  },
  
  {
    "title": "将项目导入Eclipse后JSP页面报错",
    "url": "/posts/xiangmu-daoru-eclipse-hou-jsp-yemian-baocuo/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "如何修改动态web模块版本",
    "url": "/posts/ruhe-xiugai-xiangmu-de-webdongtai-banben/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "报错信息Project facet Dynamic Web Module version 3.0 is not supported.解决方法找到工程项目的硬盘目录，打开项目下的.setting文件夹，找到.setting文件夹内的org.eclipse.wst.common.project.facet.core.xml文件，文件格式大致如下：&lt;?xml version=\"1.0\" en...",
    "content": "报错信息Project facet Dynamic Web Module version 3.0 is not supported.解决方法找到工程项目的硬盘目录，打开项目下的.setting文件夹，找到.setting文件夹内的org.eclipse.wst.common.project.facet.core.xml文件，文件格式大致如下：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  &lt;faceted-project&gt;      &lt;runtime name=\"Apache Tomcat v7.0\"/&gt;      &lt;fixed facet=\"java\"/&gt;      &lt;fixed facet=\"jst.web\"/&gt;      &lt;fixed facet=\"wst.jsdt.web\"/&gt;      &lt;installed facet=\"java\" version=\"1.7\"/&gt;      &lt;installed facet=\"jst.web\" version=\"3.0\"/&gt;      &lt;installed facet=\"wst.jsdt.web\" version=\"1.0\"/&gt;  &lt;/faceted-project&gt;  直接手动修改jst.web对应的version即可，最后重启Tomcat就可以正常使用了，然后刷新项目即可，若是在Eclispe中更改属性，则是无法更改的。"
  },
  
  {
    "title": "使用animation属性实现背景颜色动态渐变的效果",
    "url": "/posts/beijing-yanse-dongtai-jianbian/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2021-05-27 13:47:00 +0800",
    





    
    "snippet": "基础知识关键帧（传递点）是在动画中定义更改的帧。@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。@keyframes规则的名称声明为@keyframes + 任意名称。0％表示开始动画，100％表示结束时间。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。@...",
    "content": "基础知识关键帧（传递点）是在动画中定义更改的帧。@keyframes定义元素如何随每个关键帧而变化。为了使动画与其关键帧匹配，需要将@keyframes规则的名称与为元素指定的animation-name属性的名称相匹配。@keyframes规则的名称声明为@keyframes + 任意名称。0％表示开始动画，100％表示结束时间。下面的示例是将背景颜色从红色更改为橙色到粉红色的关键框架。@keyframes name {  0% { background: red; }  50% { background: orange; }  100% { background: pink; }}@-webkit-keyframes name {  0% { background: red; }  50% { background: orange; }  100% { background: pink; }}说明：对于Chrome和Safari等WebKit浏览器，需要供应商前缀（-webkit-）。以这种方式编写-webkit-keyframes。相关属性      animation-name（动画名）    @keyframes定义的名称。如果未指定此项，则不会执行动画。此外，如果指定的动画名称与任何关键帧都不匹配，则不会执行该关键帧。        animation-duration（动画持续时间）    通过秒 + s指定执行一个动画的时间长度。例如，5s持续5秒。如果为0，则不会执行。即使指定了负值，也会将其视为0。        animation-timing-function（动画定时功能）    指定动画的时间以及如何继续。可以通过调整动画进度速度的比例来表达平滑运动。        animation-delay（动画延迟）    读取元素时，从元素编号 + s指定“动画开始”的时间。例如，5s持续5秒。初始值0将立即执行。        animation-iteration-count（动画迭代计数）    使用数字指定重复动画的次数。infinite指定无限循环。        animation-direction（动画方向）    指定重复动画的方向。          normal：正常方向播放（初始值）。      alternate：在正常和偶数时间以相反方向重新生成奇数次。      reverse：向后播放。      alternate-reverse：反向播放。            animation-play-state（动画播放状态）          paused：暂停。      running：播放。            animation-fill-mode（动画填充模式）    指定播放动画之前和之后的状态。          none：默认值。      forwards：播放后保持最后一个关键帧的状态。      backwards：在播放前应用第一个关键帧的状态。      both … forwards：向前和向后都应用。      属性总结animation允许您分别指定每个属性的值，用空格分隔。项目可以省略，但动画名称必须在执行前写入。建议按以下顺序列出。animation-name（动画名称）animation-duration（动画持续时间）animation-timing-function（动画定时功能）animation-delay（动画延迟）animation-iteration-count（动画迭代计数）animation-direction（动画方向）animation-fill-mode（动画填充模式）animation-play-state（动画播放状态）具体实现在了解了基础的知识之后，我们来详细看看具体的实现方法。首先，将关键帧的名称设置为“bg-color”，并将背景颜色设置为从0到100％的过渡。@-webkit-keyframes bg-color {  0% { background-color: #e74c3c; }  20% { background-color: #f1c40f; }  40% { background-color: #1abc9c; }  60% { background-color: #3498db; }  80% { background-color: #9b59b6; }  100% { background-color: #e74c3c; }}@keyframes bg-color {  0% { background-color: #e74c3c; }  20% { background-color: #f1c40f; }  40% { background-color: #1abc9c; }  60% { background-color: #3498db; }  80% { background-color: #9b59b6; }  100% { background-color: #e74c3c; }}由于此时指定整个网页的背景颜色，body以animation指定属性。值分别为关键帧名称，bg-color更改在10秒内添加，无限循环infinite。不要忘记webkit的版本。body {  background-color: #e74c3c;  animation: bg-color 10s infinite;  -webkit-animation: bg-color 10s infinite;}完整代码&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style type=\"text/css\"&gt;      body {        background-color: #e74c3c;        animation: bg-color 10s infinite;        -webkit-animation: bg-color 10s infinite;      }      @-webkit-keyframes bg-color {        0% { background-color: #e74c3c; }        20% { background-color: #f1c40f; }        40% { background-color: #1abc9c; }        60% { background-color: #3498db; }        80% { background-color: #9b59b6; }        100% { background-color: #e74c3c; }      }      @keyframes bg-color {        0% { background-color: #e74c3c; }        20% { background-color: #f1c40f; }        40% { background-color: #1abc9c; }        60% { background-color: #3498db; }        80% { background-color: #9b59b6; }        100% { background-color: #e74c3c; }      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "项目中无法识别JDBC连接串的SID",
    "url": "/posts/xiangmuzhong-wufa-shibie-jdbc-zhongde-sid/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "将连接串：url: jdbc:oracle:thin@10.112.129.9:1521:jira修改为：url: jdbc:oracle:thin:@//10.112.129.9:1521/jira",
    "content": "将连接串：url: jdbc:oracle:thin@10.112.129.9:1521:jira修改为：url: jdbc:oracle:thin:@//10.112.129.9:1521/jira"
  },
  
  {
    "title": "Oracle 替换字符串",
    "url": "/posts/oracle-tihuan-zifuchuan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "replace(strSource, str1, str2)将strSource中的str1替换成str2  strSource：源字符串  str1: 要替换的字符串  str2: 替换后的字符串select '替换字符串' as oldStr, replace('替换字符串', '替换', '修改') as newStr from dual",
    "content": "replace(strSource, str1, str2)将strSource中的str1替换成str2  strSource：源字符串  str1: 要替换的字符串  str2: 替换后的字符串select '替换字符串' as oldStr, replace('替换字符串', '替换', '修改') as newStr from dual"
  },
  
  {
    "title": "Oracle substr函数和instr函数",
    "url": "/posts/oracle-substr-hanshu-he-instr-hanshu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "substr函数：截取字符串语法：SUBSTR(string, start, [length])  string：表示源字符串，即要截取的字符串。  start：开始位置，从1开始查找。如果start是负数，则从string字符串末尾开始算起。  length：可选项，表示截取字符串长度。示例：SELECT SUBSTR('Hello SQL!', 1) FROM dual --截取所有字符...",
    "content": "substr函数：截取字符串语法：SUBSTR(string, start, [length])  string：表示源字符串，即要截取的字符串。  start：开始位置，从1开始查找。如果start是负数，则从string字符串末尾开始算起。  length：可选项，表示截取字符串长度。示例：SELECT SUBSTR('Hello SQL!', 1) FROM dual --截取所有字符串，返回'Hello SQL!'SELECT SUBSTR('Hello SQL!', 2) FROM dual --从第2个字符开始，截取到末尾。返回'ello SQL!'SELECT SUBSTR('Hello SQL!', -4) FROM dual --从倒数第4个字符开始，截取到末尾。返回'SQL!'SELECT SUBSTR('Hello SQL!', 3, 6) FROM dual --从第3个字符开始，截取6个字符。返回'llo SQ'SELECT SUBSTR('Hello SQL!', -4, 3) FROM dual --从倒数第4个字符开始，截取3个字符。返回'SQL'instr函数：返回子字符串在源字符串中的位置语法：INSTR(string, child_string, [start], [show_time])  string：表示源字符串。  child_string：子字符串，即要查找的字符串。  start：可选项，开始位置，默认从1开始。如果为负数，则从右向左检索。  show_time：可选项，表示子字符串第几次出现在源字符串当中，默认第1次，负数则报错。示例：--表示从源字符串'city_company_staff'中第1个字符开始查找子字符串'_'第1次出现的位置SELECT INSTR('city_company_staff', '_') FROM dual --返回5--表示从源字符串'city_company_staff'中第5个字符开始查找子字符串'_'第1次出现的位置SELECT INSTR('city_company_staff', '_', 5) FROM dual --返回5--表示从源字符串'city_company_staff'中第5个字符开始查找子字符串'_'第1次出现的位置SELECT INSTR('city_company_staff', '_', 5, 1) FROM dual --返回5--表示从源字符串'city_company_staff'中第3个字符开始查找子字符串'_'第2次出现的位置SELECT INSTR('city_company_staff', '_', 3, 2) FROM dual --返回13--start参数为-1，从右向左检索，查找'_'字符串在源字符串中第1次出现的位置SELECT INSTR('city_company_staff', '_', -1, 1) FROM dual --返回13--start参数为-6，从右向左检索，查找'_'字符串在源字符串中第2次出现的位置SELECT INSTR('city_company_staff', '_', -6, 2) FROM dual --返回5substr函数结合instr函数截取字符串现有需求：数据查询处理需要对code进行”拆分”，code命名规则类似：城市_所属公司_员工职位_员工姓名，其中，城市、公司、职位、姓民字符串长度不固定，由于字符串长度不固定，只使用substr函数无法实现需求，需配合instr函数定位到字符'_'的位置，然后使用substr函数进行截取。详细见下面例子。表数据如下：SOURCE_CODEBJ_BAIDU_CEO_LYSH_BOKE_MANAGER_LWXHRB_WM_CASHIER_OYZY获取城市：SELECT  SUBSTR (SOURCE_CODE, 1, INSTR (SOURCE_CODE, '_', 1, 1) - 1) AS CITYFROM  TABLE_CODE_TEST结果：解释：此处截取源字符串SOURCE_CODE，从第1个字符开始，由于代表城市的code长度不固定，我们无法确定截取几个字符，所以使用instr函数判断第一个’_‘字符的位置，进而确定每个SOURCE_CODE截取几个字符串。那为什么减1呢？是因为INSTR (SOURCE_CODE, '_', 1, 1)获取的是源字符串中'_'字符第一次出现的位置，再减1就得出了CITY字符个数。获取公司：SELECT  SUBSTR (   SOURCE_CODE,     INSTR (SOURCE_CODE, '_', 1, 1) + 1,     INSTR (SOURCE_CODE, '_', 1, 2) - INSTR (SOURCE_CODE, '_', 1, 1)-1  ) AS COMPANYFROM  TABLE_CODE_TEST结果：解释：截取源字符串，从（第一个'_'出现位置+1）开始，截取个数为：第2个'_'出现位置减去第1个'_'出现位置，此时还多了一个下划线'_'，再减去1即可得到代表公司字符串。获取姓名：SELECT  SUBSTR (SOURCE_CODE, INSTR (SOURCE_CODE, '_', 1, 3) + 1) AS STF_NAMEFROM  TABLE_CODE_TEST结果：解释：截取源字符串，从（'_'第3次出现位置+1）开始截取，截取到末尾。"
  },
  
  {
    "title": "Oracle 拼接字符串",
    "url": "/posts/oracle-pinjie-zifuchuan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "1、使用||来拼接字符串：select '拼接'||'字符串' as Str from student;2、使用concat(param1, param2)函数实现：select concat('拼接', '字符串') as Str from student;注：oracle的concat()方法只支持两个参数，如果拼接多个参数，可以嵌套concat()：select concat(conc...",
    "content": "1、使用||来拼接字符串：select '拼接'||'字符串' as Str from student;2、使用concat(param1, param2)函数实现：select concat('拼接', '字符串') as Str from student;注：oracle的concat()方法只支持两个参数，如果拼接多个参数，可以嵌套concat()：select concat(concat('拼接', '字符串'), 'ab') as Str from student;"
  },
  
  {
    "title": "Oracle 分页的实现",
    "url": "/posts/oracle-fenye-de-shixian/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "通用分页格式，page是页码，size是每页显示条数。SELECT  *FROM  (    SELECT      T.*,      ROWNUM rn    FROM      (        SELECT          *        FROM          T_BASE_PROVINCE        ORDER BY          ID ASC      ) T ...",
    "content": "通用分页格式，page是页码，size是每页显示条数。SELECT  *FROM  (    SELECT      T.*,      ROWNUM rn    FROM      (        SELECT          *        FROM          T_BASE_PROVINCE        ORDER BY          ID ASC      ) T    WHERE      ROWNUM &lt;= page * size  )WHERE  rn &gt; (page - 1) * size;"
  },
  
  {
    "title": "Oracle 创建本地数据库",
    "url": "/posts/oracle-chuangjian-bendi-shujuku/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "  按住键盘上Windows键，打开开始菜单，找到Database Configuration Assitant并打开；  打开数据库配置助手Database Configuration Assitant，单击“下一步”，选择“创建数据库”，单击“下一步”；  选择“一般用途或事务处理”，单击“下一步”；  设置数据库的名称和实例名，两者可设置相同，也可以不同，单击“下一步”；  管理选项配...",
    "content": "  按住键盘上Windows键，打开开始菜单，找到Database Configuration Assitant并打开；  打开数据库配置助手Database Configuration Assitant，单击“下一步”，选择“创建数据库”，单击“下一步”；  选择“一般用途或事务处理”，单击“下一步”；  设置数据库的名称和实例名，两者可设置相同，也可以不同，单击“下一步”；  管理选项配置，不勾选配置Enterprise Manager，单击“下一步”；  数据库身份证明，可以为不同的账户分别设置不同的管理口令，也可以为所有账户设置同一口令，单击“下一步”；  数据库文件所在位置，默认存储类型：文件系统，存储位置：使用模版中的数据库文件位置，也可以自己指定存储路径，单击“下一步”；  恢复配置，指定快速恢复区；  数据库内容，根据需要，选择是否添加示例方案，单击“下一步”；  初始化参数，设置内存、字符集等，单击“下一步”；  数据库存储，控制文件、数据文件、重做日志文件位置设置，单击“下一步”；  创建选项，创建数据库，生成脚本，单击“完成”，开始创建数据库。"
  },
  
  {
    "title": "Oracle 查看汉字所占字节",
    "url": "/posts/oracle-chakan-hanzi-suozhan-zijie/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "使用以下语句查询select userenv('language') from dual;如果显示如下，一个汉字占用两个字节SIMPLIFIED CHINESE_CHINA.ZHS16GBK如果显示如下，一个汉字占用三个字节SIMPLIFIED CHINESE_CHINA.AL32UTF8也可以用以下语句查询一个汉字占用的字节长度select lengthb('你') from dual;",
    "content": "使用以下语句查询select userenv('language') from dual;如果显示如下，一个汉字占用两个字节SIMPLIFIED CHINESE_CHINA.ZHS16GBK如果显示如下，一个汉字占用三个字节SIMPLIFIED CHINESE_CHINA.AL32UTF8也可以用以下语句查询一个汉字占用的字节长度select lengthb('你') from dual;"
  },
  
  {
    "title": "Oracle add_month函数",
    "url": "/posts/oracle-add-month-hanshu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-19 13:47:00 +0800",
    





    
    "snippet": "SELECT  ADD_MONTHS (    TO_DATE (      TO_CHAR (SYSDATE, 'yyyy-MM-dd'),      'yyyy-MM-dd HH24:mi:ss'    ),    - 1  )FROM  dual执行结果为上一个月的今天。",
    "content": "SELECT  ADD_MONTHS (    TO_DATE (      TO_CHAR (SYSDATE, 'yyyy-MM-dd'),      'yyyy-MM-dd HH24:mi:ss'    ),    - 1  )FROM  dual执行结果为上一个月的今天。"
  },
  
  {
    "title": "Oracle 判断字符串是否相等，包含NULL的情况",
    "url": "/posts/oracle-panduan-zifuchuan-shifou-xiangdeng/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "在Oracle中，将空字符串视为null，任何值与null比较结果都为null。如此一来，在比较两个字符串的时候就会出现意外，例如：select * from test where str &lt;&gt; 'test';此时，值为null的记录不会显示出。应当将null转为其他字符串：select * from test where nvl(to_char(str),'xx') &lt;&...",
    "content": "在Oracle中，将空字符串视为null，任何值与null比较结果都为null。如此一来，在比较两个字符串的时候就会出现意外，例如：select * from test where str &lt;&gt; 'test';此时，值为null的记录不会显示出。应当将null转为其他字符串：select * from test where nvl(to_char(str),'xx') &lt;&gt; 'test';"
  },
  
  {
    "title": "Oracle 将查询出来的表数据修改一个或几个字段后，再插入到表中",
    "url": "/posts/oracle-jiang-chaxunchu-de-shuju-xiugaihou-charu/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "INSERT INTO  tableNameSELECT  seq_master.nextval, --自定义值（序列号）  TO_DATE('2012/01/01', 'YYYY/MM/DD'), --自定义值  CURR_SOURCE, --原始字段信息  CURR_DEST, --原始字段信息  EXCHANGE_RATE, --原始字段信息  SYSDATE, --自定义值 （系统时...",
    "content": "INSERT INTO  tableNameSELECT  seq_master.nextval, --自定义值（序列号）  TO_DATE('2012/01/01', 'YYYY/MM/DD'), --自定义值  CURR_SOURCE, --原始字段信息  CURR_DEST, --原始字段信息  EXCHANGE_RATE, --原始字段信息  SYSDATE, --自定义值 （系统时间）  COMPANY_CODEFROM  tableNameWHERE  TO_CHAR(EXPIRE_DATE, 'YYYY/MM/DD') = '2011/12/01'"
  },
  
  {
    "title": "Oracle 11g各种服务的作用以及哪些需要开启",
    "url": "/posts/oracle-ge-fuwu-de-zuoyong/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "Windwos server 2012 R2上成功安装Oracle 11g后共有7个服务，如果全局数据库名为orcl，则Oracle服务分别为：Oracle ORCL VSSWriter ServiceOracleDBConsoleorclOracleJobSchedulerORCLOracleMTSRecoveryServiceOracleOraDb11g_home1ClrAgentOra...",
    "content": "Windwos server 2012 R2上成功安装Oracle 11g后共有7个服务，如果全局数据库名为orcl，则Oracle服务分别为：Oracle ORCL VSSWriter ServiceOracleDBConsoleorclOracleJobSchedulerORCLOracleMTSRecoveryServiceOracleOraDb11g_home1ClrAgentOracleOraDb11g_home1TNSListenerOracleServiceORCL其中OracleOraDb11g_home1ClrAgent是默认为手动操作，其余的默认自动启动。这七个服务的含义分别为：  Oracle ORCL VSS Writer Service：Oracle卷映射拷贝写入服务，VSS(Volume Shadow Copy Service)能够让存储基础设备(比如磁盘，阵列等)创建高保真的时间点映像，即映射拷贝(shadow copy)。它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统能。(非必须启动)  OracleDBConsoleorcl：Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager(企业管理器OEM)的时候，需要启动这个服务。(非必须启动)  OracleJobSchedulerORCL：Oracle作业调度(定时器)服务，ORCL是Oracle实例标识。(非必须启动)  OracleMTSRecoveryService：服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。(非必须启动)  OracleOraDb11g_home1ClrAgent：Oracle数据库.NET扩展服务的一部分。 (非必须启动)  OracleOraDb11g_home1TNSListener：监听器服务，服务只有在数据库需要远程访问的时候才需要。(非必须启动)  OracleServiceORCL：数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础，只有该服务启动，Oracle数据库才能正常启动。(必须启动)那么在开发的时候到底需要启动哪些服务：  只用Oracle自带的sqlplus的话，只要启动OracleServiceORCL即可；  使用PL/SQL Developer等第三方工具的话，OracleOraDb11g_home1TNSListener服务也要开启；  OracleDBConsoleorcl是进入基于web的EM必须开启的，其余服务很少用。"
  },
  
  {
    "title": "Oracle 查询表中重复数据",
    "url": "/posts/oracle-chaxun-biaozhong-chongfu-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-18 13:47:00 +0800",
    





    
    "snippet": "1、查找表中的重复记录，重复记录是根据单个字段（peopleId）来判断SELECT  *FROM  peopleWHERE  peopleId IN (    SELECT      peopleId    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )2、删除表中多余的...",
    "content": "1、查找表中的重复记录，重复记录是根据单个字段（peopleId）来判断SELECT  *FROM  peopleWHERE  peopleId IN (    SELECT      peopleId    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录DELETE FROM  peopleWHERE  peopleId IN (    SELECT      peopleId    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )  AND rowid NOT IN (    SELECT      min(rowid)    FROM      people    GROUP BY      peopleId    HAVING      count(peopleId) &gt; 1  )3、查找表中多余的重复记录（多个字段） SELECT  *FROM  vitae aWHERE  (a.peopleId, a.seq) IN (    SELECT      peopleId,      seq    FROM      vitae    GROUP BY      peopleId,      seq    HAVING      count(*) &gt; 1  )4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录DELETE FROM  vitae aWHERE  (a.peopleId, a.seq) IN (    SELECT      peopleId,      seq    FROM      vitae    GROUP BY      peopleId,      seq    HAVING      count(*) &gt; 1  )  AND rowid NOT IN (    SELECT      min(rowid)    FROM      vitae    GROUP BY      peopleId,      seq    HAVING      count(*) &gt; 1  )比方说，在A表中存在一个字段“name”，而且不同记录之间的“name”值有可能会相同，现在就需要查询出在该表中的各记录之间，“name”值存在重复的项SELECT  NAME,  Count(*)FROM  AGROUP BY  NAMEHAVING  Count(*) &gt; 1如果还查性别也相同大则如下SELECT  NAME,  sex,  Count(*)FROM  AGROUP BY  NAME,  sexHAVING  Count(*) &gt; 1"
  },
  
  {
    "title": "Oracle 查询包含大小写的数据",
    "url": "/posts/oracle-chaxun-baohan-daxiaoxie-de-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-05-10 13:47:00 +0800",
    





    
    "snippet": "查询包含小写的所有数据select oper_no from info_oper where regexp_like(oper_no,'[[:lower:]]');select oper_no from info_oper where regexp_like(oper_no,'[a-z]');查询包含大写的所有数据select oper_no from info_oper where reg...",
    "content": "查询包含小写的所有数据select oper_no from info_oper where regexp_like(oper_no,'[[:lower:]]');select oper_no from info_oper where regexp_like(oper_no,'[a-z]');查询包含大写的所有数据select oper_no from info_oper where regexp_like(oper_no,'[[:upper:]]');select oper_no from info_oper where regexp_like(oper_no,'[A-Z]'); "
  },
  
  {
    "title": "Spring Boot如何快速切换配置",
    "url": "/posts/springboot-ruhe-kuaisu-qiehuan-peizhi/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2021-03-26 13:47:00 +0800",
    





    
    "snippet": "如果，我们有生产环境和开发环境，怎样更简单的切换配置呢？创建一个开发环境用的yml：application-dev.yml创建一个生产环境用的yml：application-prod.yml假如再有个都要使用的yml：application-common.yml写一个总的配置来集成他们：application.yml在不同的要求下，切换相应的配置文件即可。  参考：【springboot】【...",
    "content": "如果，我们有生产环境和开发环境，怎样更简单的切换配置呢？创建一个开发环境用的yml：application-dev.yml创建一个生产环境用的yml：application-prod.yml假如再有个都要使用的yml：application-common.yml写一个总的配置来集成他们：application.yml在不同的要求下，切换相应的配置文件即可。  参考：【springboot】【三】yml 配置文件（怎样更加简便的获取到配置文件中的属性，以便每个class都能快速获取到）"
  },
  
  {
    "title": "IntelliJ IDEA运行报Command line is too long的问题",
    "url": "/posts/intelliJ-idea-yunxing-xiangmu-bao-command-line-is-too-long/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "打开程序的运行配置，把Shorten command line改为JAR manifest或classpath file，如图所示：   参考：解决Intellij IDEA运行报Command line is too long的问题",
    "content": "打开程序的运行配置，把Shorten command line改为JAR manifest或classpath file，如图所示：   参考：解决Intellij IDEA运行报Command line is too long的问题"
  },
  
  {
    "title": "IntelliJ IDEA一键清除所有断点",
    "url": "/posts/intelliJ-idea-yijian-qingchu-suoyou-duandian/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "1.在IDEA左下方找到”View Breakpoints”按钮，点击打开2.点击”Java Line Breakpoints”前方的全选框，取消全选3.点击上方”-“即”Remove”按钮，即可取消所有Breakpoints4.清除断点后，点击”Done”  参考：intellij idea 如何一键清除所有断点",
    "content": "1.在IDEA左下方找到”View Breakpoints”按钮，点击打开2.点击”Java Line Breakpoints”前方的全选框，取消全选3.点击上方”-“即”Remove”按钮，即可取消所有Breakpoints4.清除断点后，点击”Done”  参考：intellij idea 如何一键清除所有断点"
  },
  
  {
    "title": "IntelliJ IDEA取消参数名称（形参名）提示",
    "url": "/posts/intelliJ-idea-quxiao-xingcanming-tishi/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "File -&gt; Setting -&gt; Editor -&gt; General -&gt; Appearance 把“Show parameter name hints”选项前面的勾去掉，点击“OK”，完成。  参考：IDEA取消参数名称（形参名）提示",
    "content": "File -&gt; Setting -&gt; Editor -&gt; General -&gt; Appearance 把“Show parameter name hints”选项前面的勾去掉，点击“OK”，完成。  参考：IDEA取消参数名称（形参名）提示"
  },
  
  {
    "title": "IntelliJ IDEA的Run Dashboard如何显示出来",
    "url": "/posts/intelliJ-idea-de-rundashboard-ruhe-xianshi-chulai/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-26 13:23:00 +0800",
    





    
    "snippet": "点击如图所示位置的下来三角按钮，然后选择Edit Configurations，或者点击菜单栏Run -&gt; Edit Configurations在运行配置窗口，选择一条Spring Boot的运行配置，然后点击上方的复制按钮进行复制副本复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run conf...",
    "content": "点击如图所示位置的下来三角按钮，然后选择Edit Configurations，或者点击菜单栏Run -&gt; Edit Configurations在运行配置窗口，选择一条Spring Boot的运行配置，然后点击上方的复制按钮进行复制副本复制完成之后，点击OK确定按钮，然后在屏幕右下角可以看到一个弹框提示点击弹框右下角的向下的小箭头，展开弹框详情信息，然后点击Show run configurations in Run Dashboard如图所示，则立即可以看到Run Dashboard窗口已经成功显示出来了，在Run Dashboard中可以看到当前所有的启动配置，直接点击可以方便的启动和停止如图以上方法还没有显示出来的话，则可以通过修改IDEA的workspace.xml的方式来快速打开Run Dashboard窗口打开workspace.xml文件之后，找到component为RunDashboard的节点处，然后在component标签里添加&lt;option name=\"configurationTypes\"&gt;    &lt;set&gt;        &lt;option value=\"SpringBootApplicationConfigurationType\" /&gt;    &lt;/set&gt;&lt;/option&gt;最后保存即可，保存完成之后立即自动弹出Run Dashboard窗口了  参考：springboot在idea的RunDashboard如何显示出来"
  },
  
  {
    "title": "IntelliJ IDEA项目目录的文件名显示为红色的解决办法",
    "url": "/posts/intelliJ-idea-wenjianming-xianshi-hongse/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-18 13:23:00 +0800",
    





    
    "snippet": "报错信息导入IDEA的项目文件显示为红色。报错原因项目目录中存在版本控制文件所导致的，解决办法就是——解除版本控制。解决方法File –&gt; settings –&gt; version control或者使用快捷键CTRL + ALT + S进入设置界面，在右侧的目录列表中选择项目后面的Subversion改成&lt;none&gt;即可。  参考：IDEA项目目录的文件名显示为红色的...",
    "content": "报错信息导入IDEA的项目文件显示为红色。报错原因项目目录中存在版本控制文件所导致的，解决办法就是——解除版本控制。解决方法File –&gt; settings –&gt; version control或者使用快捷键CTRL + ALT + S进入设置界面，在右侧的目录列表中选择项目后面的Subversion改成&lt;none&gt;即可。  参考：IDEA项目目录的文件名显示为红色的解决办法"
  },
  
  {
    "title": "IntelliJ IDEA项目目录的Java类文件名的左下角出现红圈",
    "url": "/posts/intelliJ-idea-wenjian-zuoxiajiao-chuxian-hongquan/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-18 13:23:00 +0800",
    





    
    "snippet": "报错信息src目录下的Java类的名字的左下角出现红圈并且中间有一个字母J。按住CTRL点左键的时候出现“cannot find declaration to go to”。报错原因模块路径错误。解决方法File –&gt; Project Structure –&gt; Modules进入模块设置界面，重新添加工程路径即可。   参考：idea的src目录下的java类文件名的左下角出现红...",
    "content": "报错信息src目录下的Java类的名字的左下角出现红圈并且中间有一个字母J。按住CTRL点左键的时候出现“cannot find declaration to go to”。报错原因模块路径错误。解决方法File –&gt; Project Structure –&gt; Modules进入模块设置界面，重新添加工程路径即可。   参考：idea的src目录下的java类文件名的左下角出现红圈中间有一个小j字母的解决方法（完美解决）"
  },
  
  {
    "title": "IntelliJ IDEA中非Maven项目如何引用jar包",
    "url": "/posts/intelliJ-idea-feimaven-xiangmu-ruhe-yinru-jarbao/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2021-03-18 13:23:00 +0800",
    





    
    "snippet": "在引用jar包方面IDEA和Eclipse是不一样的，直接复制到lib是没用的，无法自动导包。IDEA引入jar包流程：打开File -&gt; Project Structure -&gt; Modules -&gt; Dependencies -&gt; 加号 -&gt; 1. Jars or directories…  参考：IDEA中非Maven项目如何引用jar包？为什么直接放到l...",
    "content": "在引用jar包方面IDEA和Eclipse是不一样的，直接复制到lib是没用的，无法自动导包。IDEA引入jar包流程：打开File -&gt; Project Structure -&gt; Modules -&gt; Dependencies -&gt; 加号 -&gt; 1. Jars or directories…  参考：IDEA中非Maven项目如何引用jar包？为什么直接放到lib中无效？"
  },
  
  {
    "title": "Python的一些常用操作",
    "url": "/posts/python-yixie-changyong-de-caozuo/",
    "categories": "Knowledge, Python",
    "tags": "Python",
    "date": "2021-03-09 13:47:00 +0800",
    





    
    "snippet": "Python删除文件使用python删除一个文件或文件夹，需要使用os模块。import ospath = 'F:/新建文本文档.txt'  # 文件路径if os.path.exists(path):  # 如果文件存在    # 删除文件，可使用以下两种方法。    os.remove(path)      #os.unlink(path)else:    print('no such ...",
    "content": "Python删除文件使用python删除一个文件或文件夹，需要使用os模块。import ospath = 'F:/新建文本文档.txt'  # 文件路径if os.path.exists(path):  # 如果文件存在    # 删除文件，可使用以下两种方法。    os.remove(path)      #os.unlink(path)else:    print('no such file:%s'%my_file)  # 则返回文件不存在Python创建文件并写入new_page = FILE_PATH + \"\\test.txt\"    with open(new_page, 'w+') as file:        file.write(\"test\\n\")Python获取文件修改时间mtime = os.stat(file).st_mtimefile_modify_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(mtime))"
  },
  
  {
    "title": "使用Javamail通过SMTP协议发信",
    "url": "/posts/shiyong-javamail-tongguo-smtp-xieyi-faxin/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-03-04 13:47:00 +0800",
    





    
    "snippet": "package mail.util;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.io.UnsupportedEncodingException;import java.util.Properties;publi...",
    "content": "package mail.util;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.io.UnsupportedEncodingException;import java.util.Properties;public class SampleMail {    private static final String ALIDM_SMTP_HOST = \"smtpdm.aliyun.com\";    private static final String ALIDM_SMTP_PORT = \"25\"; // 或\"80\"    public static void main(String[] args) throws UnsupportedEncodingException {        // 配置发送邮件的环境属性        final Properties props = new Properties();        // 表示SMTP发送邮件，需要进行身份验证        props.put(\"mail.smtp.auth\", \"true\");        props.put(\"mail.smtp.host\", ALIDM_SMTP_HOST);        props.put(\"mail.smtp.port\", ALIDM_SMTP_PORT);        // 如果使用SSL，则去掉使用25端口的配置，进行如下配置,        // props.put(\"mail.smtp.socketFactory.class\",         //       \"javax.net.ssl.SSLSocketFactory\");        // props.put(\"mail.smtp.socketFactory.port\", \"465\");        // props.put(\"mail.smtp.port\", \"465\");        // 发件人的账号，填写控制台配置的发信地址,比如xxx@xxx.com        props.put(\"mail.user\", \"发信地址\");        // 访问SMTP服务时需要提供的密码(在控制台选择发信地址进行设置)        props.put(\"mail.password\", \"***\");        // 构建授权信息，用于进行SMTP进行身份验证        Authenticator authenticator = new Authenticator() {            @Override            protected PasswordAuthentication getPasswordAuthentication() {                // 用户名、密码                String userName = props.getProperty(\"mail.user\");                String password = props.getProperty(\"mail.password\");                return new PasswordAuthentication(userName, password);            }        };                // 使用环境属性和授权信息，创建邮件会话        Session mailSession = Session.getInstance(props, authenticator);        // mailSession.setDebug(true);        // UUID uuid = UUID.randomUUID();        // final String messageIDValue = \"&lt;\" + uuid.toString() + \"&gt;\";        // 创建邮件消息        MimeMessage message = new MimeMessage(mailSession) {            // @Override            // protected void updateMessageID() throws MessagingException {            // 设置自定义Message-ID值            // setHeader(\"Message-ID\", messageIDValue);            // }        };        try {            // 设置发件人邮件地址和名称。填写控制台配置的发信地址，            // 比如xxx@xxx.com。和上面的mail.user保持一致，            // 发件人名称用户可以自定义填写。            InternetAddress from = new InternetAddress(\"发信地址\", \"发件人名称\");            message.setFrom(from);            // 可选，设置回信地址            Address[] a = new Address[1];            a[0] = new InternetAddress(\"***\");            message.setReplyTo(a);            // 设置收件人邮件地址，比如yyy@yyy.com            InternetAddress to = new InternetAddress(\"收件人邮件地址\");            message.setRecipient(MimeMessage.RecipientType.TO, to);            // 如果同时发给多人，才将上面两行替换为如下（因为部分收信系统的一些限制，            // 尽量每次投递给一个人；同时我们限制单次允许发送的人数是30人）：            // InternetAddress[] adds = new InternetAddress[2];            // adds[0] = new InternetAddress(\"xxxxx@qq.com\");            // adds[1] = new InternetAddress(\"xxxxx@qq.com\");            // message.setRecipients(Message.RecipientType.TO, adds);            String ccUser = \"抄送邮箱\";            // 设置多个抄送地址            if (null != ccUser &amp;&amp; !ccUser.isEmpty()) {                @SuppressWarnings(\"static-access\")                InternetAddress[] internetAddressCC = new InternetAddress()                    .parse(ccUser);                message.setRecipients(Message.RecipientType.CC, internetAddressCC);            }            String bccUser = \"密送邮箱\";            // 设置多个密送地址            if (null != bccUser &amp;&amp; !bccUser.isEmpty()) {                @SuppressWarnings(\"static-access\")                InternetAddress[] internetAddressBCC = new InternetAddress()                    .parse(bccUser);                message.setRecipients(Message.RecipientType.BCC, internetAddressBCC);            }            // 设置邮件标题            message.setSubject(\"测试邮件\");            // 设置邮件的内容体            message.setContent(\"测试的HTML邮件\", \"text/html;charset=UTF-8\");                        // 若需要开启邮件跟踪服务，请使用以下代码设置跟踪链接头。首先域名需要备案，            // 设置且已正确解析了CNAME配置；其次发信需要打Tag，此Tag在控制台已创建并存在，            // Tag创建10分钟后方可使用；            // String tagName = \"Test\";            // HashMap&lt;String, String&gt; trace = new HashMap&lt;&gt;();            // trace.put(\"OpenTrace\", \"1\");            // trace.put(\"TagName\", tagName);            // String jsonTrace = JSON.toJSONString(trace);            // String base64Trace = new String(Base64            //    .encodeBase64(jsonTrace.getBytes()));            // 设置跟踪链接头            // message.addHeader(\"X-AliDM-Trace\", base64Trace);            // 发送附件，总的邮件大小不超过15M，创建消息部分            // BodyPart messageBodyPart = new MimeBodyPart();            // 消息            // messageBodyPart.setText(\"消息Text\");            // 创建多重消息            // Multipart multipart = new MimeMultipart();            // 设置文本消息部分            // multipart.addBodyPart(messageBodyPart);            // 附件部分            // messageBodyPart = new MimeBodyPart();            // 设置要发送附件的文件路径            // String filename = \"D:\\\\goProjects\\\\src\\\\测试pdf.pdf\";            // FileDataSource source = new FileDataSource(filename);            // messageBodyPart.setDataHandler(new DataHandler(source));            // 处理附件名称中文（附带文件路径）乱码问题            // messageBodyPart.setFileName(MimeUtility.encodeText(filename));            // messageBodyPart.addHeader(\"Content-Transfer-Encoding\", \"base64\");            // multipart.addBodyPart(messageBodyPart);            // 发送含有附件的完整消息            // message.setContent(multipart);            // 发送附件代码，结束            // 发送邮件            Transport.send(message);        } catch (MessagingException e) {            String err = e.getMessage();            // 在这里处理message内容， 格式是固定的            System.out.println(err);        }    }    }  参考：SMTP 之 Java 调用示例"
  },
  
  {
    "title": "MySQL中对字符串类型字段进行数字值排序",
    "url": "/posts/dui-zifuchuan-leixing-ziduan-jinxing-shuzizhi-paixu/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-01-31 13:47:00 +0800",
    





    
    "snippet": "-- 方式一SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMBER + 0 DESC                -- 方式二        SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMB...",
    "content": "-- 方式一SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMBER + 0 DESC                -- 方式二        SELECT    * FROM    TABLE_TEST WHERE    STATUS = '1' ORDER BY    ORDER_NUMBER * 1 DESC"
  },
  
  {
    "title": "Unable to load annotation processor factory",
    "url": "/posts/unable-to-load-annotation-processor-factory/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2021-01-31 13:47:00 +0800",
    





    
    "snippet": "报错信息Description Resource Path Location TypeUnable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar’ for project XXXXXXXXX Annotation processor factory path A...",
    "content": "报错信息Description Resource Path Location TypeUnable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar’ for project XXXXXXXXX Annotation processor factory path APT Build Problem.Description Resource Path Location TypeUnable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\tools.jar’ for project XXXXXXXXX Annotation processor factory path APT Build Problem说明  重点在annotation processor factory找不到C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar。  annotation processor注解的处理器是项目properties中java compiler里的。  C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\tools.jar和jconsole.jar都是JDK里的。解决方法  参考：Unable to load annotation processor factory ‘C:\\Program Files\\Java\\jdk1.8.1_11\\lib\\jconsole.jar’"
  },
  
  {
    "title": "Maven全局配置文件settings.xml详解",
    "url": "/posts/maven-quanju-peizhi-wenjian-xiangjie/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "一、概要1.1 settings.xml的作用它是用来设置Maven参数的配置文件。并且，settings.xml是Maven的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。1.2 settings.xml文件位置settings.xml文件一般存在于Maven的安装目录的conf子目录下面，或者是用户目录的.m2子目录下面。1.3 配置的优先...",
    "content": "一、概要1.1 settings.xml的作用它是用来设置Maven参数的配置文件。并且，settings.xml是Maven的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。1.2 settings.xml文件位置settings.xml文件一般存在于Maven的安装目录的conf子目录下面，或者是用户目录的.m2子目录下面。1.3 配置的优先级其实相对于多用户的PC机而言，在Maven安装目录的conf子目录下面的settings.xml才是真正的全局的配置。而用户目录的.m2子目录下面的settings.xml的配置只是针对当前用户的。当这两个文件同时存在的时候，那么对于相同的配置信息用户目录下面的settings.xml中定义的会覆盖Maven安装目录下面的settings.xml中的定义。用户目录下的settings.xml文件一般是不存在的，但是Maven允许我们在这里定义我们自己的settings.xml，如果需要在这里定义我们自己的settings.xml的时候就可以把Maven安装目录下面的settings.xml文件拷贝到用户目录的.m2目录下，然后改成自己想要的样子。二、settings.xml元素详解顶级元素概览&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0                          https://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  &lt;localRepository/&gt;  &lt;interactiveMode/&gt;  &lt;usePluginRegistry/&gt;  &lt;offline/&gt;  &lt;pluginGroups/&gt;  &lt;servers/&gt;  &lt;mirrors/&gt;  &lt;proxies/&gt;  &lt;profiles/&gt;  &lt;activeProfiles/&gt;&lt;/settings&gt;2.1 LocalRepository作用：该值表示构建系统本地仓库的路径。其默认值：~/.m2/repository。&lt;localRepository&gt;${user.home}/.m2/repository&lt;/localRepository&gt;2.2 InteractiveMode作用：表示Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。&lt;interactiveMode&gt;true&lt;/interactiveMode&gt;2.3 UsePluginRegistry作用：Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。&lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt;2.4 Offline作用：这个属性表示在Maven进行项目编译和部署等操作时是否允许Maven进行联网来下载所需要的信息。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。&lt;offline&gt;false&lt;/offline&gt;2.5 PluginGroups作用：在pluginGroups元素下面可以定义一系列的pluginGroup元素。表示当通过plugin的前缀来解析plugin的时候到哪里寻找。pluginGroup元素指定的是plugin的groupId。默认情况下，Maven会自动把org.apache.maven.plugins和org.codehaus.mojo添加到pluginGroups下。&lt;pluginGroups&gt;  &lt;!--plugin的组织Id（groupId） --&gt;  &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt;&lt;/pluginGroups&gt;2.6 Servers作用：一般，仓库的下载和部署是在pom.xml文件中的repositories和distributionManagement元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，这些信息可以配置在settings.xml中。&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;&lt;servers&gt;  &lt;!--服务器元素包含配置服务器时需要的信息 --&gt;  &lt;server&gt;    &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;    &lt;id&gt;server001&lt;/id&gt;    &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt;    &lt;username&gt;my_login&lt;/username&gt;    &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --&gt;    &lt;password&gt;my_password&lt;/password&gt;    &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt;    &lt;privateKey&gt;${usr.home}/.ssh/id_dsa&lt;/privateKey&gt;    &lt;!--鉴权时使用的私钥密码。 --&gt;    &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt;    &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt;    &lt;filePermissions&gt;664&lt;/filePermissions&gt;    &lt;!--目录被创建时的权限。 --&gt;    &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt;  &lt;/server&gt;&lt;/servers&gt;2.7 Mirrors作用：用于定义一系列的远程仓库的镜像。我们可以在pom中定义一个下载工件的时候所使用的远程仓库。但是有时候这个远程仓库会比较忙，所以这个时候人们就想着给它创建镜像以缓解远程仓库的压力，也就是说会把对远程仓库的请求转换到对其镜像地址的请求。每个远程仓库都会有一个id，这样我们就可以创建自己的mirror来关联到该仓库，那么以后需要从远程仓库下载工件的时候Maven就可以从我们定义好的mirror站点来下载，这可以很好的缓解我们远程仓库的压力。在我们定义的mirror中每个远程仓库都只能有一个mirror与它关联，也就是说你不能同时配置多个mirror的mirrorOf指向同一个repositoryId。&lt;mirrors&gt;  &lt;!-- 给定仓库的下载镜像。 --&gt;  &lt;mirror&gt;    &lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;    &lt;id&gt;mirrorId&lt;/id&gt;    &lt;!-- 镜像名称 --&gt;    &lt;name&gt;PlanetMirror Australia&lt;/name&gt;    &lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;    &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt;    &lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;    &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;2.8 Proxies作用：用来配置不同的代理。&lt;proxies&gt;  &lt;!--代理元素包含配置代理时需要的信息 --&gt;  &lt;proxy&gt;    &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;    &lt;id&gt;myproxy&lt;/id&gt;    &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt;    &lt;active&gt;true&lt;/active&gt;    &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;    &lt;protocol&gt;http&lt;/protocol&gt;    &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;    &lt;host&gt;proxy.somewhere.com&lt;/host&gt;    &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;    &lt;port&gt;8080&lt;/port&gt;    &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;    &lt;username&gt;proxyuser&lt;/username&gt;    &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt;    &lt;password&gt;somepassword&lt;/password&gt;    &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;    &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt;  &lt;/proxy&gt;&lt;/proxies&gt;2.9 Profiles作用：根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id、activation、repositories、pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings.xml中的profile被激活，它的值会覆盖任何其它定义在pom.xml中带有相同id的profile。当所有的约束条件都满足的时候就会激活这个profile。&lt;profiles&gt;    &lt;profile&gt;　　&lt;!-- profile的唯一标识 --&gt;        &lt;id&gt;test&lt;/id&gt;             &lt;!-- 自动触发profile的条件逻辑 --&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;false&lt;/activeByDefault&gt;            &lt;jdk&gt;1.6&lt;/jdk&gt;            &lt;os&gt;                &lt;name&gt;Windows 7&lt;/name&gt;                &lt;family&gt;Windows&lt;/family&gt;                &lt;arch&gt;x86&lt;/arch&gt;                &lt;version&gt;5.1.2600&lt;/version&gt;            &lt;/os&gt;            &lt;property&gt;                &lt;name&gt;mavenVersion&lt;/name&gt;                &lt;value&gt;2.0.3&lt;/value&gt;            &lt;/property&gt;            &lt;file&gt;                &lt;exists&gt;${basedir}/file2.properties&lt;/exists&gt;                &lt;missing&gt;${basedir}/file1.properties&lt;/missing&gt;            &lt;/file&gt;        &lt;/activation&gt;        &lt;!-- 扩展属性列表 --&gt;        &lt;properties /&gt;        &lt;!-- 远程仓库列表 --&gt;        &lt;repositories /&gt;        &lt;!-- 插件仓库列表 --&gt;        &lt;pluginRepositories /&gt;      ...    &lt;/profile&gt;&lt;/profiles&gt;2.9.1 Activation作用：自动触发profile的条件逻辑。这是profile中最重要的元素。跟pom.xml中的profile一样，settings.xml中的profile也可以在特定环境下改变一些值，而这些环境是通过activation元素来指定的。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。  jdk：表示当jdk的版本满足条件的时候激活，在这里是1.6。这里的版本还可以用一个范围表示，如  &lt;jdk&gt;[1.4,1.7)&lt;/jdk&gt;表示1.4、1.5和1.6满足；  &lt;jdk&gt;[1.4,1.7]&lt;/jdk&gt;表示1.4、1.5、1.6和1.7满足；  os：表示当操作系统满足条件的时候激活。  property：property是键值对的形式，表示当Maven检测到了这样一个键值对的时候就激活该profile。          下面的示例表示当存在属性hello的时候激活该profile。        &lt;property&gt;    &lt;name&gt;hello&lt;/name&gt;&lt;/property&gt;                    下面的示例表示当属性hello的值为world的时候激活该profile。        &lt;property&gt;    &lt;name&gt;hello&lt;/name&gt;    &lt;value&gt;world&lt;/value&gt;&lt;/property&gt;                这个时候如果要激活该profile的话，可以在调用Maven指令的时候加上参数hello并指定其值为world，如：mvn compile –Dhello=world              file：表示当文件存在或不存在的时候激活，exists表示存在，missing表示不存在。如下面例子表示当文件hello/world不存在的时候激活该profile。      &lt;profile&gt;      &lt;activation&gt;          &lt;file&gt;              &lt;missing&gt;hello/world&lt;/missing&gt;          &lt;/file&gt;      &lt;/activation&gt;  &lt;/profile&gt;        activeByDefault：当其值为true的时候表示如果没有其他的profile处于激活状态的时候，该profile将自动被激活。  properties：用于定义属性键值对的。当该profile是激活状态的时候，properties下面指定的属性都可以在pom.xml中使用。对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在pom.xml中的任何地方使用标记${X}来使用，这里X是指属性的名称。属性有五种不同的形式，并且都能在settings.xml文件中访问。      &lt;!--  1、env.X: 在一个变量前加上\"env.\"的前缀，会返回一个shell环境变量。例如,\"env.PATH\"指代了$path环境变量（在Windows上是%PATH%）。  2、project.x：指代了POM中对应的元素值。例如: &lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;通过${project.version}获得version的值。  3、settings.x: 指代了settings.xml中对应元素的值。例如：&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;通过 ${settings.offline}获得offline的值。  4、Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 ${java.home}。  5、x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以${someVar}的形式使用。  --&gt;  &lt;properties&gt;      &lt;user.install&gt;${user.home}/our-project&lt;/user.install&gt;  &lt;/properties&gt;        注：如果该profile被激活，则可以在pom.xml中使用${user.install}。    repositories：用于定义远程仓库的，当该profile是激活状态的时候，这里面定义的远程仓库将作为当前pom的远程仓库。它是Maven用来填充构建系统本地仓库所使用的一组远程仓库。      &lt;repositories&gt;  &lt;!--包含需要连接到远程仓库的信息 --&gt;  &lt;repository&gt;      &lt;!--远程仓库唯一标识 --&gt;      &lt;id&gt;codehausSnapshots&lt;/id&gt;      &lt;!--远程仓库名称 --&gt;      &lt;name&gt;Codehaus Snapshots&lt;/name&gt;      &lt;!--如何处理远程仓库里发布版本的下载 --&gt;      &lt;releases&gt;      &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;      &lt;enabled&gt;false&lt;/enabled&gt;      &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;      &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;      &lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --&gt;      &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt;      &lt;/releases&gt;      &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;      &lt;snapshots&gt;      &lt;enabled /&gt;      &lt;updatePolicy /&gt;      &lt;checksumPolicy /&gt;      &lt;/snapshots&gt;      &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;      &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt;      &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;      &lt;layout&gt;default&lt;/layout&gt;  &lt;/repository&gt;  &lt;/repositories&gt;              releases、snapshots：这是对于工件的类型的限制。      enabled：表示这个仓库是否允许这种类型的工件      updatePolicy：表示多久尝试更新一次。可选值有always、daily、interval:minutes（表示每多久更新一次）和never。      checksumPolicy：当Maven在部署项目到仓库的时候会连同校验文件一起提交，checksumPolicy表示当这个校验文件缺失或不正确的时候该如何处理，可选项有ignore、fail和warn。      pluginRepositories：在Maven中有两种类型的仓库，一种是存储工件的仓库，另一种就是存储plugin插件的仓库。pluginRepositories的定义和repositories的定义类似，它表示Maven在哪些地方可以找到所需要的插件。和repository类似，只是repository是管理jar包依赖的仓库，pluginRepositories则是管理插件的仓库。maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。        &lt;pluginRepositories&gt;&lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;&lt;pluginRepository&gt;    &lt;releases&gt;    &lt;enabled /&gt;    &lt;updatePolicy /&gt;    &lt;checksumPolicy /&gt;    &lt;/releases&gt;    &lt;snapshots&gt;    &lt;enabled /&gt;    &lt;updatePolicy /&gt;    &lt;checksumPolicy /&gt;    &lt;/snapshots&gt;    &lt;id /&gt;    &lt;name /&gt;    &lt;url /&gt;    &lt;layout /&gt;&lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;                示例：        &lt;activation&gt;&lt;!--profile默认是否激活的标识 --&gt;&lt;activeByDefault&gt;false&lt;/activeByDefault&gt;&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;&lt;jdk&gt;1.5&lt;/jdk&gt;&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;&lt;os&gt;    &lt;!--激活profile的操作系统的名字 --&gt;    &lt;name&gt;Windows XP&lt;/name&gt;    &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;    &lt;family&gt;Windows&lt;/family&gt;    &lt;!--激活profile的操作系统体系结构 --&gt;    &lt;arch&gt;x86&lt;/arch&gt;    &lt;!--激活profile的操作系统版本 --&gt;    &lt;version&gt;5.1.2600&lt;/version&gt;&lt;/os&gt;&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;&lt;property&gt;    &lt;!--激活profile的属性的名称 --&gt;    &lt;name&gt;mavenVersion&lt;/name&gt;    &lt;!--激活profile的属性的值 --&gt;    &lt;value&gt;2.0.3&lt;/value&gt;&lt;/property&gt;&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;&lt;file&gt;    &lt;!--如果指定的文件存在，则激活profile。 --&gt;    &lt;exists&gt;${basedir}/file2.properties&lt;/exists&gt;    &lt;!--如果指定的文件不存在，则激活profile。 --&gt;    &lt;missing&gt;${basedir}/file1.properties&lt;/missing&gt;&lt;/file&gt;&lt;/activation&gt;                    2.10 ActiveProfiles作用：手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0                      https://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt;  ...  &lt;activeProfiles&gt;    &lt;!-- 要激活的profile id --&gt;    &lt;activeProfile&gt;env-test&lt;/activeProfile&gt;  &lt;/activeProfiles&gt;  ...&lt;/settings&gt;"
  },
  
  {
    "title": "Linux 用户操作",
    "url": "/posts/linux-yonghu-caozuo/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "查看用户列表 cat /etc/passwd 或者 cat /etc/shadow增加/修改/删除用户 useradd/usermod/userdel增加/修改/删除用户组 groupadd/groupmod/groupdel修改密码 passwd &lt;accountName&gt;",
    "content": "查看用户列表 cat /etc/passwd 或者 cat /etc/shadow增加/修改/删除用户 useradd/usermod/userdel增加/修改/删除用户组 groupadd/groupmod/groupdel修改密码 passwd &lt;accountName&gt;"
  },
  
  {
    "title": "next()和nextLine()的区别",
    "url": "/posts/next-he-nextline-de-qubie/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "  next()这个函数会扫描从有效字符起到空格，Tab，回车等结束字符之间的内容并作为String返回。  nextLine()这个函数在输入完一些东西之后按下回车则视为输入结束，输入的内容将被作为String返回。  next()这个函数与之不同在于，next()什么都不输入直接敲回车不会返回，而nextLine()即使不输入东西直接敲回车也会返回。再举个例子，输入abc def gh\\...",
    "content": "  next()这个函数会扫描从有效字符起到空格，Tab，回车等结束字符之间的内容并作为String返回。  nextLine()这个函数在输入完一些东西之后按下回车则视为输入结束，输入的内容将被作为String返回。  next()这个函数与之不同在于，next()什么都不输入直接敲回车不会返回，而nextLine()即使不输入东西直接敲回车也会返回。再举个例子，输入abc def gh\\n，next()会返回abc，而nextLine()会返回abc def gh\\n。"
  },
  
  {
    "title": "Java删除数组中元素的方法",
    "url": "/posts/java-shanchu-shuzu-zhong-yuansu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "public static void main(String[] args) {    String[] data = new String[] { \"a\", \"b\", \"c\" };    String del = \"c\";    for (int i = 0; i &lt; data.length; i++) {        if (del.equals(data[i])) {     ...",
    "content": "public static void main(String[] args) {    String[] data = new String[] { \"a\", \"b\", \"c\" };    String del = \"c\";    for (int i = 0; i &lt; data.length; i++) {        if (del.equals(data[i])) {            for (int k = i; k &lt; data.length - 1; k++) {                data[k] = data[k + 1];            }            data = Arrays.copyOf(data, data.length - 1);        }    }    for (int i = 0; i &lt; data.length; i++) {        System.out.println(data[i]);    }}"
  },
  
  {
    "title": "如何判断Bigdecimal类型变量是否等于0",
    "url": "/posts/java-ruhe-panduan-bigdecimal-shifou-wei0/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-22 13:47:00 +0800",
    





    
    "snippet": "使用以下方法比较存在问题：b.equals(BigDecimal.ZERO);查看源代码发现Bigdecimal的equals方法不仅仅比较值的大小是否相等，首先比较的是scale（scale是bigdecimal的保留小数点位数，比如new Bigdecimal(\"1.001\")scale为3），也就是说，不但值的大小要相等，保留位数也要相等，equals才能返回true。Bigdecim...",
    "content": "使用以下方法比较存在问题：b.equals(BigDecimal.ZERO);查看源代码发现Bigdecimal的equals方法不仅仅比较值的大小是否相等，首先比较的是scale（scale是bigdecimal的保留小数点位数，比如new Bigdecimal(\"1.001\")scale为3），也就是说，不但值的大小要相等，保留位数也要相等，equals才能返回true。Bigdecimal b = new Bigdecimal(\"0\")和Bigdecimal c = new Bigdecimal(\"0.0\"),用equals比较，返回就是false。可以用以下方法比较：// 返回true，则等于0，返回false，则不等于0b.compareTo(BigDecimal.ZERO) == 0还可以用compareTo方法比较两个Bigdecimal数值的大小a.compareTo(b)// a&lt;b, 返回-1// a=b，返回0// a&gt;b, 返回1"
  },
  
  {
    "title": "Oracle 保留三位小数，不足补0",
    "url": "/posts/oracle-baoliu-sanwei-xiaoshu-buzu-bu0/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2021-01-21 13:47:00 +0800",
    





    
    "snippet": "格式化为小数select   to_char(round(0.2, 3),'fm99999999990.000')from   dual;格式化为百分比select  to_char(round(0.2*100,2),'fm99999999990.00')||'%'from   dual;",
    "content": "格式化为小数select   to_char(round(0.2, 3),'fm99999999990.000')from   dual;格式化为百分比select  to_char(round(0.2*100,2),'fm99999999990.00')||'%'from   dual;"
  },
  
  {
    "title": "MySQL中使用SQL语句从文本文件导入数据",
    "url": "/posts/mysql-shiyong-sql-yuju-daoru-waibu-shuju/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "load data infile 'C:\\\\Users\\\\admin\\\\Desktop\\\\test.txt' into table t_admin fields terminated by ','lines terminated by '\\r\\n';",
    "content": "load data infile 'C:\\\\Users\\\\admin\\\\Desktop\\\\test.txt' into table t_admin fields terminated by ','lines terminated by '\\r\\n';"
  },
  
  {
    "title": "MySQL查询如何把指定数据行排在前面",
    "url": "/posts/mysql-chaxun-ruhe-jiang-zhiding-shuju-paizai-qianmian/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "如果只是一条数据行，可以这样：SELECT * FROM user ORDER BY user_id &lt;&gt; 7, score DESC;主要是user_id &lt;&gt; 7 ，会把用户id为7的排在前面。如果是多条数据行：SELECT * FROM user ORDER BY user_id NOT IN (7, 8, 9), score DESC;",
    "content": "如果只是一条数据行，可以这样：SELECT * FROM user ORDER BY user_id &lt;&gt; 7, score DESC;主要是user_id &lt;&gt; 7 ，会把用户id为7的排在前面。如果是多条数据行：SELECT * FROM user ORDER BY user_id NOT IN (7, 8, 9), score DESC;"
  },
  
  {
    "title": "pom文件报错：The POM for com.oracle:ojdbc14:jar:10.2.0.1.0 is missing",
    "url": "/posts/pom-wenjian-baocuo-zhaobudao-oracle-de-qudongbao/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "报错信息The POM for com.oracle:ojdbc14:jar:10.2.0.1.0 is missing, no dependency information available; 解决方法cmd中输入mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 ...",
    "content": "报错信息The POM for com.oracle:ojdbc14:jar:10.2.0.1.0 is missing, no dependency information available; 解决方法cmd中输入mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 -Dpackaging=jar -Dfile=C:\\Users\\Administrator\\Desktop\\ojdbc14-10.2.0.2.0.jar 将Oracle驱动包导入到Maven本地库中，重新运行maven update即可。"
  },
  
  {
    "title": "关于Maven",
    "url": "/posts/guanyu-maven/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "什么是MavenMaven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期。即项目的jar包依赖，开发，测试，发布打包。Maven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期，即项目的jar包依赖，开发，测试，发布打包。项目坐标Maven通过特定的标识来定义项目名称，这样既可以唯一的匹配其他的jar包，也可以通过发布，使别人能使用自己的发布产品。这个标识就被叫做坐标。&l...",
    "content": "什么是MavenMaven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期。即项目的jar包依赖，开发，测试，发布打包。Maven是一个用于项目构建的工具，通过它便捷的管理项目的生命周期，即项目的jar包依赖，开发，测试，发布打包。项目坐标Maven通过特定的标识来定义项目名称，这样既可以唯一的匹配其他的jar包，也可以通过发布，使别人能使用自己的发布产品。这个标识就被叫做坐标。&lt;groupId&gt;com.test&lt;/groupId&gt;&lt;artifactId&gt;maventest&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;maventest&lt;/name&gt;&lt;url&gt;http://maven.apache.org&lt;/url&gt;  groupId：所述的项目名称，由于有的项目并不是一个jar包构成的，而是由很多的jar包组成的。因此这个groupId就是整个项目的名称。  artifactId：包的名称。  version：版本号。  packaging：包的类型，一般都是jar，也可以是war之类的。如果不填，默认就是jar。  name和url：一个是名称，一个是maven的地址。主要就是上面的几个参数。当想要依赖什么jar的时候就可以通过下面的方式依赖：&lt;dependencies&gt; &lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;3.8.1&lt;/version&gt;   &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;jar包的命名规则artifactId-version[-classifier].packaging比如上面的pom.xml生成的jar包名字就是：maventest-0.0.1-SNAPSHOT.jar。这里的classifier是可选的，但是有的项目可能还需要导出附属的一些文件，如javadoc，source等等，那么这个地方就需要配置一个字符串。一般都是JDKXXX之类的。"
  },
  
  {
    "title": "国内Maven库镜像（阿里云）",
    "url": "/posts/aliyun-jingxiangku/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "原来Maven地址应该是：http://repo1.maven.org/maven2/还有一个：http://central.maven.org/maven2/但是太慢了，可以改成阿里云的镜像库，配置如下：&lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&l...",
    "content": "原来Maven地址应该是：http://repo1.maven.org/maven2/还有一个：http://central.maven.org/maven2/但是太慢了，可以改成阿里云的镜像库，配置如下：&lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;          &lt;/mirror&gt;&lt;/mirrors&gt;或者直接加在repositories里面：&lt;repositories&gt;  &lt;repository&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;  &lt;/repository&gt;&lt;/repositories&gt;"
  },
  
  {
    "title": "项目启动报时区错误",
    "url": "/posts/xiangmu-qidong-bao-shiqu-cuowu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-19 13:47:00 +0800",
    





    
    "snippet": "报错信息The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must...报错原因原因是使用了Mysql Connector/J 6.x以上的版本，然后就报了时区的错误。解决方法在配置url的时候不能简单写成：jdbc:mysql://localho...",
    "content": "报错信息The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must...报错原因原因是使用了Mysql Connector/J 6.x以上的版本，然后就报了时区的错误。解决方法在配置url的时候不能简单写成：jdbc:mysql://localhost:3306/yzu而是要写成：jdbc:mysql://localhost:3306/yzu?serverTimezone=UTC"
  },
  
  {
    "title": "Java中Oracle WHERE IN查询的项超过1000条的解决方案",
    "url": "/posts/java-chuli-oracle-in-chaoguo-1000-tiao-de-qingkuang/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-19 11:47:00 +0800",
    





    
    "snippet": "/** * 处理Oracle SQL语句IN子句中WHERE id IN (1, 2, ..., 1000, 1001)， * 如果子句中超过1000项就会报错。 * 这主要是Oracle考虑性能问题做的限制。 * 如果要解决此问题，可以用 WHERE id IN (1, 2, ..., 1000) OR id IN (1001, ...) * @author hoojo * @create...",
    "content": "/** * 处理Oracle SQL语句IN子句中WHERE id IN (1, 2, ..., 1000, 1001)， * 如果子句中超过1000项就会报错。 * 这主要是Oracle考虑性能问题做的限制。 * 如果要解决此问题，可以用 WHERE id IN (1, 2, ..., 1000) OR id IN (1001, ...) * @author hoojo * @createDate 2012-8-31 下午02:36:03 * @param ids IN语句中的集合对象 * @param count IN语句中出现的条件个数 * @param field IN语句对应的数据库查询字段 * @return field IN (...) OR field IN (...)字符串 */private String getOracleSQLIn(List&lt;?&gt; ids, int count, String field) {    count = Math.min(count, 1000);    int len = ids.size();    int size = len % count;    if (size == 0) {        size = len / count;    } else {        size = (len / count) + 1;    }    StringBuilder builder = new StringBuilder();    for (int i = 0; i &lt; size; i++) {        int fromIndex = i * count;        int toIndex = Math.min(fromIndex + count, len);        String productId = StringUtils.defaultIfEmpty(StringUtils.join(ids.subList(fromIndex, toIndex), \"','\"), \"\");        if (i != 0) {            builder.append(\" or \");        }        builder.append(field).append(\" in ('\").append(productId).append(\"')\");    }    return StringUtils.defaultIfEmpty(builder.toString(), field + \" in ('')\");}  参考：处理 Oracle SQL in 超过1000 的解决方案"
  },
  
  {
    "title": "PLSQL轻客户端的配置",
    "url": "/posts/plsql-qingkehuduan-de-peizhi/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "安装instantclient的原因在64位系统上安装64位的Oracle数据库，但是没有对应的64位PLSQL Developer，此时就不能使用PLSQL Developer来进行直接连接的，所以要想实现连接还得需要安装轻客户端：instantclient_11_2。instantclient_11_2的安装其实就是从官网下载一个压缩文件，解压到任意目录下然后配置即可。配置instant...",
    "content": "安装instantclient的原因在64位系统上安装64位的Oracle数据库，但是没有对应的64位PLSQL Developer，此时就不能使用PLSQL Developer来进行直接连接的，所以要想实现连接还得需要安装轻客户端：instantclient_11_2。instantclient_11_2的安装其实就是从官网下载一个压缩文件，解压到任意目录下然后配置即可。配置instantclient的步骤  将下载的instantclient_11_2压缩包解压到任意目录，如：D:\\app\\instantclient_11_2。  然后进入PLSQL的主界面（登陆时直接点取消按钮也是可以进入主界面的），点击工具–首选项，在如下界面做如下配置：    Oracle主目录名，即为你的instantclient的解压路径。  然后配置连接文件，在D:\\app\\instantclient_11_2目录下新建文件夹NETWORK，然后把Oracle安装目录下的D:\\app\\Administrator\\product\\11.2.0\\dbhome_2\\NETWORK目录下的整个ADMIN文件夹拷贝到D:\\app\\instantclient_11_2\\NETWORK目录下，或者新建目录NETWORK\\ADMIN和tnsnames.ora文件也可以，NETWORK\\ADMIN目录下的tnsnames.ora文件就是配置连接的文件。  经过如此配置后，PLSQL就能正常使用了。"
  },
  
  {
    "title": "PLSQL通过修改配置文件实现数据库连接",
    "url": "/posts/plsql-peizhi-lianjie/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "在Oracle的安装目录下查找tnsnames.ora文件，一般路径为：%ORACLE_HOME%\\network\\admin。打开tnsnames.ora，可以看到所有的数据库连接配置，介绍下配置格式：  只需要根据上一步介绍的格式修改IP或者端口号或者SID即可，总体不变，例如：test_database =  (DESCRIPTION =    (ADDRESS = (PROTOCOL...",
    "content": "在Oracle的安装目录下查找tnsnames.ora文件，一般路径为：%ORACLE_HOME%\\network\\admin。打开tnsnames.ora，可以看到所有的数据库连接配置，介绍下配置格式：  只需要根据上一步介绍的格式修改IP或者端口号或者SID即可，总体不变，例如：test_database =  (DESCRIPTION =    (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))    (CONNECT_DATA =      (SERVER = DEDICATED)      (SERVICE_NAME = testdb)    )  )重新登陆PL/SQl，即会在database中有刚刚配置的数据库连接选项：  输入用户名密码，单击登录即可。"
  },
  
  {
    "title": "PLSQL连接数据库时报ORA-12560:TNS:协议适配器错误",
    "url": "/posts/ora-12560/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "造成ORA-12560:TNS:协议适配器错误的问题的原因有三个：  监听服务没有启起来。Windows平台可以如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleOraDb11g_home1TNSlistener服务。  database instance没有起起来。Windows平台如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleServiceBOOK...",
    "content": "造成ORA-12560:TNS:协议适配器错误的问题的原因有三个：  监听服务没有启起来。Windows平台可以如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleOraDb11g_home1TNSlistener服务。  database instance没有起起来。Windows平台如下操作：开始—程序—管理工具—服务，打开服务面板，启动OracleServiceBOOKSALES服务， BOOKSALES就是你的SID。　　　　  注册表问题。打开注册表，然后进入HKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE\\HOME将该环境变量ORACLE_SID设置为XXXX，XXXX就是你的SID。或者右击我的电脑，属性–高级–环境变量—系统变量–新建，变量名=oracle_sid，变量值=XXXX，XXXX就是你的SID。或者进入sqlplus前，在命令行下输set oracle_sid=XXXX，XXXX就是你的SID。经过以上步骤，一般就可以解决问题。"
  },
  
  {
    "title": "MyBatis查询结果为NULL时报异常的解决方法",
    "url": "/posts/mybatis-chaxun-jieguo-weinull-shi-baoyichang/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "异常信息org.apache.ibatis.binding.BindingException: Mapper method 'com.XXXXX' attempted toreturn null from a method with a primitive return type (int).源代码&lt;select id=\"selectPageviews\" resultType=\"jav...",
    "content": "异常信息org.apache.ibatis.binding.BindingException: Mapper method 'com.XXXXX' attempted toreturn null from a method with a primitive return type (int).源代码&lt;select id=\"selectPageviews\" resultType=\"java.lang.Integer\" &gt;  select     sum(yc_hobby_pageviews)  from     SCOTT.yc_hobby_course  where    yc_hobby_course_user_id = #{yc_hobby_course_user_id}&lt;/select&gt;Oracle的解决方式select NVL(sum(yc_hobby_pageviews), 0) from ....MySQL的解决方式select IFFULL(sum(yc_hobby_pageviews), 0) from ....SQL Server的解决方式 select ISNULL(sum(yc_hobby_pageviews), 0) ...所有数据库适用select COALESCE(sum(yc_hobby_pageviews), 0) ..."
  },
  
  {
    "title": "Mybatis插入数据时返回主键",
    "url": "/posts/mybatis-charu-shuju-shi-fanhui-zhujian/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "方式一&lt;insert id=\"insertAndGetId\" useGeneratedKeys=\"true\" keyProperty=\"userId\"         parameterType=\"com.chenzhou.mybatis.User\"&gt;    insert into user(userName, password, comment)    values(#{use...",
    "content": "方式一&lt;insert id=\"insertAndGetId\" useGeneratedKeys=\"true\" keyProperty=\"userId\"         parameterType=\"com.chenzhou.mybatis.User\"&gt;    insert into user(userName, password, comment)    values(#{userName}, #{password}, #{comment})&lt;/insert&gt;User user = new User();  user.setUserName(\"ceshi\");  user.setPassword(\"123456\"); userDao.insertUser(user);System.out.println(\"插入后主键为：\" + user.getUserId());    useGeneratedKeys=\"true\"表示给主键设置自增长  keyProperty=\"userId\"表示将自增长后的id赋值给实体类中的userId字段  parameterType=\"com.chenzhou.mybatis.User\"这个属性指向传递的参数实体类  实体类中uerId要有getter()和setter()方法方式二&lt;insert id=\"insertProduct\" parameterType=\"domain.model.ProductBean\" &gt;    &lt;selectKey resultType=\"java.lang.Long\" order=\"AFTER\" keyProperty=\"productId\"&gt;      SELECT LAST_INSERT_ID()    &lt;/selectKey&gt;      INSERT INTO t_product(productName, productDesrcible, merchantId)      values(#{productName}, #{productDesrcible}, #{merchantId})&lt;/insert&gt;  &lt;insert&gt;&lt;/insert&gt;中没有resultType属性，但是&lt;selectKey&gt;&lt;/selectKey&gt;标签是有的  order=\"AFTER\"表示先执行插入语句，之后再执行查询语句，可被设置为BEFORE或AFTER，如果设置为BEFORE，那么它会首先选择主键，设置keyProperty然后执行插入语句，如果设置为AFTER，那么先执行插入语句，然后是selectKey元素，这和如Oracle数据库相似，可以在插入语句中嵌入序列调用keyProperty=\"userId\"表示将自增长后的id赋值给实体类中的userId字段  SELECT LAST_INSERT_ID()表示MySQL语法中查询出刚刚插入的记录自增长id  实体类中uerId要有getter()和setter()方法"
  },
  
  {
    "title": "Jira 的一些查询",
    "url": "/posts/jira-de-yixie-chaxun/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "1. 查询Jira问题的固定或级联字段SELECT  jiraissue.*FROM  jiraissue,  OS_HISTORYSTEP,  customfieldvalue,  customfieldoptionWHERE  OS_HISTORYSTEP.ENTRY_ID = jiraissue.id  AND OS_HISTORYSTEP.ACTION_ID = &lt;action...",
    "content": "1. 查询Jira问题的固定或级联字段SELECT  jiraissue.*FROM  jiraissue,  OS_HISTORYSTEP,  customfieldvalue,  customfieldoptionWHERE  OS_HISTORYSTEP.ENTRY_ID = jiraissue.id  AND OS_HISTORYSTEP.ACTION_ID = &lt;action_id&gt;  AND OS_HISTORYSTEP.CALLER = &lt;user_name&gt;  AND customfieldvalue.issue = jiraissue.id  AND customfieldvalue.PARENTKEY = &lt;parent_key&gt;  AND customfieldvalue.stringvalue = customfieldoption.id  AND customfieldoption.customvalue like '&lt;cf_value&gt;';Where  &lt;user_name&gt; - the username of the desired user   &lt;action_id&gt; - the id of your transition into the fixed state (may need multiple)   &lt;parent_key&gt; - the id of the Level 1 option in customfieldoption - E.g.10040   &lt;cf_value&gt; - the Level 2 value of the cascading field.E.g 'realease%'2. 查一个问题的修复版本SELECT  projectversion.id,  vnameFROM  projectversion,  nodeassociation,  jiraissueWHERE  ASSOCIATION_TYPE = 'IssueFixVersion'  AND SINK_NODE_ID = projectversion.id  AND SOURCE_NODE_ID = jiraissue.id  AND pkey = '&lt;issue_key&gt;';WHERE  &lt;issue_key&gt; - the key of an issue.E.g.TEST -103. 查某个时间段更新过的所有问题SELECT  DISTINCT(j.id)FROM  jiraissue j,  changegroup gWHERE  j.id = g.issueid  AND g.author = '&lt;user name&gt;'  AND g.created &gt; '&lt;date&gt;';Where  &lt;date&gt; - the earliest desired date (The date should be in the          - format 'yyyy-mm-dd hh:mm:s'.E.g '2005-10-06 14:40:28')   &lt;username&gt; - the name of the desired user4. 查找一个项目的某个时间的所有问题的状态SELECT  JI.pkey,  STEP.STEP_IDFROM  (    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_CURRENTSTEP    WHERE      OS_CURRENTSTEP.START_DATE &lt; '&lt;your date&gt;'    UNION    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_HISTORYSTEP    WHERE      OS_HISTORYSTEP.START_DATE &lt; '&lt;your date&gt;'      AND OS_HISTORYSTEP.FINISH_DATE &gt; '&lt;your date&gt;'  ) As STEP,  (    SELECT      changeitem.OLDVALUE AS VAL,      changegroup.ISSUEID AS ISSID    FROM      changegroup,      changeitem    WHERE      changeitem.FIELD = 'Workflow'      AND changeitem.GROUPID = changegroup.ID    UNION    SELECT      jiraissue.WORKFLOW_ID AS VAL,      jiraissue.id as ISSID    FROM      jiraissue  ) As VALID,  jiraissue as JIWHERE  STEP.ENTRY_ID = VALID.VAL  AND VALID.ISSID = JI.id  AND JI.project = &lt;proj_id&gt;;Where  &lt;your date&gt; - is the date you want to check   &lt;proj_id&gt; - is the project you want to check5. 查某个项目所有状态的数量SELECT  count(*),  STEP.STEP_IDFROM  (    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_CURRENTSTEP    WHERE      OS_CURRENTSTEP.START_DATE &lt; '&lt;your date&gt;'    UNION    SELECT      STEP_ID,      ENTRY_ID    FROM      OS_HISTORYSTEP    WHERE      OS_HISTORYSTEP.START_DATE &lt; '&lt;your date&gt;'      AND OS_HISTORYSTEP.FINISH_DATE &gt; '&lt;your date&gt;'  ) As STEP,  (    SELECT      changeitem.OLDVALUE AS VAL,      changegroup.ISSUEID AS ISSID    FROM      changegroup,      changeitem    WHERE      changeitem.FIELD = 'Workflow'      AND changeitem.GROUPID = changegroup.ID    UNION    SELECT      jiraissue.WORKFLOW_ID AS VAL,      jiraissue.id as ISSID    FROM      jiraissue  ) As VALID,  jiraissue as JIWHERE  STEP.ENTRY_ID = VALID.VAL  AND VALID.ISSID = JI.id  AND JI.project = &lt;proj_id&gt;Group By  STEP.STEP_ID;Where  &lt;your date&gt; - is the date you want to check   &lt;proj_id&gt; - is the project you want to check6. 查询有多少问题被改变了状态SELECT  NEWSTRING AS Status,  count(*) AS NumberFROM  changeitem,  changegroup,  jiraissueWHERE  changeitem.field = 'Status'  AND changeitem.groupid = changegroup.id  AND changegroup.issueid = jiraissue.id  AND jiraissue.project = &lt;project_id&gt;  AND changegroup.CREATED &gt;= '&lt;date_from&gt;'  AND changegroup.CREATED &lt; '&lt;date_to&gt;'Group By  NEWSTRINGUNIONSELECT  'Created' As Status,  count(*) AS NumberFROM  jiraissueWHERE  jiraissue.CREATED &gt;= '&lt;date_from&gt;'  AND jiraissue.CREATED &lt; '&lt;date_to&gt;'  AND jiraissue.project = &lt;project_id&gt;;Where  &lt;date_from&gt; - is the date you want to checkfrom  &lt;date_to&gt; - is the date you want to check to   &lt;project_id&gt; - is the project you want to check7. 获得一个问题的所有组件 SELECT  jiraissue.pkey,  component.cnameFROM  nodeassociation,  component,  jiraissueWHERE  component.ID = nodeassociation.SINK_NODE_ID  AND jiraissue.id = nodeassociation.SOURCE_NODE_ID  AND nodeassociation.ASSOCIATION_TYPE = 'IssueComponent'  AND pkey = '&lt;issue_key&gt;';8. 查找已经关闭的问题SELECT  pKey,  OS_CURRENTSTEP.STATUS,  OS_CURRENTSTEP.START_DATEFROM  jiraissue,  OS_CURRENTSTEPWHERE  issuestatus = 6  AND OS_CURRENTSTEP.ENTRY_ID = jiraissue.WORKFLOW_ID;9. 简单的连接SELECT * FROM jiraissue LEFT JOIN jiraaction ON jiraissue.id = jiraaction.issueid;SELECT * FROM jiraissue LEFT JOIN changegroup ON jiraissue.id = changegroup.issueid;SELECT * FROM changegroup LEFT JOIN changeitem ON changegroup.id = changeitem.groupid;SELECT * FROM jiraissue LEFT JOIN OS_CURRENTSTEP ON jiraissue.WORKFLOW_ID = OS_CURRENTSTEP.ENTRY_ID;SELECT * FROM jiraissue LEFT JOIN OS_HISTORYSTEP ON jiraissue.WORKFLOW_ID = OS_HISTORYSTEP.ENTRY_ID; 10. 返回所有项目问题SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  ji.pkey AS issue_id,  ji.reporter AS issue_reporter,  pri.pname AS issue_priority,  ist.pname AS issue_status,  ji.summary AS issue_summaryFROM  project p  LEFT OUTER JOIN jiraissue ji ON ji.project = p.id  LEFT OUTER JOIN priority pri ON ji.priority = pri.id  LEFT OUTER JOIN issuestatus ist ON ji.issuestatus = ist.idWHERE  p.pname = '&lt;project_name&gt;'ORDER BY  ji.pkey;11. 查询项目的所有版本SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  pv.vname AS version_name,  pv.description AS version_desc,  pv.sequence AS version_seq,  pv.released AS version_released,  pv.archived AS version_archived,  pv.url AS version_url,  pv.releasedate AS version_release_dateFROM  project p  LEFT OUTER JOIN projectversion pv ON pv.project = p.idWHERE  p.pname = '&lt;project_name&gt;'ORDER BY  pv.sequence;12. 返回项目的所有用户SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  prc.roletypeparameter AS project_rolesFROM  project p  LEFT OUTER JOIN projectroleactor prc ON prc.pid = p.idWHERE  p.pname = '&lt;project_name&gt;';13. 返回项目工作流SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  ws.name AS project_associated_workflow_scheme,  wse.workflow AS workflow_scheme_associated_workflow,  jw.descriptor AS workflow_descriptorFROM  project p  LEFT OUTER JOIN nodeassociation na ON na.source_node_id = p.id  AND na.sink_node_entity = 'WorkflowScheme'  LEFT OUTER JOIN workflowscheme ws ON ws.id = na.sink_node_id  LEFT OUTER JOIN workflowschemeentity wse ON wse.scheme = ws.id  LEFT OUTER JOIN jiraworkflows jw ON jw.workflowname = wse.workflowWHERE  p.pname = '&lt;project_name&gt;';14. 查询问题各个字段的显示模式SELECT  p.id AS project_id,  p.pname AS project_name,  p.lead AS project_lead,  itss.name AS project_issue_type_screen_scheme,  fss.name AS screen_scheme_of_the_issue_type_screen_scheme,  fs.name AS screen_name_of_the_screen_scheme,  fst.name AS screen_tab_name,  fsli.fieldidentifier AS tab_field,  fsli.sequence AS tab_field_seqFROM  project p  LEFT OUTER JOIN nodeassociation na ON na.source_node_id = p.id  AND na.sink_node_entity = 'IssueTypeScreenScheme'  LEFT OUTER JOIN issuetypescreenscheme itss ON itss.id = na.sink_node_id  LEFT OUTER JOIN issuetypescreenschemeentity itsse ON itsse.scheme = itss.id  LEFT OUTER JOIN fieldscreenscheme fss ON itsse.fieldscreenscheme = fss.id  LEFT OUTER JOIN fieldscreenschemeitem fssi ON fss.id = fssi.fieldscreenscheme  LEFT OUTER JOIN fieldscreen fs ON fssi.fieldscreen = fs.id  LEFT OUTER JOIN fieldscreentab fst ON fs.id = fst.fieldscreen  LEFT OUTER JOIN fieldscreenlayoutitem fsli ON fst.id = fsli.fieldscreentabWHERE  p.pname = 'fengdi'ORDER BY  fsli.sequence;15. 查看一个问题的fix—for versionsselect  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueFixVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );16. 查看一个问提的影响版本select  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );17. 查看一个问题的所属模块select  *from  componentwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueComponent'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );18. 查看两个项目之间的超链接select  *from  issuelinkwhere  SOURCE =(    select      id    from      jiraissue    where      pkey = 'TP-1'  )  and DESTINATION =(    select      id    from      jiraissue    where      pkey = 'TP-2'  );19. 查看两个项目间的链接类型select  j1.pkey,  issuelinktype.INWARD,  j2.pkeyfrom  jiraissue j1,  issuelink,  issuelinktype,  jiraissue j2where  j1.id = issuelink.SOURCE  and j2.id = issuelink.DESTINATION  and issuelinktype.id = issuelink.linktype;20. 查看某个项目下的所有自定义字段select  *from  customfieldvaluewhere  issue =(    select      id    from      jiraissue    where      pkey = 'JRA-5448'  );21. 查看某个自定义字段的详细信息select * from customfield where id = 10190; 22. 查看自定义字段在某个项目的值select  stringvaluefrom  customfieldvaluewhere  customfield =(    select      id    from      customfield    where      cfname = 'Urgency'  )  and issue =(    select      id    from      jiraissue    where      pkey = 'FOR-845'  );23. 查看有多个值的自定义字段值select  stringvaluefrom  customfieldvaluewhere  customfield =(    select      id    from      customfield    where      cfname = 'Urgency'  )  and issue =(    select      id    from      jiraissue    where      pkey = 'FOR-845'  );24. 查看自定义字段的可选值select * from customfieldoption where customfieldconfig = 10031;25. 查看自定义字段的默认值select * from genericconfiguration where ID = 10031;26. 查看改动记录changegroup 和 changeItem27. 查看表的最大使用id-- 每次申请100，对应的名字配置在entitymodel.xmlselect * from SEQUENCE_VALUE_ITEM;28. 工作日志表worklog29. 用户和用户组表cwd_user, cwd_group, cwd_membership30. 用户权限表cwd_directory_operation31. 用户详细和自定义信息cwd_directory_attribute32. 关注和投票相关表userassociation33. 状态和工作流，查看问题的状态select issuestatus from jiraissue where pkey = 'TP-1';34. 状态定义表issuestatusselect pname from issuestatus, jiraissue where issuestatus.id = jiraissue.issuestatus and pkey = 'TP-1';35. 工作流名字和id对应表OS_WFENTRY 36. 查看所有问题的工作流跳转select  issuestatus.pname status,  issuestatus,  OS_CURRENTSTEP.STEP_ID,  OS_CURRENTSTEP.STATUSfrom  issuestatus,  jiraissue,  OS_CURRENTSTEPwhere  issuestatus.id = jiraissue.issuestatus  and jiraissue.workflow_id = OS_CURRENTSTEP.ENTRY_ID;37. 查询某个issue影响到的项目版本select  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );38. 查询某个issue解决的项目版本select  *from  projectversionwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueFixVersion'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );39. 查询某个issue所在的项目模块select  *from  componentwhere  id in (    select      SINK_NODE_ID    from      nodeassociation    where      ASSOCIATION_TYPE = 'IssueComponent'      and SOURCE_NODE_ID =(        select          id        from          jiraissue        where          pkey = 'JRA-5351'      )  );40. 查询issue状态转换的详情select  cu.display_name,  cu.user_name,  cg.created,  dbms_lob.substr(ci.oldstring, 4000),  dbms_lob.substr(ci.newstring, 4000),  ji.issuetype,  p.pkey || '-' || ji.issuenum,  ji.summary,  p.pnamefrom  changeitem ci  left join changegroup cg on ci.groupid = cg.id  left join jiraissue ji on ji.id = cg.issueid  left join project p on p.id = ji.project  left join app_user au on au.user_key = cg.author  left join cwd_user cu on cu.lower_user_name = au.lower_user_namewhere  p.pname = '&lt;projectName&gt;'  and ji.id = '&lt;issueId&gt;'  and ci.field = 'status'"
  },
  
  {
    "title": "Jira 7.8的安装和配置",
    "url": "/posts/jira-de-anzhuang-he-peizhi/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2021-01-17 13:47:00 +0800",
    





    
    "snippet": "一、安装前准备Jira的运行是依赖Java环境的，也就是说需要安装JDK并且要是1.8以上版本，除此之外，我们还需要安装MySQL，为Jira创建对应的数据库，注意建库字符集为UTF-8，以上环境准备完毕后，我们现在开始下载并安装Jira。二、下载Jira到Jira官方下载网站下载和系统匹配的版本，或者使用Linux命令下载：wget  https://downloads.atlassian...",
    "content": "一、安装前准备Jira的运行是依赖Java环境的，也就是说需要安装JDK并且要是1.8以上版本，除此之外，我们还需要安装MySQL，为Jira创建对应的数据库，注意建库字符集为UTF-8，以上环境准备完毕后，我们现在开始下载并安装Jira。二、下载Jira到Jira官方下载网站下载和系统匹配的版本，或者使用Linux命令下载：wget  https://downloads.atlassian.com/software/jira/downloads/atlassian-jira-software-7.8.1-x64.bin。三、破解Jira使用./atlassian-jira-software-7.8.1-x64.bin命令开始Jira的安装流程，通过终端输出的信息，我们可以很明显的看出Jira安装到了/opt/atlassian/jira和/var/atlassian/application-data/jira目录下，并且Jira监听的端口是8080。Jira的主要配置文件，存放在/opt/atlassian/jira/conf/server.xml文件中。把破解包里面的atlassian-extras-3.2.jar和mysql-connector-java-5.1.39-bin.jar两个文件复制到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下。其中atlassian-extras-3.2.jar是用来替换原来的atlassian-extras-3.2.jar文件，用作破解Jira系统的。而mysql-connector-java-5.1.39-bin.jar是用来连接MySQL数据库的驱动软件包。然后使用./start-jira.sh命令启动Jira。四、配置Jira在浏览器中输入http://localhost:8080，打开Jira的安装界面。配置数据库连接。填写好后测试连接一下看看是否成功，在下一步。连接数据库的配置文件是/var/atlassian/application-data/jira/dbconfig.xml下面的配置就比较简单了，自定义也可以，默认也可以。注意：上图中的模式中，我们在此使用的是Private（私有）模式，在这个模式下，用户的创建需要由管理员创建。而在Public（共用）模式下，用户是可以自己进行注册。下面这个页面是需要我们输入Jira的License，如下： 注意：上图中的Server ID：BSG9-24QF-8M40-O1CT，因为我们没有正式的License，所以需要我们在Jira官网注册一个账号，然后利用这个账号申请一个可以试用30天的License，点击生成Jira许可证。如下： 将生成的License复制过来。设置管理员账号。设置邮件通知。设置语言。安装完成。到此Jira 7.8的安装就好了，现在看看Jira的破解，其实我们在前面复制atlassian-extras-3.1.2.jar到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下时，再次启动Jira时就已经破解了，我们现在登陆到Jira中查看授权信息，如下：如何修改内存vim /opt/atlassian/jira/bin/setenv.sh日志查看tail -f /opt/atlassian/jira/logs/catalina.out修改Jira Home的位置vim /usr/local/jira/atlassian-jira/WEB-INF/classes/jira-application.properties"
  },
  
  {
    "title": "局域网SVN服务器的搭建",
    "url": "/posts/juyuwang-svn-fuwuqi-de-dajian/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2021-01-12 13:47:00 +0800",
    





    
    "snippet": "安装VisualSVN Server在standard edition设置”安装目录”和”存放目录”还有”端口”，端口一下要记住打开VisualSVN Server添加用户在VisualSVN Server添加项目”t”现在用TortoiseSVN试试能不能连接SVN服务器。建个文件夹”t2015”，右击选择”SVN Checkout”，输入用户名和密码",
    "content": "安装VisualSVN Server在standard edition设置”安装目录”和”存放目录”还有”端口”，端口一下要记住打开VisualSVN Server添加用户在VisualSVN Server添加项目”t”现在用TortoiseSVN试试能不能连接SVN服务器。建个文件夹”t2015”，右击选择”SVN Checkout”，输入用户名和密码"
  },
  
  {
    "title": "Linux nohup命令",
    "url": "/posts/linux-nohup-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-01-12 13:47:00 +0800",
    





    
    "snippet": "Linux下有时候我们希望某个程序可以一直在后台执行，很多都是使用&amp;在程序命令结尾来让程序自动运行。[root@lbogon roy]# ./test.sh &amp; 但是这样在终端关闭的时候，程序也会随之停止，此时我们可以使用nohup命令。[root@lbogon roy]# nohup ./test.sh &amp; 这样的话终端关闭后程序不会停止，但是如果程序执行过程中报错...",
    "content": "Linux下有时候我们希望某个程序可以一直在后台执行，很多都是使用&amp;在程序命令结尾来让程序自动运行。[root@lbogon roy]# ./test.sh &amp; 但是这样在终端关闭的时候，程序也会随之停止，此时我们可以使用nohup命令。[root@lbogon roy]# nohup ./test.sh &amp; 这样的话终端关闭后程序不会停止，但是如果程序执行过程中报错，出现了logout，程序也会随之终止。所以如果我们希望程序可以一直在后台运行，无论是否报错，可以使用下面这个命令。[root@lbogon roy]# nohup ./test.sh &gt;output.log 2&gt;&amp;1 &amp;上条命令中&gt;output.log是将输出写入到output.log文件中，2&gt;&amp;1意思是把标准错误（2）重定向到标准输出中（1），即标准输出以及错误输出都在output.log文件中，程序执行出现错误也不会终止。"
  },
  
  {
    "title": "Linux mv命令",
    "url": "/posts/linux-mv-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2021-01-12 13:47:00 +0800",
    





    
    "snippet": "作用重命名、覆盖或移动文件。参数mv [options] existing-file new-filenamemv [options] existing-file-list directorymv [options] existing-directory new-directory  第一种形式：  existing-file是需要重命名的文件路径；  new-filename是文件的新路径...",
    "content": "作用重命名、覆盖或移动文件。参数mv [options] existing-file new-filenamemv [options] existing-file-list directorymv [options] existing-directory new-directory  第一种形式：  existing-file是需要重命名的文件路径；  new-filename是文件的新路径名，用于重命名或覆盖。  第二种形式：  existing-file是需要移动的文件路径列表；  directory是文件需要移动到的新目录，用于移动。  第三种形式：  existing-file是需要重命名的目录路径；  new-directory是目录的新路径名，用于重命名或覆盖。选项-b  如果已存在相同文件名，则覆盖前进行备份-f  如果已存在相同文件名，而用户不具有写的权限，则强制覆盖-i  如果已存在相同文件名，覆盖前提示用户进行确认-u  比较原文件与目标文件修改时间，如果目标文件较新则不覆盖-v  列出所有被移动或重命名的文件示例      重命名      $ mv demo1.txt demo2.txt    # 重命名文件            对已存在的文件覆盖前进行确认，y或Y开头的字符串表示确定，其余任意字符表示否定      $ mv demo2.txt -i demo.txt    # 是否覆盖\"demo.txt\"？ y            移动目录，此处将cde目录移动到abc目录中      $ mv cde abc            重命名目录，此处将abc目录重命名为dir目录      $ mv abc dir            mv -u，确认修改时间再判断是否覆盖，此处time2.txt的修改时间比time1.txt的修改时间新，所以覆盖失败      $ mv time1.txt -u time2.txt            mv -v，列出移动或覆盖时的信息      $ mv time1.txt -v time2.txt             mv -b，覆盖时进行备份，所备份的文件尾部有个～      $ mv -b aa.txt bb.txt      Tips  在Linux中，覆盖和重命名的概念几乎是一样的，没有Windows中所谓的rename这一说法。  选项可以写在任意位置，可以mv aa -v bb，也可以mv -v aa bb，还可以mv aa bb -v。"
  },
  
  {
    "title": "Spring Boot读取properties配置文件中的数据",
    "url": "/posts/springboot-duqu-peizhi-wnejian-de-shuju/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2021-01-11 13:47:00 +0800",
    





    
    "snippet": "一、使用@Value注解读取读取properties配置文件时，默认读取的是application.properties。application.properties：demo.name = Namedemo.age = 18Java：import org.springframework.beans.factory.annotation.Value;import org.springfram...",
    "content": "一、使用@Value注解读取读取properties配置文件时，默认读取的是application.properties。application.properties：demo.name = Namedemo.age = 18Java：import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Value(\"${demo.name}\")    private String name;    @Value(\"${demo.age}\")    private String age;    @RequestMapping(value = \"/gateway\")    public String gateway() {        //1、使用@Value注解读取        return \"get properties value by ''@Value'' :\" +            \" name=\" + name +            \" , age=\" + age;    }}这里，如果要把@Value(\"${demo.name}\")private String name;@Value(\"${demo.age}\")private String age;部分放到一个单独的类A中进行读取，然后在类B中调用，则要把类A增加@Component注解，并在类B中使用@Autowired自动装配类A，代码如下：类A：import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class ConfigBeanValue {    @Value(\"${demo.name}\")    public String name;    @Value(\"${demo.age}\")    public String age;}类B：import cn.wbnull.springbootdemo.config.ConfigBeanValue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Autowired    private ConfigBeanValue configBeanValue;    @RequestMapping(value = \"/gateway\")    public String gateway() {        //1、使用@Value注解读取        return \"get properties value by ''@Value'' :\" +            \" name=\" + configBeanValue.name +            \" , age=\" + configBeanValue.age;    }}二、使用Environment读取application.properties：demo.sex = 男demo.address = 山东Java：import cn.wbnull.springbootdemo.config.ConfigBeanValue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Autowired    private ConfigBeanValue configBeanValue;    @Autowired    private Environment environment;    @RequestMapping(value = \"/gateway\")    public String gateway() {        return \"get properties value by ''@Value'' :\" +            //1、使用@Value注解读取            \" name=\" + configBeanValue.name +            \" , age=\" + configBeanValue.age +            \"&lt;p&gt;get properties value by ''Environment'' :\" +            //2、使用Environment读取            \" , sex=\" + environment.getProperty(\"demo.sex\") +            \" , address=\" + environment.getProperty(\"demo.address\");    }}运行时如果发现中文乱码，我们在application.properties做如下配置：server.tomcat.uri-encoding = UTF-8spring.http.encoding.charset = UTF-8spring.http.encoding.enabled = truespring.http.encoding.force = truespring.messages.encoding = UTF-8三、使用@ConfigurationProperties注解读取在实际项目中，当项目需要注入的变量值很多时，上述所述的两种方法工作量会变得比较大，这时候我们通常使用基于类型安全的配置方式，将properties属性和一个Bean关联在一起，即使用注解@ConfigurationProperties读取配置文件数据。在src\\main\\resources下新建config.properties配置文件：demo.phone = 10086demo.wife = self创建ConfigBeanProp并注入config.properties中的值：import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = \"demo\")@PropertySource(value = \"config.properties\")public class ConfigBeanProp {    private String phone;    private String wife;    public String getPhone() {        return phone;    }    public void setPhone(String phone) {        this.phone = phone;    }    public String getWife() {        return wife;    }    public void setWife(String wife) {        this.wife = wife;    }}@Component表示将该类标识为Bean。@ConfigurationProperties(prefix = \"demo\")用于绑定属性，其中prefix表示所绑定的属性的前缀。@PropertySource(value = \"config.properties\")表示配置文件路径。使用时，先使用@Autowired自动装载ConfigBeanProp，然后再进行取值，示例如下：import cn.wbnull.springbootdemo.config.ConfigBeanProp;import cn.wbnull.springbootdemo.config.ConfigBeanValue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.env.Environment;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GatewayController {    @Autowired    private ConfigBeanValue configBeanValue;    @Autowired    private Environment environment;    @Autowired    private ConfigBeanProp configBeanProp;    @RequestMapping(value = \"/gateway\")    public String gateway() {        return \"get properties value by ''@Value'' :\" +            //1、使用@Value注解读取            \" name=\" + configBeanValue.name +            \" , age=\" + configBeanValue.age +            \"&lt;p&gt;get properties value by ''Environment'' :\" +            //2、使用Environment读取            \" sex=\" + environment.getProperty(\"demo.sex\") +            \" , address=\" + environment.getProperty(\"demo.address\") +            \"&lt;p&gt;get properties value by ''@ConfigurationProperties'' :\" +            //3、使用@ConfigurationProperties注解读取            \" phone=\" + configBeanProp.getPhone() +            \" , wife=\" + configBeanProp.getWife();    }}"
  },
  
  {
    "title": "JSTL标签的用法",
    "url": "/posts/jstl-biaoqian-de-yongfa/",
    "categories": "Knowledge, JSTL",
    "tags": "JSTL",
    "date": "2021-01-11 13:47:00 +0800",
    





    
    "snippet": "JSP标准标记库（Standard Tag Library，JSTL）是一组以标准化格式实现许多通用的Web站点功能的定制标记。除了核心JSP标记，如jsp:include之外，定制标记库工具使您能够创建唯一的标记来描述以站点或应用程序为导向的操作。一旦您创建了定制标记库（简称taglib），当您扩展项目或转向另一个项目时您可以重复使用这些标记。您还可以将 taglib传递给其它开发人员，从...",
    "content": "JSP标准标记库（Standard Tag Library，JSTL）是一组以标准化格式实现许多通用的Web站点功能的定制标记。除了核心JSP标记，如jsp:include之外，定制标记库工具使您能够创建唯一的标记来描述以站点或应用程序为导向的操作。一旦您创建了定制标记库（简称taglib），当您扩展项目或转向另一个项目时您可以重复使用这些标记。您还可以将 taglib传递给其它开发人员，从而他们可以在自己的网站上使用，或者在您Web应用程序的其它部分使用。JSTL的目标是为了简化JSP页面的设计。对于页面设计人员来说，使用脚本语言（默认值是Java语言）操作动态数据是比较困难的，而采用标签和表达式语言相对容易一些，JSTL的使用为页面设计人员和程序开发人员的分工协作提供了便利。一、配置JSTL包括两个jar文件， jstl.jar和standard.jar。原文引入：&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;       二、core标签库core标签库主要包括了一般用途的标签、条件标签、迭代标签和URL相关的标签。在JSP页面使用core标签要使用taglig指令，指定引用的标签库，如下：&lt;%@ taglib rui=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;一般用途的标签有：&lt;c:out&gt;、&lt;c:set&gt;、&lt;c:remove&gt;、&lt;c:cath&gt;条件标签包括：&lt;c:if&gt;、&lt;c:choose&gt;、&lt;c:when&gt;、&lt;c:otherwise&gt;迭代标签有：&lt;c:forEach&gt;2.1 &lt; c:out&gt;用于计算一个表达式并将结果输出。类似于JSP中&lt;%=%&gt;表达式，或者是EL中${el-expression}。2.2 &lt; c:set&gt;用于设置范围变量的值或者javabean对象的属性。看个实际例子：&lt;c:set var=\"username\" value=\"lisi\" scope=\"session\"/&gt;这样就相当于设置了session 。2.3 &lt; c:remove&gt;相对&lt;c:set&gt;其作用是移除范围变量。比如： &lt;c:remove var=\"nusername\" scope=\"session\"/&gt;2.4 &lt; c:catch&gt;用于捕获在其中嵌套的操作所抛出的异常对象，并将异常信息保存到变量中。我们将有可能抛出异常的代码放置到开始标签&lt;c:catch&gt;和结束标签&lt;/c:catch&gt;之间。如果其中代码出现异常，异常对象将被捕获，保存在var声明的变量中，该变量有page范围。如果没有发生异常，而var所标识的范围变量将被移除。如果没有指定var属性，异常只是简单的被捕获，异常信息并不会被保存。如下：&lt;c:catch var=\"exception\"&gt;&lt;%    int i = 5;    int j = 0;    int k=i/j;%&gt;&lt;/c:catch&gt;&lt;c:out value=\"${exception}\"/&gt;&lt;br&gt;&lt;c:out value=\"${exception.massage}\"/&gt;后一句相当于exception.getMessage()。2.5 &lt; c:if&gt;用于实现Java中的if语句功能。语法：&lt;c:if test=\"逻辑表达式\"         var=\"代表逻辑表达式的值的命名变量的名字\"         scope=\"{page|request|session|application}\" / &gt; 标签会把逻辑表达式的值存放在var属性指定的命名变量中，scope属性则指定命名变量的范围，scope属性的默认值是page（页面范围）。例如以下标签先判断username请求参数的值是否为Tom，然后把判断结果作为result命名变量存放在请求范围内：&lt;c:if test=\"${param.username=='Tom'}\"  var=\"result\" scope=\"request\" /&gt; ${result} 以上标签等价于以下Java程序片段：&lt;%      String username = request.getParameter(\"username\");      if(username!=null &amp;&amp; username.equals(\"Tom\")) {        request.setAttribute(\"result\", true);      } else {        request.setAttribute(\"result\", false);      }%&gt; 2.6 &lt; c:choose&gt;&lt;c:choose&gt;和&lt;c:when&gt;、&lt;c:otherwise&gt;一起实现互斥条件执行，类似于Java中的if else。&lt;c:choose&gt;一般作为&lt;c:when&gt;、&lt;c:otherwise&gt;的父标签。比如：&lt;c:choose&gt;    &lt;c:when test=\"${row.v_money&lt;10000}\"&gt;        初学下海    &lt;/c:when&gt;    &lt;c:when test=\"${row.v_money&gt;=10000&amp;&amp;row.v_money&lt;20000}\"&gt;        身手小试    &lt;/c:when&gt;    &lt;c:otherwise&gt;        商业能手    &lt;/c:otherwise&gt;&lt;/c:choose&gt;2.7 &lt; c:forEach&gt;遍历记录集&lt;c:forEach items=\"${finalResult.rows}\" var=\"row\"&gt;           &lt;tr class=\"&lt;%=tdClass[(rank+1)%2]%&gt;\"&gt;        &lt;td align=\"center\"&gt;&lt;span&gt;&lt;%=rank%&gt;&lt;/span&gt;&lt;/td&gt;        &lt;td align=\"center\"&gt;&lt;span&gt;&lt;c:out value=\"${row.player_name}\"/&gt;&lt;/span&gt;&lt;/td&gt;        &lt;td align=\"center\"&gt;&lt;span&gt;￥&lt;c:out value=\"${row.money}\"/&gt;&lt;/span&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;%rank++;%&gt;     &lt;/c:forEach&gt;也可以设定固定次数&lt;c:forEach var =\"i\" begin=\"100\" end=\"110\"&gt;    ${i}&lt;/c:forEach&gt;如果再加个step=\"2\"那么每次增长为2。三、fmt标签库&lt;fmt:formatNumber value=\"12.3\" pattern=\".000\" /&gt;将输出12.300，应用样式”.000”将使格式化后的小数部分有3位。不足3位将以0补齐。&lt;fmt:formatDate value=\"&lt;%=new java.util.Date() %&gt;\" type=\"date\" /&gt;格式化的结果是：2007-5-27。&lt;fmt:formatDate value=\"&lt;%=new java.util.Date() %&gt;\" type=\"time\" /&gt;格式化的结果是：9:25:11。&lt;fmt:formatDate value=\"&lt;%=new java.util.Date() %&gt;\" type=\"both\" /&gt;格式化的结果是：2007-5-27 9:25:11。"
  },
  
  {
    "title": "给GitHub主页添加统计图",
    "url": "/posts/gei-github-zhuye-tianjia-tongjimianban/",
    "categories": "Knowledge, GitHub",
    "tags": "GitHub",
    "date": "2021-01-11 13:47:00 +0800",
    





    
    "snippet": "本文添加的统计图来源于这个仓库https://github.com/anuraghazra/github-readme-stats创建仓库登录你的Github帐号，然后创建一个与你的用户名同名的仓库。注意事项：  仓库名与用户名必须一样；  仓库必须公开；  仓库里需要有一个README文件；修改README的内容以下是我的配置：&lt;img align=\"right\" src=\"http...",
    "content": "本文添加的统计图来源于这个仓库https://github.com/anuraghazra/github-readme-stats创建仓库登录你的Github帐号，然后创建一个与你的用户名同名的仓库。注意事项：  仓库名与用户名必须一样；  仓库必须公开；  仓库里需要有一个README文件；修改README的内容以下是我的配置：&lt;img align=\"right\" src=\"https://github-readme-stats.vercel.app/api?username=soupk&amp;show_icons=true&amp;icon_color=27c968&amp;text_color=d4f4e1&amp;bg_color=333333&amp;hide_title=false&amp;hide_border=true&amp;title_color=ffffff&amp;include_all_commits=true\" /&gt;### Hello World 👋- :octocat:  New to GitHub- :dart:   Stick to the goal- :bird:  A green hand- :ledger:   My notebook效果如下："
  },
  
  {
    "title": "为Jekyll添加功能",
    "url": "/posts/wei-jekyll-tianjia-gongneng/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2021-01-11 00:34:00 +0800",
    





    
    "snippet": "Jekyll本身插件的安装一共3种方式:  在根目录下新建_plugins文件夹, 然后把对应的*.rb插件文件放进去即可;  在_config.yml文件中增加一个gems关键字, 然后把要引用的插件用数组形式存储其中即可;  在Gemfile中添加相关的插件;使用kramdown自动生成目录树启用kramdown，即在_config.yml中添加markdown: kramdown这一行...",
    "content": "Jekyll本身插件的安装一共3种方式:  在根目录下新建_plugins文件夹, 然后把对应的*.rb插件文件放进去即可;  在_config.yml文件中增加一个gems关键字, 然后把要引用的插件用数组形式存储其中即可;  在Gemfile中添加相关的插件;使用kramdown自动生成目录树启用kramdown，即在_config.yml中添加markdown: kramdown这一行，然后在md文章中需要插入目录的地方添加：* 目录{:toc}添加中英文字数统计      英文字数统计    jekyll中有内置的英文字数统计方法number_of_words，直接在需要显示的文章中添加代码    // 注意：以下代码显示出来的只是字数，需要加一些文字说明\\{\\{ page.content | number_of_words \\}\\}// 使用时去掉\\            中文字数统计    添加代码    // 操作同上\\{\\{ content | strip_html | strip_newlines | split: \"\" | size \\}\\}// 使用时去掉\\      "
  },
  
  {
    "title": "给Jekyll博客添加访问量统计",
    "url": "/posts/wei-jekyll-boke-tianjia-fangwenliang-tongji/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2021-01-11 00:34:00 +0800",
    





    
    "snippet": "给Jekyll博客添加访问量统计需要使用不蒜子插件，在需要统计浏览量的页面引入busuanzi.js：&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;添加站点的访问量：      pv的方式      &lt;!-- 单个用户连续点击n篇文章，...",
    "content": "给Jekyll博客添加访问量统计需要使用不蒜子插件，在需要统计浏览量的页面引入busuanzi.js：&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;添加站点的访问量：      pv的方式      &lt;!-- 单个用户连续点击n篇文章，记录n次访问量 --&gt;  &lt;span id=\"busuanzi_container_site_pv\"&gt;      本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次  &lt;/span&gt;            uv的方式      &lt;!-- 单个用户连续点击n篇文章，只记录1次访客数 --&gt;  &lt;span id=\"busuanzi_container_site_uv\"&gt;      本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次  &lt;/span&gt;      添加单页访问量：      pv的方式      &lt;!-- 单个用户点击1篇文章，本篇文章记录1次阅读量 --&gt;  &lt;span id=\"busuanzi_container_page_pv\"&gt;  本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次  &lt;/span&gt;      "
  },
  
  {
    "title": "Git获取文件commit的日期",
    "url": "/posts/git-huoqu-wenjian-de-commit-riqi/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2021-01-09 13:47:00 +0800",
    





    
    "snippet": "git log -1 --pretty=%ad --date=iso test.html",
    "content": "git log -1 --pretty=%ad --date=iso test.html"
  },
  
  {
    "title": "一些好看的头像",
    "url": "/posts/yixie-haokan-de-touxiang/",
    "categories": "Design, Picture",
    "tags": "Picture",
    "date": "2021-01-06 13:47:00 +0800",
    





    
    "snippet": "这些好看的头像是我在这个网址发现的：https://mobile.zcool.com.cn/work/ZMTQwNzQ4MjQ=.html，是叫土星浮游的一位插画师的作品，收藏了   ",
    "content": "这些好看的头像是我在这个网址发现的：https://mobile.zcool.com.cn/work/ZMTQwNzQ4MjQ=.html，是叫土星浮游的一位插画师的作品，收藏了   "
  },
  
  {
    "title": "String、Date、Timestamp之间的转换",
    "url": "/posts/string-date-timestamp-zhijian-de-huzhuan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-05 11:47:00 +0800",
    





    
    "snippet": "一、String与Date互转1.1 String转Datepublic static void main(String[] args) {    // 注意format的格式要与日期String的格式相匹配     DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");    String dateStr = \"2010/...",
    "content": "一、String与Date互转1.1 String转Datepublic static void main(String[] args) {    // 注意format的格式要与日期String的格式相匹配     DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");    String dateStr = \"2010/05/04 12:34:23\";    Date date = new Date();    try {        date = sdf.parse(dateStr);        System.out.println(date.toString());    } catch (Exception e) {        e.printStackTrace();    }}1.2 Date转Stringpublic static void main(String[] args) {    //format的格式可以任意      DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");      DateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH/mm/ss\");      Date date = new Date();      try {          System.out.println(sdf.format(date));          System.out.println(sdf2.format(date));      } catch (Exception e) {          e.printStackTrace();      }  }二、String与Timestamp互转2.1 String转Timestamppublic static void main(String[] args) {    Timestamp ts = new Timestamp(System.currentTimeMillis());      // String的类型必须形如： yyyy-mm-dd hh:mm:ss[.f...]    // 这样的格式，中括号表示可选，否则报错    String tsStr = \"2011-05-09 11:49:45\";      try {          ts = Timestamp.valueOf(tsStr);          System.out.println(ts);      } catch (Exception e) {          e.printStackTrace();      }  }2.2 Timestamp转Stringpublic static void main(String[] args) {    DateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");    Timestamp ts = new Timestamp(System.currentTimeMillis());    try {        // 方法一，优势在于可以灵活的设置字符串的形式        System.out.println(sdf.format(ts));        // 方法二        System.out.println(ts.toString());    } catch (Exception e) {        e.printStackTrace();    }}三、Date与Timestamp互转3.1 Timestamp转Datepublic static void main(String[] args) {    Timestamp ts = new Timestamp(System.currentTimeMillis());    Date date = new Date();    try {        date = ts;        System.out.println(date.toString());    } catch (Exception e) {        e.printStackTrace();    }}Date和Timesta是父子类关系。3.2 Date转Timestamppublic static void main(String[] args) {    Timestamp ts = new Timestamp(System.currentTimeMillis());    Date date = new Date();    try {        ts = new Timestamp(date.getTime());        System.out.println(ts.toString());    } catch (Exception e) {        e.printStackTrace();    }}"
  },
  
  {
    "title": "Enable Google Page Views",
    "url": "/posts/enable-google-pv/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2021-01-04 07:32:00 +0800",
    





    
    "snippet": "  The content of this post applies only to Universal Analytics property (UA), not Google Analytics 4 (GA 4). In addition, since UA is about to be deprecated on Jul 1, 2023, the Page Views feature o...",
    "content": "  The content of this post applies only to Universal Analytics property (UA), not Google Analytics 4 (GA 4). In addition, since UA is about to be deprecated on Jul 1, 2023, the Page Views feature of Chirpy will also be deprecated at that time.This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well.  Head to https://analytics.google.com/ and click on Start Measuring  Enter your desired Account Name and choose the desired checkboxes  Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard  Enter the required information About your business  Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps:  Go to Admin on the left column  Select the desired property from the drop-down on the second column  Click on Data Streams  Add a stream and click on Web  Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml file:google_analytics:  id: 'G-V6XXXXXXX'   # fill in your Google Analytics ID  # Google Analytics pageviews report settings  pv:    proxy_endpoint:   # fill in the Google Analytics superProxy endpoint of Google App Engine    cache_path:       # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine      Visit https://console.cloud.google.com/appengine        Click on Create Application        Click on Create Project        Enter the name and choose the data center close to you        Select Python language and Standard environment        Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient.        Go to your App Engine dashboard on your browser and select API &amp; Services from the left navigation menu        Click on Enable APIs and Services button on the top        Enable the following APIs: Google Analytics API        On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status        Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&lt;project-id&gt;.&lt;region&gt;.r.appspot.com/admin/auth        Note down the Your Client ID and Your Client Secret. You’ll need this in the next section.        Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart        Run the following commands:    [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser:    https://accounts.google.com/o/oauth2/auth?response_type=code&amp;client_id=XYZ.apps.googleusercontent.com&amp;redirect_uri=ABCDEFGEnter verification code: &lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here      Setup Google Analytics superProxy      Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local.        Remove the first 2 lines in the src/app.yaml file:    - application: your-project-id- version: 1            In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard.        Enter any random key for XSRF_KEY, your config.py should look similar to this    #!/usr/bin/python2.7__author__ = 'pete.frisella@gmail.com (Pete Frisella)'# OAuth 2.0 Client SettingsAUTH_CONFIG = {  'OAUTH_CLIENT_ID': 'YOUR_CLIENT_ID',  'OAUTH_CLIENT_SECRET': 'YOUR_CLIENT_SECRET',  'OAUTH_REDIRECT_URI': '%s%s' % (    'https://chirpy-test-XXXXXX.ue.r.appspot.com',    '/admin/auth'  )}# XSRF SettingsXSRF_KEY = 'OnceUponATimeThereLivedALegend'              You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com.But, for the sake of keeping it simple, we will be using the Google provided default URL.            From inside the src/ directory, deploy the app    [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor:      [/tmp/google-analytics-super-proxy/src/app.yaml]source:          [/tmp/google-analytics-super-proxy/src]target project:  [chirpy-test-XXXX]target service:  [default]target version:  [VESRION_NUM]target url:      [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage                 ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse            Visit the deployed service. Add a /admin to the end of the URL.        Click on Authorize Users and make sure to add yourself as a managed user.        If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix.  If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows:  start-date: fill in the first day of blog posting  end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date)  metrics: select ga:pageviews  dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 1:      filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=.    Among them, ; means using logical AND to concatenate two rules.    If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl.  After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics:  id: 'G-V6XXXXXXX'   # fill in your Google Analytics ID  pv:    proxy_endpoint: 'https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&lt;ID FROM SUPER PROXY&gt;'    cache_path:       # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference            Google Analytics Core Reporting API: Filters &#8617;      "
  },
  
  {
    "title": "POI使用示例",
    "url": "/posts/poi-shiyong-shili/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import java.io.FileOutputStream;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFFont;import org.apache.poi....",
    "content": "import java.io.FileOutputStream;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFFont;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.hssf.usermodel.HSSFRichTextString;import org.apache.poi.hssf.usermodel.HSSFDataFormat;import org.apache.poi.hssf.usermodel.HSSFComment;import org.apache.poi.hssf.usermodel.HSSFPatriarch;import org.apache.poi.hssf.usermodel.HSSFClientAnchor;public class PoiCreateExcelDemo {    public static void main(String[] args) {           // 创建新的Excel工作簿        HSSFWorkbook workbook = new HSSFWorkbook();                // 在Excel工作簿中建一工作表，其名为缺省值, 也可以指定Sheet名称        HSSFSheet sheet = workbook.createSheet();        //HSSFSheet sheet = workbook.createSheet(\"SheetName\");                 // 用于格式化单元格的数据        HSSFDataFormat format = workbook.createDataFormat();                // 创建新行(row),并将单元格(cell)放入其中. 行号从0开始计算.        HSSFRow row = sheet.createRow((short) 1);        // 设置字体        HSSFFont font = workbook.createFont();        font.setFontHeightInPoints((short) 20); //字体高度        font.setColor(HSSFFont.COLOR_RED); //字体颜色        font.setFontName(\"黑体\"); //字体        font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); //宽度        font.setItalic(true); //是否使用斜体\t    // font.setStrikeout(true); //是否使用划线        // 设置单元格类型        HSSFCellStyle cellStyle = workbook.createCellStyle();        cellStyle.setFont(font);        cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER); //水平布局：居中        cellStyle.setWrapText(true);                // 添加单元格注释        // 创建HSSFPatriarch对象,HSSFPatriarch是所有注释的容器.        HSSFPatriarch patr = sheet.createDrawingPatriarch();        // 定义注释的大小和位置,详见文档        HSSFComment comment = patr.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short)4, 2, (short) 6, 5));        // 设置注释内容        comment.setString(new HSSFRichTextString(\"可以在POI中添加注释！\"));        // 设置注释作者. 当鼠标移动到单元格上是可以在状态栏中看到该内容.        comment.setAuthor(\"Xuys.\");                // 创建单元格        HSSFCell cell = row.createCell((short) 1);        HSSFRichTextString hssfString = new HSSFRichTextString(\"Hello World!\");        cell.setCellValue(hssfString);//设置单元格内容        cell.setCellStyle(cellStyle);//设置单元格样式        cell.setCellType(HSSFCell.CELL_TYPE_STRING);//指定单元格格式：数值、公式或字符串        cell.setCellComment(comment);//添加注释        //格式化数据        row = sheet.createRow((short) 2);        cell = row.createCell((short) 2);        cell.setCellValue(11111.25);        cellStyle = workbook.createCellStyle();        cellStyle.setDataFormat(format.getFormat(\"0.0\"));        cell.setCellStyle(cellStyle);        row = sheet.createRow((short) 3);        cell = row.createCell((short) 3);        cell.setCellValue(9736279.073);        cellStyle = workbook.createCellStyle();        cellStyle.setDataFormat(format.getFormat(\"#,##0.0000\"));        cell.setCellStyle(cellStyle);                sheet.autoSizeColumn((short)0); //调整第一列宽度        sheet.autoSizeColumn((short)1); //调整第二列宽度        sheet.autoSizeColumn((short)2); //调整第三列宽度        sheet.autoSizeColumn((short)3); //调整第四列宽度        try {            FileOutputStream fileOut = new FileOutputStream(\"E:/demo.xls\");            workbook.write(fileOut);            fileOut.close();        } catch (Exception e) {            System.out.println(e.toString());        }    }}"
  },
  
  {
    "title": "POI自定义单元格背景颜色",
    "url": "/posts/poi-shezhi-danyuange-yanse/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import org.apache.poi.hssf.usermodel.*;import org.apache.poi.hssf.util.HSSFColor;import java.io.FileOutputStream;public class PoiBackgroundColorDemo {\tpublic static void main(String[] args) throws ...",
    "content": "import org.apache.poi.hssf.usermodel.*;import org.apache.poi.hssf.util.HSSFColor;import java.io.FileOutputStream;public class PoiBackgroundColorDemo {\tpublic static void main(String[] args) throws Exception {        //创建Excel工作薄        HSSFWorkbook excel = new HSSFWorkbook();        //创建第一个sheet        HSSFSheet sheet = excel.createSheet(\"POI Demo\");        //创建第一行    \tHSSFRow row = sheet.createRow((short) 0);        //创建第一个单元格        HSSFCell cell = row.createCell((short) 0);        //设置单元格的值        cell.setCellValue(\"Ay\");        //生成单元格样式        HSSFCellStyle style = excel.createCellStyle();        //设置背景颜色        style.setFillForegroundColor(HSSFColor.LIME.index);        //solid填充foreground前景色        style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);        cell.setCellStyle(style);        //通过流写到硬盘        FileOutputStream out = new FileOutputStream(\"D:/old_color.xls\");        excel.write(out);        out.close();        //自定义单元格的样式        cell.setCellValue(\"Al\");        //拿到palette颜色板        HSSFPalette palette = excel.getCustomPalette();        //把之前的颜色HSSFColor.LIME.index替换为RGB(51, 204, 204)宝石蓝这种颜色        palette.setColorAtIndex(HSSFColor.LIME.index, (byte) 0, (byte) 255, (byte) 127);                out = new FileOutputStream(\"D:/new_color.xls\");        excel.write(out);        out.close();    }}D:/old_color.xls结果  D:/new_color.xls结果"
  },
  
  {
    "title": "POI合并单元格",
    "url": "/posts/poi-hebing-danyuange/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "XSSFWorkbook wb = new XSSFWorkbook();XSSFSheet sheet = wb.createSheet();// 参数说明：1：开始行 2：结束行 3：开始列 4：结束列// 比如我要合并第二行到第四行，第六列到第八列 sheet.addMergedRegion(new CellRangeAddress(1, 3, 5, 7));比如我们要生成的单元格为：...",
    "content": "XSSFWorkbook wb = new XSSFWorkbook();XSSFSheet sheet = wb.createSheet();// 参数说明：1：开始行 2：结束行 3：开始列 4：结束列// 比如我要合并第二行到第四行，第六列到第八列 sheet.addMergedRegion(new CellRangeAddress(1, 3, 5, 7));比如我们要生成的单元格为：sheet.addMergedRegion(new CellRangeAddress(0, 3, 0, 0));sheet.addMergedRegion(new CellRangeAddress(0, 3, 3, 3));sheet.addMergedRegion(new CellRangeAddress(0, 3, 4, 4));// 第一行数据XSSFRow row = sheet.createRow(0);row.createCell(0).setCellValue(\"工作站\");row.createCell(1).setCellValue(\"位置\");row.createCell(2).setCellValue(\"序号\");row.createCell(3).setCellValue(\"订单号\");row.createCell(4).setCellValue(\"成品号/型号\");// 第二行数据XSSFRow row = sheet.createRow(number);// row.createCell(0).setCellValue(\"工作站\"); // 因为和上面的行合并了，所以不用再次赋值了row.createCell(1).setCellValue(\"位置\");row.createCell(2).setCellValue(\"序号\");// row.createCell(3).setCellValue(\"订单号\"); // 因为和上面的行合并了，所以不用再次赋值了// row.createCell(4).setCellValue(\"成品号/型号\"); // 因为和上面的行合并了，所以不用再次赋值了// 第三行数据和第二行是一样的// 第四五行数据和第一行是一样的 "
  },
  
  {
    "title": "POI冻结行或列",
    "url": "/posts/poi-dongjie-hang-huo-lie/",
    "categories": "Knowledge, POI",
    "tags": "POI",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "HSSFWorkbook workbook = new HSSFWorkbook();  HSSFSheet sheet = workbook.createSheet();  sheet.createFreezePane(a, b, c, d);   四个参数的含义：  ａ表示要冻结的列数；  ｂ表示要冻结的行数；  ｃ表示右边区域[可见]的首列序号；  ｄ表示下边区域[可见]的首行序号；举...",
    "content": "HSSFWorkbook workbook = new HSSFWorkbook();  HSSFSheet sheet = workbook.createSheet();  sheet.createFreezePane(a, b, c, d);   四个参数的含义：  ａ表示要冻结的列数；  ｂ表示要冻结的行数；  ｃ表示右边区域[可见]的首列序号；  ｄ表示下边区域[可见]的首行序号；举例：// 冻结第一列，冻结列右侧的第一列为B列CreateFreezePane(1, 0, 1, 0);// 冻结左侧两列，冻结列右侧的第一列为F列CreateFreezePane(2, 0, 5, 0);// 冻结第一行，冻结行下侧第一行的左边框显示“2”CreateFreezePane(0, 1, 0, 1);"
  },
  
  {
    "title": "Java随机数的两种获取方式",
    "url": "/posts/java-suijishu-de-huoqu-fangshi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import java.util.Random;public class RandomDemo {    public static void main(String[] args) {        //实现方式一        int random = (int) (Math.random() * 60);        System.out.println(random);      ...",
    "content": "import java.util.Random;public class RandomDemo {    public static void main(String[] args) {        //实现方式一        int random = (int) (Math.random() * 60);        System.out.println(random);                //实现方式二        Random random1 = new Random(124585454);        Random random2 = new Random(124585454);        int r1 = random1.nextInt(61); // 0-60        int r2 = random2.nextInt(61);        //random1和random2得到的随机数是一样的        System.out.println(r1 + \" \" + r2);    }}一、java.lang.Math.Random调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该范围内（近似）均匀分布。在使用Math.Random()的时候需要注意的地方是该函数是返回double类型的值，所以在赋值给其他类型变量的时候注意需要进行塑形转换。二、java.util.Random  在Java的API帮助文档中，总结了一下对这个Random()函数功能的描述：          java.util.Random类中实现的随机算法是伪随机，也就是有规则的随机，所谓有规则的就是在给定种(seed)的区间内随机生成数字；      相同种子数的Random对象，相同次数生成的随机数字是完全相同的；      Random类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率均等；        Random()的两种构造方法：          Random()：创建一个新的随机数生成器。      Random(long seed)：使用单个long种子创建一个新的随机数生成器。我们可以在构造Random对象的时候指定种子：Random r1 = new Random(20);，或者默认当前系统时间对应的相对时间有关的数字作为种子数: Random r1 = new Random();。你在创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。        下面是Java.util.Random()方法摘要：          protected int next(int bits)：生成下一个伪随机数。      boolean nextBoolean()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的boolean值。      void nextBytes(byte[] bytes)：生成随机字节并将其置于用户提供的byte数组中。      double nextDouble()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布的double值。      float nextFloat()：返回下一个伪随机数，它是取自此随机数生成器序列的、在0.0和1.0之间均匀分布float值。      double nextGaussian()：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。      int nextInt()：返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的int值。      int nextInt(int n)：会随机生成一个整数，这个整数的范围就是int类型的范围-2^31 ~ 2^31-1      long nextLong()：返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的long值。      void setSeed(long seed)：使用单个long种子设置此随机数生成器的种子。        示例：          生成[0, 1.0)区间的小数：double d1 = r.nextDouble();      生成[0, 5.0)区间的小数：double d2 = r.nextDouble() * 5;      生成[1, 2.5)区间的小数：double d3 = r.nextDouble() * 1.5 + 1;      生成-2^31 ~ 2^31-1之间的整数：int n = r.nextInt();      生成[0, 10)区间的整数：int n = r.nextInt(10);或n = Math.abs(r.nextInt() % 10);      三、两种方法的对比最后再来简单对比一下这两个随机函数的特点：  java.Math.Random()实际是在内部调用java.util.Random()的，它有一个致命的弱点，它和系统时间有关，也就是说相隔时间很短的两个random比如：    double a = Math.random();double b = Math.random();        极有可能会得到两个一模一样的double。    java.util.Random()在调用的时候可以实现和java.Math.Random()一样的功能，而且他具有很多的调用方法，相对来说比较灵活。所以从总体来看，使用java.util.Random()会相对来说比较灵活一些。"
  },
  
  {
    "title": "FileOutputStream类的换行写入和追加写入",
    "url": "/posts/fileoutputstream-de-huanhang-xieru-he-zhuijia-xieru/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-03 11:47:00 +0800",
    





    
    "snippet": "import java.io.FileOutputStream;    public class FileOutputStreamDemo {      public static void main(String[] args) throws Exception {          // 创建文件输出流对象          FileOutputStream fos1 = new Fil...",
    "content": "import java.io.FileOutputStream;    public class FileOutputStreamDemo {      public static void main(String[] args) throws Exception {          // 创建文件输出流对象          FileOutputStream fos1 = new FileOutputStream(\"fos1.txt\");          // 第二个参数为true表示程序每次运行都是追加字符串在原有的字符上        FileOutputStream fos2 = new FileOutputStream(\"fos2.txt\", true);             // 写数据          for (int x = 0; x &lt; 10; x++) {              fos1.write((\"hello\" + x).getBytes());              fos1.write(\"\\r\\n\".getBytes());// 写入一个换行          }          for (int x = 0; x &lt; 10; x++) {              fos2.write((\"hello\" + x).getBytes());              fos2.write(\"\\r\\n\".getBytes());// 写入一个换行          }        // 释放资源          fos1.close();          fos2.close();      }  }  "
  },
  
  {
    "title": "Maven的安装和使用",
    "url": "/posts/maven-de-anzhuang-he-shiyong/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2021-01-02 13:47:00 +0800",
    





    
    "snippet": "一、Maven的安装和配置1.1 下载进入Maven官网的下载页面：http://maven.apache.org/download.cgi，选择当前最新版本，例如apache-maven-3.0.4-bin.zip，下载到本地并解压。1.2 配置进入Maven安装目录下的conf子目录中，打开settings.xml进行配置修改。      修改默认的本地仓库位置    Maven默认的本...",
    "content": "一、Maven的安装和配置1.1 下载进入Maven官网的下载页面：http://maven.apache.org/download.cgi，选择当前最新版本，例如apache-maven-3.0.4-bin.zip，下载到本地并解压。1.2 配置进入Maven安装目录下的conf子目录中，打开settings.xml进行配置修改。      修改默认的本地仓库位置    Maven默认的本地仓库位置是当前用户工作目录下的.m2/repository，使用过程中这个目录里的文件会比较多，占用空间越来越大。一般建议更换到其它磁盘目录下。如下配置，就把默认的本地仓库更改到D:/.m2/repository这个目录（这个目录结构需要自己创建好）：    &lt;localRepository&gt;D:/.m2/repository&lt;/localRepository&gt;            修改默认的中央仓库镜像    Maven默认的中央仓库里的文件不全。所以，都需要自行添加其它的镜像地址。在settings.xml文件中的&lt;mirrors&gt;标签里添加如下内容：    &lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;      二、Maven的使用Maven一般作为插件在IDE中使用，下面以Eclipse为例。2.1 安装Maven插件Eclipse默认不支持Maven。需要给它添加m2eclipse插件。下面是具体的操作步骤：  依次选择Eclipse菜单栏的“Help”菜单“Instance NewSoftWare”菜单项，弹出如下对话窗口：  选择“Add..”按钮，弹出如下对话框：  这个对话框就是用于添加一个插件地址的。在“Name”对应的输入框里输入该操作的一个标识名。在“Location”对应的输入框里输入这个插件的安装地址。注：Maven的Eclipse插件地址为http://download.eclipse.org/technology/m2e/releases。输入后，如下图所示：  输入完成后，点击右下角的“OK”按钮，就会弹出如下对话框：  这里需要选择想要安装的插件的详细内容。选中“Maven Integration for Eclipse”前面的复选框。如下图所示：  选择完成后，点击右下方的“Next&gt;”按钮进行安装。安装成功后，会提示需要重启Eclipse来生效这次配置。重启之后，就可以使用m2eclipse插件功能了。2.2 配置Maven插件插件安装好之后，还需要进行一些配置才能够开始使用Maven的功能。  设置m2eclipse插件所关联的Maven程序          依次选择Eclipse菜单栏的“Window”菜单“Preferences”菜单项，弹出如下对话框：      在这个对话框左边的导航栏中展开“Maven”目录结点，并选择“Installations”子节点，如下图所示：      这里需要关联上对应的Maven安装程序。具体操作是，在右边面板中选择“Add…”按钮，会弹出如下选择Maven安装目录的选择对话框，通过这个对话框来选择Maven的具体安装目录。选择好之后就点击“确定”按钮。如下图所示：        设置自定义的本地仓库          选择如上图对话窗口左边菜单树 “Maven”节点下的“UserSettings”子节点，它默认的配置文件是C:\\Documents and Settings\\csdn\\.m2\\settings.xml，如下图所示：      这边需要修改为我们自定义的settings.xml文件。具体操作是，点击“Browse…”按钮来选择Maven安装目录下的settings.xml文件，点击“打开”按钮来确认刚才的选择，就会回到如下图的对话窗口中：      在上图中点击右下角的“OK”按钮来完成所有的配置修改。      "
  },
  
  {
    "title": "HashMap的四种遍历方法",
    "url": "/posts/hashmap-de-sizhong-bianli-fangfa/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;public class MapShowTest {    public static void ...",
    "content": "import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;public class MapShowTest {    public static void main(String[] args) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();        for (int i = 0; i &lt; 10; i++) {            map.put(i, i + 1);        }        // 通过Map.keySet遍历key和value        for (int temp : map.keySet()) {            System.out.print(temp + \"=\" + map.get(temp) + \", \");        }        // 通过Map.entrySet遍历key和value，推荐，尤其是容量大时        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entry = map.entrySet();        for (Map.Entry&lt;Integer, Integer&gt; temp : entry) {            System.out.print(temp.getKey() + \"=\" + temp.getValue() + \", \");        }        // 通过Map.entrySet使用iterator遍历key和value        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entry1 = map.entrySet();        Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = entry1.iterator();        while (iterator.hasNext()) {            Map.Entry&lt;Integer, Integer&gt; mapTemp = iterator.next();            System.out.print(mapTemp.getKey() + \"=\" + mapTemp.getValue() + \", \");        }        //通过Map.values()遍历所有的value，但不能遍历key        Collection&lt;Integer&gt; c = map.values();        for (int temp : c) {            System.out.print(\"value= \" + temp + \", \");        }    }}"
  },
  
  {
    "title": "final和static",
    "url": "/posts/final-he-static/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "一、final根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类的成员方法和变量（包括成员变量和局部变量）。它有以下特点：  final类不能被继承，没有子类，final类中的方法默认是final的。  final方法不能被子类的方法覆盖，但可以被继承。  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  fina...",
    "content": "一、final根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类的成员方法和变量（包括成员变量和局部变量）。它有以下特点：  final类不能被继承，没有子类，final类中的方法默认是final的。  final方法不能被子类的方法覆盖，但可以被继承。  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  final不能用于修饰构造方法。  父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。1.1 final类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。1.2 final方法final类不能被继承，因此final类的成员方法没有机会被覆盖。使用final方法的原因有二：第一、把方法锁定，防止任何继承类修改它的意义和实现。第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。1.3 final变量修饰变量是final用得最多的地方，对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。举个例子：class Man {    private final int i = 0;    public Man() {        // i = 1; // 报错        final Object obj = new Object();        // obj = new Object(); // 报错    }}另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。举个例子：package org.test;  public class Test3 {     private final String S = \"final实例变量S\";     private final int A = 100;     public final int B = 90;     public static final int C = 80;     private static final int D = 70;     public final int E; // final空白,必须在初始化对象的时候赋初值     public Test3(int x) {         E = x;     }     public static void main(String[] args) {         Test3 t = new Test3(2);         // t.A=11; // 出错,final变量的值一旦给定就无法改变         // t.B=91; // 出错,final变量的值一旦给定就无法改变         // t.C=81; // 出错,final变量的值一旦给定就无法改变         // t.D=71; // 出错,final变量的值一旦给定就无法改变         System.out.println(t.A);         System.out.println(t.B);         System.out.println(t.C); // 不推荐用对象方式访问静态字段         System.out.println(t.D); // 不推荐用对象方式访问静态字段         System.out.println(Test3.C); // 推荐使用类名直接调用        System.out.println(Test3.D); // 推荐使用类名直接调用        // System.out.println(Test3.E); // 出错,因为E为final空白,依据不同对象值有所不同.         System.out.println(t.E);         Test3 t1 = new Test3(3);         System.out.println(t1.E); // final空白变量E依据对象的不同而不同     }     private void test() {         System.out.println(new Test3(1).A);         System.out.println(Test3.C);         System.out.println(Test3.D);     }     public void test2() {             final int a; // final空白,在需要的时候才赋值             final int b = 4; // 局部常量，final用于局部变量的情形             a = 3;             // a=4; // 出错,已经给赋过值了            // b=2; // 出错,已经给赋过值了    } }二、staticstatic表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。它有以下特点：  被static修饰的成员变量和成员方法独立于该类的任何对象。  类的所有实例共享同一个static变量。  static是在内存中分配一块区域，供整个类通用，所有的类的对象都享有它的共同的值。2.1 static方法（静态方法）静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联。因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。即使没有创建对象，也需要一个能调用的方法，为满足这两方面的要求，可使用static（静态）关键字。 2.2 static变量（静态变量）static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进行初始化。2.3 static代码块（静态块）static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。利用静态代码块可以对一些static变量进行赋值。举个例子：public class Test5 {     private static int a;     private int b;     static {         Test5.a = 3;         System.out.println(a);         Test5 t = new Test5();         t.f();         t.b = 1000;         System.out.println(t.b);     }     static {         Test5.a = 4;         System.out.println(a);     }     public static void main(String[] args) {         new Test5();    }     static {         Test5.a = 5;         System.out.println(a);     }     public void f() {         System.out.println(\"hhahhahah\");     } }运行结果：3hhahhahah100045很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。"
  },
  
  {
    "title": "compareTo()在排序中的应用",
    "url": "/posts/compareto-fangfa-de-shiyong/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "public class Student implements Comparable&lt;Student&gt; {    private String name;    private int age;    private double score;    public Student(String name, int age, double score) {        this....",
    "content": "public class Student implements Comparable&lt;Student&gt; {    private String name;    private int age;    private double score;    public Student(String name, int age, double score) {        this.age = age;        this.name = name;        this.score = score;    }    public String toString() {        return \"name=\" + name + \", age=\" + age + \", score=\" + score;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public double getScore() {        return score;    }    public void setScore(double score) {        this.score = score;    }    // 重写compareTo    public int compareTo(Student o) {        return this.age - o.age;    }    public static void main(String[] args) {        Student s1 = new Student(\"Bob\", 13, 50);        Student s2 = new Student(\"Tom\", 15, 40);        Student s3 = new Student(\"Jhon\", 20, 80);        Student s4 = new Student(\"Ann\", 10, 60);        Student[] stu = new Student[4];        stu[0] = s1;        stu[1] = s2;        stu[2] = s3;        stu[3] = s4;        //利用Arrays.sort对数组进行排序的时候按照重写的compareTo方法进行        Arrays.sort(stu);        for (int i = 0; i &lt; stu.length; i++) {            System.out.println(stu[i]);        }     }}运行结果：name=Ann, age=10, score=60.0name=Bob, age=13, score=50.0name=Tom, age=15, score=40.0name=Jhon, age=20, score=80.0import java.util.ArrayList;import java.util.Collections;import java.util.List;public class Student implements Comparable&lt;Student&gt; {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    // 重写compareTo方法    public int compareTo(Student o) {        // 先按age排序        if (this.age &gt; o.getAge()) {            return (this.age - o.getAge());        }        if (this.age &lt; o.getAge()) {            return (o.getAge() - this.age);        }        // 再按name排序        if (this.name.compareTo(o.getName()) &gt; 0) {            return 1;        }        if (this.name.compareTo(o.getName()) &lt; 0) {            return -1;        }        return 0;    }    public static void main(String[] args) {        Student f1 = new Student(\"c\", 15);        Student f2 = new Student(\"a\", 25);        Student f3 = new Student(\"b\", 15);        List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        list.add(f1);        list.add(f3);        list.add(f2);        Collections.sort(list);        for (Student o : list) {            System.out.println(o.getAge() + \"--&gt;\" + o.getName());        }    }}运行结果：15--&gt;b15--&gt;c25--&gt;a"
  },
  
  {
    "title": "Java中获取当前时间的方法",
    "url": "/posts/Java-zhong-huoqu-dangqian-shijian-de-fangfa/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-02 11:47:00 +0800",
    





    
    "snippet": "package test.date.demo;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.util.Date;public class GetTimeDemo {    public static void main(String[] args) {        // 使用Date类和Sim...",
    "content": "package test.date.demo;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.util.Date;public class GetTimeDemo {    public static void main(String[] args) {        // 使用Date类和SimpleDateFormat类        SimpleDateFormat sdf = new SimpleDateFormat(\"YYYY-MM-dd hh:mm:ss\");        System.out.println(sdf.format(new Date()));                // 使用Timestamp        long time = System.currentTimeMillis();        System.out.println(new Timestamp(time).toString());    }}"
  },
  
  {
    "title": "接口编程对于开发的意义",
    "url": "/posts/jiekou-biancheng-duiyu-kaifa-de-yiyi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-01 11:47:00 +0800",
    





    
    "snippet": "对于Java的意义Java本身也是一个不断完善的语言，他也在频繁的改动他的系统API，他的API是一个庞大的体系，互相关联，如果不采用接口，而都是用实现类的话，那么API的改动就会给整个体系带来不稳定。而且如果改动API，那么就会有大量采用旧API的项目因无法正常运行，会损失大量客户。换句话说，JDK已经发布的API是一种承诺，一经发布就不能更改，即使原来API存在各种各样的问题（例如jav...",
    "content": "对于Java的意义Java本身也是一个不断完善的语言，他也在频繁的改动他的系统API，他的API是一个庞大的体系，互相关联，如果不采用接口，而都是用实现类的话，那么API的改动就会给整个体系带来不稳定。而且如果改动API，那么就会有大量采用旧API的项目因无法正常运行，会损失大量客户。换句话说，JDK已经发布的API是一种承诺，一经发布就不能更改，即使原来API存在各种各样的问题（例如java.util.Properties类就是一个失败的例子）也必须保留，于是在Java里就出现了不建议使用的方法，但JDK依然提供该方法。而且Java语言本身是一个跨平台的语言，为了满足在各个平台下运行，就必须把各种操作做成接口，在编写各个平台下的实现类。对于开发的意义在一些大型项目或者大型公司里，都是由架构师编写出系统接口，具体的实现类交给了程序员编写，公司越大这种情况越明显，所以在这些公司里做开发，我们可能都不知道编写出的系统是个什么样子，每天做的工作可能就是做“填空题”了。在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。实际上，在日常工作中，你已经按照接口编程了，只不过如果你没有这方面的意识，那么你只是在被动的实现这一思想；表现在频繁的抱怨别人改的代码影响了你（接口没有设计好），表现在某个模块的改动引起其他模块的大规模调整（模块接口没有很好的设计）等等。"
  },
  
  {
    "title": "继承和多态",
    "url": "/posts/jicheng-he-duotai/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-01 11:47:00 +0800",
    





    
    "snippet": "继承子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。或子类从父类继承方法，使得子类具有父类相同的行为。特点：在继承关系中，父类更通用、子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。表示父类和子类的术语：父类和子类、超类和子类、基类和派生类。多态多态性就是发送消息给某个对象，让该对象自行决定响应何种行为。指允许不同类的对象对...",
    "content": "继承子类继承父类的特征和行为，使得子类具有父类的各种属性和方法。或子类从父类继承方法，使得子类具有父类相同的行为。特点：在继承关系中，父类更通用、子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。表示父类和子类的术语：父类和子类、超类和子类、基类和派生类。多态多态性就是发送消息给某个对象，让该对象自行决定响应何种行为。指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态的特征是表现出多种形态，具有多种实现方式。或者多态是具有表现多种形态的能力的特征。或者同一个实现接口，使用不同的实例而执行不同的操作。多态存在的三个必要条件一、要有继承；二、要有重写；三、父类引用指向子类对象。总结1、为什么子类类型的对象实例可以赋给超类引用自动实现向上转型。通过该语句，编译器自动将子类实例向上移动，成为通用类型BaseClass。2、不能把父类对象引用赋给子类对象引用变量在Java里面，向上转型是自动进行的,但是向下转型却不是，需要我们自己定义强制进行。"
  },
  
  {
    "title": "重写和重载的区别",
    "url": "/posts/chongxie-chongzai-de-qubie/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2021-01-01 11:47:00 +0800",
    





    
    "snippet": "重写（overwrite）父类与子类之间的多态性，对父类的函数进行重新定义。重写继承到的那个方法的代码，原方法被放弃。子类继承了父类的同名有参函数。当子类继承了父类的一个同名方法，且方法参数不同，称为重写。通过方法的重写，子类可以重新实现父类的某些方法，使其具有自己的特征。重写方法只能存在于具有继承关系中，重写方法只能重写父类非私有的方法。子类函数的访问修饰权限不能低于父类的。重载（over...",
    "content": "重写（overwrite）父类与子类之间的多态性，对父类的函数进行重新定义。重写继承到的那个方法的代码，原方法被放弃。子类继承了父类的同名有参函数。当子类继承了父类的一个同名方法，且方法参数不同，称为重写。通过方法的重写，子类可以重新实现父类的某些方法，使其具有自己的特征。重写方法只能存在于具有继承关系中，重写方法只能重写父类非私有的方法。子类函数的访问修饰权限不能低于父类的。重载（overload）重载是一个类中多态性的一种表现。完全新的方法，参数和原方法不同。当前类的同名方法。通过方法的重载，一个类可以有多个具有相同名字的方法，返回值类型可以相同也可以不相同，由传递给它们不同的个数和类型的参数来决定使用哪种方法。无法以返回类型作为重载函数的区分标准。重写与重载的区别在于重写是子类覆盖父类的方法，要求方法名和参数都相同，子类方法的可访问性可以与父类方法的可访问性相同，或更公开。重载是在同一个类中的两个或两个以上的方法，拥有相同的方法名，但含有不同的参数，即参数个数、类型或顺序不同。"
  },
  
  {
    "title": "Spring Boot和Spring Cloud的关系",
    "url": "/posts/springboot-he-springcloud-de-guanxi/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2020-12-31 13:47:00 +0800",
    





    
    "snippet": "Spring Boot先于Spring Cloud问世。Spring Boot相当于脚手架，借助他可以快速搭建房子，它本身不具备任何功能属性，只是普通房间，没有其他任何功能。什么是Spring BootSpring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、产品级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置，这样...",
    "content": "Spring Boot先于Spring Cloud问世。Spring Boot相当于脚手架，借助他可以快速搭建房子，它本身不具备任何功能属性，只是普通房间，没有其他任何功能。什么是Spring BootSpring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、产品级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。多数Spring Boot应用只需要很少的Spring配置。Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是Spring Boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像Maven整合了所有的jar包，Spring Boot整合了所有的框架（不知道这样比喻是否合适）。Spring Boot的核心思想就是约定大于配置，一切自动完成。采用Spring Boot可以大大的简化你的开发模式，所有你想集成的常用框架，它都有对应的组件支持。什么是Spring CloudSpring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，Spring Cloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，Spring Cloud做为大管家就需要提供各种方案来维护整个生态。Spring Cloud就是一套分布式服务治理的框架，既然它是一套服务治理的框架，那么它本身不会提供具体功能性的操作，更专注于服务之间的通讯、熔断、监控等。因此就需要很多的组件来支持一套功能。Spring Boot和Spring Cloud的关系  Spring Boot是Spring的一套快速配置脚手架，可以基于Spring Boot快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的云应用开发工具；  Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；  Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，可以不基于Spring Boot吗？不可以。  Spring Boot可以离开Spring Cloud独立使用，但是Spring Cloud离不开Spring Boot，属于依赖的关系。总结Spring Boot在Spring Clound中起到了承上启下的作用，如果要学习Spring Cloud必须要学习Spring Boot。"
  },
  
  {
    "title": "Maven如何查看依赖冲突",
    "url": "/posts/maven-ruhe-chakan-yilai-chongtu/",
    "categories": "Knowledge, Maven",
    "tags": "Maven",
    "date": "2020-12-30 13:47:00 +0800",
    





    
    "snippet": "什么是依赖冲突Maven是个很好用的依赖管理工具，但是再好的东西也不是完美的。Maven的依赖机制会导致Jar包的冲突。举个例子，现在你的项目中，使用了两个Jar包，分别是A和B。现在A需要依赖另一个Jar包C，B也需要依赖C。但是A依赖的C的版本是1.0，B依赖的C的版本是2.0。这时候，Maven会将这1.0的C和2.0的C都下载到你的项目中，这样你的项目中就存在了不同版本的C，这时Ma...",
    "content": "什么是依赖冲突Maven是个很好用的依赖管理工具，但是再好的东西也不是完美的。Maven的依赖机制会导致Jar包的冲突。举个例子，现在你的项目中，使用了两个Jar包，分别是A和B。现在A需要依赖另一个Jar包C，B也需要依赖C。但是A依赖的C的版本是1.0，B依赖的C的版本是2.0。这时候，Maven会将这1.0的C和2.0的C都下载到你的项目中，这样你的项目中就存在了不同版本的C，这时Maven会依据依赖路径最短优先原则，来决定使用哪个版本的Jar包，而另一个无用的Jar包则未被使用，这就是所谓的依赖冲突。如何查看依赖冲突使用Maven命令：cd &lt;含有pom.xml的文件夹&gt;mvn dependency:tree -Dverbose -DoutputFile=&lt;文件名&gt;.txt-(io.netty:netty-common:jar:4.0.56.Final:compile - omitted for duplicate表示存在依赖冲突。-(io.netty:netty-common:jar:4.0.56.Final:compile - omitted for conflict with 4.1.36表示存在依赖冲突并且强制使用了4.1.36版本。如何解决依赖冲突解决依赖冲突的方法，就是使用Maven提供的标签，就像下面这样：&lt;dependency&gt;      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;      &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;      &lt;version&gt;2.10.0&lt;/version&gt;      &lt;exclusions&gt;            &lt;exclusion&gt;              &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;              &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;                 &lt;/exclusion&gt;      &lt;/exclusions&gt;&lt;/dependency&gt;log4j-core本身是依赖了log4j-api，但是因为一些其他的模块也依赖了log4j-api，并且两个log4j-api版本不同，所以我们使用标签排除掉log4j-core所依赖的log4j-api，这样Maven就不会下载log4j-core所依赖的log4j-api了，也就保证了我们的项目中只有一个版本的log4j-api。"
  },
  
  {
    "title": "Java注解规范",
    "url": "/posts/java-zhujie-guifan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-30 11:47:00 +0800",
    





    
    "snippet": "一、注解的原则优雅的注解通常要满足三要素。  Nothing is strange没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。  Less is more从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规...",
    "content": "一、注解的原则优雅的注解通常要满足三要素。  Nothing is strange没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。  Less is more从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。    // 根据id获取信息【废话注解】getMessageById(id)        Advance with the time注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。二、注解格式注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。2.1 包注解包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。/** * 落地质量检测 * 1. 用来解决什么问题 * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等;  * 模拟不同的网络：2G，3G，4G，wifi等 * * 2. 如何实现 * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络， * OS参数，获取到浏览器返回结果。 * * 注意： 网络环境配置信息{@link cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum} * 目前使用是常规速度，可以根据实际情况进行调整 *  * @author cruder * @time 2019/12/7 20:3 下午 */package cn.mycookies.landingpagecheck;2.2 类注接javadoc注解中，每个类都必须有注解。/*** Copyright (C), 2019-2020, Jann  balabala...** 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....** @author   类创建者姓名 保持对齐* @date     创建日期 保持对齐* @version  版本号 保持对齐*/2.3 属性注解在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。/** 提示信息 */private String userName;/** * 密码 */private String password;2.4 方法注释在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。/**  * 方法的详细说明，能干嘛，怎么实现的，注意事项...  *  * @param xxx   参数1的使用说明， 能否为null  * @return 返回结果的说明， 不同情况下会返回怎样的结果  * @throws 异常类型   注明从此类方法中抛出异常的说明  */2.5 构造方法注释在每个构造方法前面必须加上注释，注释模板如下：/**  * 构造方法的详细说明  *  * @param xxx   参数1的使用说明， 能否为null  * @throws 异常类型   注明从此类方法中抛出异常的说明  */三、注意事项在使用注解时应该注意一下几点：  枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。  保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。int id = 1;// 反例：不要使用行尾注释//反例：换行符与注释之间没有缩进int age = 18;// 正例：姓名String name;/** * 1. 多行注释 *  * 2. 对于不同的逻辑说明，可以用空行分隔 */"
  },
  
  {
    "title": "Java命名规范",
    "url": "/posts/java-mingming-guifan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-30 11:47:00 +0800",
    





    
    "snippet": "一、Java中的命名规范好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，类一般采用大驼峰命名，方法和局部变...",
    "content": "一、Java中的命名规范好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。            类型      约束      例                  项目名      全部小写，多个单词用中划线分隔‘-’      spring-cloud              包名      全部小写      com.alibaba.fastjson              类名      单词首字母大写      Feature, ParserConfig,DefaultFieldDeserializer              变量名      首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写      password, userName              常量名      全部大写，多个单词，用’_‘分隔      CACHE_EXPIRED_TIME              方法      同变量      read(), readObject(), getById()      二、包命名包名统一使用小写，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。包名的构成可以分为以下几四部分【前缀】【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：            前缀名      例      含义                  indi（或onem ）      indi.发起者名.项目名.模块名.……      个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。              pers      pers.个人名.项目名.模块名.……      个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人              priv      priv.个人名.项目名.模块名.……      私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。              team      team.团队名.项目名.模块名.……      团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有              顶级域名      com.公司名.项目名.模块名.……      公司项目，copyright由项目发起的公司所有      三、类命名类名使用大驼峰命名形式，类命通常时名词或名词短语，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是统一就好。            属性      约束      例                  抽象类      Abstract 或者 Base 开头      BaseUserService              枚举类      Enum 作为后缀      GenderEnum              工具类      Utils作为后缀      StringUtils              异常类      Exception结尾      RuntimeException              接口实现类      接口名+ Impl      UserServiceImpl              领域模型相关      /DO/DTO/VO/DAO      正例：UserDAO 反例： UserDo， UserDao              设计模式相关类      Builder，Factory等      当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory              处理特定功能的      Handler，Predicate, Validator      表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate              测试类      Test结尾      UserServiceTest， 表示用来测试UserService类的              MVC分层      Controller，Service，ServiceImpl，DAO后缀      UserManageController，UserManageDAO      四、方法方法命名采用小驼峰的形式，首字小写，往后的每个单词首字母都要大写。和类名不同的是，方法命名一般为动词或动词短语，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。4.1 返回真伪值的方法注：Prefix-前缀，Suffix-后缀，Alone-单独使用            位置      单词      意义      例                  Prefix      is      对象是否符合期待的状态      isValid              Prefix      can      对象能否执行所期待的动作      canRemove              Prefix      should      调用方执行某个命令或方法是好还是不好,应不应该，或者说推荐还是不推荐      shouldMigrate              Prefix      has      对象是否持有所期待的数据和属性      hasObservers              Prefix      needs      调用方是否需要执行某个命令或方法      needsMigrate      4.2 用来检查的方法            单词      意义      例                  ensure      检查是否为期待的状态，不是则抛出异常或返回error code      ensureCapacity              validate      检查是否为正确的状态，不是则抛出异常或返回error code      validateInputs      4.3 按需求才执行的方法            位置      单词      意义      例                  Suffix      IfNeeded      需要的时候执行，不需要的时候什么都不做      drawIfNeeded              Prefix      might      同上      mightCreate              Prefix      try      尝试执行，失败时抛出异常或是返回errorcode      tryCreate              Suffix      OrDefault      尝试执行，失败时返回默认值      getOrDefault              Suffix      OrElse      尝试执行、失败时返回实际参数中指定的值      getOrElse              Prefix      force      强制尝试执行。error抛出异常或是返回值      forceCreate, forceStop      4.4 异步相关方法            位置      单词      意义      例                  Prefix      blocking      线程阻塞方法      blockingGetUser              Suffix      InBackground      执行在后台的线程      doInBackground              Suffix      Async      异步方法      sendAsync              Suffix      Sync      对应已有异步方法的同步方法      sendSync              Prefix or Alone      schedule      Job和Task放入队列      schedule, scheduleJob              Prefix or Alone      post      同上      postJob              Prefix or Alone      execute      执行异步方法（注：我一般拿这个做同步方法名）      execute, executeTask              Prefix or Alone      start      同上      start, startJob              Prefix or Alone      cancel      停止异步方法      cancel, cancelJob              Prefix or Alone      stop      同上      stop, stopJob      4.5 回调方法            位置      单词      意义      例                  Prefix      on      事件发生时执行      onCompleted              Prefix      before      事件发生前执行      beforeUpdate              Prefix      pre      同上      preUpdate              Prefix      will      同上      willUpdate              Prefix      after      事件发生后执行      afterUpdate              Prefix      post      同上      postUpdate              Prefix      did      同上      didUpdate              Prefix      should      确认事件是否可以发生时执行      shouldUpdate      4.6 操作对象生命周期的方法            单词      意义      例                  initialize      初始化。也可作为延迟初始化使用      initialize              pause      暂停      onPause，pause              stop      停止      onStop，stop              abandon      销毁的替代      abandon              destroy      同上      destroy              dispose      同上      dispose      4.7 与集合操作相关的方法            单词      意义      例                  contains      是否持有与指定对象相同的对象      contains              add      添加      addJob              append      添加      appendJob              insert      插入到下标n      insertJob              put      添加与key对应的元素      putJob              remove      移除元素      removeJob              enqueue      添加到队列的最末位      enqueueJob              dequeue      从队列中头部取出并移除      dequeueJob              push      添加到栈头      pushJob              pop      从栈头取出并移除      popJob              peek      从栈头取出但不移除      peekJob              find      寻找符合条件的某物      findById      4.8 与数据相关的方法            单词      意义      例                  create      新创建      createAccount              new      新创建      newAccount              from      从既有的某物新建，或是从其他的数据新建      fromConfig              to      转换      toString              update      更新既有某物      updateAccount              load      读取      loadAccount              fetch      远程读取      fetchAccount              delete      删除      deleteAccount              remove      删除      removeAccount              save      保存      saveAccount              store      保存      storeAccount              commit      保存      commitChange              apply      保存或应用      applyChange              clear      清除数据或是恢复到初始状态      clearAll              reset      清除数据或是恢复到初始状态      resetAll      4.9 成对出现的动词            单词      意义      单词      意义                  get      获取      set      设置              add      增加      remove      删除              create      创建      destory      移除              start      启动      stop      停止              open      打开      close      关闭              read      读取      write      写入              load      载入      save      保存              create      创建      destroy      销毁              begin      开始      end      结束              backup      备份      restore      恢复              import      导入      export      导出              split      分割      merge      合并              inject      注入      extract      提取              attach      附着      detach      脱离              bind      绑定      separate      分离              view      查看      browse      浏览              edit      编辑      modify      修改              select      选取      mark      标记              copy      复制      paste      粘贴              undo      撤销      redo      重做              insert      插入      delete      移除              add      加入      append      添加              clean      清理      clear      清除              index      索引      sort      排序              find      查找      search      搜索              increase      增加      decrease      减少              play      播放      pause      暂停              launch      启动      run      运行              compile      编译      execute      执行              debug      调试      trace      跟踪              observe      观察      listen      监听              build      构建      publish      发布              input      输入      output      输出              encode      编码      decode      解码              encrypt      加密      decrypt      解密              compress      压缩      decompress      解压缩              pack      打包      unpack      解包              parse      解析      emit      生成              connect      连接      disconnect      断开              send      发送      receive      接收              download      下载      upload      上传              refresh      刷新      synchronize      同步              update      更新      revert      复原              lock      锁定      unlock      解锁              check out      签出      check in      签入              submit      提交      commit      交付              push      推      pull      拉              expand      展开      collapse      折叠              begin      起始      end      结束              start      开始      finish      完成              enter      进入      exit      退出              abort      放弃      quit      离开              obsolete      废弃      depreciate      废旧              collect      收集      aggregate      聚集      五、变量&amp;常量命名5.1 变量命名变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如computedValues，index，变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加is_ 前缀)。5.2 常量命名常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。public class HelloWorld {     // 局部常量(正例)    public static final long USER_MESSAGE_CACHE_EXPIRE_TIME = 3600;        // 局部常量(反例，命名不清晰）    public static final long MESSAGE_CACHE_TIME = 3600;        // 全局常量    private static final String ERROR_MESSAGE = \" error message\";     // 成员变量    private int currentUserId;     /**     * 控制台打印 {@code message} 信息     * @param message 消息体，局部常量     */    public void sayHello(final String message){        System.out.println(\"Hello world!\");    } }常量一般都有自己的业务含义,不要害怕长度过长而进行省略或者缩写。如，用户消息缓存过期时间的表示。六、通用命名规则  尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。正例： BeiJing， HangZhou反例： validateCanShu  命名过程中尽量不要出现特殊的字符，常量除外。  尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。  妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。  如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。"
  },
  
  {
    "title": "Windows10系统字体模糊",
    "url": "/posts/win10-ziti-mohu/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "故障原因这个不是字体的问题，是电脑的特效较高，阴影较为清晰。解决方案把阴影效果关掉。在计算机图标点击“右键”，选择“属性”，高级系统设置 —— 高级 —— 性能 —— 设置 —— 把“在桌面上为图标标签使用阴影”的勾去掉。",
    "content": "故障原因这个不是字体的问题，是电脑的特效较高，阴影较为清晰。解决方案把阴影效果关掉。在计算机图标点击“右键”，选择“属性”，高级系统设置 —— 高级 —— 性能 —— 设置 —— 把“在桌面上为图标标签使用阴影”的勾去掉。"
  },
  
  {
    "title": "Windows10打开图片时提示“在禁用UAC时，无法激活此应用”",
    "url": "/posts/win10-wufa-dakai-tupian/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "故障描述Windows10正式版打开图片时提示“在禁用UAC时，无法激活此应用”。解决方案1打开“运行”，输入’msconfig’并按回车键进入“系统配置”程序界面。切换到“工具”选项卡，选中“更改UAC设置”项，点击“启动”按钮。此时将直接打开“用户账户控制设置”窗口，将“用户账户控制”级别设置为除“从不通知”之外的其它级别，点击“确定”按钮。接下来我们必须重启一下计算机，才能使“用户账户...",
    "content": "故障描述Windows10正式版打开图片时提示“在禁用UAC时，无法激活此应用”。解决方案1打开“运行”，输入’msconfig’并按回车键进入“系统配置”程序界面。切换到“工具”选项卡，选中“更改UAC设置”项，点击“启动”按钮。此时将直接打开“用户账户控制设置”窗口，将“用户账户控制”级别设置为除“从不通知”之外的其它级别，点击“确定”按钮。接下来我们必须重启一下计算机，才能使“用户账户控制（UAC）”功能得到生效。解决方案2打开“运行”，输入Regedit运行注册表，找到HKEY_LOCAL_MACHINE——SOFTWARE——Microsoft——Windows——CurrentVersion——Policies\\System——EnableLUA的值，把数值数据改为1，修改完成后关机重启。UACUAC(User Account Control，用户帐户控制)是微软为提高系统安全而在Windows Vista中引入的新技术，它要求用户在执行可能会影响计算机运行的操作或执行更改影响其他用户的设置的操作之前，提供权限或管理员‌密码。通过在这些操作启动前对其进行验证，UAC可以帮助防止恶意软件和间谍软件在未经许可的情况下在计算机上进行安装或对计算机进行更改。通俗的说：UAC指在打开应该程序时需要用户手动授权。"
  },
  
  {
    "title": "命令提示符无法执行命令",
    "url": "/posts/DOS-jiemian-wufa-zhixing-mingling/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "故障描述可以运行cmd打开命令提示符界面，但是无法执行命令，所有的命令都提示xx不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法修改环境变量，在path变量值后添加%SystemRoot%\\system32，故障修复。",
    "content": "故障描述可以运行cmd打开命令提示符界面，但是无法执行命令，所有的命令都提示xx不是内部或外部命令，也不是可运行的程序或批处理文件。解决方法修改环境变量，在path变量值后添加%SystemRoot%\\system32，故障修复。"
  },
  
  {
    "title": "JQuery下载页面所有图片",
    "url": "/posts/xiazai-yemian-quanbu-tupian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-28 13:47:00 +0800",
    





    
    "snippet": "&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function () {    var imglist = $(\"body\").find(\"img\");    for (var i = 0; i &lt; imglist.length; i...",
    "content": "&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function () {    var imglist = $(\"body\").find(\"img\");    for (var i = 0; i &lt; imglist.length; i++) {        downloadImage($(imglist[i]).attr(\"data-src\"), i);    }});function downloadImage(path, imgName) {    var _OBJECT_URL;    var request = new XMLHttpRequest();    request.addEventListener('readystatechange', function (e) {        if (request.readyState == 4) {            _OBJECT_URL = URL.createObjectURL(request.response);            var $a = $(\"&lt;a&gt;&lt;/a&gt;\").attr(\"href\", _OBJECT_URL).attr(\"download\", imgName);            $a[0].click();        }    });    request.responseType = 'blob';    request.open('get', path);    request.send();}&lt;/script&gt;"
  },
  
  {
    "title": "Redis异常：Could not get a resource from the pool",
    "url": "/posts/redis-yichang-wufa-huoqu-lianjie/",
    "categories": "Knowledge, Redis",
    "tags": "Redis",
    "date": "2020-12-26 13:47:00 +0800",
    





    
    "snippet": "报错信息redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool  at redis.clients.util.Pool.getResource(Pool.java:22)  at com.derbysoft.jredis.longkeytest.Borrow...",
    "content": "报错信息redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool  at redis.clients.util.Pool.getResource(Pool.java:22)  at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22)  at java.lang.Thread.run(Thread.java:662)  Caused by: java.util.NoSuchElementException: Timeout waiting for idle object  at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134)  at redis.clients.util.Pool.getResource(Pool.java:20)  ... 2 more  redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the poolat redis.clients.util.Pool.getResource(Pool.java:22)at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22)at java.lang.Thread.run(Thread.java:662)Caused by: java.util.NoSuchElementException: Timeout waiting for idle objectat org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134)at redis.clients.util.Pool.getResource(Pool.java:20)... 2 more产生原因客户端去Redis服务器拿连接（代码描述的是租用对象borrowObject）的时候，池中无可用连接，即池中所有连接被占用，且在等待时候设定的超时时间后还没拿到时，报出此异常。解决办法调整JedisPoolConfig中maxActive为适合自己系统的阀值。&lt;bean id=\"dataJedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt;    &lt;property name=\"maxActive\" value=\"300\" /&gt;    &lt;property name=\"maxIdle\" value=\"100\" /&gt;    &lt;property name=\"maxWait\" value=\"10000\" /&gt;    &lt;property name=\"testOnBorrow\" value=\"true\" /&gt;&lt;/bean&gt;  "
  },
  
  {
    "title": "Java实现文件下载功能，自动弹出保存窗口",
    "url": "/posts/java-shixian-wenjian-xiazai-gongneng/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "public void download() {    String filePath = this.queueService.getCsvFilePathById(id);//所要下载的文件路径，从数据库中查询得到，当然也可以直接写文件路径，如：C:\\\\Users\\\\Administrator\\\\Desktop\\\\csv\\\\号码_utf8_100.csv    try {        F...",
    "content": "public void download() {    String filePath = this.queueService.getCsvFilePathById(id);//所要下载的文件路径，从数据库中查询得到，当然也可以直接写文件路径，如：C:\\\\Users\\\\Administrator\\\\Desktop\\\\csv\\\\号码_utf8_100.csv    try {        File file = new File(filePath);        String fileName = filePath.substring(filePath.lastIndexOf(File.separator)+1);//得到文件名        fileName = new String(fileName.getBytes(\"UTF-8\"),\"ISO8859-1\");//把文件名按UTF-8取出并按ISO8859-1编码，保证弹出窗口中的文件名中文不乱码，中文不要太多，最多支持17个中文，因为header有150个字节限制。        response.setContentType(\"application/octet-stream\");//告诉浏览器输出内容为流        response.addHeader(\"Content-Disposition\", \"attachment;filename=\"+fileName);//Content-Disposition中指定的类型是文件的扩展名，并且弹出的下载对话框中的文件类型图片是按照文件的扩展名显示的，点保存后，文件以filename的值命名，保存类型以Content中设置的为准。注意：在设置Content-Disposition头字段之前，一定要设置Content-Type头字段。        String len = String.valueOf(file.length());        response.setHeader(\"Content-Length\", len);//设置内容长度        OutputStream out = response.getOutputStream();        FileInputStream in = new FileInputStream(file);        byte[] b = new byte[1024];        int n;        while((n=in.read(b))!=-1){            out.write(b, 0, n);        }        in.close();        out.close();    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}"
  },
  
  {
    "title": "Prism支持的语言",
    "url": "/posts/prism-zhichi-de-yuyan/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "语法  ```javanew Test();```This is the list of all 218 languages currently supported by Prism, with their corresponding alias, to use in place of xxxx in the language-xxxx (or lang-xxxx) class:  Mark...",
    "content": "语法  ```javanew Test();```This is the list of all 218 languages currently supported by Prism, with their corresponding alias, to use in place of xxxx in the language-xxxx (or lang-xxxx) class:  Markup - markup, html, xml, svg, mathml, ssml, atom, rss  CSS - css  C-like - clike  JavaScript - javascript, js  ABAP - abap  Augmented Backus–Naur form - abnf  ActionScript - actionscript  Ada - ada  AL - al  ANTLR4 - antlr4, g4  Apache Configuration - apacheconf  APL - apl  AppleScript - applescript  AQL - aql  Arduino - arduino  ARFF - arff  AsciiDoc - asciidoc, adoc  6502 Assembly - asm6502  ASP.NET (C#) - aspnet  AutoHotkey - autohotkey  AutoIt - autoit  Bash - bash, shell  BASIC - basic  Batch - batch  BBcode - bbcode, shortcode  Bison - bison  Backus–Naur form - bnf, rbnf  Brainfuck - brainfuck  BrightScript - brightscript  Bro - bro  C - c  Concurnas - concurnas, conc  C# - csharp, cs, dotnet  C++ - cpp  CIL - cil  CoffeeScript - coffeescript, coffee  CMake - cmake  Clojure - clojure  Crystal - crystal  Content-Security-Policy - csp  CSS Extras - css-extras  D - d  Dart - dart  DAX - dax  Diff - diff  Django/Jinja2 - django, jinja2  DNS zone file - dns-zone-file, dns-zone  Docker - docker, dockerfile  Extended Backus–Naur form - ebnf  Eiffel - eiffel  EJS - ejs, eta  Elixir - elixir  Elm - elm  Embedded Lua templating - etlua  ERB - erb  Erlang - erlang  Excel Formula - excel-formula, xlsx, xls  F# - fsharp  Factor - factor  Firestore security rules - firestore-security-rules  Flow - flow  Fortran - fortran  FreeMarker Template Language - ftl  G-code - gcode  GDScript - gdscript  GEDCOM - gedcom  Gherkin - gherkin  Git - git  GLSL - glsl  GameMaker Language - gml, gamemakerlanguage  Go - go  GraphQL - graphql  Groovy - groovy  Haml - haml  Handlebars - handlebars  Haskell - haskell, hs  Haxe - haxe  HCL - hcl  HLSL - hlsl  HTTP - http  HTTP Public-Key-Pins - hpkp  HTTP Strict-Transport-Security - hsts  IchigoJam - ichigojam  Icon - icon  Structured Text (IEC 61131-3) - iecst  Inform 7 - inform7  Ini - ini  Io - io  J - j  Java - java  JavaDoc - javadoc  JavaDoc-like - javadoclike  Java stack trace - javastacktrace  Jolie - jolie  JQ - jq  JSDoc - jsdoc  JS Extras - js-extras  JS Templates - js-templates  JSON - json, webmanifest  JSONP - jsonp  JSON5 - json5  Julia - julia  Keyman - keyman  Kotlin - kotlin  LaTeX - latex, tex, context  Latte - latte  Less - less  LilyPond - lilypond, ly  Liquid - liquid  Lisp - lisp, emacs, elisp, emacs-lisp  LiveScript - livescript  LLVM IR - llvm  LOLCODE - lolcode  Lua - lua  Makefile - makefile  Markdown - markdown, md  Markup templating - markup-templating  MATLAB - matlab  MEL - mel  Mizar - mizar  Monkey - monkey  MoonScript - moonscript, moon  N1QL - n1ql  N4JS - n4js, n4jsd  Nand To Tetris HDL - nand2tetris-hdl  NASM - nasm  NEON - neon  nginx - nginx  Nim - nim  Nix - nix  NSIS - nsis  Objective-C - objectivec, objc  OCaml - ocaml  OpenCL - opencl  Oz - oz  PARI/GP - parigp  Parser - parser  Pascal - pascal, objectpascal  Pascaligo - pascaligo  PC-Axis - pcaxis, px  PeopleCode - peoplecode, pcode  Perl - perl  PHP - php  PHPDoc - phpdoc  PHP Extras - php-extras  PL/SQL - plsql  PowerQuery - powerquery, pq, mscript  PowerShell - powershell  Processing - processing  Prolog - prolog  .properties - properties  Protocol Buffers - protobuf  Pug - pug  Puppet - puppet  Pure - pure  PureBasic - purebasic, pbfasm  Python - python, py  Q (kdb+ database) - q  QML - qml  Qore - qore  R - r  Racket - racket, rkt  React JSX - jsx  React TSX - tsx  Ren’py - renpy, rpy  Reason - reason  Regex - regex  reST (reStructuredText) - rest  Rip - rip  Roboconf - roboconf  Robot Framework - robotframework, robot  Ruby - ruby, rb  Rust - rust  SAS - sas  Sass (Sass) - sass  Sass (Scss) - scss  Scala - scala  Scheme - scheme  Shell session - shell-session  Smalltalk - smalltalk  Smarty - smarty  Solidity (Ethereum) - solidity, sol  Solution file - solution-file, sln  Soy (Closure Template) - soy  SPARQL - sparql, rq  Splunk SPL - splunk-spl  SQF: Status Quo Function (Arma 3) - sqf  SQL - sql  Stylus - stylus  Swift - swift  TAP - tap  Tcl - tcl  Textile - textile  TOML - toml  Template Toolkit 2 - tt2  Turtle - turtle, trig  Twig - twig  TypeScript - typescript, ts  T4 Text Templates (C#) - t4-cs, t4  T4 Text Templates (VB) - t4-vb  T4 templating - t4-templating  UnrealScript - unrealscript, uscript, uc  Vala - vala  VB.Net - vbnet  Velocity - velocity  Verilog - verilog  VHDL - vhdl  vim - vim  Visual Basic - visual-basic, vb  WarpScript - warpscript  WebAssembly - wasm  Wiki markup - wiki  Xeora - xeora, xeoracube  XML doc (.net) - xml-doc  Xojo (REALbasic) - xojo  XQuery - xquery  YAML - yaml, yml  Zig - zig"
  },
  
  {
    "title": "Markdown语法",
    "url": "/posts/markdown-yufa/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "Markdown标题使用=和-标记一级和二级标题我展示的是一级标题=================我展示的是二级标题-----------------使用#号标记使用#号可表示1-6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推。# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题Markdown段落Markdown段落没有特...",
    "content": "Markdown标题使用=和-标记一级和二级标题我展示的是一级标题=================我展示的是二级标题-----------------使用#号标记使用#号可表示1-6级标题，一级标题对应一个#号，二级标题对应两个#号，以此类推。# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题Markdown段落Markdown段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。Markdown字体*斜体文本*  _斜体文本_  **粗体文本**  __粗体文本__  ***粗斜体文本***  ___粗斜体文本___分割线**** * ******- - -----------删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。下划线下划线可以通过HTML的&lt;u&gt;带下划线文本&lt;/u&gt;标签来实现。脚注脚注是对文本的补充说明。Markdown脚注的格式如下：[^要注明的文本]，以下实例演示了脚注的用法：创建脚注格式类似这样 [^foot]。[^foot]: 脚注示例！！！创建脚注格式类似这样 1。Markdown列表Markdown支持有序列表和无序列表。无序列表使用*、+或是减号-作为列表标记，这些标记后面要添加一个空格，然后再填写内容。有序列表使用数字并加上.号来表示。列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可。* 列表    * 列表  列表          列表      Markdown区块Markdown区块引用是在段落开头使用&gt;符号 ，然后后面紧跟一个空格符号。另外区块是可以嵌套的，一个&gt;符号是最外层，两个&gt;符号是第一层嵌套，以此类推。&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套   最外层      第一层嵌套          第二层嵌套      区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项      第一项    第二项              第一项        第二项        第三项            列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。* 第一项    &gt; 区块1      &gt; 区块2* 第二项  第一项          区块1区块2        第二项Markdown代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）。代码区块代码区块使用4个空格或者一个制表符（Tab 键）。你也可以用```包裹一段代码，并指定一种语言（也可以不指定）。Markdown链接链接使用方法如下：[链接名称](链接地址)或者&lt;链接地址&gt;这是一个链接 链接或者https://www.baidu.com高级链接我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：这个链接用1作为网址变量[链接][1]这个链接用test作为网址变量 [链接][test]然后在文档的结尾为变量赋值（网址）[1]: http://www.baidu.com/[test]: http://www.baidu.com/这个链接用1作为网址变量链接这个链接用test作为网址变量链接然后在文档的结尾为变量赋值（网址）Markdown图片开头一个感叹号!。接着一个方括号[]，里面放上图片的替代文字。接着一个普通括号()，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’属性的文字。![图片](https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png \"baidu\")  当然，你也可以像网址那样对图片网址使用变量:![图片][1]  [1]: https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.pngMarkdown还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的&lt;img&gt;标签。&lt;img src=\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\" width=\"50%\"&gt;Markdown表格Markdown制作表格使用| 来分隔不同的单元格，使用-来分隔表头和其他行。|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |            表头      表头                  单元格      单元格              单元格      单元格      对齐方式我们可以设置表格的对齐方式：  -:设置内容和标题栏居右对齐。  :-设置内容和标题栏居左对齐。  :-:设置内容和标题栏居中对齐。| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |            左对齐左对齐左对齐      左对齐左对齐左对齐      居中对齐居中对齐居中对齐                  单元格      单元格      单元格              单元格      单元格      单元格      Markdown高级技巧支持的HTML元素不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。目前支持的HTML元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：使用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;重启电脑使用Ctrl + Alt + Del重启电脑转义Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符。Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号            脚注示例！！！ &#8617;      "
  },
  
  {
    "title": "GitBook启动脚本",
    "url": "/posts/gitbook-qidong-jiaoben/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "@echo off clsTITLE GitBook 管理菜单color 1fgoto menu:menuecho.echo                        ╭──────────────╮echo    ╭─────────┤       GitBook 管理菜单      ├╮echo    │ 主菜单           │                        ...",
    "content": "@echo off clsTITLE GitBook 管理菜单color 1fgoto menu:menuecho.echo                        ╭──────────────╮echo    ╭─────────┤       GitBook 管理菜单      ├╮echo    │ 主菜单           │                             │ │echo    │                  ╰────────────── ╯ │echo    │ [1]初始化GitBook                                   │echo    │                                                    │echo    │ [2]下载GitBook插件                                 │echo    │                                                    │echo    │ [3]启动GitBook         [0]退出                     │echo    ╰──────────────────────────╯echo.echo. 请输入选择项目的序号：set /p  ID=if \"%id%\"==\"1\"  goto cmd1if \"%id%\"==\"2\" goto cmd2if \"%id%\"==\"3\" goto cmd3IF \"%id%\"==\"0\"  exitIF not \"%id%\"== \"\" goto cmd0pause:cmd1echo 正在初始化GitBookecho 请稍等...gitbook initecho  初始化GitBook已经完成！pause &gt;nulgoto menu:cmd2echo 正在下载GitBook插件echo 请稍等...gitbook installecho  下载GitBook插件已经完成！pause &gt;nulgoto menu:cmd3echo 正在启动GitBookecho 请稍等...gitbook serveecho  启动GitBook已经完成！pause &gt;nulgoto menu:cmd0echo 你的选择无效，请按任意键返回菜单！pause &gt;nulgoto menu"
  },
  
  {
    "title": "使用gitbook build命令导出的HTML不能跳转",
    "url": "/posts/gitbook-daochu-de-html-buzhichi-tiaozhuan/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "原因GitBook新版本不支持HTML跳转功能，所以要降版本至2.6.7。解决办法如下第一步生成时指定GitBook的版本, 本地没有会先下载。gitbook build --gitbook=2.6.7 可能会报错，如下操作，列出本地所有的GitBook版本。gitbook ls 卸载对应的GitBook版本（新版本需要先卸载，也可以先下载2.6.7版本，这样两个版本会共存，默认使用最新版本...",
    "content": "原因GitBook新版本不支持HTML跳转功能，所以要降版本至2.6.7。解决办法如下第一步生成时指定GitBook的版本, 本地没有会先下载。gitbook build --gitbook=2.6.7 可能会报错，如下操作，列出本地所有的GitBook版本。gitbook ls 卸载对应的GitBook版本（新版本需要先卸载，也可以先下载2.6.7版本，这样两个版本会共存，默认使用最新版本）。gitbook uninstall 3.2.3第二步运行命令。gitbook build会出来几行提示信息，不用管，现在可以跳转了，试下吧。  注：如果遇到:Error loading version latest: Error: Cannot find module ‘internal/util/types’，则需要降低node的版本。"
  },
  
  {
    "title": "GitBook常用插件",
    "url": "/posts/gitbook-changyong-chajian/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "{    \"pluginsConfig\": {        // 给GitBook的目录添加数字，添加章节序号        \"theme-default\": {            \"showLevel\": true        },        // 代码高亮插件的配置        \"prism\": {            \"css\": [                \"p...",
    "content": "{    \"pluginsConfig\": {        // 给GitBook的目录添加数字，添加章节序号        \"theme-default\": {            \"showLevel\": true        },        // 代码高亮插件的配置        \"prism\": {            \"css\": [                \"prism-themes/themes/prism-atom-dark.css\"            ]        },        \"anchor-navigation-ex\": {            \"showLevel\": false,             \"showGoTop\": true        },        \"edit-link\": {            \"base\": \"https://github.com/\",            \"label\": \"编辑此页面\"        },        \"favicon\": {            \"shortcut\": \"assets/img/favicon.ico\",            \"bookmark\": \"assets/img/favicon.ico\",            \"appleTouch\": \"assets/img/favicon.ico\",            \"appleTouchMore\": {                \"120x120\": \"assets/img/favicon.ico\",                \"180x180\": \"assets/img/favicon.ico\"            }        },        \"hide-element\": {            \"elements\": [\".gitbook-link\"]        },        \"tbfed-pagefooter\": {            \"copyright\":\"\",            \"modify_label\": \"该文件最后修改时间：\",            \"modify_format\": \"YYYY-MM-DD HH:mm:ss\"        },        \"github\": {            \"url\": \"https://github.com/\"        },        \"code\": {            \"copyButtons\": false        }    },    \"plugins\": [        \"-toggle-chapters\",        \"expandable-chapters\",        \"-chapter-fold\",                \"splitter\",                \"anchor-navigation-ex\",                \"-lunr\",        \"-search\",        \"search-pro\",                \"-highlight\",        \"prism\",        \"prism-themes\",                \"edit-link\",                \"favicon\",                \"hide-element\",                \"tbfed-pagefooter\",                \"github\",                \"copy-code-button\",                \"emphasize\",                \"code\"    ]}"
  },
  
  {
    "title": "学习和整理列表",
    "url": "/posts/xuexi-liebiao/",
    "categories": "Index, Learning",
    "tags": "TODO",
    "date": "2020-12-23 13:47:00 +0800",
    





    
    "snippet": "  poi导出、excel附加、word附加  SVN使用及版本控制原理  为Jekyll添加Fancybox",
    "content": "  poi导出、excel附加、word附加  SVN使用及版本控制原理  为Jekyll添加Fancybox"
  },
  
  {
    "title": "PLSQL无法使用like查询，无法查询中文",
    "url": "/posts/plsql-wufa-shiyong-like-chaxun-wufa-cahxun-zhongwen/",
    "categories": "Knowledge, PLSQL",
    "tags": "PLSQL",
    "date": "2020-12-21 13:47:00 +0800",
    





    
    "snippet": "问题描述  中文乱码。  中文显示没有乱码，中文作为条件无法查询。  like无法查询出中文内容。问题原因以上三种情况是因为Oracle客户端和服务器端的编码方式不一样导致。解决办法首先要查询Oracle服务器的语言、地域和字符集，然后将查询结果设置为本地的环境变量：NLS_LANG，具体如下：      查询Oracle服务器的语言、地域和字符集     select * from nls...",
    "content": "问题描述  中文乱码。  中文显示没有乱码，中文作为条件无法查询。  like无法查询出中文内容。问题原因以上三种情况是因为Oracle客户端和服务器端的编码方式不一样导致。解决办法首先要查询Oracle服务器的语言、地域和字符集，然后将查询结果设置为本地的环境变量：NLS_LANG，具体如下：      查询Oracle服务器的语言、地域和字符集     select * from nls_database_parameters;        查询结果中：          NLS_LANGUAGE表示语言，      NLS_TERRITORY表示地域      NLS_CHARACTSET表示字符集        将他们三个按照语言_地域.字符集的格式拼接起来，就有了AMERICAN_AMERICA.AL32UTF8（注意：这里要根据你自己的Oracle服务器的这三个值进行拼接）        设置本地环境变量（PLSQL优先从环境变量中获取属性），右击我的电脑 -&gt; 属性 -&gt; 高级系统设置-&gt; 环境变量 -&gt; 系统变量栏，新增如下记录：     NLS_LANG = AMERICAN_AMERICA.AL32UTF8      "
  },
  
  {
    "title": "Linux rm命令",
    "url": "/posts/linux-rm-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "常用的几个参数为“-f -i -r -v”-i删除前逐一询问确认。这个参数有一个好处，当在删除大量文件或目录的时候，可以防止我们误操作删除的文件或目录。-f即使原档案属性设为唯读，强制删除，系统不会逐一让我们确认。-r将目录及以下之档案文件一并删除。注意:如果rm不带此参数，是不能删除目录的。-v或–verbose 　显示指令执行后的结果信息。",
    "content": "常用的几个参数为“-f -i -r -v”-i删除前逐一询问确认。这个参数有一个好处，当在删除大量文件或目录的时候，可以防止我们误操作删除的文件或目录。-f即使原档案属性设为唯读，强制删除，系统不会逐一让我们确认。-r将目录及以下之档案文件一并删除。注意:如果rm不带此参数，是不能删除目录的。-v或–verbose 　显示指令执行后的结果信息。"
  },
  
  {
    "title": "JS限制字段输入长度",
    "url": "/posts/js-xianzhi-ziduan-shuru-changdu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "window.onload = function() {     document.getElementById(\"text1\").maxLength = 50;    document.getElementById(\"text2\").maxLength = 200;};",
    "content": "window.onload = function() {     document.getElementById(\"text1\").maxLength = 50;    document.getElementById(\"text2\").maxLength = 200;};"
  },
  
  {
    "title": "JS实现Sleep函数",
    "url": "/posts/js-shixian-sleep-hanshu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "&lt;script&gt; window.onload = function() {    sleep(5000);    alert(\"OK\"); } function sleep(numberMillis) {    var now = new Date();    var exitTime = now.getTime() + numberMillis;    while (true)...",
    "content": "&lt;script&gt; window.onload = function() {    sleep(5000);    alert(\"OK\"); } function sleep(numberMillis) {    var now = new Date();    var exitTime = now.getTime() + numberMillis;    while (true) {       now = new Date();       if (now.getTime() &gt; exitTime)          return;    } }&lt;/script&gt;"
  },
  
  {
    "title": "JS将数字格式化成货币（钱）格式",
    "url": "/posts/js-jiangshuzi-geshihua-wei-huobigeshi/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "function formatMoney(number, places, symbol, thousand, decimal) {    number = number || 0;    places = !isNaN(places = Math.abs(places)) ? places : 2;    symbol = symbol !== undefined ? symbol : \"$...",
    "content": "function formatMoney(number, places, symbol, thousand, decimal) {    number = number || 0;    places = !isNaN(places = Math.abs(places)) ? places : 2;    symbol = symbol !== undefined ? symbol : \"$\";    thousand = thousand || \",\";    decimal = decimal || \".\";    var negative = number &lt; 0 ? \"-\" : \"\",        i = parseInt(number = Math.abs(+number || 0).toFixed(places), 10) + \"\",        j = (a = i.length) &gt; 3 ? a % 3 : 0;    return symbol + negative + (j ? i.substr(0, j) + thousand : \"\")                   + i.substr(j).replace(/(\\d{3})(?=\\d)/g, \"$1\" + thousand)                   + (places ? decimal                   + Math.abs(number - i).toFixed(places).slice(2) : \"\");}// 把12345.67变成美元格式，$12,345.67console.log(formatMoney(12345.67));// 把12345.67变成人民币格式，并保留3位小数，￥12,345.670console.log(formatMoney(12345.67, 3, \"￥\"));// 把$12,345.67变成纯数字12345.67console.log(parseFloat('$12,345.67'.replace(/[^0-9-.]/g, '')));"
  },
  
  {
    "title": "JS获取当前月的前12个月",
    "url": "/posts/js-huoqu-dangqianyue-de-qian12geyue/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-18 13:47:00 +0800",
    





    
    "snippet": "var dataArr = [];var data = new Date();var year = data.getFullYear();data.setMonth(data.getMonth()+1, 1) //获取到当前月份,设置月份for (var i = 0; i &lt; 12; i++) {    data.setMonth(data.getMonth() - 1); //每次循...",
    "content": "var dataArr = [];var data = new Date();var year = data.getFullYear();data.setMonth(data.getMonth()+1, 1) //获取到当前月份,设置月份for (var i = 0; i &lt; 12; i++) {    data.setMonth(data.getMonth() - 1); //每次循环一次月份值减1    var m = data.getMonth() + 1;    m = m &lt; 10 ? \"0\" + m : m;    dataArr.push(data.getFullYear() + \"-\" + (m))}console.log(dataArr)运行结果"
  },
  
  {
    "title": "Git上传文件不区分大小写的问题",
    "url": "/posts/git-shangchuan-buqufen-daxiaoxie/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-12-17 13:47:00 +0800",
    





    
    "snippet": "问题文件名称最初新建的时候是大写，但是后面想要改成小写的，修改完提交的时候使用git status命令发现并没有修改的记录，提交之后在Git上也没有修改。解决办法因为Git默认是不区分大小写的，所以git status是不会提示你有修改的。  通过git config --get core.ignorecase查看默认配置  通过git config core.ignorecase fals...",
    "content": "问题文件名称最初新建的时候是大写，但是后面想要改成小写的，修改完提交的时候使用git status命令发现并没有修改的记录，提交之后在Git上也没有修改。解决办法因为Git默认是不区分大小写的，所以git status是不会提示你有修改的。  通过git config --get core.ignorecase查看默认配置  通过git config core.ignorecase false设置为区分大小写然后git status就可以看到修改的东西了，然后进行正常的操作就可以提交了。最好是一开始就把Git的默认配置修改掉（区分大小写的模式），后面的操作其实也可以直接本地先备份再删除提交。"
  },
  
  {
    "title": "Jackson反序列化错误的解决方法",
    "url": "/posts/json-fanxuliehua-cuowu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "错误信息com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException：Unrecognized field，出现这种问题的情况是由于JSON里面包含了实体没有的字段导致反序列化失败。第一种解决方案// ObjectMapper对象添加String s = \"{\\\"id\\\":1,\\\"name\\\":\\\"test\\\",\\\"age\\...",
    "content": "错误信息com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException：Unrecognized field，出现这种问题的情况是由于JSON里面包含了实体没有的字段导致反序列化失败。第一种解决方案// ObjectMapper对象添加String s = \"{\\\"id\\\":1,\\\"name\\\":\\\"test\\\",\\\"age\\\":19}\";ObjectMapper mapper = new ObjectMapper();mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);User user = mapper.readValue(s, User.class);第二种解决方案// 在需要转化的对象的类中添加注解，注解信息如下：@JsonIgnoreProperties(ignoreUnknown = true)public class User..."
  },
  
  {
    "title": "一个数组中的元素复制到另一个数组",
    "url": "/posts/jiang-shuzu-zhong-de-yuansu-fuzhi-dao-lingyige-shuzu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "使用函数arraycopy(Object src, int srcPos, Object dest,  int destPos, int length)，其中五个参数分别表示为：  src— 被复制的数组  srcPos —从第几个元素开始复制  dest —要复制到的数组  destPos —从第几个元素开始粘贴  length —一共需要复制的元素个数public static void...",
    "content": "使用函数arraycopy(Object src, int srcPos, Object dest,  int destPos, int length)，其中五个参数分别表示为：  src— 被复制的数组  srcPos —从第几个元素开始复制  dest —要复制到的数组  destPos —从第几个元素开始粘贴  length —一共需要复制的元素个数public static void main(String[] args) {    char a1[] = {'a', 'b', 'c', 'd', 'e', 'f'};    char b1[] = {'1', '2', '3', '4', '5', '6'};    System.arraycopy(b1, 1, a1, 3, b1.length-3);    System.out.println(new String(a1));    System.out.println(new String(b1));}输出结果abc234123456"
  },
  
  {
    "title": "Java中创建数组的三种方式",
    "url": "/posts/java-zhong-chuangjian-shuzu-de-sanzhong-fangshi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "public static void main(String[] args) {    //创建数组的第一种方法，指定数组长度    int[] arr1 = new int[6];    //创建数组的第二种方法，创建并初始化    int[] arr2 = {1, 2, 3, 4};    //创建数组的第三种方法    int[] arr3 = new int[]{1, 2, 3, 4...",
    "content": "public static void main(String[] args) {    //创建数组的第一种方法，指定数组长度    int[] arr1 = new int[6];    //创建数组的第二种方法，创建并初始化    int[] arr2 = {1, 2, 3, 4};    //创建数组的第三种方法    int[] arr3 = new int[]{1, 2, 3, 4, 5};}"
  },
  
  {
    "title": "Java将JSON转为对象数组的方法",
    "url": "/posts/java-jiang-json-zhuanwei-duixiangshuzu-de-fangfa/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-12-17 11:47:00 +0800",
    





    
    "snippet": "第一种方法String jsonStr = \"[{\\\"id\\\": \\\"0\\\", \\\"ip\\\": \\\"123\\\", \\\"mac\\\": \\\"456\\\"},                    {\\\"id\\\": \\\"1\\\", \\\"ip\\\": \\\"111\\\", \\\"mac\\\": \\\"222\\\"}]\";List&lt;User&gt; userList = new ArrayList&lt;User...",
    "content": "第一种方法String jsonStr = \"[{\\\"id\\\": \\\"0\\\", \\\"ip\\\": \\\"123\\\", \\\"mac\\\": \\\"456\\\"},                    {\\\"id\\\": \\\"1\\\", \\\"ip\\\": \\\"111\\\", \\\"mac\\\": \\\"222\\\"}]\";List&lt;User&gt; userList = new ArrayList&lt;User&gt;();ObjectMapper mapper = new ObjectMapper();// 避免JSON里面包含了实体没有的字段导致反序列化失败mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);// 转为对象数组userList = mapper.readValue(jsonStr,             mapper.getTypeFactory().constructCollectionType(List.class, User.class));第二种方法String jsonStr = \"[{\\\"id\\\": \\\"0\\\", \\\"ip\\\": \\\"123\\\", \\\"mac\\\": \\\"456\\\"},                    {\\\"id\\\": \\\"1\\\", \\\"ip\\\": \\\"111\\\", \\\"mac\\\": \\\"222\\\"}]\";List&lt;User&gt; userList = new ArrayList&lt;User&gt;();JSONArray jsonArray = JSONArray.parseArray(jsonStr);for (int i = 0; i &lt; jsonArray.size(); i++) {    User user = new User();    JSONObject object = (JSONObject) jsonArray.get(i);    user.setId(object.get(\"id\"));    user.setIp(object.get(\"ip\"));    user.setMac(object.get(\"mac\"));    userList.add(user);}"
  },
  
  {
    "title": "Tomcat各目录的作用",
    "url": "/posts/tomcat-ge-mulu-de-zuoyong/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-12-16 13:47:00 +0800",
    





    
    "snippet": "binbin目录主要是用来存放Tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是以.bat结尾的（windows命令），很多环境变量的设置都在此处，例如可以设置JDK路径、Tomcat路径。  startup用来启动Tomcat  shutdown用来关闭Tomcat  修改catalina可以设置Tomcat的内存confconf目录主要是用来存放Tomca...",
    "content": "binbin目录主要是用来存放Tomcat的命令，主要有两大类，一类是以.sh结尾的（linux命令），另一类是以.bat结尾的（windows命令），很多环境变量的设置都在此处，例如可以设置JDK路径、Tomcat路径。  startup用来启动Tomcat  shutdown用来关闭Tomcat  修改catalina可以设置Tomcat的内存confconf目录主要是用来存放Tomcat的一些配置文件。  server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码  web.xml可以设置Tomcat支持的文件类型  context.xml可以用来配置数据源之类的  tomcat-users.xml用来配置管理Tomcat的用户与权限  在Catalina目录下可以设置默认加载的项目liblib目录主要用来存放Tomcat运行需要加载的jar包，例如，像连接数据库的jdbc的包我们可以加入到lib目录中来。logslogs目录用来存放Tomcat在运行过程中产生的日志文件（清空不会对Tomcat运行带来影响）。  在Windows环境中，控制台的输出日志在catalina.xxxx-xx-xx.log文件中  在Linux环境中，控制台的输出日志在catalina.out文件中temptemp目录用来存放Tomcat在运行过程中产生的临时文件（清空不会对tomcat运行带来影响）。webappswebapps目录用来存放应用程序，当Tomcat启动时会去加载webapps目录下的应用程序。可以以文件夹、war包、jar包的形式发布应用。当然，你也可以把应用程序放置在磁盘的任意位置，在配置文件中映射好就行。workwork目录用来存放Tomcat在运行时的编译后文件，例如JSP编译后的文件。  清空work目录，然后重启Tomcat，可以达到清除缓存的作用"
  },
  
  {
    "title": "一台机器上启动多个Tomcat",
    "url": "/posts/ruhe-zai-yitai-fuwuqi-shang-qidong-duoge-tomcat/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-12-16 13:47:00 +0800",
    





    
    "snippet": "如果需要在一台机器上启动多个Tomcat服务器，在默认设置下肯定会发生端口冲突。为实现这个效果，只需修改conf子目录中的server.xml文件即可。共需修改三处：修改http访问端口（默认为8080端口）:&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\"connectionTimeout=\"20000\"redirectPort=\"8443\" UR...",
    "content": "如果需要在一台机器上启动多个Tomcat服务器，在默认设置下肯定会发生端口冲突。为实现这个效果，只需修改conf子目录中的server.xml文件即可。共需修改三处：修改http访问端口（默认为8080端口）:&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\"connectionTimeout=\"20000\"redirectPort=\"8443\" URIEncoding=\"gb2312\"/&gt;修改Shutdown端口（默认为8005端口）:&lt;Server port=\"8005\" shutdown=\"SHUTDOWN\"&gt;修改JVM启动端口（默认为8009端口）:&lt;Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" /&gt;"
  },
  
  {
    "title": "启动Tomcat时窗口一闪而过的解决方法",
    "url": "/posts/qidong-tomcat-chuangkou-yishanerguo/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-12-16 13:47:00 +0800",
    





    
    "snippet": "进入Tomcat的安装目录，看到圈出红色的3个bat文件，一般通过startup.bat启动Tomcat时流程是startup-&gt;catalina-&gt;setclasspath-&gt;catalina，如果这3个bat文件里面有一个出现错误的话就是启动失败。先打开startup.bat，在最后加上一句pause再次执行startup.bat，就会看到上图，当按任意的键时cmd窗口...",
    "content": "进入Tomcat的安装目录，看到圈出红色的3个bat文件，一般通过startup.bat启动Tomcat时流程是startup-&gt;catalina-&gt;setclasspath-&gt;catalina，如果这3个bat文件里面有一个出现错误的话就是启动失败。先打开startup.bat，在最后加上一句pause再次执行startup.bat，就会看到上图，当按任意的键时cmd窗口又是一闪而过了。但是这已经确定了环境变量都是正确的。为了更加详细的看到信息，我们再来更改一句：找到call \"%EXECUTABLE%\" start %CMD_LINE_ARGS%把里面的start替换为run再来看看cmd窗口里面输出错误信息了"
  },
  
  {
    "title": "搭建SVN服务器时报错：Cannot query proxy blanket：no such interface supported (0x80004002)",
    "url": "/posts/dajian-svn-fuwuqi-shi-baocuo/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2020-12-14 13:47:00 +0800",
    





    
    "snippet": "一、错误信息Cannot query proxy blanket: no such interface supported (0x80004002)二、解决方案这个错误只会在有NVIDIA独立显卡的笔记本上出现，只要切换到集成显卡即可，步骤为：  打开NVIDIA控制面板。  选择3D设置-&gt;管理3D设置。  选择集成显卡作为优先的图形处理器。  点击应用。三、备注1、如何打开NVID...",
    "content": "一、错误信息Cannot query proxy blanket: no such interface supported (0x80004002)二、解决方案这个错误只会在有NVIDIA独立显卡的笔记本上出现，只要切换到集成显卡即可，步骤为：  打开NVIDIA控制面板。  选择3D设置-&gt;管理3D设置。  选择集成显卡作为优先的图形处理器。  点击应用。三、备注1、如何打开NVIDIA控制面板如果安装了NVIDIA显卡驱动，就可以在电脑桌面空白处点击鼠标右键，然后选择进入“NVIDIA控制面板”，如果没有的话，可以按照以下方法操作：  打开控制面板。  在打开的窗口右上角的“查看方式”选择大图标就可以找到“NVIDIA控制面板”。  打开“NVIDIA控制面板”后在窗口的左上方点击“桌面”然后把“添加桌面上下文菜单”勾选上，这样以后在桌面的空白处鼠标右键就能找到。2、NVIDIA控制面板打不开  首先可以在添加删除程序里面完整卸载原有NVIDIA驱动程序，并在NVIDIA官网下载相应的驱动，安装完成后再重启电脑。  其次可以尝试依次打开控制面板→管理工具→服务，并找到NVIDIA Driver Helper Service和NVIDIA Update Service Daemon两个选项，然后将他们的启动类型先改成手动，接着点启动，然后再改为自动，服务状态同样都改成启动。进行设置后，再尝试看能否打开NVIDIA控制面板。  这里还可以看下msconfig系统配置里面的启动选项里有没跟NVIDIA相关的选项的，有的话就打上勾，接着再重新打开试试。"
  },
  
  {
    "title": "使用Nexus搭建Maven私服",
    "url": "/posts/nexus-dajian-maven-sifu/",
    "categories": "Knowledge, Nexus",
    "tags": "Nexus",
    "date": "2020-12-14 13:47:00 +0800",
    





    
    "snippet": "为什么要搭建Nexus私服，原因很简单，有些公司不提供外网给项目组人员，因此就不能使用Maven访问远程的仓库，所以很有必要在局域网里找一台有外网权限的机器，搭建Nexus私服，然后开发人员连到这台私服上，这样的话就可以通过这台搭建了Nexus私服的电脑访问Maven的远程仓库。1、首先确定我们的环境安装好Maven，JDK等必须的环境。  2、这些都准备好之后，去下载最新版本的Nexus，...",
    "content": "为什么要搭建Nexus私服，原因很简单，有些公司不提供外网给项目组人员，因此就不能使用Maven访问远程的仓库，所以很有必要在局域网里找一台有外网权限的机器，搭建Nexus私服，然后开发人员连到这台私服上，这样的话就可以通过这台搭建了Nexus私服的电脑访问Maven的远程仓库。1、首先确定我们的环境安装好Maven，JDK等必须的环境。  2、这些都准备好之后，去下载最新版本的Nexus，下载地址：http://www.sonatype.org/nexus/go。3、下载完成后解压，打开目录nexus-2.4.0-09-bundle\\nexus-2.4.0-09\\bin\\jsw 这个目录下面你会发现有很多系统版本的Nexus环境，根据个人的电脑系统选择对应的版本。打开一个版本你会看到如下:一般都是将Nexus安装成Windows服务，所以点击install-nexus.bat，访问http://localhost:8081/nexus/启动后如下页面，在右上角有个Log in的超链接，点击登录，默认的用户名是admin，密码是admin123。 登录后你可以在左侧修改登录信息：4、接下来，我们配置一下Maven的代理服务器(前提是你的电脑不能连接外网，如果可以上外网，这里也没有意思，只是介绍一下)，在左侧菜单找到如图：点击查看右边有很多选项，找到这里添加你的代理服务器就可以了。5、接下来，好像这里都不需要怎么配置的，这里还有一个可能需要注意一下的，就是3rd party、Snapshots、Releases这三个，分别用来保存第三方jar（典型的oracle数据库的jar驱动包），项目组内部的快照、项目组内部的发布版。我目前只是用3rd party这个第三方的功能，将maven仓库中没有构件的jar包上传到服务器。如何将第三方的jar上传到nexus上面呢?如下：举例上传oracle的驱动包。那么现在Nexus已经安装好，怎么使用上传的jar包呢，很简单，前提是你已经建立了一个Maven的项目。含有pom.xml这个文件，在这个文件中添加如下：先去服务器看看jar的Maven构件：然后在pom.xml中添加如下的本地仓库地址：到此，完成了Nexus私服的搭建，项目组开发人员开发时，只要在项目的pom.xml文件中，添加如下pom.xml信息即可获取私服的jar。如果添加其他的构件时，会先在Nexus私服下载好，以后才会下载到本地。以后，如果发现私服已经存在某一jar包，则会直接从私服下载，如果没有再去网络上下载。这就是搭建私服的好处。6、将Mavan的settings.xml配置文件与私服关联，修改settings.xml配置文件：在&lt;servers&gt;标签里添加如下内容，配置私服的账号和密码 &lt;server&gt;    &lt;id&gt;Demo&lt;/id&gt;    &lt;username&gt;admin&lt;/username&gt;    &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;    在&lt;mirrors&gt;标签里添加如下内容，配置私服的地址&lt;mirror&gt;    &lt;id&gt;nexus&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;url&gt;http://l27.0.0.1:8081/nexus/content/repositories/nexue-test/&lt;/url&gt;&lt;/mirror&gt;"
  },
  
  {
    "title": "IntelliJ IDEA快捷键",
    "url": "/posts/intelliJ-idea-kuaijiejian/",
    "categories": "Knowledge, IntelliJ IDEA",
    "tags": "IntelliJ IDEA",
    "date": "2020-12-14 13:23:00 +0800",
    





    
    "snippet": "IDEA原生导包：Alt + Enter快速切换下一行：Shift + Enter查看继承关系：F4查看类结构：Ctrl + o整体修改变量名或方法名：Ctrl + Shift + r生成try catch方法：Alt + Shift + z查找文件：Shift + Shift抽取方法：Alt + Shift + m打开最近修改的文件：Ctrl + e快速搜索类中错误：Ctrl + Shif...",
    "content": "IDEA原生导包：Alt + Enter快速切换下一行：Shift + Enter查看继承关系：F4查看类结构：Ctrl + o整体修改变量名或方法名：Ctrl + Shift + r生成try catch方法：Alt + Shift + z查找文件：Shift + Shift抽取方法：Alt + Shift + m打开最近修改的文件：Ctrl + e快速搜索类中错误：Ctrl + Shift + q 选择要粘贴的内容：Ctrl + Shift + v查找方法在哪里被调用：Ctrl + Alt + h查看类的继承结构图：Ctrl + Alt + u  格式化代码：Ctrl + Alt + lEclipse模式查看方法在哪里被调用：Ctrl + g查看调用层次：Ctrl + Alt + h  查看子类方法实现：Ctrl + Alt + b 全局搜索：Ctrl + h生成getter和setter：Alt + Insert格式化：Ctrl + A选中，然后Ctrl + I打开和关闭列模式：Alt + Shift + Insert   去除所有未引用的包：Ctrl + Alt + o"
  },
  
  {
    "title": "SpringMVC接收form表单提交的数组数据",
    "url": "/posts/springmvc-jieshou-form-biaodan-tijiao-de-shuzu-shuju/",
    "categories": "Knowledge, SpringMVC",
    "tags": "SpringMVC",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "前端页面&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=\"...",
    "content": "前端页面&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=\"test\"  method=\"post\" enctype=\"application/x-www-form-urlencoded\"&gt;            &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[0].x\"/&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[0].y\"/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[1].x\"/&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[1].y\"/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[2].x\"/&gt;&lt;/td&gt;                    &lt;td&gt;&lt;input type=\"text\" name=\"points[2].y\"/&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;input type=\"submit\" value=\"Submit\"&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;实体类public class Point {    private Integer x;    private Integer y;    public Integer getX() {        return x;    }    public void setX(Integer x) {        this.x = x;    }    public Integer getY() {        return y;    }    public void setY(Integer y) {        this.y = y;    }}实体类集合封装类SpringMVC不能用List接收，但可以用包装了List成员的对象接收public class PointModel {    private List&lt;Point&gt; points;    public List&lt;Point&gt; getPoints() {        return points;    }    public void setPoints(List&lt;Point&gt; points) {        this.points = points;    }}控制器@Controllerpublic class PointController {    @PostMapping(\"/test\")    @ResponseBody    public String testPost(PointModel pointModel){        System.out.println(JSON.toJSONString(pointModel));        return JSON.toJSONString(pointModel);    }}"
  },
  
  {
    "title": "< select>标签的回显",
    "url": "/posts/select-biaoqian-de-huixian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "&lt;div class=\"form-group\"&gt;    &lt;label class=\"col-sm-2\" contenteditable=\"true\" for=\"test\"&gt;数字&lt;/label&gt;    &lt;div class=\"col-xs-12\"&gt;        &lt;select id=\"num\" class=\"num\" name=\"num\"...",
    "content": "&lt;div class=\"form-group\"&gt;    &lt;label class=\"col-sm-2\" contenteditable=\"true\" for=\"test\"&gt;数字&lt;/label&gt;    &lt;div class=\"col-xs-12\"&gt;        &lt;select id=\"num\" class=\"num\" name=\"num\"&gt;            &lt;option value=\"00\" /&gt;            &lt;option value=\"01\"&gt;01&lt;/option&gt;            &lt;option value=\"02\"&gt;02&lt;/option&gt;            &lt;option value=\"03\"&gt;03&lt;/option&gt;        &lt;/select&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var num = ${ json }.dateMap.num;    var num_el = $(\"#num\").find(\"option\");    for (var i = 0; i &lt; num_el.length; i++) {        var num_val = num_el.eq(i).val();        if (num_val == num) {            num_el.eq(i).attr(\"selected\", true);        }    }&lt;/script&gt;"
  },
  
  {
    "title": "JQuery如何判断为null、undefined、NaN",
    "url": "/posts/jquery-ruhe-panduan-kongzhi/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "判断是否为null&lt;script type=\"text/javascript\"&gt;    var tmp = null;    if (tmp == null) {        alert(\"null\");    }&lt;/script&gt;运行结果：会弹窗null判断是否为undefined&lt;script type=\"text/javascript\"&gt;    v...",
    "content": "判断是否为null&lt;script type=\"text/javascript\"&gt;    var tmp = null;    if (tmp == null) {        alert(\"null\");    }&lt;/script&gt;运行结果：会弹窗null判断是否为undefined&lt;script type=\"text/javascript\"&gt;    var tmp = undefined;    if (typeof (tmp) == \"undefined\") {        alert(\"undefined\");    }&lt;/script&gt;结果：弹出undefined说明：typeof(a)的作用是返回变量a的类型的字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”判断是否为NaN&lt;script type=\"text/javascript\"&gt;    var tmp = 0 / 0;    var temp = parseInt(\"a\");    if (isNaN(tmp) &amp;&amp; isNaN(temp)) {        alert(\"NaN\");    }&lt;/script&gt;结果：弹出NaN，可以看出当出现字符串转化数字异常的时候回返回NaN，0除以0也会返回NaN说明：如果把NaN与任何值（包括其自身）相比得到的结果均是false，所以要判断某个值是否是NaN，不能使用 == 或 === 运算符。 提示：isNaN()函数通常用于检测parseFloat()和parseInt()的结果，以判断它们表示的是否是合法的数字。当然也可以用isNaN()函数来检测算数错误，比如用0作除数的情况。 判断undefined和null&lt;script type=\"text/javascript\"&gt;    var tmp = undefined;    if (tmp == undefined) {        alert(\"null or undefined\");    } &lt;/script&gt;或者：&lt;script type=\"text/javascript\"&gt;    var tmp = undefined;    if (tmp == null) {        alert(\"null or undefined\");    }&lt;/script&gt;结果：都可以弹出：null or undefined&lt;script type=\"text/javascript\"&gt;    if (null == undefined) {        alert(\"null == undefined\");    }&lt;/script&gt;结果：弹出： null == undefined说明：null == undefined判断undefined、null与NaN&lt;script type=\"text/javascript\"&gt;    var tmp = null; //这里tmp可以使 null undefine NaN 都可以进入判断语句    if (!tmp) {        alert(\"null or undefined or NaN\");    }&lt;/script&gt;结果：弹出：null or undefined or NaN总结：一般不那么区分就使用这个足够"
  },
  
  {
    "title": "JQuery获取元素的属性及对元素操作",
    "url": "/posts/jquery-huoqu-yuansu-de-shuxing-ji-dui-yuansu-caozuo/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-10 13:47:00 +0800",
    





    
    "snippet": "获取宽度为百分比(%)的对象具体宽度(px)&lt;div id=\"panel\"&gt;    &lt;div id =\"a\" style=\"width:66%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    $(document).ready(function () {        alert($(...",
    "content": "获取宽度为百分比(%)的对象具体宽度(px)&lt;div id=\"panel\"&gt;    &lt;div id =\"a\" style=\"width:66%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    $(document).ready(function () {        alert($(\"#a\").innerWidth());\t});&lt;/script&gt;获取元素自身的HTML$(\"#panel\").prop(\"outerHTML\");复制元素$(\"#panel\").clone()关于元素包裹的演示&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;演示文档&lt;/title&gt;    &lt;script src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt;    &lt;style&gt;        li{background: #ccc;margin-top: 25px;width: 150px;}        .orange{background: orange}        .red{background: red}        .green{background: green}        .ccc{background: #ccc;}        #div1{width: 200px;height: 25px;}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=\"div1\" class=\"ccc\"&gt;&lt;/div&gt;    &lt;ol&gt;        &lt;li class=\"orange\"&gt;列表项1&lt;/li&gt;        &lt;li class=\"red\"&gt;&lt;i&gt;列表项2&lt;/i&gt;&lt;/li&gt;        &lt;li class=\"green\"&gt;列表项3&lt;/li&gt;    &lt;/ol&gt;    &lt;input id=\"btn1\" type=\"button\" value='wrap'&gt;    &lt;input id=\"btn2\" type=\"button\" value='wrapAll'&gt;    &lt;input id=\"btn3\" type=\"button\" value='unwrap'&gt;    &lt;input id=\"btn4\" type=\"button\" value='wrapInner'&gt;        &lt;script type=\"text/javascript\"&gt;        $(function () {            $('#btn1').click(function () {                // 在div元素中包裹每个i元素                $('li').wrap($('#div1'));            })            $('#btn2').click(function () {                // 在div元素中包裹所有i元素                $('li').wrapAll($('#div1'));            })            $('#btn3').click(function () {                // 移除所有i元素的父元素                $('li').unwrap();            })            $('#btn4').click(function () {                // 在每个i元素的内容上包裹div元素                $('li').wrapInner($('#div1'));            })        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "JQuery的attr()和prop()的区别",
    "url": "/posts/jquery-prop-hanshu-he-attr-hanshu-de-qubie/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-09 13:47:00 +0800",
    





    
    "snippet": "根据官方的建议，具有 true 和 false 两个值的属性，如 checked, selected 或者 disabled 使用 prop()，其他的使用 attr()",
    "content": "根据官方的建议，具有 true 和 false 两个值的属性，如 checked, selected 或者 disabled 使用 prop()，其他的使用 attr()"
  },
  
  {
    "title": "JQuery判断下拉和单选是否选中并获取值和索引",
    "url": "/posts/jquery-panduan-xiala-danxuan-shifou-xuanzhong/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-09 13:47:00 +0800",
    





    
    "snippet": "select判断option是否被选中$(\"#mySelect\").is(\":checked\"); // false是未被选中，true是被选中$(\"#mySelect\").attr('checked') == undefined; // false是未被选中，true是被选中获取select选中的值$(\"#mySelect option:selected\").val();$(\"#mySel...",
    "content": "select判断option是否被选中$(\"#mySelect\").is(\":checked\"); // false是未被选中，true是被选中$(\"#mySelect\").attr('checked') == undefined; // false是未被选中，true是被选中获取select选中的值$(\"#mySelect option:selected\").val();$(\"#mySelect\").find('option:selected').val();$(\"#mySelect\").val();获取select选中的索引$('#mySelect').prop('selectedIndex');$(\"#mySelect option:selected\").index();radio判断radio是否被选中&lt;html&gt;    &lt;head&gt;        &lt;script src=\"http://libs.baidu.com/jquery/1.9.1/jquery.min.js\"&gt;&lt;/script&gt;        &lt;script type=\"text/javascript\"&gt;            $(document).ready(function () {                $(\"input\").click(function () {                    if ($(this).prop(\"checked\")) {                        alert($('input:radio[name=\"sex\"]:checked').val());                    }                });            });        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        男&lt;input type=\"radio\" name=\"sex\" value=\"male\"/&gt;        女&lt;input type=\"radio\" name=\"sex\" value=\"female\"/&gt;    &lt;/body&gt;&lt;/html&gt;获取radio选中的值$('input:radio[name=\"sex\"]:checked').val();"
  },
  
  {
    "title": "JQuery获取字符串字节长度",
    "url": "/posts/jquery-huoqu-zifuchuan-zijie-changdu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-09 13:47:00 +0800",
    





    
    "snippet": "function getByteLen(val) {    var len = 0;    for (var i = 0; i &lt; val.length; i++) {        var code = val.charCodeAt(i);        if (code &gt;= 0 &amp;&amp; code &lt;= 128) {            len += 1...",
    "content": "function getByteLen(val) {    var len = 0;    for (var i = 0; i &lt; val.length; i++) {        var code = val.charCodeAt(i);        if (code &gt;= 0 &amp;&amp; code &lt;= 128) {            len += 1;        } else {            len += 2;        }    }    return len;}"
  },
  
  {
    "title": "Linux退出vi编辑模式",
    "url": "/posts/linux-vi-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "按ESC键跳到命令模式，然后：:w         保存文件但不退出vi:w file    将修改另外保存到file中，不退出vi:w!        强制保存，不推出vi:wq        保存文件并退出vi:wq!       强制保存文件，并退出viq:         不保存文件，退出vi:q!        不保存文件，强制退出vi:e!        放弃所有修改，从上次保存...",
    "content": "按ESC键跳到命令模式，然后：:w         保存文件但不退出vi:w file    将修改另外保存到file中，不退出vi:w!        强制保存，不推出vi:wq        保存文件并退出vi:wq!       强制保存文件，并退出viq:         不保存文件，退出vi:q!        不保存文件，强制退出vi:e!        放弃所有修改，从上次保存文件开始再编辑"
  },
  
  {
    "title": "Linux常用命令",
    "url": "/posts/linux-changyong-mingling/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "ps -ef|grep tomcat                 查看Tomcat进程kill -9 进程号                      杀进程./startup.sh                       启动Tomcattail -f catalina.out               查看Tomcat日志信息echo -n \"\" &gt; catalina.o...",
    "content": "ps -ef|grep tomcat                 查看Tomcat进程kill -9 进程号                      杀进程./startup.sh                       启动Tomcattail -f catalina.out               查看Tomcat日志信息echo -n \"\" &gt; catalina.out          清空Tomcat日志nohup java -jar xxx.jar &amp;          启动Spring Boot工程nohup java -jar xxx.jar --server.port=8080 &amp;                                      启动Spring Boot工程时指定端口号clear                              清除信息pwd                                查看当前路径cat /etc/redhat-release            系统安装时CentOS默认的发行版信息  du -sh /home/*                     查看用户使用的存储空间的大小du -sh *|sort -h                   按占用空间大小排序df -h                              查看系统硬盘大小ls -lh xxx                         查看文件大小yum list installed |grep jdk       查看系统是否安装了JDKrpm -qa|grep \"软件或者包的名字\"    查找软件是否安装rpm -e \"包名\"                      卸载软件zip -r test.20170216.zip test      zip压缩tar -zcvf a.tar.gz a.txt           创建文件a的gzip压缩的tar包tar -zxvf a.tar.gz                 释放a.tar.gz包的内容mv a.txt b.txt                     将a.txt重命名为b.txtmv 文件名 路径名                   移动文件到指定目录cp -R 源路径 目标路径              复制文件cp 文件 新文件名                   复制一个文件为新文件grep 字符串 文件                   收索某个字符串           #根据pid查询启动文件所在目录lsof -p PID | grep cwd# 根据pid查询进程的启动目录cd /proc/29539(pid)ls -ail# 查看Nginx监听的端口ps aux|grep nginxnetstat -anp|grep (pid)"
  },
  
  {
    "title": "JQuery在iframe中查找元素",
    "url": "/posts/jquery-zai-iframe-zhong-chazhao-yuansu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "$(window).on('load', function () {    $('#mainiframe').contents().find('#myTab').remove();});",
    "content": "$(window).on('load', function () {    $('#mainiframe').contents().find('#myTab').remove();});"
  },
  
  {
    "title": "JQuery为input绑定触发事件",
    "url": "/posts/jquery-wei-input-bangding-chufa-shijian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "输入框正在输入时$(\"#ipt\").on('input', function() {    if (!($('#ipt').val() == '')) {        $(\".cancle_ico\").removeClass('hide');    } else {        $(\".cancle_ico\").addClass('hide');    }})输入框得到焦点时$(\"#ip...",
    "content": "输入框正在输入时$(\"#ipt\").on('input', function() {    if (!($('#ipt').val() == '')) {        $(\".cancle_ico\").removeClass('hide');    } else {        $(\".cancle_ico\").addClass('hide');    }})输入框得到焦点时$(\"#ipt\").on('focus', function() {    if (!($('#ipt').val() == '')) {        $(\".cancle_ico\").removeClass('hide');    } else {        $(\".cancle_ico\").addClass('hide');    }})输入框失去焦点时$(\"#ipt\").on('blur', function() {    if (($('#ipt').val() == '')) {        $(\".cancle_ico\").addClass('hide');    } else {        $(\".cancle_ico\").removeClass('hide');    }})"
  },
  
  {
    "title": "JQuery使用Replace函数替换全部匹配项",
    "url": "/posts/jquery-shiyong-replace-hanshu-tihuan-quanbu-pipeixiang/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "JQuery的Replace仅能替换第一个匹配的内容，例如：var str = \"a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;\";var Newstr = str.Replace(\"&lt;br/&gt;\", \"\");alert(Newstr); // 内容为：ab&lt;br/&gt;c&lt;br/&gt;要替换全部匹配项，可以使用正则表达式：var str ...",
    "content": "JQuery的Replace仅能替换第一个匹配的内容，例如：var str = \"a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;\";var Newstr = str.Replace(\"&lt;br/&gt;\", \"\");alert(Newstr); // 内容为：ab&lt;br/&gt;c&lt;br/&gt;要替换全部匹配项，可以使用正则表达式：var str = \"a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;\";re = new RegExp(\"&lt;br/&gt;\", \"g\");// 第一个参数是要替换掉的内容，第二个参数\"g\"表示替换全部（global）。var Newstr = str.Replace(re, \"\"); // 第一个参数是正则表达式。alert(Newstr); // 内容为：abc"
  },
  
  {
    "title": "JQuery检查字段是否为空",
    "url": "/posts/jquery-jiancha-ziduan-shifou-weikong/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        al...",
    "content": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        alert(\"输入框1不能为空！\");        flag = false;    }    if (flag &amp;&amp; test2) {        flag = true;    } else if (flag) {        alert(\"输入框2不能为空！\");        flag = false;    }    return flag;}或function checkIsNull() {    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (!test1) {        alert(\"输入框1不能为空！\");        return;    }    if (!test2) {        alert(\"输入框2不能为空！\");        return;    }}"
  },
  
  {
    "title": "JQuery检查输入内容是否包含特殊字符",
    "url": "/posts/jquery-jiancha-shuru-neirong-shifou-baohan-teshu-zifu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "调用函数判断function checkNameReg(val) {     var regEn = /[@#$%^&amp;*()[\\]]/im,        regCn = /[@#￥%……&amp;*[\\]]/im;    if(regEn.test(val) || regCn.test(val)) {        return false;    }    return true...",
    "content": "调用函数判断function checkNameReg(val) {     var regEn = /[@#$%^&amp;*()[\\]]/im,        regCn = /[@#￥%……&amp;*[\\]]/im;    if(regEn.test(val) || regCn.test(val)) {        return false;    }    return true; }或直接在键入的时候将特殊符号替换$(function() {    $(\"#TEST\").keyup(function() {          var inputNumber = $(this).val();        inputNumber = inputNumber.replace(/[@#\\$%\\^&amp;\\*\\……\\￥]/g, '');        $(this).val(inputNumber);    });});IE使用特殊字符替换时光标跳到最后的解决方法$(function () {    $(\"#TEST\").keyup(function () {        var text = $(this).val();        var nowPosition = $(this).getCursorPosition();        var textLength = text.length;        text = text.replace(/[@#\\$\\^&amp;\\*\\……\\￥]/g, '');        if (text.length - textLength &lt; 0) {            nowPosition = nowPosition - 1;        }        $(this).val(text);        var txtFocus = document.getElementById(\"TEST\");        var isIE = false || !!document.documentMode;        if (isIE) {            var range = txtFocus.createTextRange();            range.move(\"character\", nowPosition);            range.select();        } else {            txtFocus.setSelectionRange(nowPosition, nowPosition);            txtFocus.focus();        }    });});(function ($, undefined) {    $.fn.getCursorPosition = function () {        var el = $(this).get(0);        var pos = 0;        if ('selectionStart' in el) {            pos = el.selectionStart;        } else if ('selection' in document) {            el.focus();            var Sel = document.selection.createRange();            var SelLength = document.selection.createRange().text.length;            Sel.moveStart('character', -el.value.length);            pos = Sel.text.length - SelLength;        }        return pos;    }})(jQuery);"
  },
  
  {
    "title": "$ is not defined",
    "url": "/posts/$-is-not-defined/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-08 13:47:00 +0800",
    





    
    "snippet": "报错信息ReferenceError: $ is not defined [详细了解]&lt;script type=\"text/javascript\"&gt;    $(function () {        alert(\"OK\");    });&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"...",
    "content": "报错信息ReferenceError: $ is not defined [详细了解]&lt;script type=\"text/javascript\"&gt;    $(function () {        alert(\"OK\");    });&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"&gt;&lt;/script&gt;修改办法，把JQuery代码放在引用JQuery文件引入的后面&lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    $(function () {        alert(\"OK\");    });&lt;/script&gt;"
  },
  
  {
    "title": "JS实现禁用浏览器后退",
    "url": "/posts/js-shixian-jinzhi-liulanqi-houtui/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "这种方式，可以消除后退的所有动作，包括键盘、鼠标手势等产生的后退动作。&lt;script language=\"javascript\"&gt;    //防止页面后退    history.pushState(null, null, document.URL);    window.addEventListener('popstate', function () {        histo...",
    "content": "这种方式，可以消除后退的所有动作，包括键盘、鼠标手势等产生的后退动作。&lt;script language=\"javascript\"&gt;    //防止页面后退    history.pushState(null, null, document.URL);    window.addEventListener('popstate', function () {        history.pushState(null, null, document.URL);    });&lt;/script&gt;"
  },
  
  {
    "title": "JS常用函数",
    "url": "/posts/js-changyong-hanshu-zhengli/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "Math.abs()取绝对值var a = -20;var b = Math.abs(a);",
    "content": "Math.abs()取绝对值var a = -20;var b = Math.abs(a);"
  },
  
  {
    "title": "JQuery的页面加载完毕事件",
    "url": "/posts/jquery-yemian-jiazai-wanbi-shijian/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "第一种$(document).ready(function() {    // do something});$(document)把原生的document这个DOM对象转换为JQuery对象，转换完成后才能调用。其中ready方法ready(fn)表示的是页面结构被加载完毕后执行传入函数fn。第二种$(function() {    // do something});当页面加载完毕后执行...",
    "content": "第一种$(document).ready(function() {    // do something});$(document)把原生的document这个DOM对象转换为JQuery对象，转换完成后才能调用。其中ready方法ready(fn)表示的是页面结构被加载完毕后执行传入函数fn。第二种$(function() {    // do something});当页面加载完毕后执行里面的函数，这一种相对简单，用的最多。第三种window.οnlοad = function() {    // do something}上面两种方式与window.onload的区别为：  JQuery中的页面加载完毕事件，表示的是页面结构被加载完毕（不包含图片等非文字媒体文件）；  window.onload指页面包含图片等文件在内的所有元素都加载完成，如:&lt;img src=”htttp://baidu.com/1.jpg”/&gt;，onload必须等页面中的图片、声音、图像等远程资源被加载完毕后才调用，而JQuery中只需要页面结构被加载完毕就可以调用。"
  },
  
  {
    "title": "JQuery控制输入字段的长度",
    "url": "/posts/jquery-kongzhi-shuru-ziduan-de-changdu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "$(\"#TEST\").attr(\"onkeyup\", \"checkLength(this, 50);\"); // 设置触发事件var checkLength = function(dom, maxLength) {    var l = 0;    for(var i = 0; i &lt; dom.value.length; i++) {        if (/[\\u4e00-\\u9fa...",
    "content": "$(\"#TEST\").attr(\"onkeyup\", \"checkLength(this, 50);\"); // 设置触发事件var checkLength = function(dom, maxLength) {    var l = 0;    for(var i = 0; i &lt; dom.value.length; i++) {        if (/[\\u4e00-\\u9fa5]/.test(dom.value[i])) {            l+=2;        } else {            l++;        }        if (l &gt; maxLength) {            dom.value = dom.value.substr(0,i);            break;        }    }};  "
  },
  
  {
    "title": "JQuery获取相邻元素",
    "url": "/posts/jquery-huoqu-xianglin-yuansu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "JQuery里我们要获取某个元素的相邻元素时，可以用到的命令有三个：  next()：用来获取下一个同辈元素。  prev()：用来获取上一个同辈元素。  siblings()：用来获取所有的同辈元素。下面来看看简单的实例：&lt;div&gt;    &lt;p id=\"1\"&gt;1&lt;/p&gt;    &lt;p id=\"2\"&gt;2&lt;/p&gt;    &lt;p id...",
    "content": "JQuery里我们要获取某个元素的相邻元素时，可以用到的命令有三个：  next()：用来获取下一个同辈元素。  prev()：用来获取上一个同辈元素。  siblings()：用来获取所有的同辈元素。下面来看看简单的实例：&lt;div&gt;    &lt;p id=\"1\"&gt;1&lt;/p&gt;    &lt;p id=\"2\"&gt;2&lt;/p&gt;    &lt;p id=\"3\"&gt;3&lt;/p&gt;&lt;/div&gt;&lt;script language=\"javascript\"&gt;    $(\"#2\").next(); // 这个获取的等同于$(\"#3\")    $(\"#2\").prev(); // 这个获取的等同于$(\"#1\")    $(\"#2\").siblings(); // 这个获取的等同于$(\"#1, #3\")&lt;/script&gt;"
  },
  
  {
    "title": "JQuery对象和DOM元素的互转",
    "url": "/posts/jquery-he-dom-yuansu-huzhuan/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "JQuery对象转成DOM元素id选择器 $(“#id”)[0]&lt;input type=\"text\" id=\"tx\" value=\"44\"&gt;&lt;script&gt;$(function() {    // 通过id选择器获取Jquery对象    var tx =  $(\"#tx\");    // 转成dom对象    var domObj = tx[0];    alert...",
    "content": "JQuery对象转成DOM元素id选择器 $(“#id”)[0]&lt;input type=\"text\" id=\"tx\" value=\"44\"&gt;&lt;script&gt;$(function() {    // 通过id选择器获取Jquery对象    var tx =  $(\"#tx\");    // 转成dom对象    var domObj = tx[0];    alert(domObj.value);})&lt;/script&gt;id选择器 $(“#id”).get(0)&lt;input type=\"text\" id=\"tt\" value=\"33\"&gt;&lt;script&gt;$(function() {    // 通过id选择器获取Jquery对象    var tx =  $(\"#tx\");    // 转成dom对象    var domObj =  tx.get(0);    alert(domObj.value);})&lt;/script&gt;标签选择器 $(“input”).eq(0)[0]$(“input”).eq(0)[0] 或 $(“标签名”).get(0) // 下标从0开始    &lt;input type=\"text\" name=\"tt\" value=\"33\"&gt;&lt;input type=\"text\" name=\"tt\" value=\"44\"&gt;&lt;script&gt;$(function() {       // 通过标签选择器获取Jquery对象（多个）    var jqObj = $(\"input\");    // 获取单个jquery对象    var jq = jqObj.eq(0);    // 获取dom对象    var domObj = jqObj.get(0);})&lt;/script&gt;DOM元素转成Jquery对象&lt;input type=\"text\" id=\"tx\" value=\"33\"&gt;&lt;script&gt;$(function() {       // 获取DOM元素    var domObj =  document.getElementById(\"tx\");    // 转成Jquery对象    var jq = $(domObj);})&lt;/script&gt;"
  },
  
  {
    "title": "JQuery发送POST请求",
    "url": "/posts/jquery-fasong-post-qingqiu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "$.post(\"/test/test/deleteAction.do\", function(data) {    alert(data);});",
    "content": "$.post(\"/test/test/deleteAction.do\", function(data) {    alert(data);});"
  },
  
  {
    "title": "JQuery获取当前点击元素的自定义属性",
    "url": "/posts/huoqu-dianji-duixiang-de-shuxing/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "&lt;a onclick=\"goTest(this)\" myAttr=\"${data}\"&gt;点击删除&lt;/a&gt;';传this过去即可function goTest(e) {    var data = $(e).attr(\"myAttr\");    $(\"form\").attr(\"action\", \"goTest.do?data=\" + data).submit();    ...",
    "content": "&lt;a onclick=\"goTest(this)\" myAttr=\"${data}\"&gt;点击删除&lt;/a&gt;';传this过去即可function goTest(e) {    var data = $(e).attr(\"myAttr\");    $(\"form\").attr(\"action\", \"goTest.do?data=\" + data).submit();     return false;}"
  },
  
  {
    "title": "将< a>标签转为POST方式提交",
    "url": "/posts/a-biaoqian-zhuanwei-post-fangshi-tijiao/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-07 13:47:00 +0800",
    





    
    "snippet": "点击&lt;a&gt;标签调用JS函数提交，使用Ajax请求后台，发现无法获得ModelAndView返回的View，无法跳转页面，因此将&lt;a&gt;标签跳转改为POST方式提交。function goTest(el) {    var href = $(el).attr(\"href\"); // 获取&lt;a&gt;标签的href    $(\"form\").attr(\"action\"...",
    "content": "点击&lt;a&gt;标签调用JS函数提交，使用Ajax请求后台，发现无法获得ModelAndView返回的View，无法跳转页面，因此将&lt;a&gt;标签跳转改为POST方式提交。function goTest(el) {    var href = $(el).attr(\"href\"); // 获取&lt;a&gt;标签的href    $(\"form\").attr(\"action\", \"web.goTest.do\").submit(); // 将href赋值给action然后提交    return false; // 取消&lt;a&gt;标签默认动作}"
  },
  
  {
    "title": "JQuery四舍五入保留两位小数",
    "url": "/posts/jquery-sishewuru-baoliuliangwei-xiaoshu/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-06 13:47:00 +0800",
    





    
    "snippet": "function gettoDecimal(num) {    var result = parseFloat(num);    if (isNaN(result)) {        return false;    }    result = Math.round(num * 100) / 100;    var s_x = result.toString();    var pos_d...",
    "content": "function gettoDecimal(num) {    var result = parseFloat(num);    if (isNaN(result)) {        return false;    }    result = Math.round(num * 100) / 100;    var s_x = result.toString();    var pos_decimal = s_x.indexOf('.');    if (pos_decimal &lt; 0) {        pos_decimal = s_x.length;        s_x += '.';    }    while (s_x.length &lt;= pos_decimal + 2) {        s_x += '0';    }    return s_x;}注:  indexOf() 方法对大小写敏感  如果要检索的字符串值没有出现，则该方法返回-1"
  },
  
  {
    "title": "JQuery获取当前日期",
    "url": "/posts/jquery-huoqu-dangqian-riqi/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-12-06 13:47:00 +0800",
    





    
    "snippet": "function getNowDate(){    var myDate = new Date;    var year = myDate.getFullYear(); // 获取当前年    var mon = myDate.getMonth() + 1; // 获取当前月    var date = myDate.getDate(); // 获取当前日    var h = myDate...",
    "content": "function getNowDate(){    var myDate = new Date;    var year = myDate.getFullYear(); // 获取当前年    var mon = myDate.getMonth() + 1; // 获取当前月    var date = myDate.getDate(); // 获取当前日    var h = myDate.getHours(); // 获取当前小时数(0-23)    var m = myDate.getMinutes(); // 获取当前分钟数(0-59)    var s = myDate.getSeconds(); // 获取当前秒    var week = myDate.getDay();    var weeks = [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"];    return year + \"年\" + mon + \"月\" + date + \"日\" + \" \"     + h + \"时\" + m + \"分\" + s + \"秒\" + \" \" + weeks[week];}"
  },
  
  {
    "title": "NodeJS安装",
    "url": "/posts/nodejs-anzhuang/",
    "categories": "Knowledge, NodeJS",
    "tags": "NodeJS",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "下载首先去到官网：https://nodejs.org/en/download/下载对应的版本：接着选择好路径，一路安装即可。新版的NodeJS自带npm ，所以无需重新安装npm，安装结束后，在cmd输入node -v和npm -v即可显示安装成功：配置路径和环境变量安装之后，我们需要对路径进行重新配置，如果不重新配置路径，则下载的moudle还是在C盘，例如在安装路径下新建两个文件夹：用...",
    "content": "下载首先去到官网：https://nodejs.org/en/download/下载对应的版本：接着选择好路径，一路安装即可。新版的NodeJS自带npm ，所以无需重新安装npm，安装结束后，在cmd输入node -v和npm -v即可显示安装成功：配置路径和环境变量安装之后，我们需要对路径进行重新配置，如果不重新配置路径，则下载的moudle还是在C盘，例如在安装路径下新建两个文件夹：用来存放模块和缓存。创建之后，我们在窗口输入：# 配置npm全局安装目录npm config set prefix D:\\nodejs\\node_global# 配置npm缓存目录npm config set cache D:\\nodejs\\node_cache# 查看配置结果npm config ls接着需要修改环境变量，找到此电脑点击右键，进入属性设置窗口，点击高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; Path变量 –&gt; 编辑 –&gt; 新建，输入配置成功的默认全局安装路径D:\\nodejs\\node_global  把路径改成你的安装路径，如我的：修改默认镜像将默认镜像设置为淘宝镜像。npm config set registry https://registry.npm.taobao.org下载测试上面已经配置好了路径，接着，我们下载一个moudle试试npm install express -g-g 表示全局下载的意思，这样下载的moudle才会到我们配好好的路径下，如果不加-g参数，则下载的模块会安装在当前路径下。"
  },
  
  {
    "title": "Log4j日志文件乱码",
    "url": "/posts/log4j-rizhi-wenjian-luanma/",
    "categories": "Knowledge, Log4j",
    "tags": "Log4j",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "在默认语言非中文（或者说默认语言不支持中文的）的Windows、Linux、Unix上，用Log4j打印日志，出现乱码，常见的就是一堆问号。解决方法如果是log4j.properties为配置文件，比如log4j.appender.A1=org.apache.log4j.RollingFileAppenderlog4j.appender.A1.File=all.log加入一行log4j.ap...",
    "content": "在默认语言非中文（或者说默认语言不支持中文的）的Windows、Linux、Unix上，用Log4j打印日志，出现乱码，常见的就是一堆问号。解决方法如果是log4j.properties为配置文件，比如log4j.appender.A1=org.apache.log4j.RollingFileAppenderlog4j.appender.A1.File=all.log加入一行log4j.appender.A1=org.apache.log4j.RollingFileAppenderlog4j.appender.A1.Encoding=UTF-8log4j.appender.A1.File=all.log 如果是log4j.xml为配置文件，比如&lt;appender name=\"A1\" class=\"org.apache.log4j.RollingFileAppender\"&gt;&lt;param name=\"File\" value=\"all.log\" /&gt;......&lt;/appender&gt;加入一行&lt;appender name=\"A1\" class=\"org.apache.log4j.RollingFileAppender\"&gt;&lt;param name=\"Encoding\" value=\"UTF-8\" /&gt;&lt;param name=\"File\" value=\"all.log\" /&gt;......&lt;/appender&gt;"
  },
  
  {
    "title": "Jira REST API调用方式",
    "url": "/posts/jira-rest-api-diaoyong-fangfa/",
    "categories": "Knowledge, Jira",
    "tags": "Jira",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "调用Jira REST API时的权限验证采用basic authentication这种验证方式，主要考虑到简单易行、操作方便。具体的操作方法为在请求的http header中添加Authorization参数，取值为Basic base64(username:password)，这里的username和password是企业自己部署的JIRA平台的登陆账号和密码。Jira REST AP...",
    "content": "调用Jira REST API时的权限验证采用basic authentication这种验证方式，主要考虑到简单易行、操作方便。具体的操作方法为在请求的http header中添加Authorization参数，取值为Basic base64(username:password)，这里的username和password是企业自己部署的JIRA平台的登陆账号和密码。Jira REST API：https://docs.atlassian.com/software/jira/docs/api/REST/5.1.3/#id120417package com.jira.test.util;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.mail.MessagingException;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.HttpStatus;import org.apache.http.client.config.CookieSpecs;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.springframework.util.Base64Utils;import com.jira.test.model.vo.JiraAttachment;import com.jira.test.model.vo.JiraAttachmentVo;public class JiraAttachmentUtil {    private static final String BASE_URL = \"http://localhost:8080/rest/api/2/issue/\";     private static final String ADMIN_ACCOUNT = \"admin\";    private static final String ADMIN_PASSWORD = \"admin\";    /**     * @Title: getAttachmentUrlList     * @Description: 获取当前issue关联所有附件的下载链接     * @param issueId issue的id     * @return     * @throws IOException     * @throws MessagingException List&lt;String&gt;     */    public static List&lt;Map&lt;String, Object&gt;&gt; getAttachmentList(String issueId) throws IOException, MessagingException {        String body = \"\";        JiraAttachmentVo jiraAttachmentVo = new JiraAttachmentVo(); // 根据Jira返回的json数据格式建立的vo类        List&lt;Map&lt;String, Object&gt;&gt; attachmentList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 作为返回的数据集，也可以是json或其他类型                // 权限验证        String basic_auth = \"Basic \"; // 后面一定要跟一个空格        basic_auth += Base64Utils.encodeToString((ADMIN_ACCOUNT + \":\" + ADMIN_PASSWORD).getBytes());                // 请求API接口的相关实体类        CloseableHttpClient closeableHttpClient = HttpClients.createDefault();        RequestConfig defaultConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD).build();        HttpResponse httpResponse = null;                // 权限验证参数设置        HttpGet httpGet;        httpGet = new HttpGet(BASE_URL + issueId);        httpGet.setConfig(defaultConfig);        httpGet.setHeader(\"Accept\", \"application/json\");        httpGet.setHeader(\"Content-Type\", \"application/json\");        httpGet.setHeader(\"Authorization\", basic_auth);                try {            // 开始请求            httpResponse = closeableHttpClient.execute(httpGet);            // 返回数据            if (HttpStatus.SC_OK == httpResponse.getStatusLine().getStatusCode()) {                HttpEntity httpEntity = httpResponse.getEntity();                if (httpEntity != null) {                    body = EntityUtils.toString(httpEntity, \"UTF-8\");                    System.out.println(\"jira返回数据：\" + body);                    jiraAttachmentVo = JsonUtil.toBean(body, JiraAttachmentVo.class);                    if (null != jiraAttachmentVo &amp;&amp; null != jiraAttachmentVo.getFields()                            &amp;&amp; jiraAttachmentVo.getFields().getAttachment().size() &gt; 0) {                        for (JiraAttachment jiraAttachment : jiraAttachmentVo.getFields().getAttachment()) {                            Map&lt;String, Object&gt; attachmentMap = new HashMap&lt;String, Object&gt;();                            attachmentMap.put(\"content\", jiraAttachment.getContent());                            attachmentMap.put(\"created\", jiraAttachment.getCreated());                            attachmentMap.put(\"filename\", jiraAttachment.getFilename());                            attachmentMap.put(\"id\", jiraAttachment.getId());                            attachmentList.add(attachmentMap);                        }                    }                }            }        } catch (IOException e) {            e.printStackTrace();        } finally {            closeableHttpClient.close();        }        return attachmentList;    }    /**      * @Title: createIssue      * @Description: 创建issue     * @param jiraIssueVo     * @return     * @throws IOException JiraIssueResponseVo     */     private static JiraIssueResponseVo createIssue(JiraIssueVo jiraIssueVo) throws IOException {        String body = \"\";        JiraIssueResponseVo jiraIssueResponseVo = new JiraIssueResponseVo();        // 权限验证        String basic_auth = \"Basic \";        basic_auth += Base64Utils.encodeToString((ADMIN_ACCOUNT + \":\" + ADMIN_PASSWORD).getBytes());        // 请求API接口的相关实体类        CloseableHttpClient closeableHttpClient = HttpClients.createDefault();        HttpResponse httpResponse = null;        // 参数设置        String param = JSON.toJSONString(jiraIssueVo);        StringEntity stringEntity = new StringEntity(param, Charset.forName(\"UTF-8\"));        stringEntity.setContentEncoding(\"UTF-8\");        stringEntity.setContentType(\"application/json\");        // 权限验证参数设置        HttpPost httpPost;        httpPost = new HttpPost(BASE_URL);        httpPost.setHeader(\"Content-Type\", \"application/json; charset=UTF-8\");        httpPost.setHeader(\"Authorization\", basic_auth);        httpPost.setEntity(stringEntity);        try {            // 请求开始            httpResponse = (HttpResponse) closeableHttpClient.execute(httpPost);            // 返回数据            if (HttpStatus.SC_OK == httpResponse.getStatusLine().getStatusCode()) {                HttpEntity httpEntity = httpResponse.getEntity();                if (httpEntity != null) {                    body = EntityUtils.toString(httpResponse.getEntity(), \"UTF-8\");                    System.out.println(\"jira返回数据：\" + body);                    jiraIssueResponseVo = JsonUtil.toBean(body, JiraIssueResponseVo.class);                }            }        } catch (IOException e) {            e.printStackTrace();        } finally {            closeableHttpClient.close();        }        return jiraIssueResponseVo;    }}"
  },
  
  {
    "title": "MySQL、SQLServer、Oracle三种数据库的JDBC连接方式",
    "url": "/posts/sanzhong-shujuk-jdbc-lianjiefangshi/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "MySQLClass.forName(\"com.mysql.jdbc.Driver\");String url = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF8\";Connection connection = DriverManager.getConnection(url, username, password);State...",
    "content": "MySQLClass.forName(\"com.mysql.jdbc.Driver\");String url = \"jdbc:mysql://localhost:3306/test?characterEncoding=UTF8\";Connection connection = DriverManager.getConnection(url, username, password);Statement stmt = connection.createStatement();Result result = stmt.executeUpdate(sql);SQLServerClass.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");String url = \"jdbc:microsoft.sqlserver://localhost:1433/test\";Connection connection = DriverManager.getConnection(url, username, password);Statement stmt = connection.createStatement();Result result = stmt.executeUpdate(sql);OracleClass.forName(\"oracle.jdbc.driver.OracleDriver\");String url = \"jdbc:oracle:thin:@localhost:1521:test\";Connection connection = DriverManager.getConnection(url, username, password);PreparedStatement pstmt = connection.prepareStatement(sql);pstmt.setString(\"param\");Result result = pstmt.executeUpdate();"
  },
  
  {
    "title": "JDBC各大数据库的连接字符串和驱动类",
    "url": "/posts/geda-shujuku-lianjiechuan/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "OracledriverClass：oracle.jdbc.OracleDriverurl：jdbc:oracle:thin:@localhost:1521:dbnameMySQLdriverClass：com.mysql.jdbc.Driverurl：jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=tru...",
    "content": "OracledriverClass：oracle.jdbc.OracleDriverurl：jdbc:oracle:thin:@localhost:1521:dbnameMySQLdriverClass：com.mysql.jdbc.Driverurl：jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=true // 注意: 高版本的MySQL需要显示指定useSSLDB2driverClass：com.ibm.db2.jcc.DB2Driverurl：jdbc:db2://localhost:50000/dbnameSybasedriverClass：com.sybase.jdbc.SybDriverurl：jdbc:sybase:Tds:localhost:5007/dbnamePostgreSQLdriverClass：org.postgresql.Driverurl：jdbc:postgresql://localhost/dbnameSQLServerdriverClass：com.microsoft.sqlserver.jdbc.SQLServerDriverurl：jdbc:sqlserver://localhost:1433; DatabaseName=dbname"
  },
  
  {
    "title": "JDBC操作数据库出现中文乱码",
    "url": "/posts/caozuo-shujuku-chuxian-luanma/",
    "categories": "Knowledge, JDBC",
    "tags": "JDBC",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "通过JDBC操作数据库表时，如果记录中有中文，可能会碰到乱码的问题。主要原因是字符编码（characterEncoding）不正确，包括以下几个方面：  在数据库服务器上创建表格时没有选择支持中文的编码方式；  建立JDBC连接时没有指明支持中文的编码方式；建议在创建表格和建立JDBC连接时都采用utf-8编码。具体方法如下：  创建数据库表时，选择character与collation时都...",
    "content": "通过JDBC操作数据库表时，如果记录中有中文，可能会碰到乱码的问题。主要原因是字符编码（characterEncoding）不正确，包括以下几个方面：  在数据库服务器上创建表格时没有选择支持中文的编码方式；  建立JDBC连接时没有指明支持中文的编码方式；建议在创建表格和建立JDBC连接时都采用utf-8编码。具体方法如下：  创建数据库表时，选择character与collation时都选utf-8  建立JDBC连接时在url中加入characterEncoding=utf-8，以MySQL为例代码如下：Class.forName(\"com.mysql.jdbc.Driver\").newInstance();String url = \"jdbc:mysql://localhost:3306/db1?characterEncoding=utf-8\";String dbUsername = \"root\";String dbPassword = \"root\";Connection conn = DriverManager.getConnection(url, dbUsername, dbPassword);"
  },
  
  {
    "title": "Windows下Docker打开新窗口报错",
    "url": "/posts/docker-dakai-xinchuangkou-baocuo/",
    "categories": "Knowledge, Docker",
    "tags": "Docker",
    "date": "2020-12-02 13:47:00 +0800",
    





    
    "snippet": "错误信息error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.26/containers/json: open  //./pipe/docker_engine: The system cannot find the file specified. In the default daemon configurati...",
    "content": "错误信息error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.26/containers/json: open  //./pipe/docker_engine: The system cannot find the file specified. In the default daemon configuration on Windows, the docker client must be run elevated to connect. This error may also indicate that the docker daemon is not running.解决方法打开新窗口后执行@FOR /f \"tokens=*\" %i IN ('docker-machine env default') DO @%idefault是docker-machine的name，可以通过docker-machine -ls查看"
  },
  
  {
    "title": "Solr精准查询",
    "url": "/posts/solr-jingzhun-chaxun/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "外面加上双引号，必须是双引号，就可以了。UserRealname : 某某家长// 改为UserRealname : \"某某家长\" ",
    "content": "外面加上双引号，必须是双引号，就可以了。UserRealname : 某某家长// 改为UserRealname : \"某某家长\" "
  },
  
  {
    "title": "Solr管理界面详解",
    "url": "/posts/solr-guanlijiemian-xiangjie/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "solr服务器管理界面可以查看系统状态、solr设置、分词检测、查询索引、增减core、查看日志等。1. Dashboard（仪表盘）访问http://localhost:8080/solr时，出现该主页面，可查看到Solr运行时间、Solr版本，系统内存、虚拟机内存的使用情况。2. Logging（日志）显示Solr运行出现的异常或错误。3. Core Admin（core管理）主要有Ad...",
    "content": "solr服务器管理界面可以查看系统状态、solr设置、分词检测、查询索引、增减core、查看日志等。1. Dashboard（仪表盘）访问http://localhost:8080/solr时，出现该主页面，可查看到Solr运行时间、Solr版本，系统内存、虚拟机内存的使用情况。2. Logging（日志）显示Solr运行出现的异常或错误。3. Core Admin（core管理）主要有Add Core（添加核心）， Unload（卸载核心），Rename（重命名核心），Reload（重新加载核心），Optimize（优化索引库）Add Core是添加core：主要是在instanceDir对应的文件夹里生成一个core.properties文件。  name：给core起的名字；  instanceDir：与我们在配置Solr到Tomcat里时的solr_home里新建的core文件夹名一致；  dataDir:确认Add Core时，会在new_core目录下生成名为data的文件夹；  config：new_core下的conf下的config配置文件(solrconfig.xml)；  schema: new_core下的conf下的schema文件(schema.xml)。确认Add Core时，会在new_core下生成data文件夹，与core.properties文件。core.properties文件里内容如下：4. Java Propertie（Java属性）可查看到Java相关的一些属性的信息。5. Core Selecter（core选择器）需要在Core Admin里添加了core后才有可选项，这里以已经添加好的ims_advertiser_core为例。5.1 overview（概览）包含基本统计如当前文档数；和实例信息如当前核心的配置目录；5.2 Analysis（分析）检验分词效果，如图，我们对companyName字段进行了分词（至于哪些字段能分词，取决于在schema.xml文件里配置该字段时的type是否为配置的分词器类型text_ik）&lt;!-- 这里的text_ik就是下面name属性的值 --&gt;&lt;field name=\"companyName\" type=\"text_ik\" indexed=\"false\" stored=\"true\" multiValued=\"false\" /&gt;&lt;!-- 配置IK分词器 --&gt;&lt;fieldType name=\"text_ik\" class=\"solr.TextField\" positionIncrementGap=\"100\"&gt;    &lt;analyzer type=\"index\"&gt;        &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" isMaxWordLength=\"false\"/&gt;        &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt;    &lt;/analyzer&gt;    &lt;analyzer type=\"query\"&gt;        &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" isMaxWordLength=\"false\"/&gt;        &lt;filter class=\"solr.LowerCaseFilterFactory\"/&gt;    &lt;/analyzer&gt;&lt;/fieldType&gt; 这里的高亮背景色是灰色5.3 Dataimport（导入数据）前提是已经配置好了相关的配置，详情参见：Solr从数据库导入数据  Comman选项：full_import：全导入；delta_import:增量导入。所谓delta-import主要是对于数据库（也可能是文件等等）中增加或者被修改的字段进行导入。主要原理是利用每次我们进行import的时候在solr.home\\conf下面生成的dataimport.properties文件，此文件里面有最近一次导入的相关信息。这个文件如下：    #Tue Jul 19 10:15:50 CST 2016advertiser.last_index_time=2016-07-19 10:15:49last_index_time=2016-07-19 10:15:49        其实last_index_time是最近一次索引（full-import或者delta-import）的时间。通过比较这个时间和我们数据库表中的timestamp列即可得出哪些是之后修改或者添加的。    Verbose：  Clean：在索引开始构建之前是否删除之前的索引，默认为true。  Commit：在索引完成之后是否提交。默认为true。  Optimize：是否在索引完成之后对索引进行优化。默认为true。  Debug：是否以调试模式运行，适用于交互式开发（interactive development mode）之中。请注意，如果以调试模式运行，那么默认不会自动提交，请加参数commit=true。  Entity：Entity是document下面的标签data-config.xml。使用这个参数可以有选择的执行一个或多个Entity 。使用多个Entity参数可以使得多个Entity同时运行。如果不选择此参数那么所有的都会被运行。  Start,Rows：  Custom Parameters：  Excute：执行导入。  Refresh Status：刷新后才能看到数据发生了变化，如果刷新后数据还是0，说明未导入。5.4 Documents（索引文档）Documents（索引文档）索引的相关操作，如：增加，修改，删除等，例如我们要增加一个索引（companyName）的办法：1.先要在Solr的D:\\solr_home\\mycore1\\conf的schema.xml配置文件下，增加相关的字段field&lt;field name=\"a\" type=\"text_ik\" indexed=\"false\" stored=\"true\" multiValued=\"false\" /&gt;否则会出现如下错误：Status: errorError: Bad RequestError:{  \"responseHeader\": {    \"status\": 400,    \"QTime\": 1  },  \"error\": {    \"msg\": \"ERROR: [doc=126] unknown field 'companyName'\",    \"code\": 400  }}2.在如下页面，选择/update，文档格式选择json，然后submit提交。这样索引就增加上了。修改与增加一样，都是/update,删除为/delete。成功之后,我们去query里查询数据就能查到我们刚添加的数据。  Request-Handler(qt)：要进行的操作（update\\delete）。  Document Type：类型，有JSON、XML等格式。  Document(s)：内容，手动写的内容。  Commit Within：  Overwrite：为true,说明如果id重复则覆盖以前的值;为false说明如果id重复不覆盖以前的值。  Boost：好像是什么版本，没用过。5.5 Files（文件）solr_home下的core下的conf下的相关文件，可单击查看里面的内容。5.6 Query（查询页面）查询的结果要显示哪个字段,就得将schema.xml文件配置字段时的stored属性设为true。查询索引的文档，包含是否存在，排序是否正确等。 进入该页面后，直接点击Execute Query时，在右侧会生查回数据：  Request-Handler(qt)：  q：查询字符串（必须的）。*:*表示查询所有；keyword:东看表示按关键字“东看”查询  fq：Filter query过滤查询。使用Filter Query可以充分利用Filter Query Cache，提高检索性能。作用：在q查询符合结果中同时是fq查询符合的(类似求交集)，例如：q=mm&amp;fq=date_time：[20081001 TO 20091031]，找关键字mm，并且date_time是20081001到20091031之间的。  sort：排序。格式如下：字段名 排序方式；如advertiserId desc表示按id字段降序排列查询结果。  start,rows：表示查回结果从第几条数据开始显示，共显示多少条。  fl：field list。指定查询结果返回哪些字段。多个时以空格“ ”或逗号“,”分隔。不指定时，默认全返回。  df：default field默认的查询字段，一般默认指定。  Raw Query Parameters：  wt：write type。指定查询输出结果格式，我们常用的有json格式与xml格式。在solrconfig.xml中定义了查询输出格式：xml、json、python、ruby、php、phps、custom。  indent：返回的结果是否缩进，默认关闭，用indent=true | on开启，一般调试json,php,phps,ruby输出才有必要用这个参数。  debugQuery：设置返回结果是否显示Debug信息。  dismax：  edismax：  hl：high light高亮。hl=true表示启用高亮  hl.fl：用空格或逗号隔开的字段列表（指定高亮的字段）。要启用某个字段的highlight功能，就得保证该字段在schema中是stored。如果该参数未被给出，那么就会高亮默认字段，standard handler会用df参数，dismax字段用qf参数。你可以使用星号去方便的高亮所有字段。如果你使用了配符，那么要考虑启用hl.requiredFieldMatch选项。  hl.simple.pre：  hl.requireFieldMatch：如果置为true，除非该字段的查询结果不为空才会被高亮。它的默认值是false，意味着它可能匹配某个字段却高亮一个不同的字段。如果hl.fl使用了通配符，那么就要启用该参数。尽管如此，如果你的查询是all字段（可能是使用copy-field指令），那么还是把它设为false，这样搜索结果能表明哪个字段的查询文本未被找到  hl.usePhraseHighlighter：如果一个查询中含有短语（引号框起来的）那么会保证一定要完全匹配短语的才会被高亮。  hl.highlightMultiTerm：如果使用通配符和模糊搜索，那么会确保与通配符匹配的term会高亮。默认为false，同时hl.usePhraseHighlighter要为true。  facet：分组统计，在搜索关键字的同时,能够按照Facet的字段进行分组并统计。  facet.query：Facet Query利用类似于Filter Query的语法提供了更为灵活的Facet。通过facet.query参数，可以对任意字段进行筛选。  facet.field：需要分组统计的字段，可以多个。  facet.prefix：表示Facet字段值的前缀。比如facet.field=cpu&amp;facet.prefix=Intel，那么对cpu字段进行Facet查询，返回的cpu都是以Intel开头的， AMD开头的cpu型号将不会被统计在内。  spatial：  spellcheck：拼写检查。"
  },
  
  {
    "title": "Solr复制域的作用",
    "url": "/posts/solr-fuzhiyu-de-zuoyong/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "复制域常用于多域搜索，如：电商项目中搜索商品，既要在名字域中搜索也要在描述域中搜索，传统的做法需要手工写两次，而solr想发送一次请求，可到两个域中搜索，为此，引入了复制域的概念，将两个域的域名复制到一个text文本域中。Solr复制域可以将多个索引字段结合到一起作为查询使用的域，逻辑上拓展了可查询对象的范围。将一个字段的值作为复制字段，给其设置新的数据类型，如数值类型，可以作为排序字段来使...",
    "content": "复制域常用于多域搜索，如：电商项目中搜索商品，既要在名字域中搜索也要在描述域中搜索，传统的做法需要手工写两次，而solr想发送一次请求，可到两个域中搜索，为此，引入了复制域的概念，将两个域的域名复制到一个text文本域中。Solr复制域可以将多个索引字段结合到一起作为查询使用的域，逻辑上拓展了可查询对象的范围。将一个字段的值作为复制字段，给其设置新的数据类型，如数值类型，可以作为排序字段来使用，而不影像其模糊查询的效果。"
  },
  
  {
    "title": "Solr查询语句",
    "url": "/posts/solr-chaxun-yuju/",
    "categories": "Knowledge, Solr",
    "tags": "Solr",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "基本字段查询key:中国key:*中   // 结束值为“中”的值key:中*   // 开始值为“中”的值key:*中*  // 含有“中”的值强制不分词key:'中国'多字段与或关系 OR/ANDkey:(02 OR 10 OR 11 OR 12 )key:(02 AND 10 AND 11 AND 12 )key1:01 AND key2:02多字段不包含关系 NOTproduct_n...",
    "content": "基本字段查询key:中国key:*中   // 结束值为“中”的值key:中*   // 开始值为“中”的值key:*中*  // 含有“中”的值强制不分词key:'中国'多字段与或关系 OR/ANDkey:(02 OR 10 OR 11 OR 12 )key:(02 AND 10 AND 11 AND 12 )key1:01 AND key2:02多字段不包含关系 NOTproduct_name:(* NOT 1)    // 字段不含1product_name:(* NOT *1)   // 字段结束时不为1product_name:(* NOT 1*)   // 字段开始时不为1范围查询total_price:[5000 TO 10000]   // 数值区间registration_date:['2011-04-27 17:22:55' TO '2013-04-27 17:22:55']   // 时间区间"
  },
  
  {
    "title": "SQL中EXISTS的用法",
    "url": "/posts/sql-zhong-esists-de-yongfa/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "功能EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。EXISTS与IN的使用效率的问题，通常情况下采用EXISTS要比IN效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。用法在插入记录前，需要检查这条记录是否已经...",
    "content": "功能EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。EXISTS指定一个子查询，检测行的存在。EXISTS与IN的使用效率的问题，通常情况下采用EXISTS要比IN效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。用法在插入记录前，需要检查这条记录是否已经存在，只有当记录不存在时才执行插入操作，可以通过使用 EXISTS 条件句防止插入重复记录。示例INSERT INTO TableIn (ANAME, ASEX)SELECT top 1 '张三', '男' FROM TableInWHERE not exists (select * from TableIn where TableIn.AID = 7)"
  },
  
  {
    "title": "Firefox如何启用Pocket for Firefox",
    "url": "/posts/firefox-ruhe-qiyong-pocket/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "  在地址栏，输入about:config，然后按回车。  有时会出现警告页面。点击我了解此风险，请继续！，以打开about:config页面。  在偏好列表上面的搜索栏里输入pocket。  点击首选项extensions.pocket.enabled旁边的按钮设其值为true。  Pocket是Firefox的内置功能。此时，它会在地址栏中添加一个Pocket按钮，在我的足迹菜单里添加一...",
    "content": "  在地址栏，输入about:config，然后按回车。  有时会出现警告页面。点击我了解此风险，请继续！，以打开about:config页面。  在偏好列表上面的搜索栏里输入pocket。  点击首选项extensions.pocket.enabled旁边的按钮设其值为true。  Pocket是Firefox的内置功能。此时，它会在地址栏中添加一个Pocket按钮，在我的足迹菜单里添加一个查看Pocket列表选项。"
  },
  
  {
    "title": "数据库三范式",
    "url": "/posts/shujuk-sanfanshi/",
    "categories": "Knowledge, Database",
    "tags": "Database",
    "date": "2020-12-01 13:47:00 +0800",
    





    
    "snippet": "三范式解释1NF：字段不可分;原子性字段不可再分，否则就不是关系数据库; 2NF：有主键，非主键字段依赖主键;唯一性，一个表只说明一个事物;  3NF：非主键字段不能相互依赖;每列都与主键有直接关系，不存在传递依赖;不符合1NF的例子表字段1，字段2(字段2.1，字段2.2)，字段3 …… (关系数据库中create不出这样的表)存在问题因为设计不出这样的表，所以没有问题。不符合2NF的例子...",
    "content": "三范式解释1NF：字段不可分;原子性字段不可再分，否则就不是关系数据库; 2NF：有主键，非主键字段依赖主键;唯一性，一个表只说明一个事物;  3NF：非主键字段不能相互依赖;每列都与主键有直接关系，不存在传递依赖;不符合1NF的例子表字段1，字段2(字段2.1，字段2.2)，字段3 …… (关系数据库中create不出这样的表)存在问题因为设计不出这样的表，所以没有问题。不符合2NF的例子表学号，姓名，年龄，课程名称，成绩，学分这个表明显说明了两个事务:学生信息，课程信息存在问题  数据冗余，每条记录都含有相同信息；  删除异常：删除所有学生成绩，就把课程信息全删除了；  插入异常：学生未选课，无法记录进数据库；  更新异常：调整课程学分，所有行都调整。修正学生：Student(学号，姓名，年龄)； 课程：Course(课程名称，学分)； 选课关系：SelectCourse(学号，课程名称，成绩)。 满足2NF只消除了插入异常。不符合3NF的例子表学号，姓名，年龄，所在学院，学院联系电话，关键字为单一关键字”学号”; 存在依赖传递: (学号) → (所在学院) → (学院地点，学院电话) 存在问题  数据冗余：有重复值；  更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况  删除异常修正 学生：(学号，姓名，年龄，所在学院)； 学院：(学院，地点，电话)。"
  },
  
  {
    "title": "转发和重定向的参数传递",
    "url": "/posts/zhuanfa-he-chongdingxiang-de-canshuchuandi/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-11-30 13:47:00 +0800",
    





    
    "snippet": "重定向跳转超链接标签&lt;a&gt;就是一种重定向跳转，这样的跳转request对象是传不到下一个页面的，下一个页面得到的request对象是一个新的对象，而不是上一个页面传过来的，得不到上一个页面的数据。如果你想通过这种方法跳转的话，那就要用&lt;a href=\"a.jsp?参数名=参数值\"&gt;传递参数，在下一个页面用request.getParameter(\"参数名\")得到值。转...",
    "content": "重定向跳转超链接标签&lt;a&gt;就是一种重定向跳转，这样的跳转request对象是传不到下一个页面的，下一个页面得到的request对象是一个新的对象，而不是上一个页面传过来的，得不到上一个页面的数据。如果你想通过这种方法跳转的话，那就要用&lt;a href=\"a.jsp?参数名=参数值\"&gt;传递参数，在下一个页面用request.getParameter(\"参数名\")得到值。转发跳转这种跳转request对象会被传往下一个页面，可以用&lt;jsp:forward page=\"/a.jsp\"/&gt;，这样你可以把参数用request.setAttribute()的方法存进request对象里，再到下一个页面用request.getAttribute()得到参数。两种方法最明显的区别是，重定向跳转当你从a.jsp到b.jsp页面的时候，地址栏的地址已经由a.jsp变为b.jsp;相反，转发跳转当你从a.jsp到b.jsp页面的时候，地址栏仍然是a.jsp。"
  },
  
  {
    "title": "JSP页面拼装项目地址",
    "url": "/posts/jsp-yemian-pinzhuang-xiangmu-dizhi/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-11-30 13:47:00 +0800",
    





    
    "snippet": "&lt;% String path = request.getContextPath(); String basePath = request.getScheme()    + \"://\" + request.getServerName()    + \":\" + request.getServerPort()    + path;%&gt;&lt;!-- JSP中引用地址 --&gt;&lt...",
    "content": "&lt;% String path = request.getContextPath(); String basePath = request.getScheme()    + \"://\" + request.getServerName()    + \":\" + request.getServerPort()    + path;%&gt;&lt;!-- JSP中引用地址 --&gt;&lt;%=basePath %&gt;/TcService/insertTcService.controller"
  },
  
  {
    "title": "静态包含和动态包含",
    "url": "/posts/jingtaibaohan-he-dongtaibaohan/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-11-30 13:47:00 +0800",
    





    
    "snippet": "区别      书写上不同静态包含：&lt;%@include file=\"1.jsp\"%&gt;动态包含：&lt;jsp:include page=\"1.jsp\"&gt;&lt;/jsp:include&gt;&lt;%@include file=\"1.jsp\"%&gt;是指令元素；&lt;jsp:include page=\"1.jsp\"/&gt;是行为元素。        最终编译成Ja...",
    "content": "区别      书写上不同静态包含：&lt;%@include file=\"1.jsp\"%&gt;动态包含：&lt;jsp:include page=\"1.jsp\"&gt;&lt;/jsp:include&gt;&lt;%@include file=\"1.jsp\"%&gt;是指令元素；&lt;jsp:include page=\"1.jsp\"/&gt;是行为元素。        最终编译成Java文件的数目不同静态包含在转换成为Java文件的时候将包含文件的内容”复制”到主体文件，然后作为一个整体编译。最终编译为一个Java文件。动态包含是各个JSP文件分别转换，分别编译。最终编程成多个Java文件。        执行时间不同静态包含发生在：JSP–&gt;Java文件阶段。动态包含发生在：执行class文件阶段，动态加入。        静态包含在两个文件中不能有相同的变量，动态包含允许由于静态包含相当于将包含文件内容直接复制到主体文件中，如果出现相同的变量，就会出现覆盖等问题，导致文件出错。而动态包含相当于调用不同的JSP，变量所在的空间不同，自然不会出现覆盖等现象。        无论是动态包含还是静态包含，其request对象都是相同的，也就是同一个request对象静态包含最终编译成一个Java文件，有一个request对象很好理解。而动态包含最终编译成多个JSP文件，为何会使用一个request对象呢？其实这些JSP组合的过程是一个请求转发的过程，自然也使用同一个request对象了。  注意  两个JSP页面的&lt;%@page contentType=\"text/html;charset=gbk\"%&gt;应该保持一致  不能通过fileurl向被包含的JSP页面传递参数，因为静态包含是发生在JSP页面转换为servlet的转换期间，此时的参数是服务器端设置的死的参数，完全没有经过客户端，这种参数是没有意义的，如&lt;%@include file=\"fileurl?user=admin\"%&gt;，而且此时会报错。  包含的JSP页面与被包含的JSP页面共用一个request内置对象。比如说在客户端访问包含页面时地址栏后面直接加上参数后传递，这种形式的传参是客户端送来的，两个页面都能够访问此参数。我们可以通过这两个页面合成的servlet中可以看到有传递的参数成为servlet的成员变量。  包含的JSP页面与被包含的JSP页面最好没有重复的HTML标签。否则会发生覆盖现象。  动态包含传参方式：&lt;jsp:include page=\"a.jsp\"&gt;    &lt;jsp:param name=\"age\" value=\"123\"&gt;&lt;/ jsp:include&gt;"
  },
  
  {
    "title": "Chrome小恐龙",
    "url": "/posts/dino/",
    "categories": "Games",
    "tags": "Games",
    "date": "2020-11-29 13:47:00 +0800",
    





    
    "snippet": "             \t                                                                                                                                                                     ",
    "content": "             \t                                                                                                                                                                     "
  },
  
  {
    "title": 2048,
    "url": "/posts/2048/",
    "categories": "Games",
    "tags": "Games",
    "date": "2020-11-29 13:47:00 +0800",
    





    
    "snippet": "\t\t\t\t\t\t\t2048\t\t\t\t\t\t\t\t\t\t\t\t\t最佳: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t分数: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t游戏结束🙈再试一次\t\t\t\t\t\t\t重新启动游戏\t\t\t\t\t\t\t",
    "content": "\t\t\t\t\t\t\t2048\t\t\t\t\t\t\t\t\t\t\t\t\t最佳: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t分数: \t\t\t\t\t\t\t\t\t0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t游戏结束🙈再试一次\t\t\t\t\t\t\t重新启动游戏\t\t\t\t\t\t\t"
  },
  
  {
    "title": "Filter拦截中忽略指定url和资源",
    "url": "/posts/guolvqi-fangxing-zhiding-dizhi/",
    "categories": "Knowledge, Servlet",
    "tags": "Servlet",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "web.xml中的配置&lt;filter&gt;    &lt;filter-name&gt;SystemAuthorityFilter&lt;/filter-name&gt;    &lt;filter-class&gt;platform.filter.SystemAuthorityFilter&lt;/filter-class&gt;    &lt;init-param&gt;    ...",
    "content": "web.xml中的配置&lt;filter&gt;    &lt;filter-name&gt;SystemAuthorityFilter&lt;/filter-name&gt;    &lt;filter-class&gt;platform.filter.SystemAuthorityFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;IGNORE_URL&lt;/param-name&gt;        &lt;param-value&gt;/login/login.do,/test/test.do&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;        &lt;param-name&gt;IGNORE_DIR&lt;/param-name&gt;        &lt;param-value&gt;/css/,/images/,/script/&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;SystemAuthorityFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;"
  },
  
  {
    "title": "Git检出和提交代码至远程仓库",
    "url": "/posts/git-ruhe-jianchu-he-tijiao-daima/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "我们使用Git需要先安装Git工具，这里给出下载地址：https://git-for-windows.github.io/从远程仓库检出代码找到自己在GitHub上的代码仓库，点击Clone or dowload会出现一个地址，复制这个地址备用。  打开我的电脑，选择一个盘，比如F盘，右键空白处点击git bash here，打开命令行。输入如下命令，克隆Test repository到Te...",
    "content": "我们使用Git需要先安装Git工具，这里给出下载地址：https://git-for-windows.github.io/从远程仓库检出代码找到自己在GitHub上的代码仓库，点击Clone or dowload会出现一个地址，复制这个地址备用。  打开我的电脑，选择一个盘，比如F盘，右键空白处点击git bash here，打开命令行。输入如下命令，克隆Test repository到Test文件夹中git clone https://github.com/JiayiLi/Test.git # 地址替换成你之前复制的地址将代码推送到远程仓库将要提交的文件复制粘贴至F盘的Test文件夹中，接着输入命令cd Test，进入Test文件夹，接下来依次输入以下代码即可完成提交操作：git add .                 # 别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来git commit -m  \"提交信息\"  # “提交信息”里面换成你的备注信息，如“first commit”git push -u origin master # 此操作是把本地仓库push到GitHub上面，此步骤需要输入帐号和密码"
  },
  
  {
    "title": "Java中使用FreeMarker导出Word文档",
    "url": "/posts/java-shiyong-freemarker-shengcheng-word-wendang/",
    "categories": "Knowledge, FreeMarker",
    "tags": "FreeMarker",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "制作模板在制作模板时需要注意的一些问题如下：  用Microsoft Office Word 2003或以上的版本来制作，不要用WPS做。  关于图片，一定要插入一张图片，方便后面找到图片的位置好进行替换。  一些需要动态生成的数据，如个人信息，用personInfo（其他字段也行，建议和程序中的VO字段对应）来代替，注意，单词要先用一个文本框写好，再复制黏贴过来，不要在Word上手动敲，不...",
    "content": "制作模板在制作模板时需要注意的一些问题如下：  用Microsoft Office Word 2003或以上的版本来制作，不要用WPS做。  关于图片，一定要插入一张图片，方便后面找到图片的位置好进行替换。  一些需要动态生成的数据，如个人信息，用personInfo（其他字段也行，建议和程序中的VO字段对应）来代替，注意，单词要先用一个文本框写好，再复制黏贴过来，不要在Word上手动敲，不然再转成xml时单词会被拆散，也不要直接黏贴过来一个${personInfo}，还是会被拆散，最好直接黏贴一个单词过来，在xml中再找到这个单词再添加${}。  表格只需要画一行，循环在xml中配置。模板画好之后，直接将Word另存为xml格式，保存完后将Word关掉，用Notepad++打开保存的xml格式的文档找到你写的单词如stdName。在单词前后加上${}，所有你写的单词都加上。搜索w:tr找到表格。在表格标签&lt;w:tr&gt;的首尾分别加上&lt;#list expList as exp&gt;和&lt;/#list&gt;标签，并且标签里的单词要改成${exp.time}这种形式。解释一下：list标签可以使标签内的表格自动循环生成相应的行数，expList是自己命名的，是表格的数据来源，是一个list集合，exp是别名。 搜索&lt;pkg:binaryData&gt;，你会发现这个标签里的内容特别多，这就是你画模板时插入的图片的BASE64字符串。将&lt;pkg:binaryData&gt;标签里的内容删完，替换为${images}，这样就可以在代码中设置，然后导出自己获取的图片了，当然名字自己取，叫img也可以，只要在代码中和这对应就好了。将上面修改好的xml文档保存好，点击重命名将其类型修改为ftl。至此，模板就制作好了，在后面代码中要用的模板就是template.ftl。Java代码private void exportWord(String ssdw, String image64Str, String stdName, String personInfo, List&lt;FamilyInfo&gt; familyInfos,                        Map&lt;String, String&gt; maps) {    Map&lt;String, Object&gt; dataMap = new HashMap&lt;String, Object&gt;();    // ssdw 是职员信息    dataMap.put(\"orgName\", ssdw);    // image64Str 是职员的照片转换后的BASE64字符串    dataMap.put(\"images\", image64Str);    // stdName 是职员信息    dataMap.put(\"stdName\", stdName);    // personInfo 是职员信息    dataMap.put(\"personInfo\", personInfo);    // familyList 是职员的家庭信息的集合，对应模板中的表格    List&lt;Map&lt;String, Object&gt;&gt; familyList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    for (int i = 0; i &lt; familyInfos.size(); i++) {        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(\"gx\", familyInfos.get(i).getYbrgx());        map.put(\"xm\", familyInfos.get(i).getCyxm());        map.put(\"dwjzw\", familyInfos.get(i).getDwjzw());        familyList.add(map);    }    dataMap.put(\"familyList\", familyList);    // expList 是职员的工作经历信息的集合，对应模板中的表格    List&lt;Map&lt;String, Object&gt;&gt; expList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();    Iterator&lt;Entry&lt;String, String&gt;&gt; it = maps.entrySet().iterator();    while (it.hasNext()) {        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        Map.Entry&lt;String, String&gt; entity = (Entry&lt;String, String&gt;) it.next();        map.put(\"time\", entity.getKey());        map.put(\"experience\", entity.getValue());        expList.add(map);    }    dataMap.put(\"expList\", expList);    @SuppressWarnings(\"deprecation\")    Configuration configuration = new Configuration();    configuration.setDefaultEncoding(\"utf-8\");    // 有两种方式获取你的模板，模板在项目中时用第一个，模板在本地时用第二个。    // 注意：两种方式的路径都只需要写到模板的上一级目录    configuration.setClassForTemplateLoading(this.getClass(), \"/tem\");    // configuration.setDirectoryForTemplateLoading(new File(\"C:/\"));      File outFile = new File(\"D:/outFilessa\" + Math.random() * 10000 + \".doc\"); // 输出路径    Template t = null;      Writer out = null;    try {        t = configuration.getTemplate(\"template.ftl\", \"utf-8\"); // 获取模板        out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outFile), \"utf-8\"));         // 如果想由浏览器指定下载位置，则使用下面代码        // String filename = \"模板.doc\";        // response.setContentType(\"application/ms-excel;charset=UTF-8\");        // response.setHeader(\"Content-Disposition\", \"attachment;filename=\".concat(String.valueOf(URLEncoder.encode(filename, \"UTF-8\"))));        // out = new BufferedWriter(new OutputStreamWriter(response.getOutputStream(), \"utf-8\"));        t.process(dataMap, out);    } catch (Exception e) {        e.printStackTrace();      } finally {        try {            out.close();        } catch (IOException  e1) {            e.printStackTrace();         }    }}"
  },
  
  {
    "title": "FreeMarker如何格式化数字",
    "url": "/posts/freemarker-geshihua-shuzi/",
    "categories": "Knowledge, FreeMarker",
    "tags": "FreeMarker",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "// 如果小数点后不足两位，用\"0\"代替${num?string('0.00')} // 输出为：1239765.46 // 如果小数点后多余两位，就只保留两位，否则输出实际值 ${num?string('#.##')} // 输出为：1,239,765.46 // 整数部分每三位用\",\"分割，并且保证小数点后保留两位，不足用\"0\"代替${num?string(',###.00')} // ...",
    "content": "// 如果小数点后不足两位，用\"0\"代替${num?string('0.00')} // 输出为：1239765.46 // 如果小数点后多余两位，就只保留两位，否则输出实际值 ${num?string('#.##')} // 输出为：1,239,765.46 // 整数部分每三位用\",\"分割，并且保证小数点后保留两位，不足用\"0\"代替${num?string(',###.00')} // 输出为：1,239,765.46 // 整数部分每三位用\",\"分割，并且小数点后多余两位就只保留两位，不足两位就取实际位数${num?string(',###.##')} // 输出为：012.70 // 整数部分如果不足三位（000），前面用\"0\"补齐，否则取实际的整数位${num?string('000.00')} "
  },
  
  {
    "title": "Bitbucket-4.10.1安装和破解",
    "url": "/posts/bitbucket-anzhuang-he-pojie/",
    "categories": "Knowledge, Bitbucket",
    "tags": "Bitbucket",
    "date": "2020-11-26 13:47:00 +0800",
    





    
    "snippet": "需要安装的环境有：jdk、mysql、git安装官网下载Bitbucket的安装包atlassian-bitbucket-4.10.1-x64.bin，运行安装程序，系统默认http端口为7990，服务端口为8006，安装时可以根据自己需要重新输入，安装成功后，启动服务，可以通过http://localhost:7990访问。破解停止服务，并上传文件atlassian-extras-deco...",
    "content": "需要安装的环境有：jdk、mysql、git安装官网下载Bitbucket的安装包atlassian-bitbucket-4.10.1-x64.bin，运行安装程序，系统默认http端口为7990，服务端口为8006，安装时可以根据自己需要重新输入，安装成功后，启动服务，可以通过http://localhost:7990访问。破解停止服务，并上传文件atlassian-extras-decoder-v2-3.3.0.jar和atlassian-extras-legacy-3.3.0.jar，路径为atlassian/bitbucket/4.10.1/atlassian-bitbucket/WEB-INF/lib，上传完成后重启服务。汉化下载Bitbucket4.10.1中文语言包（下载地址：https://translations.atlassian.com/dashboard/download?lang=zh_CN#/Bitbucket/4.11.0-rc1），在插件管理中上传语言插件。创建Jira连接点击”设置(Settigns)” -&gt; “应用程序连接(Application Links)”, 填入Jira的地址: http://192.168.X.X/8080后, 点击创建链接即可。安装过程截图"
  },
  
  {
    "title": "微信公众号自动应答的实现",
    "url": "/posts/weixin-zidong-yingda/",
    "categories": "Knowledge, WeChat",
    "tags": "WeChat",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "开发主要分为以下几个步骤：  申请测试公众号  配置服务器地址  验证服务器地址的有效性  接收消息，回复消息申请测试公众号  记录：不知道如何使用微信公众号进行调试，百度了很多资料，发现微信公众平台提供了相当好的测试工具，这是一个模拟的公众号，我们可以用自己的微信关注该公众号，然后进行接口调试。第一步首先要申请一个测试的微信公众号，便于调试，地址：https://mp.weixin.qq....",
    "content": "开发主要分为以下几个步骤：  申请测试公众号  配置服务器地址  验证服务器地址的有效性  接收消息，回复消息申请测试公众号  记录：不知道如何使用微信公众号进行调试，百度了很多资料，发现微信公众平台提供了相当好的测试工具，这是一个模拟的公众号，我们可以用自己的微信关注该公众号，然后进行接口调试。第一步首先要申请一个测试的微信公众号，便于调试，地址：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login配置服务器地址在测试号页面上有接口配置信息选项，在这个选项下面进行配置：有两个配置项：服务器地址（URL），Token，在正式的公众号上还有一个选项EncodingAESKey。  URL：开发者用来接收微信消息和事件的接口URL。  Token：可以任意填写，用作生成签名（该Token和接口URL中包含的Token进行比对，从而验证安全性）。  EncodingAESKey：由开发者手动填写或随机生成，将用作消息体加解密密钥。当输入URL和Token点击保存的时候，需要后台启动并且验证Token通过之后才能保存，不然会保存失败，所以先把后台代码启动起来。  记录：验证方式在这里可以找到。在验证的时候始终调不到后台，后来发现需要将本地的服务器映射到外网，这里使用了nat123，但是这个软件用了两天就不能用了，需要收费，于是换成了Sunny-Ngrok，这里推荐使用Sunny-Ngrok，用起来相当顺手。这些工作做完之后就可以保存配置了。验证服务器地址的有效性当填写URL，Token，点击保存时，微信会通过GET的方式把微信加密签名（signature），时间戳（timestamp），随机数（nonce）和随机字符串（echostr）传到后台，通过检验signature对请求进行校验。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。验证步骤如下：  将token、timestamp、nonce三个参数进行字典序排序。  将三个参数字符串拼接成一个字符串进行sha1加密。  获得加密后的字符串与signature对比，如果相等，返回echostr，表示配置成功，否则返回null，配置失败。签名校检工具类：package com.weixin.util;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class WeixinCheckoutUtil {        private static String token = \"you_token\";    public static boolean checkSignature(String signature, String timestamp,     String nonce) {        String[] arr = { token, timestamp, nonce };        sort(arr);        StringBuilder content = new StringBuilder();        for (int i = 0; i &lt; arr.length; i++) {            content.append(arr[i]);        }        MessageDigest md = null;        String tmpStr = null;        try {            md = MessageDigest.getInstance(\"SHA-1\");            byte[] digest = md.digest(content.toString().getBytes());            tmpStr = byteToStr(digest);        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        content = null;        return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;    }    private static String byteToStr(byte[] byteArray) {        String strDigest = \"\";        for (int i = 0; i &lt; byteArray.length; i++) {            strDigest = strDigest + byteToHexStr(byteArray[i]);        }        return strDigest;    }    private static String byteToHexStr(byte mByte) {        char[] Digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',         'A', 'B', 'C', 'D', 'E', 'F' };        char[] tempArr = new char[2];        tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4 &amp; 0xF)];        tempArr[1] = Digit[(mByte &amp; 0xF)];        String s = new String(tempArr);        return s;    }    public static void sort(String[] a) {        for (int i = 0; i &lt; a.length - 1; i++) {            for (int j = i + 1; j &lt; a.length; j++) {                if (a[j].compareTo(a[i]) &lt; 0) {                    String temp = a[i];                    a[i] = a[j];                    a[j] = temp;                }            }        }    }    }签名校验请求控制器package com.weixin.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.weixin.util.WeixinCheckoutUtil;@RestControllerpublic class WeixinCheckController {        @RequestMapping(value = \"/wx\", method = { RequestMethod.GET })    public String doGet(String signature, String timestamp,     String nonce, String echostr) {        // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功        if (signature != null &amp;&amp; WeixinCheckoutUtil.checkSignature(signature,          timestamp, nonce)) {            return echostr;        }        return null;    }}接收消息，回复消息  记录：微信服务器设置如果使用了安全模式，后台需要对报文进行解密，而且响应微信服务器的报文也需要加密。调试可以使用微信公众平台接口调试工具jar包依赖微信服务器发送过来的是XML格式的消息，所以我们可以采用开源框架dom4j去解析XML。而weixin-popular则是微信消息体加密及解密需要的。&lt;dependency&gt;    &lt;groupId&gt;dom4j&lt;/groupId&gt;    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;    &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.liyiorg&lt;/groupId&gt;    &lt;artifactId&gt;weixin-popular&lt;/artifactId&gt;    &lt;version&gt;2.8.24&lt;/version&gt;&lt;/dependency&gt;Message实体public class Message {    private String signature;    private String timestamp;    private String nonce;    private String openid;    private String msg_signature;    private String encrypt_type;}回调接口消息、事件回调跟校验回调是同一个接口地址，但是请求方式为POST。消息、事件会以xml格式的传输到后台，后台解析xml进行处理。package com.weixin.service.impl;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import com.qq.weixin.mp.aes.WXBizMsgCrypt;public class WechatCallbackServiceImpl implements WechatCallbackService {        private static String TOKEN = \"\";    private static String ENCODINGAES_KEY = \"\";    private static String APPID = \"\";    public void doPost(HttpServletRequest request, HttpServletResponse response)                             throws Exception {        request.setCharacterEncoding(\"UTF-8\");        response.setCharacterEncoding(\"UTF-8\");        PrintWriter out = response.getWriter();        String content = \"\"; // 应答消息        String msg = \"\"; // 用户发来的消息        String wechatId = \"\"; // 发送方帐号        String openid = \"\"; // 开发者微信号                try {            /** 获取回调入参 **/            String encryptType = request.getParameter(\"encrypt_type\"); // 加密类型            String timestamp = request.getParameter(\"timestamp\"); // 时间戳            String nonce = request.getParameter(\"nonce\"); // 随机数            String msgSignature = request.getParameter(\"msg_signature\"); // 加密签名            /** 对不同模式下的报文进行处理 **/            WXBizMsgCrypt pc = new WXBizMsgCrypt(TOKEN, ENCODINGAES_KEY, APPID);            String requestXml = streamToString(request);            String result = \"\";            if ((encryptType != null)                     &amp;&amp; (!\"\".equals(encryptType))                     &amp;&amp; (\"aes\".equals(encryptType))) {                // 安全模式，解密                result = pc.decryptMsg(msgSignature, timestamp, nonce, requestXml);            } else {                // 明文模式                result = requestXml;            }                        /** 解析XML报文 **/            Document doc = DocumentHelper.parseText(result);            Element root = doc.getRootElement();            List&lt;Element&gt; elelist = root.elements();            Map&lt;String, String&gt; map = new HashMap();            for (Element e : elelist) {                map.put(e.getName(), e.getText());            }            wechatId = (String) map.get(\"ToUserName\");            openid = (String) map.get(\"FromUserName\");            msg = (String) map.get(\"Content\");            /** 对消息进行响应 **/            if (msg.contains(\"消息\")) {                content = \"后台接收到了消息！\";            } else {                content = \"\";            }                        /** 拼装响应报文 **/            String responseXml = \"\"                 + \"&lt;xml&gt;\"                     + \"&lt;ToUserName&gt;&lt;![CDATA[\" + openid + \"]]&gt;&lt;/ToUserName&gt;\"                     + \"&lt;FromUserName&gt;&lt;![CDATA[\" + wechatId + \"]]&gt;&lt;/FromUserName&gt;\"                     + \"&lt;CreateTime&gt;\" + System.currentTimeMillis() + \"&lt;/CreateTime&gt;\"                    + \"&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\"                     + \"&lt;Content&gt;&lt;![CDATA[\" + content + \"]]&gt;&lt;/Content&gt;\"                + \" &lt;/xml&gt;\";                        /** 安全模式下对响应报文进行加密 **/            if ((encryptType != null)                     &amp;&amp; (!\"\".equals(encryptType))                     &amp;&amp; (\"aes\".equals(encryptType))) {                responseXml = pc.encryptMsg(responseXml, timestamp, nonce);            }                        /** 响应 **/            if (\"\".equals(content)) {                out.println(\"\");            } else {                out.println(responseXml);            }        } catch (Exception e) {            throw new Exception(\"回调接口发生错误，错误信息：\" + e.toString());        }    }    private String streamToString(HttpServletRequest request) throws IOException {        BufferedReader reader = new BufferedReader(                new InputStreamReader(request.getInputStream()));        StringBuilder sb = new StringBuilder();        try {            String line;            while ((line = reader.readLine()) != null) {                sb.append(line);            }        } catch (IOException e) {            e.printStackTrace();        }        return sb.toString();    }}回调接口控制器package com.weixin.controller;import javax.servlet.http.HttpServletRequest;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.weixin.util.WeixinCheckoutUtil;import com.weixin.service.WechatCallbackService;@RestControllerpublic class WeixinCheckController {    @Autowired    private WechatCallbackService wechatCallbackService;        @RequestMapping(value = \"/wx\", method = { RequestMethod.GET })    public String doGet(String signature, String timestamp,     String nonce, String echostr) {        if (signature != null &amp;&amp; WeixinCheckoutUtil.checkSignature(signature,          timestamp, nonce)) {            return echostr;        }        return null;    }    @RequestMapping(value = \"/wx\", method = { RequestMethod.POST })    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws Exception {        wechatCallbackService.doPost(request, response);    }}不同消息体报文的封装可以参考微信官方文档或者微信公众平台开发入门教程[2020版]  参考：1、java实现微信公众号token验证2、微信官方文档3、微信公众平台开发入门教程[2020版]"
  },
  
  {
    "title": "对微信服务器发送来的报文解密时报错：illegal Key Size",
    "url": "/posts/jiemi-shi-baocuo/",
    "categories": "Knowledge, WeChat",
    "tags": "WeChat",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "问题在加密解密时遇到这个问题：java.security.InvalidKeyException:illegal Key Size问题原因这是因为微信在进行数据传输的时候，会进行加密，微信使用的AES加密是256位，Java默认使用的解密包是local_policy.jar和US_export_policy.jar，但是这个默认的只支持128位的解密(java版本在1.8.0_161之后就没...",
    "content": "问题在加密解密时遇到这个问题：java.security.InvalidKeyException:illegal Key Size问题原因这是因为微信在进行数据传输的时候，会进行加密，微信使用的AES加密是256位，Java默认使用的解密包是local_policy.jar和US_export_policy.jar，但是这个默认的只支持128位的解密(java版本在1.8.0_161之后就没有这个问题了，默认是支持)。我们的版本低于1.8.0_161，默认是只支持128位的解密。解决办法  到这里选择下载Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 1.4.2  下载jce_policy-1_4_2.zip后解压，放入$JAVA_HOME/jre/lib/security/目录下替换原来的jar包。  重启服务"
  },
  
  {
    "title": "使用Excel生成SQL语句",
    "url": "/posts/shiyong-excel-shengcheng-sql/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "\"update TEST_TABLE set co1='\"&amp;A1&amp;\"', co2='\"&amp;B1&amp;\"', co3='\"&amp;C1&amp;\"' where co4='\"&amp;D1&amp;\"'\"",
    "content": "\"update TEST_TABLE set co1='\"&amp;A1&amp;\"', co2='\"&amp;B1&amp;\"', co3='\"&amp;C1&amp;\"' where co4='\"&amp;D1&amp;\"'\""
  },
  
  {
    "title": "查询数据库所有表的所有字段",
    "url": "/posts/chaxun-suoyoubiao-de-suoyou-ziduan/",
    "categories": "Knowledge, SQL",
    "tags": "SQL",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "MySQL数据库SELECT table_name, column_nameFROM information_schema. COLUMNSWHERE table_schema = 'testdb'AND table_name IN ( SELECT  TABLE_NAME FROM  INFORMATION_SCHEMA. TABLES WHERE  TABLE_SCHEMA = 'tes...",
    "content": "MySQL数据库SELECT table_name, column_nameFROM information_schema. COLUMNSWHERE table_schema = 'testdb'AND table_name IN ( SELECT  TABLE_NAME FROM  INFORMATION_SCHEMA. TABLES WHERE  TABLE_SCHEMA = 'testdb')ORDER BY table_name, column_nameOracle数据库SELECT A .table_name, A .COLUMN_NAMEFROM user_tab_columns AWHERE TABLE_NAME IN (  SELECT   table_name  FROM   user_tables )ORDER BY A .table_nameSQLServer数据库SELECT table_name, column_nameFROM information_schema.columnsWHERE table_name IN (  SELECT   TOP 100 PERCENT name  FROM   sysobjects  WHERE   xtype = 'u' )ORDER BY table_name"
  },
  
  {
    "title": "Linux中查看进程的端口号，查看哪个进程占用了该端口",
    "url": "/posts/linux-duankoujijincheng/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "知道进程，查看进程的端口号[root@localhost ~]# ps -ef|grep ssh961 ?         00:00:00 sshd...[root@localhost ~]# netstat -anp|grep 961tcp   0   0 0.0.0.0:22   0.0.0.0:*   LISTEN   961/sshd         ...          查看...",
    "content": "知道进程，查看进程的端口号[root@localhost ~]# ps -ef|grep ssh961 ?         00:00:00 sshd...[root@localhost ~]# netstat -anp|grep 961tcp   0   0 0.0.0.0:22   0.0.0.0:*   LISTEN   961/sshd         ...          查看哪个进程占用了某个端口[root@localhost ~]# netstat -anp|grep 22tcp   0   0 0.0.0.0:22   0.0.0.0:*   LISTEN   961/sshd            ...[root@localhost ~]# ps -ef|grep sshd961 ?        00:00:00 sshd1154 ?        00:00:00 sshd1156 ?        00:00:00 sshd"
  },
  
  {
    "title": "查看当前目录下文件及文件夹的大小",
    "url": "/posts/linux-chakan-dangqian-muluxia-wenjian-daxiao/",
    "categories": "Knowledge, Linux",
    "tags": "Linux",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "# 查看当前目录下各个文件及目录占用空间大小du -sh *# 按兆（M）来排序du -sh * | sort -rn",
    "content": "# 查看当前目录下各个文件及目录占用空间大小du -sh *# 按兆（M）来排序du -sh * | sort -rn"
  },
  
  {
    "title": "Git切换远程仓库地址",
    "url": "/posts/git-qiehuan-yuancheng-cangku-dizhi/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "Git仓库的服务器IP地址变了，本地代码挺多，重新检出太占时间，可以修改一个什么配置让本地仓库和新的远程仓库建立关联吗， 答案是肯定的！方式一：修改远程仓库地址git remote -v  # 查看当前远程仓库地址git remote set-url origin &lt;new url&gt;  # 修改远程地址为新的地址 &lt;new url&gt; 改为新的地址方式二：先删除远程仓库...",
    "content": "Git仓库的服务器IP地址变了，本地代码挺多，重新检出太占时间，可以修改一个什么配置让本地仓库和新的远程仓库建立关联吗， 答案是肯定的！方式一：修改远程仓库地址git remote -v  # 查看当前远程仓库地址git remote set-url origin &lt;new url&gt;  # 修改远程地址为新的地址 &lt;new url&gt; 改为新的地址方式二：先删除远程仓库地址，然后再添加git remote -v  # 查看当前远程仓库地址git remote rm origin  # 删除现有远程仓库git remote add origin url  # 添加新远程仓库"
  },
  
  {
    "title": "Git推送代码时报错：error:src refspec master does not match any",
    "url": "/posts/git-push-baocuo/",
    "categories": "Knowledge, Git",
    "tags": "Git",
    "date": "2020-11-25 13:47:00 +0800",
    





    
    "snippet": "将git push origin master 改成git push origin HEADHEAD指向当前工作的branch，master不一定指向当前工作的branch",
    "content": "将git push origin master 改成git push origin HEADHEAD指向当前工作的branch，master不一定指向当前工作的branch"
  },
  
  {
    "title": "如何防止U盘拷贝",
    "url": "/posts/ruhe-fangzhi-youpan-kaobei/",
    "categories": "Knowledge, SECURITY",
    "tags": "SECURITY",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "拒绝移动存储权限gpedit.msc——用户配置——管理模板——系统——可移动存储访问——所有可移动存储类——拒绝所有权限——已启用隐藏右键send to删除SendTo文件夹HKEY_CLASSES_ROOT\\AllFilesystemObjects\\shellex\\ContextMenuHandlers\\SendTo添加磁盘写保护HKEY_LOCAL_MACHINE\\SYSTEM\\Cur...",
    "content": "拒绝移动存储权限gpedit.msc——用户配置——管理模板——系统——可移动存储访问——所有可移动存储类——拒绝所有权限——已启用隐藏右键send to删除SendTo文件夹HKEY_CLASSES_ROOT\\AllFilesystemObjects\\shellex\\ContextMenuHandlers\\SendTo添加磁盘写保护HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\storagedevicepolicies解除写保护：writeprotect”=dword:00000000添加写保护：writeprotect”=dword:00000001隐藏U盘盘符HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\USBSTOR隐藏：Start”=dword:00000004显示：Start”=dword:00000003"
  },
  
  {
    "title": "常用DOS命令",
    "url": "/posts/changyong-dos-mingling/",
    "categories": "Knowledge, DOS",
    "tags": "DOS",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "calc -----------启动计算器  control --------打开控制面板 cleanmgr -------磁盘清理eventvwr -------事件查看器mplayer2 -------简易widnowsmediaplayer  Sndvol32 -------音量控制程序 mmc ------------打开控制台write ----------写字板dfrg.msc ...",
    "content": "calc -----------启动计算器  control --------打开控制面板 cleanmgr -------磁盘清理eventvwr -------事件查看器mplayer2 -------简易widnowsmediaplayer  Sndvol32 -------音量控制程序 mmc ------------打开控制台write ----------写字板dfrg.msc -------磁盘碎片整理程序compmgmt.msc ---计算机管理 diskmgmt.msc ---磁盘管理实用程序gpedit.msc -----组策略  lusrmgr.msc ----本机用户和组certmgr.msc ----证书管理实用程序 fsmgmt.msc -----共享文件夹管理器 devmgmt.msc --- 设备管理器 secpol.msc -----本地安全策略 desk.cpl -------显示属性 firewall.cpl ---WINDOWS防火墙 ncpa.cpl -------网络连接 sysdm.cpl ------系统 wscui.cpl ------安全中心sfc.exe --------系统文件检查器chkdsk.exe -----Chkdsk磁盘检查 shutdown -------关机，详细请在cmd中输入shutdown /?logoff ---------注销wmic bios ------查看BIOS信息dxdiag ---------查看系统信息方式1start msinfo32 -查看系统信息方式2winmsd ---------查看系统信息方式3ipconfig/all ---查询IP地址getmac ---------查询MAC地址winver ---------检测windows版本netstat -na ----查看电脑端口号"
  },
  
  {
    "title": "颜色搭配",
    "url": "/posts/yanse-dapei/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "交互按钮设计",
    "url": "/posts/jiaohu-anniu-sheji/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "算法复杂度速查表",
    "url": "/posts/suanfa-fuzadu-suchabiao/",
    "categories": "Collection, Technical",
    "tags": "Technical",
    "date": "2020-11-24 13:47:00 +0800",
    





    
    "snippet": "这篇文章覆盖了计算机科学里面常见算法的时间和空间的大O复杂度图例数据结构操作数组排序算法图操作堆操作大O复杂度图表",
    "content": "这篇文章覆盖了计算机科学里面常见算法的时间和空间的大O复杂度图例数据结构操作数组排序算法图操作堆操作大O复杂度图表"
  },
  
  {
    "title": "Spring Boot @Transactional注解不起作用的两种情况",
    "url": "/posts/shiwu-buqizuoyong-de-liangzhong-teshu-qingkuang/",
    "categories": "Knowledge, Spring Boot",
    "tags": "Spring Boot",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "1、事务的回滚仅仅对于unchecked的异常有效注解为事务范围的方法中，事务的回滚仅仅对于unchecked的异常有效。对于checked异常无效。也就是说事务回滚仅仅发生在出现RuntimeException或Error的时候。如果希望一般的异常也能触发事务回滚，需要在注解了@Transactional的方法上，将@Transactional回滚参数设为：@Transactional(r...",
    "content": "1、事务的回滚仅仅对于unchecked的异常有效注解为事务范围的方法中，事务的回滚仅仅对于unchecked的异常有效。对于checked异常无效。也就是说事务回滚仅仅发生在出现RuntimeException或Error的时候。如果希望一般的异常也能触发事务回滚，需要在注解了@Transactional的方法上，将@Transactional回滚参数设为：@Transactional(rollbackFor = Exception.class)2、 Service类内部方法调用大概就是Service中有一个方法A，会内部调用方法B， 方法A没有事务管理，方法B采用了声明式事务，通过在方法上声明Transactional的注解来做事务管理。声明式事务是通过AOP动态代理实现的，这样会产生一个代理类来做事务管理，而目标类（service）本身是不能感知代理类的存在的。对于加了@Transactional注解的方法来说，在调用代理类的方法时，会先通过拦截器TransactionInterceptor开启事务，然后在调用目标类的方法，最后在调用结束后，TransactionInterceptor 会提交或回滚事务。在方法A中调用方法B，实际上是通过“this”的引用，也就是直接调用了目标类的方法，而非通过Spring上下文获得的代理类，所以事务是不会开启的。将不同方法放到不同的类中进行调用即可避免此类错误。"
  },
  
  {
    "title": "激活Windows7提示系统保留分区未分配驱动器号",
    "url": "/posts/win7-jihuo-tishi-weifenpei-qudongqihao/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "  鼠标右键点击桌面的“计算机”图标，选择“管理”项  在“计算机管理”窗中，选择“磁盘管理”项，点击打开  找到磁盘大小为“100M”的那个分区  鼠标右键，然后选择“更改驱动器号和路径”，进行驱动器号的设置  然后点击“添加”，选择一个可用的驱动号，比如这里选择“H”即可，然后点击“确定”完成  然后出现添加成功的信息  接下来，点击Windows7“激活”按钮，完成系统的激活即可",
    "content": "  鼠标右键点击桌面的“计算机”图标，选择“管理”项  在“计算机管理”窗中，选择“磁盘管理”项，点击打开  找到磁盘大小为“100M”的那个分区  鼠标右键，然后选择“更改驱动器号和路径”，进行驱动器号的设置  然后点击“添加”，选择一个可用的驱动号，比如这里选择“H”即可，然后点击“确定”完成  然后出现添加成功的信息  接下来，点击Windows7“激活”按钮，完成系统的激活即可"
  },
  
  {
    "title": "CSS实现文字下面波浪线",
    "url": "/posts/geiwenzi-jia-bolangxian/",
    "categories": "Knowledge, CSS",
    "tags": "CSS, Jekyll",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "方法1.使用径向渐变绘制波浪线一个波浪线循环段是有一个朝上的半个圆弧和一个朝下的半个圆弧组合而成的。所以，我们只要使用径向渐变绘制圆弧，再通过background-position控制两个圆弧的位置，让其前后拼接在一起就可以实现波浪线效果。&lt;style type=\"text/css\"&gt;.flow-wave {    background: radial-gradient(circ...",
    "content": "方法1.使用径向渐变绘制波浪线一个波浪线循环段是有一个朝上的半个圆弧和一个朝下的半个圆弧组合而成的。所以，我们只要使用径向渐变绘制圆弧，再通过background-position控制两个圆弧的位置，让其前后拼接在一起就可以实现波浪线效果。&lt;style type=\"text/css\"&gt;.flow-wave {    background: radial-gradient(circle at 10px -7px, transparent 8px, currentColor 8px, currentColor 9px, transparent 9px) repeat-x,        radial-gradient(circle at 10px 27px, transparent 8px, currentColor 8px, currentColor 9px, transparent 9px) repeat-x;    background-size: 20px 20px;    background-position: -10px calc(100% + 16px), 0 calc(100% - 4px);}&lt;/style&gt;&lt;font class=\"flow-wave\"&gt;段落文字&lt;/font&gt;效果：段落文字方法2.使用SVG波形矢量图作为背景&lt;style type=\"text/css\"&gt;.flow-wave {    background: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 4'%3E%3Cpath fill='none' stroke='red' d='M0 3.5c5 0 5-3 10-3s5 3 10 3 5-3 10-3 5 3 10 3'/%3E%3C/svg%3E\") repeat-x 0 100%;     background-size: 20px auto;}&lt;/style&gt;&lt;font class=\"flow-wave\"&gt;段落文字&lt;/font&gt;效果：段落文字  参考：CSS实现文字下面波浪线"
  },
  
  {
    "title": "为什么越学反而越蠢",
    "url": "/posts/20201118/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2020-11-18 13:47:00 +0800",
    





    
    "snippet": "先给你讲个故事，看你有没有中招有一天，你的朋友给你“知识装逼”了一个术语，他推给你一个公众号，你开始关注，觉得哇！大神！长见识！每天刷每天刷每天刷。很多问题也有了解决方法——按照这个进度，过3年就能理解宇宙终极奥义了，慢慢你有了十多个类似的号，承包了你从专业、生活、工作、跑步、减肥、饮食、情感关系……等等所有的领域，有点看不过来的你决定提高效率碎片化学习！利用一切碎片时间，上地铁看一篇，吃饭...",
    "content": "先给你讲个故事，看你有没有中招有一天，你的朋友给你“知识装逼”了一个术语，他推给你一个公众号，你开始关注，觉得哇！大神！长见识！每天刷每天刷每天刷。很多问题也有了解决方法——按照这个进度，过3年就能理解宇宙终极奥义了，慢慢你有了十多个类似的号，承包了你从专业、生活、工作、跑步、减肥、饮食、情感关系……等等所有的领域，有点看不过来的你决定提高效率碎片化学习！利用一切碎片时间，上地铁看一篇，吃饭时看一篇，睡前刷2篇。眼睛看不完，用音频刷，平时看不完，跑步还能刷，但是，还是刷不完！还好有收藏功能，全收藏！这也叫“ 松鼠症 ” —— 不断攒不断攒不断攒……等到收藏超过100篇未读的时候，你终于发现收藏 = 永不再读，这让你沮丧，更让人沮丧的是，你好像距离写文章的大牛越来越远了——在你“学习”的这段时间，这100位大牛好像都更牛逼了一点，而且牛逼的人好像越来越多，观点越来越新，每天都有人用全新的玩法颠覆原来的牛人，—哇，原来这才是对的！别说宇宙奥义了，你对于生活有了深深的怀疑……再好的鸡汤也掩饰不了你日益的郁闷，确实，这个世界LOW的就是刷了无数文章的你你越来越焦虑，终于有一天，你彻底瘫痪了，对自己说，为什么活得这么累？我要做一只猪，一坨肉，一个死尸，你开始转战娱乐、小说和短视频……中招的请举手更加让你想抽自己的是，过了几天你歇过来，你又开始了新一轮的循环，刷刷刷，焦虑症！松鼠症！懒癌！本世纪三大绝症，其实是个死循环为什么会这样？因为，所有的当代人都面临两个问题：信息超载和知识碎片化信息超载老话题不多说了，讲几个数据：全世界每天有4000本书出版，超过4亿个字；纽约时报一天的文字量等于牛顿同时代的人一生的阅读量；一个专业领域，每天大概有200个公众号正在注册，有近1000篇文字正在产生，过去杂家、博物家在现代社会已经不可能存在，即使有，也干不过谷歌度娘。知识的储存能力，人类早就被电脑完胜了，知识的搜索和链接能力，才是学习的核心竞争力。另一个趋势也很明显：知识碎片化。这个碎片化从3个方面开始：1、首先时间和空间被打碎，移动手机允许你在三站地铁里听完一本书；2、其次被打碎的是信息，如果你翻知乎、今日头条或者某个博客，你并不会像看一本书一样，知道前面一章讲什么的，后面即将讲什么，除了标题党，你根本对下一个博客、内容毫无预期，只能被动接受；3、最糟糕的其实是知识结构碎片化，你并不知道是谁，在什么情况下，针对什么问题讲的这句话。所有的信息缺乏了上下文，就是废话。比如说有段时间我刷管理类的文，你会发现在雷军、傅盛、彼得德鲁克、吴伯凡、马云、吴晓波……各位大佬针对同一个问题讲的内容完全不同。到底信哪个？其实雷军讲的是互联网行业；傅盛讲的是小企业逆袭，他正在做投资；彼得德鲁克用管理在讲哲学；吴伯凡老师在讲中西方文化；马云老师在对大众励志；吴晓波其实是用管理谈财经，更重要的是，他们讲话的场合，时间点和对象你一无所知。如果一个人没有搜索能力，他不会知道背景；没有思考能力，不会知道为什么，这样单纯知道一句话，比不知道更糟糕。常年刷微信的人的大脑把前面两个结论放一块，结果很清晰，时间空间碎片化确实能够提高学习的效率（其实也干不过电脑），而信息碎片化和知识结构碎片化带来的，则是学习效率的倒退和焦虑之源，因为他毁掉你的主动搜索能力和主动链接的能力，也就是深度思考的能力，这就是碎片化的陷阱，极大的提高了并没有什么用的信息，而降低了最重要的独立思考的能力。深度思考是件难事，也是件需要时间和空间的事，它远远比迅速点开另一个同样标题很好玩、内容很逗比的标题的文章难得多也长得多，但这个时候，90%的人会选择点开下一个话题，你的浅薄之路也从此开始。这也形成一个上瘾机制，瞬间点开新话题能让你获得“哇我懂了”的廉价快感，但看的信息越多，就见到越多牛人的思想高度，你却无法越无法深度思考。为了抵御这种焦虑，你只好继续打开更多窗口，见证更多顶峰，然后更多焦虑。饮鸩止渴，一直到瘫痪。“我看了本书特好的书！”“是吗是吗说什么的给我讲讲？”“恩……特别好！特别牛！……我讲不出来，给个链接你自己看吧。”是不是这样？所以大部分的人学习，起初是为了解决问题，结果变成了逃避问题。他们越学越焦虑。什么是靠谱的学习方式？观察下那些给你喂知识的专家们怎么做的。他们都挺贼的，专注于一个小领域，以热点为关键词，搜索他们自己专业领域的内容；然后通过新的知识结构表达出来。他们一方面无限度的降低了知识的门槛，其实反而被拉高的是你和他之间的距离。知识创富时代，内容创业时代——无论你怎么说这个领域的弄潮儿，靠的都是这三个能力：在某个专业领域的专注力；与热点、痛点和经典结合的搜索力；以及重新架构的链接能力。  他们知道即使你拿回来一百万个知识的砂砾，也只是沙漠，人们爱看的，是沙子集合成的金字塔，有组织的知识才是核心竞争力。有高度的知识，才有知识压强。在你不断的在沙漠闲逛，他们自己的金字塔盖了起来。怎么办呢？下面是3个把抵御碎片化，让知识“零存整取”的方式：1、学习的起点不是焦虑，而是问题李小龙当年刚回香港，在《欢乐今宵》上节目，节目组请来了一名太极拳拳师，想考验他能不能推到对方。拳师也摆好架子等他来推，结果李小龙一拳打在对方脸上。（此处有人准备直接拉到下面准备开骂，这就是碎片化太厉害，完全不看上下文），李小龙想表达的是，在真实的实战中，没有人会等你摆好架势，只冲着你规定的地方打过来。学习也是一样。在真实生活中，环境和知识都变化太多——你不可能像学校里一样，系统的学好学完一门知识，然后坐在教室等着不超过知识点的考试。大部分时间，生活会先给你一个考试，然后你根据问题，自己找出关键词，开始学习。所以，学习的起点不是某人在朋友圈晒的一本书、推荐的一个微信文、或者这个行业的一个经典教材引发你的焦虑，而应该是你真实遇到的一个问题：      通过不断的思考和对话，一直到能清晰的提出一个明确具体的问题，这时候，已经解决了一半        把问题拆分出关键字，然后开始搜索认知资源        找到你要到资源  2、扩充学习资源——人事网书找学习资源的能力，就是搜索能力。大部分人找资源，第一反应是上网，或买本书。这很容易陷入困境，因为网络是个无底洞，这里翻翻那里看看，一不小心，2天都出不来。要把书里面的内容消化用完至少2周，前提还是你选对了书。信息爆炸时代，最重要的不是增加信息，而是筛选和删除信息。所以其实最好的方式是：      从有经验的人开始，根据你提出的问题，给你清晰的建议、方向和边界        找到行业对标，看看人家是怎么做的        进一步用网络搜索资料和书的总结和评论，最后才是系统的看书  3、721法则：留出足够多的时间练习、思考和讨论行动学习理论认为，人要掌握一门技能，需要有10%的时间学习知识和信息，70%的时间练习和践行，还有20%的时间与人沟通和讨论。这个原则叫做721原则。碎片化学习对于10%的信息接收非常有用，而剩下独处练习的70%和讨论的20%，则需要留出大量时间来系统学习——碎片化学习永远只是系统化学习的辅助。你需要留出足够多整块时间学习。如果能看到这里，顺便说一句——我每周只写一篇不那么好读的干货文，一方面因为我懒，另一方面也因为我并不认为天天刷文能对人有所帮助，每周三晚上，如果能重新思考一个观点，做一点行动和思辨，帮助远远更大。4、输出倒逼输入如何能保证让自己思考有体系？我看过、试过很多方法，最后最有效的只有一个，就是用输出倒逼输入。你可以写文章、讲课、做PPT、做读书笔记、导图……只有一个要求，你的输出有结构。你要先搭好图纸，设计出一个承重结构，然后铺钢筋，最后才放水泥和沙子。先建立一个结构，你的知识和信息量会自动吸附在结构之上。时间一长，你会成为一个能根据结构链接知识的人。很多人会说，我不会写该怎么办？研究新建构主义的王竹立老师有一个观点，把知识零存整取：第一步，叫做积件式写作，就是用ctrlC加ctrlV的方法，先拼出一篇符合逻辑的文字。第二步，进入个性化改写阶段，在第一步的基础上，你可以根据自己的个性化，写出自己的案例，自己的风格，自己的侧重点——现在网络上大部分的写作和讲课都是此类。第三步，创造性重构，在持续的前两步积累下，创造出全新的思路和模型。大部分人的问题，都是看了第二第三步的文章，下结论说自己完全不适合写作，然后放弃。其实每个人都应该动笔从第一步做起，写作不是为了传播，至少为了思考和学习。希望你建立一座自己的金字塔。"
  },
  
  {
    "title": "MyBatis如何传入多个参数",
    "url": "/posts/mybatis-chuanru-duoge-canshu/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2020-11-17 13:47:00 +0800",
    





    
    "snippet": "单个参数javapublic List&lt;Test&gt; getTestList(String id);xml&lt;select id=\"getTestList\" parameterType=\"java.lang.String\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{id}&lt;/se...",
    "content": "单个参数javapublic List&lt;Test&gt; getTestList(String id);xml&lt;select id=\"getTestList\" parameterType=\"java.lang.String\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{id}&lt;/select&gt;多个参数使用索引javapublic List&lt;Test&gt; getTestList(String id, String name);xml&lt;select id=\"getTestList\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{0} and t.name=#{1} &lt;/select&gt;使用Map封装javapublic List&lt;Test&gt; getTestList(HashMap map);xml&lt;select id=\"getTestList\" parameterType=\"hashmap\" resultType=\"com.test.Test\"&gt;　　select t.* from test t where t.id=#{id} and t.name=#{name}    &lt;!-- #{}中的变量名要和map中的key对应 --&gt;&lt;/select&gt;使用注解javapublic List&lt;Test&gt; getTestList(@Param(\"id\") int id, @Param(\"name\") int name);xml&lt;select id=\"getTestList\" resultMap=\"com.test.Test\"&gt;   select t.* from test t where t.id=#{id} and t.name=#{name}&lt;/select&gt;"
  },
  
  {
    "title": "月入10万，难吗？",
    "url": "/posts/20201117/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2020-11-17 13:47:00 +0800",
    





    
    "snippet": "前面说过：赚钱，就是你付出一定的成本，换来一定的回报。归根到底，大家都是出来卖的，无非通过四种方式：  卖信息（中介）  卖钱（投资）  卖他人的注意力（直播）  卖自己的时间（服务）1、卖自己的时间大多数人都靠处在卖自己的时间赚钱这个阶段。没本金、没人脉，只有时间，就只能靠时间来赚钱。也许你学了很多的专业知识，到头来加班加到死，也不过每个月就几千一万的。由于处在这个状态的人太多，竞争太过于...",
    "content": "前面说过：赚钱，就是你付出一定的成本，换来一定的回报。归根到底，大家都是出来卖的，无非通过四种方式：  卖信息（中介）  卖钱（投资）  卖他人的注意力（直播）  卖自己的时间（服务）1、卖自己的时间大多数人都靠处在卖自己的时间赚钱这个阶段。没本金、没人脉，只有时间，就只能靠时间来赚钱。也许你学了很多的专业知识，到头来加班加到死，也不过每个月就几千一万的。由于处在这个状态的人太多，竞争太过于激烈，以至于在面对企业时几乎没什么议价能力，只能任人宰割。少部分聪明一点的人通过学习进修升职的方式来增加自己的劳动效率，增加自己的时间单价，能多赚一点。大部分的人就只能靠加班来增加收入。那些凌晨就出来摆摊的商贩和加班到天亮的职场精英也并没有什么质的区别，收入都和劳动时长挂钩。人一天只有24个小时，意味着靠卖时间赚钱，是有产能上限的。这就是为什么卖时间赚不了大钱的关键。有个笑话是这么说的：王思聪他爸爸给了他5亿，他赚到40亿，翻了8倍！我爸给了我5块，我买了双手套去工地，一天200块，翻了40倍！我们来换算一下，王思聪可能是一年才赚到了40亿，翻了8倍，而你一年搬砖能7万3，足足翻了14600倍。然而这有什么意义呢？王思聪轻轻松松赚了35亿，而你累死累活不过才赚了7万多，零头的零头都不到。而且给王思聪10亿，可能他一年就能赚到80亿，还不需要比原来多付出多少。而给你10块，让你挣14万，大概就得累死在工地上了。想要跳出卖时间的泥潭，关键的关键，是降低劳动边际成本，也就是你不需要付出双倍的工作量，却能获得双倍或者更多的收益。通过卖钱的方式赚钱，就是一种方法。2、卖钱P2P、基金股票、房租、利息，都算是靠钱来赚钱。普通人见过的升值最快的投资应该就算房产了，那收益率可是连P2P都望尘莫及。上个月单价还是1万2，这个月就1万4了，月收益率16.7%，折合成年化，足足有200%！对普通人而言，在这个时代，个人财富增长的主要载体就只有房产增值（当然还有房屋拆迁）。普通白领辛辛苦苦攒了好几年的收入瞬间前功尽弃，赚的再多也追不上资产增值的速度。现在只有极个别的行业(如互联网)，其劳动回报率的增速才有可能高于资本回报率的增速，这其实也可以作为判断一个行业是否是朝阳行业的标尺。香港人把买房叫“上车”，把工薪阶层购置的第一套楼盘叫“上车盘”，其实特别形象——想象一群人跟着汽车跑，只要你能跳上这辆车，你就是在车里坐着躺着，也比外面那些追着跑的人要移动的快。这，就是是靠钱赚钱的魔力。还有一个行业不如房产赚钱这么轻松，但来钱速度也很快，现在也是处在风口，那就是直播。3、卖他人的注意力很多人小时候可能都做过这样的白日梦：“全中国只要每个人给我一块钱我就是亿万富翁了。”现在可能没那么玄乎，但几十万人，平均每个人给你10块钱，你也有几百万了。注意力经济能够达到的规模其实很好计算：假设一个人一天24小时，除了工作8小时睡觉8小时外，还剩8小时，扣掉吃饭逛街，还剩下4小时的纯闲暇时间，那么注意力经济，就是在抢这剩下的4个小时。一个人愿意为闲暇时间支付的开销是固定的，通过简单的计算就能得出平均每分钟的注意力停留时间值多少钱，再乘以关注数，papi酱之类的网络红人就可以开始定价叫售了。 “得屌丝者得天下”，在卖注意力这个行当体现的淋漓尽致，一台电脑一根网线，一年几百万上千万的钱，几乎无本万利，玩的就是群聚效应和屌丝经济。这些新经济的现状有时会让许多传统的，循规蹈矩好好读书上班的人心里不平衡。 就比如说网络直播，一个脸蛋还不错的漂亮姑娘月入十万不是问题，凭的是什么？男屌丝够多，男屌丝手机有支付功能，满足这两点就够了。第一个条件以前一直有，第二个条件最近几年才达成，所以对于这些姑娘来说，尽管没有文凭，甚至也没有进入职场的能力，这个以前自己根本不敢想也想不到的神奇的时代就这样来到了。靠钱赚钱，万一投资失败还可能有一定的财产损失，而靠卖他人注意力赚钱，却几乎不会损失什么。最后一种赚钱方式则既不会有什么损失，也不会太累。4、卖信息信息不对称是白手起家最快的捷径，越不对称，越来钱。古代消息迟滞，商旅靠A地买，B地卖的差价就能赚取巨额财富，这是因为“什么东西在哪里稀缺”的信息是差价的关键，一旦掌握，就站到了价值链的上游。现代有一个常见的例子：房产中介。在很多人心目中那些站在街头，穿着连接西装的房产中介。几乎和“洗剪吹们”是一个档次。但在这些年房价不断上涨的大环境里，北上广深随便一套房子都四五百万，市中心更是千万起跳，中介费即使按1%算也有十多万万。一年成交个几套，就比不少白领挣得多了。要知道2016年前七个月，上海仅二手房就成交了22.8万套。 与此对比，一个新三板公司上板钱的法律审核，律师事务所收费也不过就15万，律师收了钱还要承担法律意见书的责任。而房产中介根本不用负什责任，既不要什么文凭，也不用做太多的事情，甚至现在有很多人是直接上门找中介看房子，连嘴皮子的功夫都省了，十几万中介费就轻松入袋。 当一个人掌握了足够多的信息，撮合行业间的交易，合同谈成后，可以获得不菲的收入，即使谈不成，也不会有什么损失。足够分量的合作只要促成一笔，一年基本就能歇着了。对大多数人而言，只有努力从底层打工干起，做到中高层，掌握大量信息资源后，从做业务切换到做信息掮客，靠撮合行业内的交易来赚钱。或掌握一定的信息后创业，垄断了信息交换节点的人，往往在体系中拥有最大的议价权，什么都不用自己干，光靠指定游戏规则就能赚钱。最后以一个例子收尾吧。一个创业团队10个人，2015年项目分成1000万，头目一个人拿走800万，剩下9个人分200万。活都是手下干的，自己轻轻松松。手下那些人因为处在信息链的下游，所以汤是有的，肉是没有的。"
  },
  
  {
    "title": "访问http://localhost:8080不能显示Tomcat页面",
    "url": "/posts/buneng-xianshi-tomcat-yemian/",
    "categories": "Knowledge, Tomcat",
    "tags": "Tomcat",
    "date": "2020-11-16 13:47:00 +0800",
    





    
    "snippet": "排查  确认Tomcat正常安装  确认环境变量配置无误  确认地址无误：http://localhost:8080/  确认这些都是无误的情况下，还是不能访问，就要进一下Tomcat路径下的webapps文件夹下查看是否有ROOT文件夹，这个是Tomcat默认的web项目原因部署项目出错的话，把webapps目录下文件夹清空了，重新部署，这样就附带的把ROOT文件夹清理掉了，所以就显示不了...",
    "content": "排查  确认Tomcat正常安装  确认环境变量配置无误  确认地址无误：http://localhost:8080/  确认这些都是无误的情况下，还是不能访问，就要进一下Tomcat路径下的webapps文件夹下查看是否有ROOT文件夹，这个是Tomcat默认的web项目原因部署项目出错的话，把webapps目录下文件夹清空了，重新部署，这样就附带的把ROOT文件夹清理掉了，所以就显示不了解决方法重新安装一下，或者找到ROOT文件夹复制过来就能正常访问了"
  },
  
  {
    "title": "SVN客户端如何修改登陆账号",
    "url": "/posts/svn-kehuduan-xiugai-denglu-zhanghao/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2020-11-16 13:47:00 +0800",
    





    
    "snippet": "首先找到一个空白地方.右键单击,找到如图的菜单(例如桌面)进入svn的设置界面出现清除框.选择你要清除的.确定即可. 下次你再用svn提交代码的时候.就会提示你输入用户名和密码了",
    "content": "首先找到一个空白地方.右键单击,找到如图的菜单(例如桌面)进入svn的设置界面出现清除框.选择你要清除的.确定即可. 下次你再用svn提交代码的时候.就会提示你输入用户名和密码了"
  },
  
  {
    "title": "SVN插件如何修改登录账号",
    "url": "/posts/svn-chajian-xiugai-denglu-zhanghao/",
    "categories": "Knowledge, SVN",
    "tags": "SVN",
    "date": "2020-11-16 13:47:00 +0800",
    





    
    "snippet": "打开Window菜单栏中的Perference，打开Eclipse配置，搜索框输入svn，然后点击SVN，找到下方SVN接口，查看下svn是什么类型的接口，如果是JavaHL打开我的电脑\\系统安装盘\\用户 打开之后，在搜索栏里面输入auth 找到这个文件夹之后打开，然后删除这个文件夹里面的文件，重启Eclipse，使用svn的时候就会要求重新输入账号密码了Eclipse的svn类型一般为Ja...",
    "content": "打开Window菜单栏中的Perference，打开Eclipse配置，搜索框输入svn，然后点击SVN，找到下方SVN接口，查看下svn是什么类型的接口，如果是JavaHL打开我的电脑\\系统安装盘\\用户 打开之后，在搜索栏里面输入auth 找到这个文件夹之后打开，然后删除这个文件夹里面的文件，重启Eclipse，使用svn的时候就会要求重新输入账号密码了Eclipse的svn类型一般为JavaHL类型，路径在C:\\Users\\Administrator\\AppData\\Roaming\\Subversion\\auth，要是实在找不到可以全局搜索在C盘如果svn的接口类型是SVNKit，则删除eclipse\\configuration\\org.eclipse.core.runtime下的文件"
  },
  
  {
    "title": "Oracle 使用SQL语句对索引的操作",
    "url": "/posts/oracle-chuangjian-suoyin/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-11-15 13:47:00 +0800",
    





    
    "snippet": "创建索引-- 创建索引create index index_name on table_name(column_name) ;-- 创建联合索引create index index_name on table_name(column_name1, column_name2) ;使用索引-- 使用索引select * from table_name where column_name = 1;",
    "content": "创建索引-- 创建索引create index index_name on table_name(column_name) ;-- 创建联合索引create index index_name on table_name(column_name1, column_name2) ;使用索引-- 使用索引select * from table_name where column_name = 1;"
  },
  
  {
    "title": "使用Ajax方式实现form表单的提交",
    "url": "/posts/ajax-shixian-form-biaodan-tijiao/",
    "categories": "Knowledge, Ajax",
    "tags": "Ajax",
    "date": "2020-11-15 13:47:00 +0800",
    





    
    "snippet": "在使用form表单的时候,一旦点击提交触发submit事件，一般会使得页面跳转，页面间的跳转等行为的控制权往往在后端，后端会控制页面的跳转及数据传递，但是在某些时候不希望页面跳转，或者说想要将控制权放在前端，通过js来操作页面的跳转或者数据变化。一般这种异步的操作，我们都会想到Ajax方式，因此在实现了功能后就整理了这篇文章，通过Ajax方式实现form表单的提交并进行后续的异步操作。常见的...",
    "content": "在使用form表单的时候,一旦点击提交触发submit事件，一般会使得页面跳转，页面间的跳转等行为的控制权往往在后端，后端会控制页面的跳转及数据传递，但是在某些时候不希望页面跳转，或者说想要将控制权放在前端，通过js来操作页面的跳转或者数据变化。一般这种异步的操作，我们都会想到Ajax方式，因此在实现了功能后就整理了这篇文章，通过Ajax方式实现form表单的提交并进行后续的异步操作。常见的form表单提交方式&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;login test&lt;/title&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"expires\" content=\"0\"&gt;        &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;        &lt;meta http-equiv=\"description\" content=\"login test\"&gt;       &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"form-div\"&gt;            &lt;form id=\"form1\" action=\"/users/login\" method=\"post\"&gt;                &lt;p&gt;用户名：&lt;input name=\"userName\" type=\"text\" id=\"txtUserName\" tabindex=\"1\" size=\"15\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;密　码：&lt;input name=\"password\" type=\"password\" id=\"TextBox2\" tabindex=\"2\" size=\"16\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&amp;nbsp&lt;input type=\"reset\" value=\"重置\"&gt;&lt;/p&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;Ajax实现form提交方式&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;login test&lt;/title&gt;        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;        &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt;        &lt;meta http-equiv=\"expires\" content=\"0\"&gt;        &lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt;        &lt;meta http-equiv=\"description\" content=\"ajax方式\"&gt;        &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt;        &lt;script type=\"text/javascript\"&gt;            function login() {                $.ajax({                    //几个参数需要注意一下                    type: \"POST\",//方法类型                    dataType: \"json\",//预期服务器返回的数据类型                    url: \"/users/login\" ,//url                    data: $('#form1').serialize(),                    success: function (result) {                        console.log(result);//打印服务端返回的数据(调试用)                        if (result.resultCode == 200) {                            alert(\"SUCCESS\");                        };                    },                    error : function() {                        alert(\"异常！\");                    }                });            }        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=\"form-div\"&gt;            &lt;form id=\"form1\" onsubmit=\"return false\" action=\"##\" method=\"post\"&gt;                &lt;p&gt;用户名：&lt;input name=\"userName\" type=\"text\" id=\"txtUserName\" tabindex=\"1\" size=\"15\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;密　码：&lt;input name=\"password\" type=\"password\" id=\"TextBox2\" tabindex=\"2\" size=\"16\" value=\"\"/&gt;&lt;/p&gt;                &lt;p&gt;&lt;input type=\"button\" value=\"登录\" onclick=\"login()\"&gt;&amp;nbsp;&lt;input type=\"reset\" value=\"重置\"&gt;&lt;/p&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "Oracle 如何查询CLOB字段的值",
    "url": "/posts/chaxun-clob-ziduan/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-11-12 13:47:00 +0800",
    





    
    "snippet": "select dbms_lob.substr(column) from table_name;select to_char(column) from table_name;错误发生场景在对视图中的CLOB进行TO_CHAR处理后，在CLOB字段录入字段信息小于4000字符时，查询正常，但当录入字符大于4000字符时，就会发生错误。错误提示：ORA-22835:缓冲区对于CLOB到CHAR转换...",
    "content": "select dbms_lob.substr(column) from table_name;select to_char(column) from table_name;错误发生场景在对视图中的CLOB进行TO_CHAR处理后，在CLOB字段录入字段信息小于4000字符时，查询正常，但当录入字符大于4000字符时，就会发生错误。错误提示：ORA-22835:缓冲区对于CLOB到CHAR转换或BLOB到RAWZ转换而言太小。原因分析在对CLOB进行的TO_CHAR处理，可以理解为将CLOB中存储的信息转换成VARCHAR2，然后再进行展现，对于VARCHAR2来言，最多存储4000个字符，当超出4000字符时，就报错了。错误的大致意思就是超出了VARCHAR2的缓冲大小。解决方案对CLOB字段进行截取，使其在TO_CHAR之前获取的数据小于4000字符，这样在进行TO_CHAR时就不会报错了。截取SQLSUBSTR(column, 1, 4000);需要注意一点，如果是大字段中存在汉字，则需要将汉字所占字节数考虑进入，如一个汉字占2个字节，实际截取字节数为2000。SUBSTR(column, 1, 2000);对CLOB大字段处理的完整SQL如下：TO_CHAR( SUBSTR(column, 1, 2000)) as column;查询SQLselect dbms_lob.substr(column, 4000) from table_name;select TO_CHAR(SUBSTR(column, 1, 2000)) from table_name;  参考：Oracle查询显示CLOB的内容"
  },
  
  {
    "title": "NPM命令",
    "url": "/posts/npm-mingling/",
    "categories": "Knowledge, NodeJS",
    "tags": "NodeJS",
    "date": "2020-11-12 13:47:00 +0800",
    





    
    "snippet": "NPM是随同NodeJS一起安装的包管理工具,能解决NodeJS代码部署上的很多问题，常用的命令有：  清除缓存    npm cache clean --force        显示配置列表    npm config list        淘宝镜像的安装    npm config set registry https://registry.npm.taobao.org --glob...",
    "content": "NPM是随同NodeJS一起安装的包管理工具,能解决NodeJS代码部署上的很多问题，常用的命令有：  清除缓存    npm cache clean --force        显示配置列表    npm config list        淘宝镜像的安装    npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global         淘宝镜像的卸载    npm config set disturl https://npm.taobao.org/dist      "
  },
  
  {
    "title": "Windows非服务模式下如何启动和关闭MySQL数据库",
    "url": "/posts/feifuwu-moshi-xia-qidong-he-guanbi-mysql/",
    "categories": "Knowledge, MySQL",
    "tags": "MySQL",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "启动mysqld --standalone关闭mysqladmin -uroot -proot shutdown",
    "content": "启动mysqld --standalone关闭mysqladmin -uroot -proot shutdown"
  },
  
  {
    "title": "< c:forEach>遍历list数组时怎么取出元素下标",
    "url": "/posts/qu-shuzu-xiabiao/",
    "categories": "Knowledge, JSTL",
    "tags": "JSTL",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "&lt;c:forEach var=\"o\" items=\"${orders }\" varStatus=\"st\"&gt;当前迭代的元素：${o.ord_code} 当前迭代的元素：${st.current.ord_code}当前迭代的索引：${st.index} 迭代计数：${st.count}是否是第一次迭代：${st.first} 是否是最后次迭代：${st.last} 示例&lt;c:f...",
    "content": "&lt;c:forEach var=\"o\" items=\"${orders }\" varStatus=\"st\"&gt;当前迭代的元素：${o.ord_code} 当前迭代的元素：${st.current.ord_code}当前迭代的索引：${st.index} 迭代计数：${st.count}是否是第一次迭代：${st.first} 是否是最后次迭代：${st.last} 示例&lt;c:forEach var=\"cost\" items=\"${otherCost}\" varStatus=\"st\"&gt;     &lt;c:if test=\"${!st.last}\"&gt;        &lt;td&gt;${cost}&lt;/td&gt;    &lt;/c:if&gt;    &lt;c:if test=\"${st.last}\"&gt;        &lt;td style=\"border-right: 0px;\"&gt;${cost}&lt;/td&gt;    &lt;/c:if&gt;&lt;/c:forEach&gt; "
  },
  
  {
    "title": "< c:forEach>如何终止循环",
    "url": "/posts/jstl-de-tiaojian-panduan/",
    "categories": "Knowledge, JSTL",
    "tags": "JSTL",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "&lt;c:set var=\"exitId\" value=\"0\"/&gt;&lt;c:forEach items=\"${opinions }\" var=\"map\" varStatus=\"status\"&gt;    &lt;c:if test=\"${exitId eq '0'}\"&gt;&lt;!--for循环里面的操作都写在c:if中--&gt;        &lt;td&gt;在循环&...",
    "content": "&lt;c:set var=\"exitId\" value=\"0\"/&gt;&lt;c:forEach items=\"${opinions }\" var=\"map\" varStatus=\"status\"&gt;    &lt;c:if test=\"${exitId eq '0'}\"&gt;&lt;!--for循环里面的操作都写在c:if中--&gt;        &lt;td&gt;在循环&lt;/td&gt;        &lt;!--如果下标等于5则不会循环出td--&gt;        &lt;c:if test=\"${status.index eq '5'}\"&gt;            &lt;c:set var=\"exitId\" value=\"1\"/&gt;        &lt;/c:if&gt;    &lt;/c:if&gt;&lt;/c:forEach&gt;"
  },
  
  {
    "title": "JQuery的正则匹配",
    "url": "/posts/jquery-de-zhengze-pipei/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "[属性名称] 匹配包含给定属性的元素[att=value] 匹配包含给定属性的元素 (大小写区分)[att*=value] 模糊匹配[att!=value] 不能是这个值[att$=value] 结尾是这个值[att^=value] 开头是这个值[att1][att2][att3]... 匹配多个属性条件中的一个例：JQuery获取class=”abc”的input值$('input[cla...",
    "content": "[属性名称] 匹配包含给定属性的元素[att=value] 匹配包含给定属性的元素 (大小写区分)[att*=value] 模糊匹配[att!=value] 不能是这个值[att$=value] 结尾是这个值[att^=value] 开头是这个值[att1][att2][att3]... 匹配多个属性条件中的一个例：JQuery获取class=”abc”的input值$('input[class=\"abc\"]').val();"
  },
  
  {
    "title": "Ajax案例",
    "url": "/posts/ajax-anli/",
    "categories": "Knowledge, Ajax",
    "tags": "Ajax",
    "date": "2020-11-11 13:47:00 +0800",
    





    
    "snippet": "function queryPasswordById(pass_id) {    var params = {        pass_id : pass_id    };    var param = JSON.stringify(params);    // 加密    // var requestJson1 = btoa(encodeURIComponent(param));    $...",
    "content": "function queryPasswordById(pass_id) {    var params = {        pass_id : pass_id    };    var param = JSON.stringify(params);    // 加密    // var requestJson1 = btoa(encodeURIComponent(param));    $.ajax({        url : \"password/queryPasswordById\",        type : \"post\",        dataType : \"json\",         data : {            requestJson : param        },        async : false,        success : function(data) {            // dataType已为json格式，转换报错：missing ] after element list            // var res = eval(\"(\" + data + \")\");            window.location.href = data; // 跳转，data为后台返回的ModelAndView        }    });}$.ajax ({    type : \"get\",    url : \"checkFile.do?attachId=\" + attachId,    async:false,    success: function(data) {        flag = data;    }});"
  },
  
  {
    "title": "Windows7刷新环境变量的方法",
    "url": "/posts/win7-shuaxin-huanjingbianliang/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中增加或修改环境变量后，需重启系统才能使之生效。有没有什么方法可让它即时生效呢？ 下面介绍一种方法：  　　  以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：set PATH=C:，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，可以发现“我的电脑”-&gt;“属性”-&gt...",
    "content": "在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中增加或修改环境变量后，需重启系统才能使之生效。有没有什么方法可让它即时生效呢？ 下面介绍一种方法：  　　  以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：set PATH=C:，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的PATH值已经生效。  　　不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的。"
  },
  
  {
    "title": "Windows10安装陷入无限循环",
    "url": "/posts/win10-anzhuang-xianru-wuxian-xunhuan/",
    "categories": "Knowledge, SYSTEM",
    "tags": "SYSTEM",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "故障描述当你安装Windows10到了系统初始化设置界面时，电脑会一遍又一遍地让你进行相同的设置解决方案1、按Ctrl + Shift + F3跳过OOBE（Out-of-box experience）直接进入系统2、进入系统的过程中，会弹出一个错误窗口，上面写着：应用程序无法正常启动0xc00001423、点击确定，之后应该会出现一个系统准备工具，不用管它4、进去之后你就会发现，这是一个残...",
    "content": "故障描述当你安装Windows10到了系统初始化设置界面时，电脑会一遍又一遍地让你进行相同的设置解决方案1、按Ctrl + Shift + F3跳过OOBE（Out-of-box experience）直接进入系统2、进入系统的过程中，会弹出一个错误窗口，上面写着：应用程序无法正常启动0xc00001423、点击确定，之后应该会出现一个系统准备工具，不用管它4、进去之后你就会发现，这是一个残废的系统5、打开“命令提示符”窗口输入字符串命令sfc/scannow回车，之后就是耐心等待命令程序对每个系统文件搜索扫描，然后修复6、上面这些完成后，重启电脑就可以了名称解释：OOBE开箱体验（OOBE）是在安装完Windows后就会进行的一个步骤，在这个步骤，用户需要对Windows进行一些基本设置。"
  },
  
  {
    "title": "Outlook邮箱启动时提示找不到Outlook.pst文件",
    "url": "/posts/outlook-youxiang-qidong-baocun/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "什么是pst文件pst文件是outlook的数据文件，包括邮箱账号的所有信息，比如：收到的邮件，发出的邮件，联系人信息等等。pst文件找不到的主要原因是pst文件被删除，文件路径被修改，或者被移动到其他地方。解决方法1、打开“命令提示符”窗口，使用cd命令切换到“Outlook.exe”所在安装目录2、输入命令outlook /importprf ..prf初始化Outlook数据文件3、初...",
    "content": "什么是pst文件pst文件是outlook的数据文件，包括邮箱账号的所有信息，比如：收到的邮件，发出的邮件，联系人信息等等。pst文件找不到的主要原因是pst文件被删除，文件路径被修改，或者被移动到其他地方。解决方法1、打开“命令提示符”窗口，使用cd命令切换到“Outlook.exe”所在安装目录2、输入命令outlook /importprf ..prf初始化Outlook数据文件3、初始化完成后即可进入outlook邮箱"
  },
  
  {
    "title": "Google Play Store显示“从服务器检索信息时出错，DF-DFERH-01”",
    "url": "/posts/google-play-store-DF-DFERH-01/",
    "categories": "Knowledge, SOFTWARE",
    "tags": "SOFTWARE",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "原因是软件要请求的services.googleapis.cn域名被解析到了国内。解决思路就是将该域名解析到国外即可，若是采用代理软件，设置为全局代理。",
    "content": "原因是软件要请求的services.googleapis.cn域名被解析到了国内。解决思路就是将该域名解析到国外即可，若是采用代理软件，设置为全局代理。"
  },
  
  {
    "title": "Eclipse常用快捷键",
    "url": "/posts/eclipse-changyong-kuaijiejian/",
    "categories": "Knowledge, Eclipse",
    "tags": "Eclipse",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "Ctrl + Alt + H       查看一个类的方法被哪些其他的类调用Ctrl + Shift + l     快捷键提示  Ctrl + Shift + R     搜索 Ctrl + 2 + l         自动生成变量名声明(按方法返回值为本地变量赋值），注：Ctrl和2同时按完以后释放，再按l",
    "content": "Ctrl + Alt + H       查看一个类的方法被哪些其他的类调用Ctrl + Shift + l     快捷键提示  Ctrl + Shift + R     搜索 Ctrl + 2 + l         自动生成变量名声明(按方法返回值为本地变量赋值），注：Ctrl和2同时按完以后释放，再按l"
  },
  
  {
    "title": "透过上层div点击下层的元素",
    "url": "/posts/touguo-shangceng-div-dianji-xiaceng/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "pointer-events: none;",
    "content": "pointer-events: none;"
  },
  
  {
    "title": "鼠标指针变成禁止点击的样式",
    "url": "/posts/shubiao-zhizhen-biancheng-jinzhi-dianji/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "/* 是一个红色的圈加一个斜杠，表示禁止的意思 */cursor:no-drop cursor:not-allowed ",
    "content": "/* 是一个红色的圈加一个斜杠，表示禁止的意思 */cursor:no-drop cursor:not-allowed "
  },
  
  {
    "title": "Bootstrap悬浮窗口(popover)",
    "url": "/posts/bootstrap-xuanfuchuang/",
    "categories": "Knowledge, Bootstrap",
    "tags": "Bootstrap",
    "date": "2020-11-10 13:47:00 +0800",
    





    
    "snippet": "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;悬浮窗口&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /&gt;    &lt;!--JavaScript...",
    "content": "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;悬浮窗口&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /&gt;    &lt;!--JavaScript插件都是依赖jQuery库--&gt;    &lt;script type=\"text/javascript\" src=\"js/jquery-3.2.1.min.js\"&gt;&lt;/script&gt;    &lt;script type=\"text/javascript\" src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=\"#\" id=\"abc\" class=\"btn btn-lg btn-danger\" data-toggle=\"popover\"&gt;xxxxxx&lt;/a&gt;    &lt;script&gt;        $(function () {            $(\"[data-toggle='popover']\").each(function () {                var element = $(this);                element.popover({                    trigger: 'manual',                    html: true,                    title: 'kkkk',                    placement: 'bottom',                    content: function () {                        return content();                    }                }).on(\"mouseenter\", function () {                    $(this).popover(\"show\");                }).on(\"mouseleave\", function () {                    $(_this).popover(\"hide\")                });            });        });        //模拟动态加载内容(真实情况可能会跟后台进行ajax交互)          function content() {            var data = $(\"&lt;form&gt;&lt;ul&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;粉丝数:&lt;/font&gt;7389223&lt;/li&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;关注:&lt;/font&gt;265&lt;/li&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;微博:&lt;/font&gt;645&lt;/li&gt;\"                + \"&lt;li&gt;&lt;span aria-hidden='true'&gt;&lt;/span&gt;&amp;nbsp;&lt;font&gt;所在地:&lt;/font&gt;台湾&lt;/li&gt;\"                + \"&lt;input id='btn' type='button' value='关注' onclick='test()'/&gt;&lt;/form&gt;\");            return data;        }        //模拟悬浮框里面的按钮点击操作          function test() {            alert('关注成功');        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
  },
  
  {
    "title": "对String进行强制转码",
    "url": "/posts/dui-string-jinxing-qiangzhi-zhuanma/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-11-10 11:47:00 +0800",
    





    
    "snippet": "String test = new String(object.getTest().getBytes(\"ISO-8859-1\"), \"UTF-8\");",
    "content": "String test = new String(object.getTest().getBytes(\"ISO-8859-1\"), \"UTF-8\");"
  },
  
  {
    "title": "SQl格式化工具",
    "url": "/posts/sql-geshihua-gongju/",
    "categories": "Tools",
    "tags": "Tools",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "    SQL-Format                                                                                                                                                                                       ...",
    "content": "    SQL-Format                                                                                                                                                                                                                                                                                                                                                                                                 Format&nbsp;&nbsp;\t\t\t\t\t\t\t\t\t\tCopy&nbsp;&nbsp;\t\t\t\t\t\t\t\t\t\tClear                                                                                                                                                                                                                                                                                                                                                                                                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                                                                                                            "
  },
  
  {
    "title": "Java线程的生命周期",
    "url": "/posts/xiancheng-de-shengming-zhouqi/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "Java线程的生命周期",
    "content": "Java线程的生命周期"
  },
  
  {
    "title": "获取客户端的IP地址",
    "url": "/posts/huoqu-kehuduan-ip/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "public String getIpAddr(HttpServletRequest request) {    String ip = \"\";    try {        ip = request.getHeader(\"x-forwarded-for\");        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgno...",
    "content": "public String getIpAddr(HttpServletRequest request) {    String ip = \"\";    try {        ip = request.getHeader(\"x-forwarded-for\");        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {            ip = request.getHeader(\"Proxy-Client-IP\");        }        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {            ip = request.getHeader(\"WL-Proxy-Client-IP\");        }        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {            ip = request.getRemoteAddr();        }    } catch (Exception e) {        e.printStackTrace();        ip = \"\";    }    return ip;}"
  },
  
  {
    "title": "使用gitbook serve命令报错",
    "url": "/posts/gitbook-bao-cuo/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "错误信息在使用gitbook serve启动服务时报错：Error: ENOENT: no such file or directory, stat ‘C:***demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’  原因这一个Bug（Vesion：3.2.3）https://github.com/Gitboo...",
    "content": "错误信息在使用gitbook serve启动服务时报错：Error: ENOENT: no such file or directory, stat ‘C:***demo_book_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js’  原因这一个Bug（Vesion：3.2.3）https://github.com/GitbookIO/gitbook/issues/1309解决办法用户目录下找到以下文件.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js替换 confirm: true 为 confirm: false"
  },
  
  {
    "title": "GitBook安装",
    "url": "/posts/gitbook-anzhuang/",
    "categories": "Knowledge, GitBook",
    "tags": "GitBook",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "1.搭建Nodejs环境前往Node.js官网下载最新版Nodejs windows系统安装包安装成功后再cmd窗体中输入node -v查看是否安装成功2.安装GitBook可视化编写工具  GitBook Editor Windows版  Visual Studio Code下载Markdown All in One插件  Typora3.安装GitBook在任意目录下运行cmd控制台 输...",
    "content": "1.搭建Nodejs环境前往Node.js官网下载最新版Nodejs windows系统安装包安装成功后再cmd窗体中输入node -v查看是否安装成功2.安装GitBook可视化编写工具  GitBook Editor Windows版  Visual Studio Code下载Markdown All in One插件  Typora3.安装GitBook在任意目录下运行cmd控制台 输入:npm install gitbook-cli -g进行安装4.开始使用GitBookrem 初始化gitBookgitbook initrem 下载gitBook插件 gitbook installrem 发布gitBookgitbook serverem 编译gitBookgitbook build"
  },
  
  {
    "title": "界面动效设计",
    "url": "/posts/jiemian_dongxiao_sheji/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "趣味交互动效趣味音量调节动效  by.ALEX BENDER点赞按钮动效  by.Aaron Iker趣味捐赠按钮动画  by.Aaron IkerBUTTON V2  by.Aaron Iker项目管理APP完成动效  by.Leonid Arestov一组可爱的标签栏交互动效  by.Dimest压缩文件动画  by.Aaron IkerAR拍照应用标签栏交互设计  by.Oleg Fr...",
    "content": "趣味交互动效趣味音量调节动效  by.ALEX BENDER点赞按钮动效  by.Aaron Iker趣味捐赠按钮动画  by.Aaron IkerBUTTON V2  by.Aaron Iker项目管理APP完成动效  by.Leonid Arestov一组可爱的标签栏交互动效  by.Dimest压缩文件动画  by.Aaron IkerAR拍照应用标签栏交互设计  by.Oleg Frolov创意举重提交按钮  by.Aaron IkerFILTER UX  by.Yurii家居装修应用动效设计  by.YanBin Tan引导页3D动画  by Minh Pham ✪响应式HTML设计  by.Anton Tkachevwelovedail网站的趣味交互动画  by Dennis Snellenberg智能银行app动效设计  by.Jakub Kośla3D风格引导页设计  by.Ramotion交付执行小动效  by.Saptarshi Prakash3D网页动画设计  by.Barthelemy Chalvet"
  },
  
  {
    "title": "App界面设计欣赏",
    "url": "/posts/app-sheji-xinshang/",
    "categories": "Design, Mutual",
    "tags": "Mutual",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "布里萨戈群岛旅游LOGO",
    "url": "/posts/bu-li-sa-ge-qun-dao/",
    "categories": "Design, Logo",
    "tags": "Logo",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "布里萨戈群岛（Isole di Brissago）位于瑞士南部的马焦雷湖，靠近瑞士城镇布里萨戈，是一组由两个岛屿组成的小岛，较大的岛屿（圣潘克拉齐奥）占地25568平方米，较小的岛屿（圣阿波利奈尔）占地8186平方米。其中大岛上有著名的植物园，它由安托瓦内特·圣莱热男爵夫人于1885年创建，园内拥有超过2000多种亚热带植物，具有重要的科学研究价值，吸引了大批专家和植物爱好者前往参观。今年3...",
    "content": "布里萨戈群岛（Isole di Brissago）位于瑞士南部的马焦雷湖，靠近瑞士城镇布里萨戈，是一组由两个岛屿组成的小岛，较大的岛屿（圣潘克拉齐奥）占地25568平方米，较小的岛屿（圣阿波利奈尔）占地8186平方米。其中大岛上有著名的植物园，它由安托瓦内特·圣莱热男爵夫人于1885年创建，园内拥有超过2000多种亚热带植物，具有重要的科学研究价值，吸引了大批专家和植物爱好者前往参观。今年3月份，受到疫情的影响，布里萨戈群岛临时关闭了旅游入口。上周，该岛屿宣布将重新向公众开放。与此同时，布里萨戈群岛还重新设计了旅游LOGO来宣传群岛的旅游文化。由于群岛最显著的特点是由两个小岛组成，所以在LOGO的设计上将两个岛屿抽象化，变为一大一小两个圆点。大的绿色圆点●为圣潘克拉齐奥岛，右下角的小圆点•则代表了圣阿波利奈尔岛。重新开放后，新LOGO也将正式和旅客见面。据悉，在关闭岛屿期间，岛屿的管理机构与设计公司合作完成了新形象的设计，包括员工制服，旅游指导手册，纪念品等周边产品的开发和设计。"
  },
  
  {
    "title": "博客系统 Halo",
    "url": "/posts/halo/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "Halo是一款使用 Spring Boot 框架搭建的现代化的个人开源博客系统。该系统具有完备的 Markdown 编辑器以及文章、页面系统，包含分类/标签/预览图，附件管理，评论系统，主题系统，系统设置等功能。提供的功能halo 博客主站，用来展示我们发布的博客及其他我们编辑的内容。后台管理（halo-admin），用来管理维护我们的博客。评论插件（halo-comment），用来给我们的...",
    "content": "Halo是一款使用 Spring Boot 框架搭建的现代化的个人开源博客系统。该系统具有完备的 Markdown 编辑器以及文章、页面系统，包含分类/标签/预览图，附件管理，评论系统，主题系统，系统设置等功能。提供的功能halo 博客主站，用来展示我们发布的博客及其他我们编辑的内容。后台管理（halo-admin），用来管理维护我们的博客。评论插件（halo-comment），用来给我们的博客添加评论模块。主题库（halo-theme-* ），提供众多博客主题模版。预览链接官网：https://halo.run/Github：https://github.com/halo-dev/halo"
  },
  
  {
    "title": "静态博客写作客户端 Gridea",
    "url": "/posts/gridea/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "当下大多数人可能已经对 Github Pages 不再陌生，他是很多喜欢写文章的人第一次接触的用于免费搭建 Blog 的工具，使用 Github Pages 你能很快速的构建一个简洁却又不失优雅的个人 Blog ，直到现在互联网上还有大量的基于 Github Pages 的个人博客和搭建方法的教程。然而搭建虽然简单，但是管理和上传文章却相对麻烦不少，官方的教程里，你需要经历繁琐的 Git 步...",
    "content": "当下大多数人可能已经对 Github Pages 不再陌生，他是很多喜欢写文章的人第一次接触的用于免费搭建 Blog 的工具，使用 Github Pages 你能很快速的构建一个简洁却又不失优雅的个人 Blog ，直到现在互联网上还有大量的基于 Github Pages 的个人博客和搭建方法的教程。然而搭建虽然简单，但是管理和上传文章却相对麻烦不少，官方的教程里，你需要经历繁琐的 Git 步骤才能发布一篇文章和修改你的个人空间界面。对于那些想更便捷和优雅的操作 Github Pages 写作者来说，我郑重推荐这款工具 Gridea。Gridea提供Mac 、Windows 、Linux 多个版本下载，目前最新版本是v0.9.2。Gridea内置了丰富的主题，可以满足大部分写作者的需求。同时，也提供了主题市场，更多优秀的主题可以选择。Gridea特性  你可以使用最酷的 Markdown 语法，进行快速创作  你可以给文章配上精美的封面图和在文章任意位置插入图片  你可以对文章进行标签分组  你可以自定义菜单，甚至可以创建外部链接菜单  你可以在 或 或 Linux 设备上使用此客户端  你可以使用 或 Coding Pages 向世界展示，未来将支持更多平台  你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统  你可以使用中文简体、中文繁体、英语  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步链接官网：https://gridea.dev/主题：https://gridea.dev/themes/"
  },
  
  {
    "title": "后台管理系统 Dcat Admin",
    "url": "/posts/dcat-admin/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "Dcat Admin是一个基于laravel-admin二次开发而成的后台系统构建工具，只需很少的代码即可快速构建出一个功能完善的高颜值后台系统。内置丰富的后台常用组件，开箱即用，让开发者告别冗杂的HTML代码，对后端开发者非常友好。更新内容Dcat Admin v1.2.0已发布，更新内容如下：功能新增及优化部分  集成editor-md作为内置markdown编辑器，并支持图片上传功能 ...",
    "content": "Dcat Admin是一个基于laravel-admin二次开发而成的后台系统构建工具，只需很少的代码即可快速构建出一个功能完善的高颜值后台系统。内置丰富的后台常用组件，开箱即用，让开发者告别冗杂的HTML代码，对后端开发者非常友好。更新内容Dcat Admin v1.2.0已发布，更新内容如下：功能新增及优化部分  集成editor-md作为内置markdown编辑器，并支持图片上传功能  表格过滤搜索增加panel布局方式  优化数据表格边框模式  工具表单增加buildSuccessScript方法  数据表格表头过滤器重置按钮优化  通过Form::action法设置url时自动拼接路由前缀  按钮样式优化  菜单配色及导航栏样式优化  快速创建功能样式优化  登陆页面优化  进度条样式优化  默认禁用滚动条插件  增加action以及form生成命令对非app目录的支持Bug修复部分  修复数据表格checkbox显示类型不兼容非数组字段值问题  修复登陆页面不兼容Laravel5.5问题"
  },
  
  {
    "title": "密码管理软件 Bitwarden",
    "url": "/posts/bitwarden/",
    "categories": "Collection, Storage",
    "tags": "Storage",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "特性  提供免费和付费选择  适用于团队（企业）和个人  开源  支持自托管  能够作为身份验证器应用（如 Google 身份验证器）  跨平台支持（安卓、iOS、Linux、Windows 和 macOS）  提供浏览器扩展（Firefox,、Chrome、Opera、Edge、Safari）  提供命令行工具  提供网页保管库  能够导入/导出密码  密码生成器  自动填充密码  两步身...",
    "content": "特性  提供免费和付费选择  适用于团队（企业）和个人  开源  支持自托管  能够作为身份验证器应用（如 Google 身份验证器）  跨平台支持（安卓、iOS、Linux、Windows 和 macOS）  提供浏览器扩展（Firefox,、Chrome、Opera、Edge、Safari）  提供命令行工具  提供网页保管库  能够导入/导出密码  密码生成器  自动填充密码  两步身份验证下载地址https://bitwarden.com/"
  },
  
  {
    "title": "去哪儿网机票搜索系统的高并发架构设计",
    "url": "/posts/20201028/",
    "categories": "Collection, Reading",
    "tags": "Reading",
    "date": "2020-10-27 13:47:00 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "生成随机id",
    "url": "/posts/shengcheng-suiji-id/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:23:00 +0800",
    





    
    "snippet": "// 需要引入import java.util.UUID包public static String getUUID() {   UUID uuid = UUID.randomUUID();   String str = uuid.toString();   String uuidStr = str.replace(\"-\", \"\");   return uuidStr;}",
    "content": "// 需要引入import java.util.UUID包public static String getUUID() {   UUID uuid = UUID.randomUUID();   String str = uuid.toString();   String uuidStr = str.replace(\"-\", \"\");   return uuidStr;}"
  },
  
  {
    "title": "HTML元素禁用的方法",
    "url": "/posts/html-jinyong-yuansu/",
    "categories": "Knowledge, HTML",
    "tags": "HTML",
    "date": "2020-10-27 13:23:00 +0800",
    





    
    "snippet": "禁用radio，设置为只读，不能选定&lt;input type=\"radio\" name=\"gender\" value=\"1\" disabled/&gt;&lt;span &gt;男&lt;/span&gt;&lt;input type=\"radio\" name=\"gender\" value=\"0\" disabled/&gt;&lt;span &gt;女&lt;/span&gt; 禁用in...",
    "content": "禁用radio，设置为只读，不能选定&lt;input type=\"radio\" name=\"gender\" value=\"1\" disabled/&gt;&lt;span &gt;男&lt;/span&gt;&lt;input type=\"radio\" name=\"gender\" value=\"0\" disabled/&gt;&lt;span &gt;女&lt;/span&gt; 禁用input，设置为只读，不能填写&lt;input name=\"gender\" type=\"text\" value=\"1\" readonly/&gt;禁用select，设置为只读，不能选择&lt;select id=\"test\" name=\"sortId\" disabled&gt;   &lt;option value=\"\"&gt;&lt;/option&gt;   &lt;option value=\"1\"&gt;低&lt;/option&gt;   &lt;option value=\"2\"&gt;中&lt;/option&gt;   &lt;option value=\"3\"&gt;高&lt;/option&gt;&lt;/select&gt;"
  },
  
  {
    "title": "计算相差的月数",
    "url": "/posts/jisuan-xiangcha-de-yueshu/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 13:13:00 +0800",
    





    
    "snippet": "public static int getMonthDiff(Date d1, Date d2) {\tCalendar c1 = Calendar.getInstance();\tCalendar c2 = Calendar.getInstance();\tc1.setTime(d1);\tc2.setTime(d2);\tint year1 = c1.get(Calendar.YEAR);\tint...",
    "content": "public static int getMonthDiff(Date d1, Date d2) {\tCalendar c1 = Calendar.getInstance();\tCalendar c2 = Calendar.getInstance();\tc1.setTime(d1);\tc2.setTime(d2);\tint year1 = c1.get(Calendar.YEAR);\tint year2 = c2.get(Calendar.YEAR);\tint month1 = c1.get(Calendar.MONTH);\tint month2 = c2.get(Calendar.MONTH);\tint day1 = c1.get(Calendar.DAY_OF_MONTH);\tint day2 = c2.get(Calendar.DAY_OF_MONTH);\t// 获取年的差值\tint yearInterval = year1 - year2;\t// 如果 d1的 月-日 小于 d2的 月-日 那么 yearInterval-- 这样就得到了相差的年数\tif (month1 &lt; month2 || month1 == month2 &amp;&amp; day1 &lt; day2) {\t\tyearInterval--;\t}\t// 获取月数差值\tint monthInterval = (month1 + 12) - month2;\tif (day1 &lt; day2) {\t\tmonthInterval--;\t}\tmonthInterval %= 12;\tint monthsDiff = Math.abs(yearInterval * 12 + monthInterval);\treturn monthsDiff;}"
  },
  
  {
    "title": "Java中Array和List的相互转换",
    "url": "/posts/java-zhong-array-he-list-de-zhuanhuan/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 11:47:00 +0800",
    





    
    "snippet": "Array转ListString[] array = {\"string1\", \"string2\", \"string3\"};List&lt;String&gt; list = Arrays.asList(array);//Arrays.asList产生一个Arrays内置的类，其中数组用final表示// list.add(\"string4\");  所以不能往其中添加元素for(String ...",
    "content": "Array转ListString[] array = {\"string1\", \"string2\", \"string3\"};List&lt;String&gt; list = Arrays.asList(array);//Arrays.asList产生一个Arrays内置的类，其中数组用final表示// list.add(\"string4\");  所以不能往其中添加元素for(String s : list){    System.out.println(s);}List转ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();list2.add(\"t1\");list2.add(\"t2\");list2.add(\"t3\");//toArray中不指定参数，只能转换为Object类型String[] strings = list2.toArray(new String[list2.size()]);for (String v : strings) {    System.out.println(v);}  参考：Java中Array和List的相互转换"
  },
  
  {
    "title": "使用Calendar类来输出年份、月份等",
    "url": "/posts/shiyong-calendar-huoqu-shijain/",
    "categories": "Knowledge, Java",
    "tags": "Java",
    "date": "2020-10-27 11:47:00 +0800",
    





    
    "snippet": "import java.util.Calendar;public class Main {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        int day = cal.get(Calendar.DATE);        int month = c...",
    "content": "import java.util.Calendar;public class Main {    public static void main(String[] args) {        Calendar cal = Calendar.getInstance();        int day = cal.get(Calendar.DATE);        int month = cal.get(Calendar.MONTH) + 1;        int year = cal.get(Calendar.YEAR);        int dow = cal.get(Calendar.DAY_OF_WEEK);        int dom = cal.get(Calendar.DAY_OF_MONTH);        int doy = cal.get(Calendar.DAY_OF_YEAR);         System.out.println(\"当期时间: \" + cal.getTime());        System.out.println(\"日期: \" + day);        System.out.println(\"月份: \" + month);        System.out.println(\"年份: \" + year);        System.out.println(\"一周的第几天: \" + dow);          // 星期日为一周的第一天输出为 1        // 星期一输出为 2，以此类推        System.out.println(\"一月中的第几天: \" + dom);        System.out.println(\"一年的第几天: \" + doy);    }}以上代码运行输出结果为：当期时间: Fri Mar 27 21:44:15 CST 2015日期: 27月份: 3年份: 2015一周的第几天: 6一月中的第几天: 27一年的第几天: 86"
  },
  
  {
    "title": "在springmvc-servlet.xml中设置上传文件的大小限制",
    "url": "/posts/shezhi-shangchuan-wenjian-de-daxiao/",
    "categories": "Knowledge, Spring",
    "tags": "Spring",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;  &lt;!-- 设置上传文件编码 --&gt;  &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/pr...",
    "content": "&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;  &lt;!-- 设置上传文件编码 --&gt;  &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt;  &lt;!-- 设置上传文件最大为200M--&gt;  &lt;property name=\"maxUploadSize\" value=\"209715200\"&gt;&lt;/property&gt;  &lt;!-- 设置上传最大内存40KB --&gt;  &lt;property name=\"maxInMemorySize\" value=\"40960\"&gt;&lt;/property&gt;&lt;/bean&gt;"
  },
  
  {
    "title": "Oracle 使用SQL语句对序列的操作",
    "url": "/posts/xulie-caozuo/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "创建序列CREATE SEQUENCE test_seq     MINVALUE 1     MAXVALUE 9999999999     START WITH 100000     INCREMENT BY 1     CACHE 20查询所有序列select * from user_sequences;查询特定序列select * from user_sequences where ...",
    "content": "创建序列CREATE SEQUENCE test_seq     MINVALUE 1     MAXVALUE 9999999999     START WITH 100000     INCREMENT BY 1     CACHE 20查询所有序列select * from user_sequences;查询特定序列select * from user_sequences where sequence_name like '%T_SELL_BRAND%';select * from user_sequences where sequence_name = 'SEQ_T_SELL_BRAND';"
  },
  
  {
    "title": "Oracle 使用SQL创建备份表",
    "url": "/posts/chuangjian-beifenbiao/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "create table a_bak as select * from a;",
    "content": "create table a_bak as select * from a;"
  },
  
  {
    "title": "Oracle 取查询结果排序后的第一条记录",
    "url": "/posts/qu-paixuhou-diyitiao-shuju/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "select * from (select t.*, row_number() over(order by id) rn from test_order t) t where rn = 1;",
    "content": "select * from (select t.*, row_number() over(order by id) rn from test_order t) t where rn = 1;"
  },
  
  {
    "title": "Oracle 批量删除表、视图、序列、函数",
    "url": "/posts/piliang-shanchu-xulie/",
    "categories": "Knowledge, Oracle",
    "tags": "Oracle",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "网上有很多利用函数批量删除的例子，但是个人觉得有些复杂，参考Coding迷这位网友的做法，我认为比较简单。批量删除表、视图、序列、函数前，生成对应的SQL执行脚本，然后执行生成对应的脚本即可。--删除表select 'drop table '||table_name||';' as sqlscript from user_tables; -- drop tables--删除序列select ...",
    "content": "网上有很多利用函数批量删除的例子，但是个人觉得有些复杂，参考Coding迷这位网友的做法，我认为比较简单。批量删除表、视图、序列、函数前，生成对应的SQL执行脚本，然后执行生成对应的脚本即可。--删除表select 'drop table '||table_name||';' as sqlscript from user_tables; -- drop tables--删除序列select 'drop sequence ' || sequence_name||';' as sqlscript from user_sequences; -- drop seqs--删除存储过程select 'drop procedure ' || object_name||';' as sqlscript from user_objects  where object_type='PROCEDURE'; -- drop procedure--删除视图select 'drop view ' || view_name||';' as sqlscript from user_views;  -- drop views--删除函数select 'drop function ' || object_name||';' as sqlscript from user_objects  where object_type='FUNCTION'; -- drop functions  参考：Oracle数据库批量删除表、视图、序列、函数"
  },
  
  {
    "title": "MyBatis的xml文件中如何处理特殊字符",
    "url": "/posts/mybatis-zhong-de-teshu-zifu/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;![CDATA[   包含SQL特殊字符 ]]&gt;",
    "content": "&lt;![CDATA[   包含SQL特殊字符 ]]&gt;"
  },
  
  {
    "title": "MyBatis中使用模糊查询",
    "url": "/posts/mybatis-shiyong-mohu-chaxun/",
    "categories": "Knowledge, MyBatis",
    "tags": "MyBatis",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;if test='testdata != null and testdata !=\"\"'&gt;    AND T.TEST_DATA LIKE CONCAT(CONCAT('%', #{testdata, jdbcType = VARCHAR}), '%') &lt;/if&gt;",
    "content": "&lt;if test='testdata != null and testdata !=\"\"'&gt;    AND T.TEST_DATA LIKE CONCAT(CONCAT('%', #{testdata, jdbcType = VARCHAR}), '%') &lt;/if&gt;"
  },
  
  {
    "title": "JavaScript实现submit按钮的功能",
    "url": "/posts/shoudong-commit/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "document.forms[0].action = \"/demo/test/doSubmit.do?param=0\";document.forms[0].method = \"post\";document.forms[0].submit();\t",
    "content": "document.forms[0].action = \"/demo/test/doSubmit.do?param=0\";document.forms[0].method = \"post\";document.forms[0].submit();\t"
  },
  
  {
    "title": "截图",
    "url": "/posts/jietu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "html&lt;div class=\"demo-container\"&gt;    &lt;div id=\"demo\"&gt;        &lt;div class=\"orange\"&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用...",
    "content": "html&lt;div class=\"demo-container\"&gt;    &lt;div id=\"demo\"&gt;        &lt;div class=\"orange\"&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;            &lt;p&gt;如果原来使用百分比设置元素宽高，请更改为px为单位的宽高，避免样式二次计算导致的模糊&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;button id=\"saveImg\"&gt;截图&lt;/button&gt;css#demo {    background-color: #fff;}.orange {    background-color: orange;    width: 700px;    height: 200px;}javaScript&lt;script src=\"jquery-3.2.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"html2canvas.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    $(\"#saveImg\").on(\"click\", function () {        var getPixelRatio = function (context) {                 // 获取设备的PixelRatio            var backingStore = context.backingStorePixelRatio ||                context.webkitBackingStorePixelRatio ||                context.mozBackingStorePixelRatio ||                context.msBackingStorePixelRatio ||                context.oBackingStorePixelRatio ||                context.backingStorePixelRatio || 1;            return (window.devicePixelRatio || 1) / backingStore;        };        var shareContent = $(\".orange\")[0];        var width = shareContent.offsetWidth;        var height = shareContent.offsetHeight;        var canvas = document.createElement(\"canvas\");        var context = canvas.getContext('2d');        // 将canvas的容器扩大PixelRatio倍，再将画布缩放，将图像放大PixelRatio倍。        var scale = getPixelRatio(context);            canvas.width = width * scale;        canvas.height = height * scale;        canvas.style.width = width + 'px';        canvas.style.height = height + 'px';        context.scale(scale, scale);        var opts = {            scale: scale,            canvas: canvas,            width: width,            height: height,            dpi: window.devicePixelRatio        };        html2canvas(shareContent, opts).then(function (canvas) {            context.mozImageSmoothingEnabled = false;            context.webkitImageSmoothingEnabled = false;            context.msImageSmoothingEnabled = false;            context.imageSmoothingEnabled = false;            var dataUrl = canvas.toDataURL('image/jpeg', 1.0);            var newImg = document.createElement(\"img\");            newImg.src = dataUrl;            newImg.width = width;            newImg.height = height;            saveImg(dataUrl);        });    });    function saveImg(Url) {        debugger        var blob = new Blob([''], { type: 'application/octet-stream' });        var url = URL.createObjectURL(blob);        var a = document.createElement('a');        a.href = Url;        var date = new Date();        a.download = \"screenshot_\" + date.getTime();        var e = document.createEvent('MouseEvents');        e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);        a.dispatchEvent(e);        URL.revokeObjectURL(url);    }&lt;/script&gt;需要的包：  html2canvas.min.js  jquery-3.2.1.min.js"
  },
  
  {
    "title": "iframe自适应高度",
    "url": "/posts/iframe-zishiying-gaodu/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;iframe src=\"backtop.html\" frameborder=\"0\" scrolling=\"no\" id=\"test\" οnlοad=\"this.height=100\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;function reinitIframe () {    var iframe = doc...",
    "content": "&lt;iframe src=\"backtop.html\" frameborder=\"0\" scrolling=\"no\" id=\"test\" οnlοad=\"this.height=100\"&gt;&lt;/iframe&gt;&lt;script type=\"text/javascript\"&gt;function reinitIframe () {    var iframe = document.getElementById(\"test\");    iframe.height = 0; // 只有先设置原来的iframe高度为0，之前的iframe高度才不会对现在的设置有影响    try{        var bHeight = iframe.contentWindow.document.body.scrollHeight;        var dHeight = iframe.contentWindow.document.documentElement.scrollHeight;        var height = Math.max(bHeight, dHeight);        iframe.height = height;    } catch (ex) {    }}window.setInterval(\"reinitIframe()\", 200);&lt;/script&gt;"
  },
  
  {
    "title": "页面弹出框的操作",
    "url": "/posts/dan-chu-kuang-dong-zuo/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "var notice = \"您确认要执行该操作吗？\";var flag = window.confirm(notice);if (flag) {    alert(\"OK\");} else {    alert(\"NO\");}",
    "content": "var notice = \"您确认要执行该操作吗？\";var flag = window.confirm(notice);if (flag) {    alert(\"OK\");} else {    alert(\"NO\");}"
  },
  
  {
    "title": "比较时间大小",
    "url": "/posts/bijiao-shijian-daxiao/",
    "categories": "Knowledge, JavaScript",
    "tags": "JavaScript",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "// 获取页面时间字符串并使用new Date()函数转换为日期格式var date_begin = new Date($(\"#date_begin\").val().replace(\"-\", \"/\").replace(\"-\", \"/\"));var date_end = new Date($(\"#date_end\").val().replace(\"-\", \"/\").replace(\"-\", \"...",
    "content": "// 获取页面时间字符串并使用new Date()函数转换为日期格式var date_begin = new Date($(\"#date_begin\").val().replace(\"-\", \"/\").replace(\"-\", \"/\"));var date_end = new Date($(\"#date_end\").val().replace(\"-\", \"/\").replace(\"-\", \"/\"));// 使用Date.getTime()函数获取时间数比较两个日期之间的大小if(date_begin.getTime() &gt; date_end.getTime()) {    alert(\"起始时间必须小于结束时间！\");}"
  },
  
  {
    "title": "JSP页面获取Controller设置的参数",
    "url": "/posts/jsp-yemain-huoqu-controller-shezhi-de-canshu/",
    "categories": "Knowledge, JSP",
    "tags": "JSP",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "在controller中设置参数request.setAttribute(\"param\", \"123\");在JSP页面获取该参数var param = '&lt;%=request.getAttribute(\"param\")%&gt;';",
    "content": "在controller中设置参数request.setAttribute(\"param\", \"123\");在JSP页面获取该参数var param = '&lt;%=request.getAttribute(\"param\")%&gt;';"
  },
  
  {
    "title": "JQuery获取元素高度不同方法的区别",
    "url": "/posts/jquery-huoqu-yuansu-gaodu-de-butong-fangfa/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "$ele = $(\"#element\")$ele.height() // 纯内高height$ele.innerHeight() //  height + padding$ele.outerHeight() // height + padding + border$ele.outerHeight(True) // height + padding + border + margin  参考：...",
    "content": "$ele = $(\"#element\")$ele.height() // 纯内高height$ele.innerHeight() //  height + padding$ele.outerHeight() // height + padding + border$ele.outerHeight(True) // height + padding + border + margin  参考：JQuery获取元素高度"
  },
  
  {
    "title": "原生 JS 或 JQuery 实现父窗口传值",
    "url": "/posts/fuchuangkou-chuanzhi/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "做WEB前端开发的过程中，经常会有这样的需求，用户点击【编辑】按钮，弹出一个对话框，在里边修改相应的值，然后把修改后的值显示在原页面，最后点击保存。用window.parent.document.getElementById(\"\").setAttribute(\"value\", \"\")可以很好的解决这个问题。父页面中的代码&lt;!doctype html&gt;&lt;html lang=\"...",
    "content": "做WEB前端开发的过程中，经常会有这样的需求，用户点击【编辑】按钮，弹出一个对话框，在里边修改相应的值，然后把修改后的值显示在原页面，最后点击保存。用window.parent.document.getElementById(\"\").setAttribute(\"value\", \"\")可以很好的解决这个问题。父页面中的代码&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;meta name=\"Keywords\" content=\"\"&gt;        &lt;meta name=\"Description\" content=\"\"&gt;    &lt;/head&gt;    &lt;body style=\"height:3000px\"&gt;        &lt;input type=\"text\" id=\"parent\"&gt;        &lt;button id=\"parentBtn\"&gt;编辑&lt;/button&gt;        &lt;div class=\"clear\" style=\"width:500px;height:200px;border:1px solid red;position:fixed;top:100px;left:100px;display:none\"&gt;            &lt;iframe src=\"son.html\" style=\"border:none\"&gt;&lt;/iframe&gt;        &lt;/div&gt;        &lt;button id=\"content\"&gt;获取内容值&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\" src=\"http://www.zymseo.com/js/demo.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    // 显示子窗口    $(\"#parentBtn\").click(function(){        $(\".clear\").show();    })    // 显示子窗口获取到的值    $(\"#content\").click(function(){        alert($(\"#parent\").val());    })&lt;/script&gt;子页面中的代码&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;meta name=\"Keywords\" content=\"\"&gt;        &lt;meta name=\"Description\" content=\"\"&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=\"text\" id=\"son\"&gt;        &lt;button id=\"sonBtn\"&gt;确定&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;&lt;script type=\"text/javascript\" src=\"http://www.zymseo.com/js/demo.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;    $(\"#sonBtn\").click(function(){        var $val = $(\"#son\").val();        // JQuery写法给父页面传值        $(\"#parent\", window.parent.document).val($val);         // 原生javascript写法给父页面传值        // window.parent.document.getElementById(\"parent\").setAttribute(\"value\", $val);        // JQuery写法控制父页面中的某个元素隐藏         $(\".clear\", window.parent.document).hide();         // 原生javascript写法控制父页面中的某个元素隐藏        // window.parent.document.getElementsByClassName(\"clear\")[0].style.display = \"none\";     })&lt;/script&gt;  参考：window.parent.document解决方案【原生js或jQuery 实现父窗口的问题】"
  },
  
  {
    "title": "页面字段空值校验",
    "url": "/posts/yemian-ziduan-kongzhi-jiaoyan/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        al...",
    "content": "function checkIsNull() {    var flag = false;    var test1 = $('input:radio[name=\"test1\"]:checked').val();    var test2 = $(\"#test2\").val()    if (test1) {        flag = true;    } else {        alert(\"输入框1不能为空！\");        flag = false;    }    if (flag &amp;&amp; test2) {        flag = true;    } else if (flag) {        alert(\"输入框2不能为空！\");        flag = false;    }    return flag;}"
  },
  
  {
    "title": "按钮置灰",
    "url": "/posts/anniu-zhihui/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "$(document).ready(function() {  $(\"#button_li\").click(function() {\t  $(this).css(\"pointer-events\", \"none\");\t  $(this).css(\"background-color\", \"gray\");   });});",
    "content": "$(document).ready(function() {  $(\"#button_li\").click(function() {\t  $(this).css(\"pointer-events\", \"none\");\t  $(this).css(\"background-color\", \"gray\");   });});"
  },
  
  {
    "title": "input输入框锁定",
    "url": "/posts/input-shurukuang-suoding/",
    "categories": "Knowledge, JQuery",
    "tags": "JQuery",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "$(el).find(\"input[name='a']\").attr(\"style\", \"background-color:#f6f6f6;cursor:no-drop\");$(el).find(\"input[name='a']\").attr(\"readonly\", \"readonly\");$(el).find(\"input[name='a']\").attr(\"onclick\", \"\");$...",
    "content": "$(el).find(\"input[name='a']\").attr(\"style\", \"background-color:#f6f6f6;cursor:no-drop\");$(el).find(\"input[name='a']\").attr(\"readonly\", \"readonly\");$(el).find(\"input[name='a']\").attr(\"onclick\", \"\");$(el).find(\"input[name='a']\").attr(\"onfocus\", \"\");"
  },
  
  {
    "title": "EL表达式判断字符串相等（eq）和不相等（ne）",
    "url": "/posts/el-panduan-xiangdeng-buxiangdeng/",
    "categories": "Knowledge, EL",
    "tags": "EL",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;td class=\"t1\"&gt;  &lt;input type=\"hidden\" class=\"name\" value=\"${name}\"&gt;  &lt;a class=\"c-link fb delete-btn\"&gt;删除&lt;/a&gt;  &lt;a class=\"c-link fb ml10\"&gt;记录&lt;/a&gt;  &lt;!-- 相等（eq）、不相等...",
    "content": "&lt;td class=\"t1\"&gt;  &lt;input type=\"hidden\" class=\"name\" value=\"${name}\"&gt;  &lt;a class=\"c-link fb delete-btn\"&gt;删除&lt;/a&gt;  &lt;a class=\"c-link fb ml10\"&gt;记录&lt;/a&gt;  &lt;!-- 相等（eq）、不相等（ne） --&gt;  &lt;c:if test=\"${staus eq '1'}\"&gt;&lt;a class=\"c-link fb ml10\"&gt;开启流程&lt;/a&gt;&lt;/c:if&gt;  &lt;c:if test=\"${staus ne '1'}\"&gt;&lt;a class=\"c-link fb ml10\"&gt;处理流程&lt;/a&gt;&lt;/c:if&gt;&lt;/td&gt;"
  },
  
  {
    "title": "EL表达式标签判断参数是否为空",
    "url": "/posts/el-panduan-canshu-shifou-weikong/",
    "categories": "Knowledge, EL",
    "tags": "EL",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "&lt;c:if test=\"${empty str}\"&gt; str为空 &lt;/c:if&gt;&lt;c:if test=\"${not empty str}\"&gt; str不为空 &lt;/c:if&gt;",
    "content": "&lt;c:if test=\"${empty str}\"&gt; str为空 &lt;/c:if&gt;&lt;c:if test=\"${not empty str}\"&gt; str不为空 &lt;/c:if&gt;"
  },
  
  {
    "title": "DOS命令集",
    "url": "/posts/dos-mingling-ji/",
    "categories": "Knowledge, DOS",
    "tags": "DOS",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": ".                   C:\\DocumentsandSettings\\用户名所在文件夹 ..                  C:\\DocumentsandSettings ...                 我的电脑 \\                   C盘 C:/windows/fonts    字体cmd /k systeminfo   查询系统信息OSK ...",
    "content": ".                   C:\\DocumentsandSettings\\用户名所在文件夹 ..                  C:\\DocumentsandSettings ...                 我的电脑 \\                   C盘 C:/windows/fonts    字体cmd /k systeminfo   查询系统信息OSK                 屏幕键盘"
  },
  
  {
    "title": "选择器的优先级",
    "url": "/posts/xuanzeqi-de-youxianji/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "1.最高优先级是 （直接在标签中的设置样式） &lt;div style=\"color:Red;\"&gt;&lt;/div&gt;2.次优先级是（ID选择器 ,假设级别为100） #myDiv{color:Red;}3.其次优先级是（类选择器，假设级别为10） .divClass{color:Red;}4.最后优先级是 （标签选择器，假设级别是1） div{color:Red;}",
    "content": "1.最高优先级是 （直接在标签中的设置样式） &lt;div style=\"color:Red;\"&gt;&lt;/div&gt;2.次优先级是（ID选择器 ,假设级别为100） #myDiv{color:Red;}3.其次优先级是（类选择器，假设级别为10） .divClass{color:Red;}4.最后优先级是 （标签选择器，假设级别是1） div{color:Red;}"
  },
  
  {
    "title": "使用CSS设置textarea不可拖动",
    "url": "/posts/shezhi-textarea-buke-tuodong/",
    "categories": "Knowledge, CSS",
    "tags": "CSS",
    "date": "2020-10-26 13:47:00 +0800",
    





    
    "snippet": "默认情况下，我们将鼠标移动到&lt;textarea&gt;的右下角时发现文本域是可以通过拖动的方式改变其大小的，这会影响我们原本的页面布局。若想设置其不可拖动，可为其添加如下属性：&lt;textarea style=\"resize:none;\"&gt;&lt;/textarea&gt;",
    "content": "默认情况下，我们将鼠标移动到&lt;textarea&gt;的右下角时发现文本域是可以通过拖动的方式改变其大小的，这会影响我们原本的页面布局。若想设置其不可拖动，可为其添加如下属性：&lt;textarea style=\"resize:none;\"&gt;&lt;/textarea&gt;"
  },
  
  {
    "title": "使用Jekyll部署自己的博客",
    "url": "/posts/jekyll-anzhuang/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-11 00:34:00 +0800",
    





    
    "snippet": "原理使用Jekyll将Markdown编写的博客生成HTML文件，也就是静态的网页，部署到GitHub上，使用GitHub提供的GitHub Pages功能来运行展示自己的博客，无需自己的数据库和服务器。安装Ruby环境需要在Ruby环境下才可以运行Jekyll，所有首先要安装Ruby环境。根据自己的操作系统下载Ruby的安装包 https://rubyinstaller.org/downl...",
    "content": "原理使用Jekyll将Markdown编写的博客生成HTML文件，也就是静态的网页，部署到GitHub上，使用GitHub提供的GitHub Pages功能来运行展示自己的博客，无需自己的数据库和服务器。安装Ruby环境需要在Ruby环境下才可以运行Jekyll，所有首先要安装Ruby环境。根据自己的操作系统下载Ruby的安装包 https://rubyinstaller.org/downloads/，选择WITH DEVKIT这一栏的安装包，后面编译需要用到DevKit，免去了自己下载安装DevKit的步骤。我这里下载的是 Ruby+Devkit 2.7.2-1 (x64) 。双击安装包进行安装。安装完成后打开cmd窗口，输入ruby -v查看是否安装成功。如下出现Ruby的版本号则表示安装成功。还需要安装RubyGems，RubyGems是Ruby的一个包管理器，RubyGems在功能上与apt-get、portage、yum和npm非常相似。Ruby1.9.1 以后版本已经自带了，所以无需额外下载。打开cmd窗口，输入gem -v查看是否安装RubyGems，如下出现RubyGems的版本号则表示安装成功。切换RubyGems源由于网络原因，导致rubygems.org存放在Amazon S3上面的资源文件间歇性连接失败。所以首先要切换Ruby的gem源，有两个比较好的镜像源可供选择，一个是淘宝，另一个是ruby-china，网上大部分的教程都是用淘宝的，但是我在使用淘宝镜像源https://ruby.taobao.org/的时候发现老是会出现认证错误：Error fetching https://ruby.taobao.org/:SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://rubygems-china.oss-cn-hangzhou.aliyuncs.com/specs.4.8.gz) 原因是淘宝的这个镜像源已经不再维护，所以改用https://gems.ruby-china.org/的镜像源，但是也报错了：Error fetching https://gems.ruby-china.org/: bad response Not Found 404 (https://gems.ruby-china.org/specs.4.8.gz) 原因是服务域名更换了，打开报错地址：https://gems.ruby-china.org/ 会有如下图提示，将org后缀改为com即可。使用以下命令来切换镜像源gem sources  # 查看当前使用的源地址gem sources -r url  # 删除默认的源地址，注：默认的url地址后必须有”/”,否则删不掉gem sources -a url  #添加新的镜像源地址gem sources -u  # 更新源的缓存# 以切换ruby-china为例gem sources  gem sources -r https://rubygems.org/gem sources -a https://gems.ruby-china.com/gem sources -u gem sources  # 查看一下是否切换成功安装Jekyll输入以下命令等待Jekyll安装完成gem install jekyllgem install jekyll -v '指定版本号' # 安装指定版本输入jekyll -v查看是否安装成功，如下出现Jekyll的版本号则表示安装成功。下载Jekyll主题从Jekyll的主题官网 http://jekyllthemes.org/ 下载自己喜欢的主题，并解压到本地。运行Jekyll进入到解压好的主题根目录下，输入以下命令启动Jekylljekyll serve可能会出现以下的错误jekyll serveC:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.13.6/lib/bundler/resolver.rb:366:in `block in verify_gemfile_dependencies_are_found!': Could not find gem 'github-pages x64-mingw32' in any of the gem sources listed in your Gemfile or available on this machine. (Bundler::GemNotFound)        from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.13.6/lib/bundler/resolver.rb:341:in `each'        from C:/Ruby23-x64/lib/ruby/gems/2.3.0/gems/bundler-1.13.6/lib/bundler/resolver.rb:341:in `verify_gemfile_dependencies_are_found!'下载对应的依赖即可gem install github-pagesgem install github-pages -v 版本号 # 安装指定版本依赖显示以下内容则表示启动成功在浏览器中输入http://localhost:4000/访问，enjoy it。Jekyll的目录结构.├──_config.yml├── _drafts|   ├── begin-with-the-crazy-ideas.textile|   └── on-simplicity-in-technology.markdown├── _includes|   ├── footer.html|   └── header.html├── _layouts|   ├── default.html|   └── post.html├── _posts|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile|   └── 2009-04-26-barcamp-boston-4-roundup.textile├── _site├── .jekyll-metadata└── index.html每个目录的作用            目录      描述                  _config.yml      保存配置数据              _drafts      drafts（草稿）是未发布的文章              _includes      你可以加载这些包含部分到你的布局或者文章中以方便重用              _layouts      layouts（布局）是包裹在文章外部的模板              _posts      这里放的就是文章了              _data      格式化好的网站数据。Jekyll的引擎会自动加载在该目录下所有的yaml文件（后缀是.yml, .yaml, .json或者.csv ）。这些文件可以经由site.data访问。如果有一个members.yml文件在该目录下，你就可以通过site.data.members获取该文件的内容。              _site      一旦Jekyll完成转换，就会将生成的页面放在这里      将博客发布到GitHub首先需要有一个GitHub帐号，其次拥有一个存储库，存储库名称必须是&lt;username&gt;.github.io，&lt;username&gt;就是你的GitHub用户名。然后需要打开GitHub Pages功能  在本地使用jekyll serve命令将md文件编译成HTML文件，然后将_site目录下的内容上传到刚才新建的存储库中，在浏览器打开https://xxx.github.io，就可以看到博客页面了。附几款博客主题  Typecho的主题：未命名 DEFAULT小改模板，预览：未命名  Wordpress的主题：smarty_hankin，预览：hankin"
  },
  
  {
    "title": "Customize the Favicon",
    "url": "/posts/customize-the-favicon/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-11 00:34:00 +0800",
    





    
    "snippet": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons...",
    "content": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files:  browserconfig.xml  site.webmanifestAnd then copy the remaining image files (.PNG and .ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files:            File(s)      From Online Tool      From Chirpy                  *.PNG      ✓      ✗              *.ICO      ✓      ✗        ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition."
  },
  
  {
    "title": "Getting Started",
    "url": "/posts/getting-started/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-09 20:55:00 +0800",
    





    
    "snippet": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of the basic environment. Git also needs to be installed.InstallationCreating a New SiteThere are two ways to cr...",
    "content": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of the basic environment. Git also needs to be installed.InstallationCreating a New SiteThere are two ways to create a new repository for this theme:  Using the Chirpy Starter - Easy to upgrade, isolates irrelevant project files so you can focus on writing.  GitHub Fork - Convenient for custom development, but difficult to upgrade. Unless you are familiar with Jekyll and are determined to tweak or contribute to this project, this approach is not recommended.Option 1. Using the Chirpy StarterSign in to GitHub and browse to Chirpy Starter, click the button Use this template &gt; Create a new repository, and name the new repository USERNAME.github.io, where USERNAME represents your GitHub username.Option 2. GitHub ForkSign in to GitHub to fork Chirpy, and then rename it to USERNAME.github.io (USERNAME means your username).Next, clone your site to local machine. In order to build JavaScript files later, we need to install Node.js, and then run the tool:$ bash tools/init  If you don’t want to deploy your site on GitHub Pages, append option --no-gh at the end of the above command.The above command will:  Check out the code to the latest tag (to ensure the stability of your site: as the code for the default branch is under development).  Remove non-essential sample files and take care of GitHub-related files.  Build JavaScript files and export to assets/js/dist/, then make them tracked by Git.  Automatically create a new commit to save the changes above.Installing DependenciesBefore running local server for the first time, go to the root directory of your site and run:$ bundleUsageConfigurationUpdate the variables of _config.yml as needed. Some of them are typical options:  url  avatar  timezone  langCustomizing StylesheetIf you need to customize the stylesheet, copy the theme’s assets/css/style.scss to the same path on your Jekyll site, and then add the custom style at the end of it.Starting with version 4.1.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, copy the main sass file _sass/jekyll-theme-chirpy.scss into the _sass directory in your site’s source, then create a new file _sass/variables-hook.scss and assign new value.Customing Static AssetsStatic assets configuration was introduced in version 5.1.0. The CDN of the static assets is defined by file _data/origin/cors.yml, and you can replace some of them according to the network conditions in the region where your website is published.Also, if you’d like to self-host the static assets, please refer to the chirpy-static-assets.Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sOr run the site on Docker with the following command:$ docker run -it --rm \\    --volume=\"$PWD:/srv/jekyll\" \\    -p 4000:4000 jekyll/jekyll \\    jekyll serveAfter a few seconds, the local service will be published at http://127.0.0.1:4000.DeploymentBefore the deployment begins, check out the file _config.yml and make sure the url is configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than GitHub Pages, remember to change the baseurl to your project name that starts with a slash, e.g, /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy by Using GitHub ActionsThere are a few things to get ready for.  If you’re on the GitHub Free plan, keep your site repository public.      If you have committed Gemfile.lock to the repository, and your local machine is not running Linux, go the the root of your site and update the platform list of the lock-file:    $ bundle lock --add-platform x86_64-linux      Next, configure the Pages service.      Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar. Then, in the Source section (under Build and deployment), select GitHub Actions from the dropdown menu.        Push any commits to GitHub to trigger the Actions workflow. In the Actions tab of your repository, you should see the workflow Build and Deploy running. Once the build is complete and successful, the site will be deployed automatically.  At this point, you can go to the URL indicated by GitHub to access your site.Manually Build and DeployOn self-hosted servers, you cannot enjoy the convenience of GitHub Actions. Therefore, you should build the site on your local machine and then upload the site files to the server.Go to the root of the source project, and build your site as follows:$ JEKYLL_ENV=production bundle exec jekyll bOr build the site on Docker:$ docker run -it --rm \\    --env JEKYLL_ENV=production \\    --volume=\"$PWD:/srv/jekyll\" \\    jekyll/jekyll \\    jekyll buildUnless you specified the output path, the generated site files will be placed in folder _site of the project’s root directory. Now you should upload those files to the target server."
  },
  
  {
    "title": "Writing a New Post",
    "url": "/posts/write-a-new-post/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-08 14:10:00 +0800",
    





    
    "snippet": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set.Naming and P...",
    "content": "This tutorial will guide you how to write a post in the Chirpy template, and it’s worth reading even if you’ve used Jekyll before, as many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG]     # TAG names should always be lowercase---  The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:Adding author information in _data/authors.yml (If your website doesn’t have this file, don’t hesitate to create one).&lt;author_id&gt;:  name: &lt;full name&gt;  twitter: &lt;twitter_of_author&gt;  url: &lt;homepage_of_author&gt;And then use author to specify a single entry or authors to specify multiple entries:---author: &lt;author_id&gt;                     # for single entry# orauthors: [&lt;author1_id&gt;, &lt;author2_id&gt;]   # for multiple entries---Having said that, the key author can also identify multiple entries.  The benefit of reading the author information from the file _data/authors.yml is that the page will have the meta tag twitter:creator, which enriches the Twitter Cards and is good for SEO.Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesCaptionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image.![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }  For an SVG, you have to at least specify its width, otherwise it won’t be rendered.Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right.  Once the position is specified, the image caption should not be added.      Normal position    Image will be left aligned in below sample:    ![Desktop View](/assets/img/sample/mockup.png){: .normal }            Float to the left    ![Desktop View](/assets/img/sample/mockup.png){: .left }            Float to the right    ![Desktop View](/assets/img/sample/mockup.png){: .right }      Dark/Light modeYou can make images follow theme preferences in dark/light mode. This requires you to prepare two images, one for dark mode and one for light mode, and then assign them a specific class (dark or light):![Light mode only](/path/to/light-mode.png){: .light }![Dark mode only](/path/to/dark-mode.png){: .dark }ShadowThe screenshots of the program window can be considered to show the shadow effect:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.comOnce img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&lt;img src=\"https://cdn.com/path/to/flower.png\" alt=\"The flower\"&gt;Image PathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&lt;img src=\"/img/path/flower.png\" alt=\"The flower\"&gt;Preview ImageIf you want to add an image at the top of the post, please provide an image with a resolution of 1200 x 630. Please note that if the image aspect ratio does not meet 1.91 : 1, the image will be scaled and cropped.Knowing these prerequisites, you can start setting the image’s attribute:---image:  path: /path/to/image  alt: image alternative text---Note that the img_path can also be passed to the preview image, that is, when it has been set, the  attribute path only needs the image file name.For simple use, you can also just use image to define the path.---image: /path/to/image---LQIPFor preview images:---image:  lqip: /path/to/lqip-file # or base64 URI---  You can observe LQIP in the preview image of post Text and Typography.For normal images:![Image description](/path/to/image){: lqip=\"/path/to/lqip-file\" }Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---PromptsThere are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows:&gt; Example line for prompt.{: .prompt-info }SyntaxInline Code`inline code part`Filepath Hightlight`/path/to/a/file.extend`{: .filepath}Code BlockMarkdown symbols ``` can easily create a code block as follows:```This is a plaintext code snippet.```Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value```  The Jekyll tag {% highlight %} is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it:```shellecho 'No more line numbers!'```{: .nolineno }Specifying the FilenameYou may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=\"path/to/file\" }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains 'Pack' %}  This product's title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.VideosYou can embed a video with the following syntax:{% include embed/{Platform}.html id='{ID}' %}Where Platform is the lowercase of the platform name, and ID is the video ID.The following table shows how to get the two parameters we need in a given video URL, and you can also know the currently supported video platforms.            Video URL      Platform      ID                  https://www.youtube.com/watch?v=H-B46URT4mg      youtube      H-B46URT4mg              https://www.twitch.tv/videos/1634779211      twitch      1634779211      Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts."
  },
  
  {
    "title": "Text and Typography",
    "url": "/posts/text-and-typography/",
    "categories": "Index, Jekyll",
    "tags": "Jekyll",
    "date": "2019-08-08 11:33:00 +0800",
    





    
    "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.HeadingsH1 - headingH2 - headingH3 - headingH...",
    "content": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.HeadingsH1 - headingH2 - headingH3 - headingH4 - headingParagraphQuisque egestas convallis ipsum, ut sollicitudin risus tincidunt a. Maecenas interdum malesuada egestas. Duis consectetur porta risus, sit amet vulputate urna facilisis ac. Phasellus semper dui non purus ultrices sodales. Aliquam ante lorem, ornare a feugiat ac, finibus nec mauris. Vivamus ut tristique nisi. Sed vel leo vulputate, efficitur risus non, posuere mi. Nullam tincidunt bibendum rutrum. Proin commodo ornare sapien. Vivamus interdum diam sed sapien blandit, sit amet aliquam risus mattis. Nullam arcu turpis, mollis quis laoreet at, placerat id nibh. Suspendisse venenatis eros eros.ListsOrdered list  Firstly  Secondly  ThirdlyUnordered list  Chapter          Section                  Paragraph                    ToDo list  Job          Step 1      Step 2      Step 3      Description list  Sun  the star around which the earth orbits  Moon  the natural satellite of the earth, visible by reflected light from the sunBlock Quote  This line shows the block quote.Prompts  An example showing the tip type prompt.  An example showing the info type prompt.  An example showing the warning type prompt.  An example showing the danger type prompt.Tables            Company      Contact      Country                  Alfreds Futterkiste      Maria Anders      Germany              Island Trading      Helen Bennett      UK              Magazzini Alimentari Riuniti      Giovanni Rovelli      Italy      Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Inline codeThis is an example of Inline Code.FilepathHere is the /path/to/the/file.extend.Code blocksCommonThis is a common code snippet, without syntax highlight and line number.Specific Languageif [ $? -ne 0 ]; then  echo \"The command was not successful.\";  #do the needful / exitfi;Specific filename@import  \"colors/light-typography\",  \"colors/dark-typography\";MathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Mermaid SVG gantt  title  Adding GANTT diagram functionality to mermaid  apple :a, 2017-07-20, 1w  banana :crit, b, 2017-07-23, 1d  cherry :active, c, after b a, 1dImagesDefault (with caption)Full screen width and center alignmentLeft alignedFloat to leftPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Float to rightPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Dark/Light mode &amp; ShadowThe image below will toggle dark/light mode based on theme preference, notice it has shadows.VideoReverse Footnote            The footnote source &#8617;              The 2nd footnote source &#8617;      "
  }
  
]

